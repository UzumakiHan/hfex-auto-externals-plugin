import require$$1$3, { fileURLToPath } from 'url';
import require$$0$4, { resolve as resolve$1, isAbsolute, normalize } from 'path';
import fs$1 from 'fs';
import { Buffer as Buffer$1 } from 'buffer';
import process$1 from 'process';
import require$$0$3 from 'constants';
import require$$0$5 from 'util';
import require$$1$4 from 'vm';
import require$$5 from 'tty';
import require$$10 from 'console';
import require$$0$6 from 'os';
import require$$0$7 from 'http';
import require$$1$2 from 'https';

// This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range.

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
  return false
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

var hasOwn = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty.call(obj, propName)
); });

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (!opts || opts.allowHashBang == null)
    { options.allowHashBang = options.ecmaVersion >= 14; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser$1 = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser$1.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser$1.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser$1.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser$1.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser$1.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser$1.prototype, prototypeAccessors );

var pp$9 = Parser$1.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser$1.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
  if (context) { return false }

  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1 = [];

pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);

  return param
};

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) { return null }

  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;

  if (this.eatContextual("static")) {
    // Parse static init block
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }

  // Parse element name
  if (keyName) {
    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
    // The last token is any of those. Make it the element name.
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }

  // Parse element value
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }

  return node
};

pp$8.isClassElementNameStart = function() {
  return (
    this.type === types$1.name ||
    this.type === types$1.privateId ||
    this.type === types$1.num ||
    this.type === types$1.string ||
    this.type === types$1.bracketL ||
    this.type.keyword
  )
};

pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};

pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  // Check key and flags
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  // Parse value
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

  // Check value
  if (method.kind === "get" && value.params.length !== 0)
    { this.raiseRecoverable(value.start, "getter should have no params"); }
  if (method.kind === "set" && value.params.length !== 1)
    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && value.params[0].type === "RestElement")
    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

  return this.finishNode(method, "MethodDefinition")
};

pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }

  if (this.eat(types$1.eq)) {
    // To raise SyntaxError if 'arguments' exists in the initializer.
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();

  return this.finishNode(field, "PropertyDefinition")
};

pp$8.parseClassStaticBlock = function(node) {
  node.body = [];

  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;

  return this.finishNode(node, "StaticBlock")
};

pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};

pp$8.enterClassBody = function() {
  var element = {declared: Object.create(null), used: []};
  this.privateNameStack.push(element);
  return element.declared
};

pp$8.exitClassBody = function() {
  var ref = this.privateNameStack.pop();
  var declared = ref.declared;
  var used = ref.used;
  if (!this.options.checkPrivateFields) { return }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
      }
    }
  }
};

function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];

  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }

  // `class { get #a(){}; static set #a(_){} }` is also conflict.
  if (
    curr === "iget" && next === "iset" ||
    curr === "iset" && next === "iget" ||
    curr === "sget" && next === "sset" ||
    curr === "sset" && next === "sget"
  ) {
    privateNameMap[name] = "true";
    return false
  } else if (!curr) {
    privateNameMap[name] = next;
    return false
  } else {
    return true
  }
}

function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (
    key.type === "Identifier" && key.name === name ||
    key.type === "Literal" && key.value === name
  )
}

// Parses module export declaration.

pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration")
};

pp$8.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports)
  }
  if (this.eat(types$1._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);

        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null)
};

pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID")
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration
  }
};

pp$8.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (typeof name !== "string")
    { name = name.type === "Identifier" ? name.name : name.value; }
  if (hasOwn(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();

  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );

  return this.finishNode(node, "ExportSpecifier")
};

pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes
};

// Parses import declaration.

pp$8.parseImport = function(node) {
  this.next();

  // import '...'
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();

  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);

  return this.finishNode(node, "ImportSpecifier")
};

pp$8.parseImportDefaultSpecifier = function() {
  // import defaultObj, { x, y as z } from '...'
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier")
};

pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier")
};

pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) { return nodes }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseImportSpecifier());
  }
  return nodes
};

pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral
  }
  return this.parseIdent(true)
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return (
    this.options.ecmaVersion >= 5 &&
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$7 = Parser$1.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types$1.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types$1.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types$1.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types$1.comma); }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts
};

pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem
};

pp$7.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// The following three functions all verify that a node is an lvalue —
// something that can be bound, or assigned to. In order to do so, they perform
// a variety of checks:
//
// - Check that none of the bound/assigned-to identifiers are reserved words.
// - Record name declarations for bindings in the appropriate scope.
// - Check duplicate argument names, if checkClashes is set.
//
// If a complex binding pattern is encountered (e.g., object and array
// destructuring), the entire pattern is recursively checked.
//
// There are three versions of checkLVal*() appropriate for different
// circumstances:
//
// - checkLValSimple() shall be used if the syntactic construct supports
//   nothing other than identifiers and member expressions. Parenthesized
//   expressions are also correctly handled. This is generally appropriate for
//   constructs for which the spec says
//
//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
//   > simple.
//
//   It is also appropriate for checking if an identifier is valid and not
//   defined elsewhere, like import declarations or function/class identifiers.
//
//   Examples where this is used include:
//     a += …;
//     import a from '…';
//   where a is the node to be checked.
//
// - checkLValPattern() shall be used if the syntactic construct supports
//   anything checkLValSimple() supports, as well as object and array
//   destructuring patterns. This is generally appropriate for constructs for
//   which the spec says
//
//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
//   > simple.
//
//   Examples where this is used include:
//     (a = …);
//     const a = …;
//     try { … } catch (a) { … }
//   where a is the node to be checked.
//
// - checkLValInnerPattern() shall be used if the syntactic construct supports
//   anything checkLValPattern() supports, as well as default assignment
//   patterns, rest elements, and other constructs that may appear within an
//   object or array destructuring pattern.
//
//   As a special case, function parameters also use checkLValInnerPattern(),
//   as they also support defaults and rest constructs.
//
// These functions deliberately support both assignment and binding constructs,
// as the logic for both is exceedingly similar. If the node is the target of
// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
// should be set to the appropriate BIND_* constant, like BIND_VAR or
// BIND_LEXICAL.
//
// If the function is called with a non-BIND_NONE bindingType, then
// additionally a checkClashes object may be specified to allow checking for
// duplicate argument names. checkClashes is ignored if the provided construct
// is an assignment (i.e., bindingType is BIND_NONE).

pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  var isBind = bindingType !== BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (isBind) {
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (checkClashes) {
        if (hasOwn(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ParenthesizedExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

  default:
    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};

pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
      var prop = list[i];

    this.checkLValInnerPattern(prop, bindingType, checkClashes);
    }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
    }
    break

  default:
    this.checkLValSimple(expr, bindingType, checkClashes);
  }
};

pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
    break

  case "AssignmentPattern":
    this.checkLValPattern(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLValPattern(expr.argument, bindingType, checkClashes);
    break

  default:
    this.checkLValPattern(expr, bindingType, checkClashes);
  }
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$6 = Parser$1.prototype;

pp$6.initialContext = function() {
  return [types.b_stat]
};

pp$6.curContext = function() {
  return this.context[this.context.length - 1]
};

pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat)
    { return true }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
    { return true }
  if (prevType === types$1.braceL)
    { return parent === types.b_stat }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
    { return false }
  return !this.exprAllowed
};

pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Used to handle egde cases when token context could not be inferred correctly during tokenization phase

pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};

// Token-specific context update code

types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

types$1.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else &&
      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
    { this.context.push(types.f_expr); }
  else
    { this.context.push(types.f_stat); }
  this.exprAllowed = false;
};

types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types.q_tmpl); }
  this.exprAllowed = false;
};

types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr)
      { this.context[index] = types.f_expr_gen; }
    else
      { this.context[index] = types.f_gen; }
  }
  this.exprAllowed = true;
};

types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


var pp$5 = Parser$1.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(forInit) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq)
      { left = this.toAssignable(left, false, refDestructuringErrors); }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    if (this.type === types$1.eq)
      { this.checkLValPattern(left); }
    else
      { this.checkLValSimple(left); }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
    }
  }
  return left
};

pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLValSimple(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
    expr = this.parsePrivateIdent();
    // only could be private fields in 'in', such as #x in obj
    if (this.type !== types$1._in) { this.unexpected(); }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary)
      { this.unexpected(this.lastTokStart); }
    else
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
  } else {
    return expr
  }
};

function isPrivateFieldAccess(node) {
  return (
    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
  )
}

// Parse call, dot, and `[]`-subscript expressions.

pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
  }
  return result
};

pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow)
};

pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
};

pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types$1.bracketL);
  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types$1.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types$1._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types$1.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types$1._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types$1.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
      this.overrideContext(types.f_expr);
      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
    }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types$1.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
      }
    }
    return id

  case types$1.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types$1.num: case types$1.string:
    return this.parseLiteral(this.value)

  case types$1._null: case types$1._true: case types$1._false:
    node = this.startNode();
    node.value = this.type === types$1._null ? null : this.type === types$1._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types$1.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types$1.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types$1.braceL:
    this.overrideContext(types.b_expr);
    return this.parseObj(false, refDestructuringErrors)

  case types$1._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types$1._class:
    return this.parseClass(this.startNode(), false)

  case types$1._new:
    return this.parseNew()

  case types$1.backQuote:
    return this.parseTemplate()

  case types$1._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport(forNew)
    } else {
      return this.unexpected()
    }

  default:
    return this.parseExprAtomDefault()
  }
};

pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};

pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  var meta = this.parseIdent(true);

  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node)
  } else if (this.type === types$1.dot) {
    node.meta = meta;
    return this.parseImportMeta(node)
  } else {
    this.unexpected();
  }
};

pp$5.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$5.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val
};

pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon()
};

pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);

    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$5.parseParenItem = function(item) {
  return item
};

pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$2 = [];

pp$5.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.allowNewDotTarget)
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$2; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$5.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$5.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types$1.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get")
      { this.raiseRecoverable(start, "getter should have no params"); }
    else
      { this.raiseRecoverable(start, "setter should have exactly one param"); }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
      { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
  }
};

pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon)
    { this.unexpected(); }

  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types$1.comma)
      { elt = null; }
    else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$5.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.currentThisScope().inClassFieldInit && name === "arguments")
    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  return node
};

pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");

  // For validating existence
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }

  return node
};

// Parses yield expression inside generator.

pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser$1.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$3 = Parser$1.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
  // A switch to disallow the identifier reference 'arguments'
  this.inClassFieldInit = false;
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$3.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$3.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$2 = Parser$1.prototype;

pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) { newNode[prop] = node[prop]; }
  return newNode
};

// This file contains Unicode properties extracted from the ECMAScript specification.
// The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;

var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};

// #table-binary-unicode-properties-of-strings
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";

var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

for (var i$1 = 0, list = [9, 10, 11, 12, 13, 14]; i$1 < list.length; i$1 += 1) {
  var ecmaVersion = list[i$1];

  buildUnicodeData(ecmaVersion);
}

var pp$1 = Parser$1.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.pos, forceU)
};

RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.nextIndex(this.pos, forceU), forceU)
};

RegExpValidationState.prototype.advance = function advance (forceU) {
    if ( forceU === void 0 ) forceU = false;

  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat (ch, forceU) {
    if ( forceU === void 0 ) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true
  }
  return false
};

RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];

      var current = this.at(pos, forceU);
    if (current === -1 || current !== ch) {
      return false
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true
};

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  var u = false;
  var v = false;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") { u = true; }
    if (flag === "v") { v = true; }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$1.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$1.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$1.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$1.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$1.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if ( forceU === void 0 ) forceU = false;

  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// Return values used by character set parsing methods, needed to
// forbid negation of sets that can match strings.
var CharSetNone = 0; // Nothing parsed
var CharSetOk = 1; // Construct parsed, cannot contain strings
var CharSetString = 2; // Construct parsed, can contain strings

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk
  }

  var negate = false;
  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (
      state.eat(0x7B /* { */) &&
      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
      state.eat(0x7D /* } */)
    ) {
      if (negate && result === CharSetString) { state.raise("Invalid property name"); }
      return result
    }
    state.raise("Invalid property name");
  }

  return CharSetNone
};

function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
  }
  return CharSetNone
};

pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};

pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
  state.raise("Invalid property name");
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};

function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (!state.eat(0x5D /* ] */))
      { state.raise("Unterminated character class"); }
    if (negate && result === CharSetString)
      { state.raise("Negated character class may contain strings"); }
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassContents
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
pp$1.regexp_classContents = function(state) {
  if (state.current() === 0x5D /* ] */) { return CharSetOk }
  if (state.switchV) { return this.regexp_classSetExpression(state) }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://tc39.es/ecma262/#prod-ClassSetExpression
// https://tc39.es/ecma262/#prod-ClassUnion
// https://tc39.es/ecma262/#prod-ClassIntersection
// https://tc39.es/ecma262/#prod-ClassSubtraction
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) { result = CharSetString; }
    // https://tc39.es/ecma262/#prod-ClassIntersection
    var start = state.pos;
    while (state.eatChars([0x26, 0x26] /* && */)) {
      if (
        state.current() !== 0x26 /* & */ &&
        (subResult = this.regexp_eatClassSetOperand(state))
      ) {
        if (subResult !== CharSetString) { result = CharSetOk; }
        continue
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    while (state.eatChars([0x2D, 0x2D] /* -- */)) {
      if (this.regexp_eatClassSetOperand(state)) { continue }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
  } else {
    state.raise("Invalid character in character class");
  }
  // https://tc39.es/ecma262/#prod-ClassUnion
  for (;;) {
    if (this.regexp_eatClassSetRange(state)) { continue }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) { return result }
    if (subResult === CharSetString) { result = CharSetString; }
  }
};

// https://tc39.es/ecma262/#prod-ClassSetRange
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true
    }
    state.pos = start;
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetOperand
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
};

// https://tc39.es/ecma262/#prod-NestedClass
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (state.eat(0x5D /* ] */)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result
    }
    state.pos = start;
  }
  if (state.eat(0x5C /* \ */)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunction
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars([0x5C, 0x71] /* \q */)) {
    if (state.eat(0x7B /* { */)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(0x7D /* } */)) {
        return result
      }
    } else {
      // Make the same message as V8.
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(0x7C /* | */)) {
    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
  }
  return result
};

// https://tc39.es/ecma262/#prod-ClassString
// https://tc39.es/ecma262/#prod-NonEmptyClassString
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) { count++; }
  return count === 1 ? CharSetOk : CharSetString
};

// https://tc39.es/ecma262/#prod-ClassSetCharacter
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (
      this.regexp_eatCharacterEscape(state) ||
      this.regexp_eatClassSetReservedPunctuator(state)
    ) {
      return true
    }
    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }
    state.pos = start;
    return false
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
  if (isClassSetSyntaxCharacter(ch)) { return false }
  state.advance();
  state.lastIntValue = ch;
  return true
};

// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
    ch === 0x2E /* . */ ||
    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
    ch === 0x5E /* ^ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
function isClassSetSyntaxCharacter(ch) {
  return (
    ch === 0x28 /* ( */ ||
    ch === 0x29 /* ) */ ||
    ch === 0x2D /* - */ ||
    ch === 0x2F /* / */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
function isClassSetReservedPunctuator(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch === 0x23 /* # */ ||
    ch === 0x25 /* % */ ||
    ch === 0x26 /* & */ ||
    ch === 0x2C /* , */ ||
    ch === 0x2D /* - */ ||
    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
    ch === 0x40 /* @ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp = Parser$1.prototype;

// Move to the next token

pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp[Symbol.iterator] = function() {
    var this$1$1 = this;

    return {
      next: function () {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xdc00) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
};

pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types$1.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot)
  }
};

pp.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.slash, 1)
};

pp.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
};

pp.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.bitwiseXOR, 1)
};

pp.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types$1.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.plusMin, 1)
};

pp.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
    return this.finishOp(types$1.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types$1.relational, size)
};

pp.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types$1.arrow)
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
};

pp.readToken_question = function() { // '?'
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
      }
      return this.finishOp(types$1.coalesce, 2)
    }
  }
  return this.finishOp(types$1.question, 1)
};

pp.readToken_numberSign = function() { // '#'
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35; // '#'
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
      return this.finishToken(types$1.privateId, this.readWord1())
    }
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types$1.parenL)
  case 41: ++this.pos; return this.finishToken(types$1.parenR)
  case 59: ++this.pos; return this.finishToken(types$1.semi)
  case 44: ++this.pos; return this.finishToken(types$1.comma)
  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
  case 123: ++this.pos; return this.finishToken(types$1.braceL)
  case 125: ++this.pos; return this.finishToken(types$1.braceR)
  case 58: ++this.pos; return this.finishToken(types$1.colon)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types$1.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.
  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 63: // '?'
    return this.readToken_question()

  case 126: // '~'
    return this.finishOp(types$1.prefix, 1)

  case 35: // '#'
    return this.readToken_numberSign()
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
      lastCode = code;
      continue
    }

    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8)
  }

  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
  return parseFloat(str.replace(/_/g, ""))
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null
  }

  // `BigInt(value)` throws syntax error if the string contains numeric separators.
  return BigInt(str.replace(/_/g, ""))
}

pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types$1.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types$1.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 0x2028 || ch === 0x2029) {
      if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }

    // falls through
    case "`":
      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  case 56:
  case 57:
    if (this.strict) {
      this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      );
    }
    if (inTemplate) {
      var codePos = this.pos - 1;

      this.invalidStringToken(
        codePos,
        "Invalid escape sequence in template string"
      );
    }
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// [walk]: util/walk.js


var version = "8.10.0";

Parser$1.acorn = {
  Parser: Parser$1,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext: TokContext,
  tokContexts: types,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var lib$b = {};

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var Source_1;
var hasRequiredSource;

function requireSource () {
	if (hasRequiredSource) return Source_1;
	hasRequiredSource = 1;

	class Source {
		source() {
			throw new Error("Abstract");
		}

		buffer() {
			const source = this.source();
			if (Buffer.isBuffer(source)) return source;
			return Buffer.from(source, "utf-8");
		}

		size() {
			return this.buffer().length;
		}

		map(options) {
			return null;
		}

		sourceAndMap(options) {
			return {
				source: this.source(),
				map: this.map(options)
			};
		}

		updateHash(hash) {
			throw new Error("Abstract");
		}
	}

	Source_1 = Source;
	return Source_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var getGeneratedSourceInfo_1;
var hasRequiredGetGeneratedSourceInfo;

function requireGetGeneratedSourceInfo () {
	if (hasRequiredGetGeneratedSourceInfo) return getGeneratedSourceInfo_1;
	hasRequiredGetGeneratedSourceInfo = 1;

	const CHAR_CODE_NEW_LINE = "\n".charCodeAt(0);

	const getGeneratedSourceInfo = source => {
		if (source === undefined) {
			return {};
		}
		const lastLineStart = source.lastIndexOf("\n");
		if (lastLineStart === -1) {
			return {
				generatedLine: 1,
				generatedColumn: source.length,
				source
			};
		}
		let generatedLine = 2;
		for (let i = 0; i < lastLineStart; i++) {
			if (source.charCodeAt(i) === CHAR_CODE_NEW_LINE) generatedLine++;
		}
		return {
			generatedLine,
			generatedColumn: source.length - lastLineStart - 1,
			source
		};
	};

	getGeneratedSourceInfo_1 = getGeneratedSourceInfo;
	return getGeneratedSourceInfo_1;
}

var splitIntoLines_1;
var hasRequiredSplitIntoLines;

function requireSplitIntoLines () {
	if (hasRequiredSplitIntoLines) return splitIntoLines_1;
	hasRequiredSplitIntoLines = 1;
	const splitIntoLines = str => {
		const results = [];
		const len = str.length;
		let i = 0;
		for (; i < len; ) {
			const cc = str.charCodeAt(i);
			// 10 is "\n".charCodeAt(0)
			if (cc === 10) {
				results.push("\n");
				i++;
			} else {
				let j = i + 1;
				// 10 is "\n".charCodeAt(0)
				while (j < len && str.charCodeAt(j) !== 10) j++;
				results.push(str.slice(i, j + 1));
				i = j + 1;
			}
		}
		return results;
	};
	splitIntoLines_1 = splitIntoLines;
	return splitIntoLines_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var streamChunksOfRawSource_1;
var hasRequiredStreamChunksOfRawSource;

function requireStreamChunksOfRawSource () {
	if (hasRequiredStreamChunksOfRawSource) return streamChunksOfRawSource_1;
	hasRequiredStreamChunksOfRawSource = 1;

	const getGeneratedSourceInfo = requireGetGeneratedSourceInfo();
	const splitIntoLines = requireSplitIntoLines();

	const streamChunksOfRawSource = (source, onChunk, onSource, onName) => {
		let line = 1;
		const matches = splitIntoLines(source);
		let match;
		for (match of matches) {
			onChunk(match, line, 0, -1, -1, -1, -1);
			line++;
		}
		return matches.length === 0 || match.endsWith("\n")
			? {
					generatedLine: matches.length + 1,
					generatedColumn: 0
			  }
			: {
					generatedLine: matches.length,
					generatedColumn: match.length
			  };
	};

	streamChunksOfRawSource_1 = (source, onChunk, onSource, onName, finalSource) => {
		return finalSource
			? getGeneratedSourceInfo(source)
			: streamChunksOfRawSource(source, onChunk);
	};
	return streamChunksOfRawSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var RawSource_1;
var hasRequiredRawSource;

function requireRawSource () {
	if (hasRequiredRawSource) return RawSource_1;
	hasRequiredRawSource = 1;

	const streamChunksOfRawSource = requireStreamChunksOfRawSource();
	const Source = requireSource();

	class RawSource extends Source {
		constructor(value, convertToString = false) {
			super();
			const isBuffer = Buffer.isBuffer(value);
			if (!isBuffer && typeof value !== "string") {
				throw new TypeError("argument 'value' must be either string of Buffer");
			}
			this._valueIsBuffer = !convertToString && isBuffer;
			this._value = convertToString && isBuffer ? undefined : value;
			this._valueAsBuffer = isBuffer ? value : undefined;
			this._valueAsString = isBuffer ? undefined : value;
		}

		isBuffer() {
			return this._valueIsBuffer;
		}

		source() {
			if (this._value === undefined) {
				this._value = this._valueAsBuffer.toString("utf-8");
			}
			return this._value;
		}

		buffer() {
			if (this._valueAsBuffer === undefined) {
				this._valueAsBuffer = Buffer.from(this._value, "utf-8");
			}
			return this._valueAsBuffer;
		}

		map(options) {
			return null;
		}

		/**
		 * @param {object} options options
		 * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
		 * @param {function(number, string, string)} onSource called for each source
		 * @param {function(number, string)} onName called for each name
		 * @returns {void}
		 */
		streamChunks(options, onChunk, onSource, onName) {
			if (this._value === undefined) {
				this._value = Buffer.from(this._valueAsBuffer, "utf-8");
			}
			if (this._valueAsString === undefined) {
				this._valueAsString =
					typeof this._value === "string"
						? this._value
						: this._value.toString("utf-8");
			}
			return streamChunksOfRawSource(
				this._valueAsString,
				onChunk,
				onSource,
				onName,
				!!(options && options.finalSource)
			);
		}

		updateHash(hash) {
			if (this._valueAsBuffer === undefined) {
				this._valueAsBuffer = Buffer.from(this._value, "utf-8");
			}
			hash.update("RawSource");
			hash.update(this._valueAsBuffer);
		}
	}

	RawSource_1 = RawSource;
	return RawSource_1;
}

var getFromStreamChunks = {};

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var createMappingsSerializer_1;
var hasRequiredCreateMappingsSerializer;

function requireCreateMappingsSerializer () {
	if (hasRequiredCreateMappingsSerializer) return createMappingsSerializer_1;
	hasRequiredCreateMappingsSerializer = 1;

	const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
		""
	);

	const CONTINUATION_BIT = 0x20;

	const createMappingsSerializer = options => {
		const linesOnly = options && options.columns === false;
		return linesOnly
			? createLinesOnlyMappingsSerializer()
			: createFullMappingsSerializer();
	};

	const createFullMappingsSerializer = () => {
		let currentLine = 1;
		let currentColumn = 0;
		let currentSourceIndex = 0;
		let currentOriginalLine = 1;
		let currentOriginalColumn = 0;
		let currentNameIndex = 0;
		let activeMapping = false;
		let activeName = false;
		let initial = true;
		return (
			generatedLine,
			generatedColumn,
			sourceIndex,
			originalLine,
			originalColumn,
			nameIndex
		) => {
			if (activeMapping && currentLine === generatedLine) {
				// A mapping is still active
				if (
					sourceIndex === currentSourceIndex &&
					originalLine === currentOriginalLine &&
					originalColumn === currentOriginalColumn &&
					!activeName &&
					nameIndex < 0
				) {
					// avoid repeating the same original mapping
					return "";
				}
			} else {
				// No mapping is active
				if (sourceIndex < 0) {
					// avoid writing unneccessary generated mappings
					return "";
				}
			}

			let str;
			if (currentLine < generatedLine) {
				str = ";".repeat(generatedLine - currentLine);
				currentLine = generatedLine;
				currentColumn = 0;
				initial = false;
			} else if (initial) {
				str = "";
				initial = false;
			} else {
				str = ",";
			}

			const writeValue = value => {
				const sign = (value >>> 31) & 1;
				const mask = value >> 31;
				const absValue = (value + mask) ^ mask;
				let data = (absValue << 1) | sign;
				for (;;) {
					const sextet = data & 0x1f;
					data >>= 5;
					if (data === 0) {
						str += ALPHABET[sextet];
						break;
					} else {
						str += ALPHABET[sextet | CONTINUATION_BIT];
					}
				}
			};
			writeValue(generatedColumn - currentColumn);
			currentColumn = generatedColumn;
			if (sourceIndex >= 0) {
				activeMapping = true;
				if (sourceIndex === currentSourceIndex) {
					str += "A";
				} else {
					writeValue(sourceIndex - currentSourceIndex);
					currentSourceIndex = sourceIndex;
				}
				writeValue(originalLine - currentOriginalLine);
				currentOriginalLine = originalLine;
				if (originalColumn === currentOriginalColumn) {
					str += "A";
				} else {
					writeValue(originalColumn - currentOriginalColumn);
					currentOriginalColumn = originalColumn;
				}
				if (nameIndex >= 0) {
					writeValue(nameIndex - currentNameIndex);
					currentNameIndex = nameIndex;
					activeName = true;
				} else {
					activeName = false;
				}
			} else {
				activeMapping = false;
			}
			return str;
		};
	};

	const createLinesOnlyMappingsSerializer = () => {
		let lastWrittenLine = 0;
		let currentLine = 1;
		let currentSourceIndex = 0;
		let currentOriginalLine = 1;
		return (
			generatedLine,
			_generatedColumn,
			sourceIndex,
			originalLine,
			_originalColumn,
			_nameIndex
		) => {
			if (sourceIndex < 0) {
				// avoid writing generated mappings at all
				return "";
			}
			if (lastWrittenLine === generatedLine) {
				// avoid writing multiple original mappings per line
				return "";
			}
			let str;
			const writeValue = value => {
				const sign = (value >>> 31) & 1;
				const mask = value >> 31;
				const absValue = (value + mask) ^ mask;
				let data = (absValue << 1) | sign;
				for (;;) {
					const sextet = data & 0x1f;
					data >>= 5;
					if (data === 0) {
						str += ALPHABET[sextet];
						break;
					} else {
						str += ALPHABET[sextet | CONTINUATION_BIT];
					}
				}
			};
			lastWrittenLine = generatedLine;
			if (generatedLine === currentLine + 1) {
				currentLine = generatedLine;
				if (sourceIndex === currentSourceIndex) {
					currentSourceIndex = sourceIndex;
					if (originalLine === currentOriginalLine + 1) {
						currentOriginalLine = originalLine;
						return ";AACA";
					} else {
						str = ";AA";
						writeValue(originalLine - currentOriginalLine);
						currentOriginalLine = originalLine;
						return str + "A";
					}
				} else {
					str = ";A";
					writeValue(sourceIndex - currentSourceIndex);
					currentSourceIndex = sourceIndex;
					writeValue(originalLine - currentOriginalLine);
					currentOriginalLine = originalLine;
					return str + "A";
				}
			} else {
				str = ";".repeat(generatedLine - currentLine);
				currentLine = generatedLine;
				if (sourceIndex === currentSourceIndex) {
					currentSourceIndex = sourceIndex;
					if (originalLine === currentOriginalLine + 1) {
						currentOriginalLine = originalLine;
						return str + "AACA";
					} else {
						str += "AA";
						writeValue(originalLine - currentOriginalLine);
						currentOriginalLine = originalLine;
						return str + "A";
					}
				} else {
					str += "A";
					writeValue(sourceIndex - currentSourceIndex);
					currentSourceIndex = sourceIndex;
					writeValue(originalLine - currentOriginalLine);
					currentOriginalLine = originalLine;
					return str + "A";
				}
			}
		};
	};

	createMappingsSerializer_1 = createMappingsSerializer;
	return createMappingsSerializer_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var hasRequiredGetFromStreamChunks;

function requireGetFromStreamChunks () {
	if (hasRequiredGetFromStreamChunks) return getFromStreamChunks;
	hasRequiredGetFromStreamChunks = 1;

	const createMappingsSerializer = requireCreateMappingsSerializer();

	getFromStreamChunks.getSourceAndMap = (inputSource, options) => {
		let code = "";
		let mappings = "";
		let sources = [];
		let sourcesContent = [];
		let names = [];
		const addMapping = createMappingsSerializer(options);
		const { source } = inputSource.streamChunks(
			Object.assign({}, options, { finalSource: true }),
			(
				chunk,
				generatedLine,
				generatedColumn,
				sourceIndex,
				originalLine,
				originalColumn,
				nameIndex
			) => {
				if (chunk !== undefined) code += chunk;
				mappings += addMapping(
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				);
			},
			(sourceIndex, source, sourceContent) => {
				while (sources.length < sourceIndex) {
					sources.push(null);
				}
				sources[sourceIndex] = source;
				if (sourceContent !== undefined) {
					while (sourcesContent.length < sourceIndex) {
						sourcesContent.push(null);
					}
					sourcesContent[sourceIndex] = sourceContent;
				}
			},
			(nameIndex, name) => {
				while (names.length < nameIndex) {
					names.push(null);
				}
				names[nameIndex] = name;
			}
		);
		return {
			source: source !== undefined ? source : code,
			map:
				mappings.length > 0
					? {
							version: 3,
							file: "x",
							mappings,
							sources,
							sourcesContent:
								sourcesContent.length > 0 ? sourcesContent : undefined,
							names
					  }
					: null
		};
	};

	getFromStreamChunks.getMap = (source, options) => {
		let mappings = "";
		let sources = [];
		let sourcesContent = [];
		let names = [];
		const addMapping = createMappingsSerializer(options);
		source.streamChunks(
			Object.assign({}, options, { source: false, finalSource: true }),
			(
				chunk,
				generatedLine,
				generatedColumn,
				sourceIndex,
				originalLine,
				originalColumn,
				nameIndex
			) => {
				mappings += addMapping(
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				);
			},
			(sourceIndex, source, sourceContent) => {
				while (sources.length < sourceIndex) {
					sources.push(null);
				}
				sources[sourceIndex] = source;
				if (sourceContent !== undefined) {
					while (sourcesContent.length < sourceIndex) {
						sourcesContent.push(null);
					}
					sourcesContent[sourceIndex] = sourceContent;
				}
			},
			(nameIndex, name) => {
				while (names.length < nameIndex) {
					names.push(null);
				}
				names[nameIndex] = name;
			}
		);
		return mappings.length > 0
			? {
					version: 3,
					file: "x",
					mappings,
					sources,
					sourcesContent: sourcesContent.length > 0 ? sourcesContent : undefined,
					names
			  }
			: null;
	};
	return getFromStreamChunks;
}

var splitIntoPotentialTokens_1;
var hasRequiredSplitIntoPotentialTokens;

function requireSplitIntoPotentialTokens () {
	if (hasRequiredSplitIntoPotentialTokens) return splitIntoPotentialTokens_1;
	hasRequiredSplitIntoPotentialTokens = 1;
	// \n = 10
	// ; = 59
	// { = 123
	// } = 125
	// <space> = 32
	// \r = 13
	// \t = 9

	const splitIntoPotentialTokens = str => {
		const len = str.length;
		if (len === 0) return null;
		const results = [];
		let i = 0;
		for (; i < len; ) {
			const s = i;
			block: {
				let cc = str.charCodeAt(i);
				while (cc !== 10 && cc !== 59 && cc !== 123 && cc !== 125) {
					if (++i >= len) break block;
					cc = str.charCodeAt(i);
				}
				while (
					cc === 59 ||
					cc === 32 ||
					cc === 123 ||
					cc === 125 ||
					cc === 13 ||
					cc === 9
				) {
					if (++i >= len) break block;
					cc = str.charCodeAt(i);
				}
				if (cc === 10) {
					i++;
				}
			}
			results.push(str.slice(s, i));
		}
		return results;
	};
	splitIntoPotentialTokens_1 = splitIntoPotentialTokens;
	return splitIntoPotentialTokens_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var OriginalSource_1;
var hasRequiredOriginalSource;

function requireOriginalSource () {
	if (hasRequiredOriginalSource) return OriginalSource_1;
	hasRequiredOriginalSource = 1;

	const { getMap, getSourceAndMap } = requireGetFromStreamChunks();
	const splitIntoLines = requireSplitIntoLines();
	const getGeneratedSourceInfo = requireGetGeneratedSourceInfo();
	const Source = requireSource();
	const splitIntoPotentialTokens = requireSplitIntoPotentialTokens();

	class OriginalSource extends Source {
		constructor(value, name) {
			super();
			const isBuffer = Buffer.isBuffer(value);
			this._value = isBuffer ? undefined : value;
			this._valueAsBuffer = isBuffer ? value : undefined;
			this._name = name;
		}

		getName() {
			return this._name;
		}

		source() {
			if (this._value === undefined) {
				this._value = this._valueAsBuffer.toString("utf-8");
			}
			return this._value;
		}

		buffer() {
			if (this._valueAsBuffer === undefined) {
				this._valueAsBuffer = Buffer.from(this._value, "utf-8");
			}
			return this._valueAsBuffer;
		}

		map(options) {
			return getMap(this, options);
		}

		sourceAndMap(options) {
			return getSourceAndMap(this, options);
		}

		/**
		 * @param {object} options options
		 * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
		 * @param {function(number, string, string)} onSource called for each source
		 * @param {function(number, string)} onName called for each name
		 * @returns {void}
		 */
		streamChunks(options, onChunk, onSource, onName) {
			if (this._value === undefined) {
				this._value = this._valueAsBuffer.toString("utf-8");
			}
			onSource(0, this._name, this._value);
			const finalSource = !!(options && options.finalSource);
			if (!options || options.columns !== false) {
				// With column info we need to read all lines and split them
				const matches = splitIntoPotentialTokens(this._value);
				let line = 1;
				let column = 0;
				if (matches !== null) {
					for (const match of matches) {
						const isEndOfLine = match.endsWith("\n");
						if (isEndOfLine && match.length === 1) {
							if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);
						} else {
							const chunk = finalSource ? undefined : match;
							onChunk(chunk, line, column, 0, line, column, -1);
						}
						if (isEndOfLine) {
							line++;
							column = 0;
						} else {
							column += match.length;
						}
					}
				}
				return {
					generatedLine: line,
					generatedColumn: column,
					source: finalSource ? this._value : undefined
				};
			} else if (finalSource) {
				// Without column info and with final source we only
				// need meta info to generate mapping
				const result = getGeneratedSourceInfo(this._value);
				const { generatedLine, generatedColumn } = result;
				if (generatedColumn === 0) {
					for (let line = 1; line < generatedLine; line++)
						onChunk(undefined, line, 0, 0, line, 0, -1);
				} else {
					for (let line = 1; line <= generatedLine; line++)
						onChunk(undefined, line, 0, 0, line, 0, -1);
				}
				return result;
			} else {
				// Without column info, but also without final source
				// we need to split source by lines
				let line = 1;
				const matches = splitIntoLines(this._value);
				let match;
				for (match of matches) {
					onChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);
					line++;
				}
				return matches.length === 0 || match.endsWith("\n")
					? {
							generatedLine: matches.length + 1,
							generatedColumn: 0,
							source: finalSource ? this._value : undefined
					  }
					: {
							generatedLine: matches.length,
							generatedColumn: match.length,
							source: finalSource ? this._value : undefined
					  };
			}
		}

		updateHash(hash) {
			if (this._valueAsBuffer === undefined) {
				this._valueAsBuffer = Buffer.from(this._value, "utf-8");
			}
			hash.update("OriginalSource");
			hash.update(this._valueAsBuffer);
			hash.update(this._name || "");
		}
	}

	OriginalSource_1 = OriginalSource;
	return OriginalSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var getSource_1;
var hasRequiredGetSource;

function requireGetSource () {
	if (hasRequiredGetSource) return getSource_1;
	hasRequiredGetSource = 1;

	const getSource = (sourceMap, index) => {
		if (index < 0) return null;
		const { sourceRoot, sources } = sourceMap;
		const source = sources[index];
		if (!sourceRoot) return source;
		if (sourceRoot.endsWith("/")) return sourceRoot + source;
		return sourceRoot + "/" + source;
	};

	getSource_1 = getSource;
	return getSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var readMappings_1;
var hasRequiredReadMappings;

function requireReadMappings () {
	if (hasRequiredReadMappings) return readMappings_1;
	hasRequiredReadMappings = 1;

	const ALPHABET =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	const CONTINUATION_BIT = 0x20;
	const END_SEGMENT_BIT = 0x40;
	const NEXT_LINE = END_SEGMENT_BIT | 0x01;
	const INVALID = END_SEGMENT_BIT | 0x02;
	const DATA_MASK = 0x1f;

	const ccToValue = new Uint8Array("z".charCodeAt(0) + 1);
	{
		ccToValue.fill(INVALID);
		for (let i = 0; i < ALPHABET.length; i++) {
			ccToValue[ALPHABET.charCodeAt(i)] = i;
		}
		ccToValue[",".charCodeAt(0)] = END_SEGMENT_BIT;
		ccToValue[";".charCodeAt(0)] = NEXT_LINE;
	}
	const ccMax = ccToValue.length - 1;

	/**
	 * @param {string} mappings the mappings string
	 * @param {function(number, number, number, number, number, number): void} onMapping called for each mapping
	 * @returns {void}
	 */
	const readMappings = (mappings, onMapping) => {
		// generatedColumn, [sourceIndex, originalLine, orignalColumn, [nameIndex]]
		const currentData = new Uint32Array([0, 0, 1, 0, 0]);
		let currentDataPos = 0;
		// currentValue will include a sign bit at bit 0
		let currentValue = 0;
		let currentValuePos = 0;
		let generatedLine = 1;
		let generatedColumn = -1;
		for (let i = 0; i < mappings.length; i++) {
			const cc = mappings.charCodeAt(i);
			if (cc > ccMax) continue;
			const value = ccToValue[cc];
			if ((value & END_SEGMENT_BIT) !== 0) {
				// End current segment
				if (currentData[0] > generatedColumn) {
					if (currentDataPos === 1) {
						onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
					} else if (currentDataPos === 4) {
						onMapping(
							generatedLine,
							currentData[0],
							currentData[1],
							currentData[2],
							currentData[3],
							-1
						);
					} else if (currentDataPos === 5) {
						onMapping(
							generatedLine,
							currentData[0],
							currentData[1],
							currentData[2],
							currentData[3],
							currentData[4]
						);
					}
					generatedColumn = currentData[0];
				}
				currentDataPos = 0;
				if (value === NEXT_LINE) {
					// Start new line
					generatedLine++;
					currentData[0] = 0;
					generatedColumn = -1;
				}
			} else if ((value & CONTINUATION_BIT) === 0) {
				// last sextet
				currentValue |= value << currentValuePos;
				const finalValue =
					currentValue & 1 ? -(currentValue >> 1) : currentValue >> 1;
				currentData[currentDataPos++] += finalValue;
				currentValuePos = 0;
				currentValue = 0;
			} else {
				currentValue |= (value & DATA_MASK) << currentValuePos;
				currentValuePos += 5;
			}
		}
		// End current segment
		if (currentDataPos === 1) {
			onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
		} else if (currentDataPos === 4) {
			onMapping(
				generatedLine,
				currentData[0],
				currentData[1],
				currentData[2],
				currentData[3],
				-1
			);
		} else if (currentDataPos === 5) {
			onMapping(
				generatedLine,
				currentData[0],
				currentData[1],
				currentData[2],
				currentData[3],
				currentData[4]
			);
		}
	};

	readMappings_1 = readMappings;
	return readMappings_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var streamChunksOfSourceMap;
var hasRequiredStreamChunksOfSourceMap;

function requireStreamChunksOfSourceMap () {
	if (hasRequiredStreamChunksOfSourceMap) return streamChunksOfSourceMap;
	hasRequiredStreamChunksOfSourceMap = 1;

	const getGeneratedSourceInfo = requireGetGeneratedSourceInfo();
	const getSource = requireGetSource();
	const readMappings = requireReadMappings();
	const splitIntoLines = requireSplitIntoLines();

	const streamChunksOfSourceMapFull = (
		source,
		sourceMap,
		onChunk,
		onSource,
		onName
	) => {
		const lines = splitIntoLines(source);
		if (lines.length === 0) {
			return {
				generatedLine: 1,
				generatedColumn: 0
			};
		}
		const { sources, sourcesContent, names, mappings } = sourceMap;
		for (let i = 0; i < sources.length; i++) {
			onSource(
				i,
				getSource(sourceMap, i),
				(sourcesContent && sourcesContent[i]) || undefined
			);
		}
		if (names) {
			for (let i = 0; i < names.length; i++) {
				onName(i, names[i]);
			}
		}

		const lastLine = lines[lines.length - 1];
		const lastNewLine = lastLine.endsWith("\n");
		const finalLine = lastNewLine ? lines.length + 1 : lines.length;
		const finalColumn = lastNewLine ? 0 : lastLine.length;

		let currentGeneratedLine = 1;
		let currentGeneratedColumn = 0;

		let mappingActive = false;
		let activeMappingSourceIndex = -1;
		let activeMappingOriginalLine = -1;
		let activeMappingOriginalColumn = -1;
		let activeMappingNameIndex = -1;

		const onMapping = (
			generatedLine,
			generatedColumn,
			sourceIndex,
			originalLine,
			originalColumn,
			nameIndex
		) => {
			if (mappingActive && currentGeneratedLine <= lines.length) {
				let chunk;
				const mappingLine = currentGeneratedLine;
				const mappingColumn = currentGeneratedColumn;
				const line = lines[currentGeneratedLine - 1];
				if (generatedLine !== currentGeneratedLine) {
					chunk = line.slice(currentGeneratedColumn);
					currentGeneratedLine++;
					currentGeneratedColumn = 0;
				} else {
					chunk = line.slice(currentGeneratedColumn, generatedColumn);
					currentGeneratedColumn = generatedColumn;
				}
				if (chunk) {
					onChunk(
						chunk,
						mappingLine,
						mappingColumn,
						activeMappingSourceIndex,
						activeMappingOriginalLine,
						activeMappingOriginalColumn,
						activeMappingNameIndex
					);
				}
				mappingActive = false;
			}
			if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {
				if (currentGeneratedLine <= lines.length) {
					const chunk = lines[currentGeneratedLine - 1].slice(
						currentGeneratedColumn
					);
					onChunk(
						chunk,
						currentGeneratedLine,
						currentGeneratedColumn,
						-1,
						-1,
						-1,
						-1
					);
				}
				currentGeneratedLine++;
				currentGeneratedColumn = 0;
			}
			while (generatedLine > currentGeneratedLine) {
				if (currentGeneratedLine <= lines.length) {
					onChunk(
						lines[currentGeneratedLine - 1],
						currentGeneratedLine,
						0,
						-1,
						-1,
						-1,
						-1
					);
				}
				currentGeneratedLine++;
			}
			if (generatedColumn > currentGeneratedColumn) {
				if (currentGeneratedLine <= lines.length) {
					const chunk = lines[currentGeneratedLine - 1].slice(
						currentGeneratedColumn,
						generatedColumn
					);
					onChunk(
						chunk,
						currentGeneratedLine,
						currentGeneratedColumn,
						-1,
						-1,
						-1,
						-1
					);
				}
				currentGeneratedColumn = generatedColumn;
			}
			if (
				sourceIndex >= 0 &&
				(generatedLine < finalLine ||
					(generatedLine === finalLine && generatedColumn < finalColumn))
			) {
				mappingActive = true;
				activeMappingSourceIndex = sourceIndex;
				activeMappingOriginalLine = originalLine;
				activeMappingOriginalColumn = originalColumn;
				activeMappingNameIndex = nameIndex;
			}
		};
		readMappings(mappings, onMapping);
		onMapping(finalLine, finalColumn, -1, -1, -1, -1);
		return {
			generatedLine: finalLine,
			generatedColumn: finalColumn
		};
	};

	const streamChunksOfSourceMapLinesFull = (
		source,
		sourceMap,
		onChunk,
		onSource,
		_onName
	) => {
		const lines = splitIntoLines(source);
		if (lines.length === 0) {
			return {
				generatedLine: 1,
				generatedColumn: 0
			};
		}
		const { sources, sourcesContent, mappings } = sourceMap;
		for (let i = 0; i < sources.length; i++) {
			onSource(
				i,
				getSource(sourceMap, i),
				(sourcesContent && sourcesContent[i]) || undefined
			);
		}

		let currentGeneratedLine = 1;

		const onMapping = (
			generatedLine,
			_generatedColumn,
			sourceIndex,
			originalLine,
			originalColumn,
			_nameIndex
		) => {
			if (
				sourceIndex < 0 ||
				generatedLine < currentGeneratedLine ||
				generatedLine > lines.length
			) {
				return;
			}
			while (generatedLine > currentGeneratedLine) {
				if (currentGeneratedLine <= lines.length) {
					onChunk(
						lines[currentGeneratedLine - 1],
						currentGeneratedLine,
						0,
						-1,
						-1,
						-1,
						-1
					);
				}
				currentGeneratedLine++;
			}
			if (generatedLine <= lines.length) {
				onChunk(
					lines[generatedLine - 1],
					generatedLine,
					0,
					sourceIndex,
					originalLine,
					originalColumn,
					-1
				);
				currentGeneratedLine++;
			}
		};
		readMappings(mappings, onMapping);
		for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {
			onChunk(
				lines[currentGeneratedLine - 1],
				currentGeneratedLine,
				0,
				-1,
				-1,
				-1,
				-1
			);
		}

		const lastLine = lines[lines.length - 1];
		const lastNewLine = lastLine.endsWith("\n");

		const finalLine = lastNewLine ? lines.length + 1 : lines.length;
		const finalColumn = lastNewLine ? 0 : lastLine.length;

		return {
			generatedLine: finalLine,
			generatedColumn: finalColumn
		};
	};

	const streamChunksOfSourceMapFinal = (
		source,
		sourceMap,
		onChunk,
		onSource,
		onName
	) => {
		const result = getGeneratedSourceInfo(source);
		const { generatedLine: finalLine, generatedColumn: finalColumn } = result;

		if (finalLine === 1 && finalColumn === 0) return result;
		const { sources, sourcesContent, names, mappings } = sourceMap;
		for (let i = 0; i < sources.length; i++) {
			onSource(
				i,
				getSource(sourceMap, i),
				(sourcesContent && sourcesContent[i]) || undefined
			);
		}
		if (names) {
			for (let i = 0; i < names.length; i++) {
				onName(i, names[i]);
			}
		}

		let mappingActiveLine = 0;

		const onMapping = (
			generatedLine,
			generatedColumn,
			sourceIndex,
			originalLine,
			originalColumn,
			nameIndex
		) => {
			if (
				generatedLine >= finalLine &&
				(generatedColumn >= finalColumn || generatedLine > finalLine)
			) {
				return;
			}
			if (sourceIndex >= 0) {
				onChunk(
					undefined,
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				);
				mappingActiveLine = generatedLine;
			} else if (mappingActiveLine === generatedLine) {
				onChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);
				mappingActiveLine = 0;
			}
		};
		readMappings(mappings, onMapping);
		return result;
	};

	const streamChunksOfSourceMapLinesFinal = (
		source,
		sourceMap,
		onChunk,
		onSource,
		_onName
	) => {
		const result = getGeneratedSourceInfo(source);
		const { generatedLine, generatedColumn } = result;
		if (generatedLine === 1 && generatedColumn === 0) {
			return {
				generatedLine: 1,
				generatedColumn: 0
			};
		}

		const { sources, sourcesContent, mappings } = sourceMap;
		for (let i = 0; i < sources.length; i++) {
			onSource(
				i,
				getSource(sourceMap, i),
				(sourcesContent && sourcesContent[i]) || undefined
			);
		}

		const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;

		let currentGeneratedLine = 1;

		const onMapping = (
			generatedLine,
			_generatedColumn,
			sourceIndex,
			originalLine,
			originalColumn,
			_nameIndex
		) => {
			if (
				sourceIndex >= 0 &&
				currentGeneratedLine <= generatedLine &&
				generatedLine <= finalLine
			) {
				onChunk(
					undefined,
					generatedLine,
					0,
					sourceIndex,
					originalLine,
					originalColumn,
					-1
				);
				currentGeneratedLine = generatedLine + 1;
			}
		};
		readMappings(mappings, onMapping);
		return result;
	};

	streamChunksOfSourceMap = (
		source,
		sourceMap,
		onChunk,
		onSource,
		onName,
		finalSource,
		columns
	) => {
		if (columns) {
			return finalSource
				? streamChunksOfSourceMapFinal(
						source,
						sourceMap,
						onChunk,
						onSource,
						onName
				  )
				: streamChunksOfSourceMapFull(
						source,
						sourceMap,
						onChunk,
						onSource,
						onName
				  );
		} else {
			return finalSource
				? streamChunksOfSourceMapLinesFinal(
						source,
						sourceMap,
						onChunk,
						onSource)
				: streamChunksOfSourceMapLinesFull(
						source,
						sourceMap,
						onChunk,
						onSource);
		}
	};
	return streamChunksOfSourceMap;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var streamChunksOfCombinedSourceMap_1;
var hasRequiredStreamChunksOfCombinedSourceMap;

function requireStreamChunksOfCombinedSourceMap () {
	if (hasRequiredStreamChunksOfCombinedSourceMap) return streamChunksOfCombinedSourceMap_1;
	hasRequiredStreamChunksOfCombinedSourceMap = 1;

	const streamChunksOfSourceMap = requireStreamChunksOfSourceMap();
	const splitIntoLines = requireSplitIntoLines();

	const streamChunksOfCombinedSourceMap = (
		source,
		sourceMap,
		innerSourceName,
		innerSource,
		innerSourceMap,
		removeInnerSource,
		onChunk,
		onSource,
		onName,
		finalSource,
		columns
	) => {
		let sourceMapping = new Map();
		let nameMapping = new Map();
		const sourceIndexMapping = [];
		const nameIndexMapping = [];
		const nameIndexValueMapping = [];
		let innerSourceIndex = -2;
		const innerSourceIndexMapping = [];
		const innerSourceIndexValueMapping = [];
		const innerSourceContents = [];
		const innerSourceContentLines = [];
		const innerNameIndexMapping = [];
		const innerNameIndexValueMapping = [];
		const innerSourceMapLineData = [];
		const findInnerMapping = (line, column) => {
			if (line > innerSourceMapLineData.length) return -1;
			const { mappingsData } = innerSourceMapLineData[line - 1];
			let l = 0;
			let r = mappingsData.length / 5;
			while (l < r) {
				let m = (l + r) >> 1;
				if (mappingsData[m * 5] <= column) {
					l = m + 1;
				} else {
					r = m;
				}
			}
			if (l === 0) return -1;
			return l - 1;
		};
		return streamChunksOfSourceMap(
			source,
			sourceMap,
			(
				chunk,
				generatedLine,
				generatedColumn,
				sourceIndex,
				originalLine,
				originalColumn,
				nameIndex
			) => {
				// Check if this is a mapping to the inner source
				if (sourceIndex === innerSourceIndex) {
					// Check if there is a mapping in the inner source
					const idx = findInnerMapping(originalLine, originalColumn);
					if (idx !== -1) {
						const { chunks, mappingsData } = innerSourceMapLineData[
							originalLine - 1
						];
						const mi = idx * 5;
						const innerSourceIndex = mappingsData[mi + 1];
						const innerOriginalLine = mappingsData[mi + 2];
						let innerOriginalColumn = mappingsData[mi + 3];
						let innerNameIndex = mappingsData[mi + 4];
						if (innerSourceIndex >= 0) {
							// Check for an identity mapping
							// where we are allowed to adjust the original column
							const innerChunk = chunks[idx];
							const innerGeneratedColumn = mappingsData[mi];
							const locationInChunk = originalColumn - innerGeneratedColumn;
							if (locationInChunk > 0) {
								let originalSourceLines =
									innerSourceIndex < innerSourceContentLines.length
										? innerSourceContentLines[innerSourceIndex]
										: null;
								if (originalSourceLines === undefined) {
									const originalSource = innerSourceContents[innerSourceIndex];
									originalSourceLines = originalSource
										? splitIntoLines(originalSource)
										: null;
									innerSourceContentLines[innerSourceIndex] = originalSourceLines;
								}
								if (originalSourceLines !== null) {
									const originalChunk =
										innerOriginalLine <= originalSourceLines.length
											? originalSourceLines[innerOriginalLine - 1].slice(
													innerOriginalColumn,
													innerOriginalColumn + locationInChunk
											  )
											: "";
									if (innerChunk.slice(0, locationInChunk) === originalChunk) {
										innerOriginalColumn += locationInChunk;
										innerNameIndex = -1;
									}
								}
							}

							// We have a inner mapping to original source

							// emit source when needed and compute global source index
							let sourceIndex =
								innerSourceIndex < innerSourceIndexMapping.length
									? innerSourceIndexMapping[innerSourceIndex]
									: -2;
							if (sourceIndex === -2) {
								const [source, sourceContent] =
									innerSourceIndex < innerSourceIndexValueMapping.length
										? innerSourceIndexValueMapping[innerSourceIndex]
										: [null, undefined];
								let globalIndex = sourceMapping.get(source);
								if (globalIndex === undefined) {
									sourceMapping.set(source, (globalIndex = sourceMapping.size));
									onSource(globalIndex, source, sourceContent);
								}
								sourceIndex = globalIndex;
								innerSourceIndexMapping[innerSourceIndex] = sourceIndex;
							}

							// emit name when needed and compute global name index
							let finalNameIndex = -1;
							if (innerNameIndex >= 0) {
								// when we have a inner name
								finalNameIndex =
									innerNameIndex < innerNameIndexMapping.length
										? innerNameIndexMapping[innerNameIndex]
										: -2;
								if (finalNameIndex === -2) {
									const name =
										innerNameIndex < innerNameIndexValueMapping.length
											? innerNameIndexValueMapping[innerNameIndex]
											: undefined;
									if (name) {
										let globalIndex = nameMapping.get(name);
										if (globalIndex === undefined) {
											nameMapping.set(name, (globalIndex = nameMapping.size));
											onName(globalIndex, name);
										}
										finalNameIndex = globalIndex;
									} else {
										finalNameIndex = -1;
									}
									innerNameIndexMapping[innerNameIndex] = finalNameIndex;
								}
							} else if (nameIndex >= 0) {
								// when we don't have an inner name,
								// but we have an outer name
								// it can be used when inner original code equals to the name
								let originalSourceLines =
									innerSourceContentLines[innerSourceIndex];
								if (originalSourceLines === undefined) {
									const originalSource = innerSourceContents[innerSourceIndex];
									originalSourceLines = originalSource
										? splitIntoLines(originalSource)
										: null;
									innerSourceContentLines[innerSourceIndex] = originalSourceLines;
								}
								if (originalSourceLines !== null) {
									const name = nameIndexValueMapping[nameIndex];
									const originalName =
										innerOriginalLine <= originalSourceLines.length
											? originalSourceLines[innerOriginalLine - 1].slice(
													innerOriginalColumn,
													innerOriginalColumn + name.length
											  )
											: "";
									if (name === originalName) {
										finalNameIndex =
											nameIndex < nameIndexMapping.length
												? nameIndexMapping[nameIndex]
												: -2;
										if (finalNameIndex === -2) {
											const name = nameIndexValueMapping[nameIndex];
											if (name) {
												let globalIndex = nameMapping.get(name);
												if (globalIndex === undefined) {
													nameMapping.set(name, (globalIndex = nameMapping.size));
													onName(globalIndex, name);
												}
												finalNameIndex = globalIndex;
											} else {
												finalNameIndex = -1;
											}
											nameIndexMapping[nameIndex] = finalNameIndex;
										}
									}
								}
							}
							onChunk(
								chunk,
								generatedLine,
								generatedColumn,
								sourceIndex,
								innerOriginalLine,
								innerOriginalColumn,
								finalNameIndex
							);
							return;
						}
					}

					// We have a mapping to the inner source, but no inner mapping
					if (removeInnerSource) {
						onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
						return;
					} else {
						if (sourceIndexMapping[sourceIndex] === -2) {
							let globalIndex = sourceMapping.get(innerSourceName);
							if (globalIndex === undefined) {
								sourceMapping.set(source, (globalIndex = sourceMapping.size));
								onSource(globalIndex, innerSourceName, innerSource);
							}
							sourceIndexMapping[sourceIndex] = globalIndex;
						}
					}
				}

				const finalSourceIndex =
					sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length
						? -1
						: sourceIndexMapping[sourceIndex];
				if (finalSourceIndex < 0) {
					// no source, so we make it a generated chunk
					onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
				} else {
					// Pass through the chunk with mapping
					let finalNameIndex = -1;
					if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {
						finalNameIndex = nameIndexMapping[nameIndex];
						if (finalNameIndex === -2) {
							const name = nameIndexValueMapping[nameIndex];
							let globalIndex = nameMapping.get(name);
							if (globalIndex === undefined) {
								nameMapping.set(name, (globalIndex = nameMapping.size));
								onName(globalIndex, name);
							}
							finalNameIndex = globalIndex;
							nameIndexMapping[nameIndex] = finalNameIndex;
						}
					}
					onChunk(
						chunk,
						generatedLine,
						generatedColumn,
						finalSourceIndex,
						originalLine,
						originalColumn,
						finalNameIndex
					);
				}
			},
			(i, source, sourceContent) => {
				if (source === innerSourceName) {
					innerSourceIndex = i;
					if (innerSource !== undefined) sourceContent = innerSource;
					else innerSource = sourceContent;
					sourceIndexMapping[i] = -2;
					streamChunksOfSourceMap(
						sourceContent,
						innerSourceMap,
						(
							chunk,
							generatedLine,
							generatedColumn,
							sourceIndex,
							originalLine,
							originalColumn,
							nameIndex
						) => {
							while (innerSourceMapLineData.length < generatedLine) {
								innerSourceMapLineData.push({
									mappingsData: [],
									chunks: []
								});
							}
							const data = innerSourceMapLineData[generatedLine - 1];
							data.mappingsData.push(
								generatedColumn,
								sourceIndex,
								originalLine,
								originalColumn,
								nameIndex
							);
							data.chunks.push(chunk);
						},
						(i, source, sourceContent) => {
							innerSourceContents[i] = sourceContent;
							innerSourceContentLines[i] = undefined;
							innerSourceIndexMapping[i] = -2;
							innerSourceIndexValueMapping[i] = [source, sourceContent];
						},
						(i, name) => {
							innerNameIndexMapping[i] = -2;
							innerNameIndexValueMapping[i] = name;
						},
						false,
						columns
					);
				} else {
					let globalIndex = sourceMapping.get(source);
					if (globalIndex === undefined) {
						sourceMapping.set(source, (globalIndex = sourceMapping.size));
						onSource(globalIndex, source, sourceContent);
					}
					sourceIndexMapping[i] = globalIndex;
				}
			},
			(i, name) => {
				nameIndexMapping[i] = -2;
				nameIndexValueMapping[i] = name;
			},
			finalSource,
			columns
		);
	};

	streamChunksOfCombinedSourceMap_1 = streamChunksOfCombinedSourceMap;
	return streamChunksOfCombinedSourceMap_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var SourceMapSource_1;
var hasRequiredSourceMapSource;

function requireSourceMapSource () {
	if (hasRequiredSourceMapSource) return SourceMapSource_1;
	hasRequiredSourceMapSource = 1;

	const Source = requireSource();
	const streamChunksOfSourceMap = requireStreamChunksOfSourceMap();
	const streamChunksOfCombinedSourceMap = requireStreamChunksOfCombinedSourceMap();
	const { getMap, getSourceAndMap } = requireGetFromStreamChunks();

	class SourceMapSource extends Source {
		constructor(
			value,
			name,
			sourceMap,
			originalSource,
			innerSourceMap,
			removeOriginalSource
		) {
			super();
			const valueIsBuffer = Buffer.isBuffer(value);
			this._valueAsString = valueIsBuffer ? undefined : value;
			this._valueAsBuffer = valueIsBuffer ? value : undefined;

			this._name = name;

			this._hasSourceMap = !!sourceMap;
			const sourceMapIsBuffer = Buffer.isBuffer(sourceMap);
			const sourceMapIsString = typeof sourceMap === "string";
			this._sourceMapAsObject =
				sourceMapIsBuffer || sourceMapIsString ? undefined : sourceMap;
			this._sourceMapAsString = sourceMapIsString ? sourceMap : undefined;
			this._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : undefined;

			this._hasOriginalSource = !!originalSource;
			const originalSourceIsBuffer = Buffer.isBuffer(originalSource);
			this._originalSourceAsString = originalSourceIsBuffer
				? undefined
				: originalSource;
			this._originalSourceAsBuffer = originalSourceIsBuffer
				? originalSource
				: undefined;

			this._hasInnerSourceMap = !!innerSourceMap;
			const innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap);
			const innerSourceMapIsString = typeof innerSourceMap === "string";
			this._innerSourceMapAsObject =
				innerSourceMapIsBuffer || innerSourceMapIsString
					? undefined
					: innerSourceMap;
			this._innerSourceMapAsString = innerSourceMapIsString
				? innerSourceMap
				: undefined;
			this._innerSourceMapAsBuffer = innerSourceMapIsBuffer
				? innerSourceMap
				: undefined;

			this._removeOriginalSource = removeOriginalSource;
		}

		_ensureValueBuffer() {
			if (this._valueAsBuffer === undefined) {
				this._valueAsBuffer = Buffer.from(this._valueAsString, "utf-8");
			}
		}

		_ensureValueString() {
			if (this._valueAsString === undefined) {
				this._valueAsString = this._valueAsBuffer.toString("utf-8");
			}
		}

		_ensureOriginalSourceBuffer() {
			if (this._originalSourceAsBuffer === undefined && this._hasOriginalSource) {
				this._originalSourceAsBuffer = Buffer.from(
					this._originalSourceAsString,
					"utf-8"
				);
			}
		}

		_ensureOriginalSourceString() {
			if (this._originalSourceAsString === undefined && this._hasOriginalSource) {
				this._originalSourceAsString = this._originalSourceAsBuffer.toString(
					"utf-8"
				);
			}
		}

		_ensureInnerSourceMapObject() {
			if (this._innerSourceMapAsObject === undefined && this._hasInnerSourceMap) {
				this._ensureInnerSourceMapString();
				this._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString);
			}
		}

		_ensureInnerSourceMapBuffer() {
			if (this._innerSourceMapAsBuffer === undefined && this._hasInnerSourceMap) {
				this._ensureInnerSourceMapString();
				this._innerSourceMapAsBuffer = Buffer.from(
					this._innerSourceMapAsString,
					"utf-8"
				);
			}
		}

		_ensureInnerSourceMapString() {
			if (this._innerSourceMapAsString === undefined && this._hasInnerSourceMap) {
				if (this._innerSourceMapAsBuffer !== undefined) {
					this._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString(
						"utf-8"
					);
				} else {
					this._innerSourceMapAsString = JSON.stringify(
						this._innerSourceMapAsObject
					);
				}
			}
		}

		_ensureSourceMapObject() {
			if (this._sourceMapAsObject === undefined) {
				this._ensureSourceMapString();
				this._sourceMapAsObject = JSON.parse(this._sourceMapAsString);
			}
		}

		_ensureSourceMapBuffer() {
			if (this._sourceMapAsBuffer === undefined) {
				this._ensureSourceMapString();
				this._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, "utf-8");
			}
		}

		_ensureSourceMapString() {
			if (this._sourceMapAsString === undefined) {
				if (this._sourceMapAsBuffer !== undefined) {
					this._sourceMapAsString = this._sourceMapAsBuffer.toString("utf-8");
				} else {
					this._sourceMapAsString = JSON.stringify(this._sourceMapAsObject);
				}
			}
		}

		getArgsAsBuffers() {
			this._ensureValueBuffer();
			this._ensureSourceMapBuffer();
			this._ensureOriginalSourceBuffer();
			this._ensureInnerSourceMapBuffer();
			return [
				this._valueAsBuffer,
				this._name,
				this._sourceMapAsBuffer,
				this._originalSourceAsBuffer,
				this._innerSourceMapAsBuffer,
				this._removeOriginalSource
			];
		}

		buffer() {
			this._ensureValueBuffer();
			return this._valueAsBuffer;
		}

		source() {
			this._ensureValueString();
			return this._valueAsString;
		}

		map(options) {
			if (!this._hasInnerSourceMap) {
				this._ensureSourceMapObject();
				return this._sourceMapAsObject;
			}
			return getMap(this, options);
		}

		sourceAndMap(options) {
			if (!this._hasInnerSourceMap) {
				this._ensureValueString();
				this._ensureSourceMapObject();
				return {
					source: this._valueAsString,
					map: this._sourceMapAsObject
				};
			}
			return getSourceAndMap(this, options);
		}

		streamChunks(options, onChunk, onSource, onName) {
			this._ensureValueString();
			this._ensureSourceMapObject();
			this._ensureOriginalSourceString();
			if (this._hasInnerSourceMap) {
				this._ensureInnerSourceMapObject();
				return streamChunksOfCombinedSourceMap(
					this._valueAsString,
					this._sourceMapAsObject,
					this._name,
					this._originalSourceAsString,
					this._innerSourceMapAsObject,
					this._removeOriginalSource,
					onChunk,
					onSource,
					onName,
					!!(options && options.finalSource),
					!!(options && options.columns !== false)
				);
			} else {
				return streamChunksOfSourceMap(
					this._valueAsString,
					this._sourceMapAsObject,
					onChunk,
					onSource,
					onName,
					!!(options && options.finalSource),
					!!(options && options.columns !== false)
				);
			}
		}

		updateHash(hash) {
			this._ensureValueBuffer();
			this._ensureSourceMapBuffer();
			this._ensureOriginalSourceBuffer();
			this._ensureInnerSourceMapBuffer();

			hash.update("SourceMapSource");

			hash.update(this._valueAsBuffer);

			hash.update(this._sourceMapAsBuffer);

			if (this._hasOriginalSource) {
				hash.update(this._originalSourceAsBuffer);
			}

			if (this._hasInnerSourceMap) {
				hash.update(this._innerSourceMapAsBuffer);
			}

			hash.update(this._removeOriginalSource ? "true" : "false");
		}
	}

	SourceMapSource_1 = SourceMapSource;
	return SourceMapSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var streamChunks;
var hasRequiredStreamChunks;

function requireStreamChunks () {
	if (hasRequiredStreamChunks) return streamChunks;
	hasRequiredStreamChunks = 1;

	const streamChunksOfRawSource = requireStreamChunksOfRawSource();
	const streamChunksOfSourceMap = requireStreamChunksOfSourceMap();

	streamChunks = (source, options, onChunk, onSource, onName) => {
		if (typeof source.streamChunks === "function") {
			return source.streamChunks(options, onChunk, onSource, onName);
		} else {
			const sourceAndMap = source.sourceAndMap(options);
			if (sourceAndMap.map) {
				return streamChunksOfSourceMap(
					sourceAndMap.source,
					sourceAndMap.map,
					onChunk,
					onSource,
					onName,
					!!(options && options.finalSource),
					!!(options && options.columns !== false)
				);
			} else {
				return streamChunksOfRawSource(
					sourceAndMap.source,
					onChunk,
					onSource,
					onName,
					!!(options && options.finalSource)
				);
			}
		}
	};
	return streamChunks;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var streamAndGetSourceAndMap_1;
var hasRequiredStreamAndGetSourceAndMap;

function requireStreamAndGetSourceAndMap () {
	if (hasRequiredStreamAndGetSourceAndMap) return streamAndGetSourceAndMap_1;
	hasRequiredStreamAndGetSourceAndMap = 1;

	const createMappingsSerializer = requireCreateMappingsSerializer();
	const streamChunks = requireStreamChunks();

	const streamAndGetSourceAndMap = (
		inputSource,
		options,
		onChunk,
		onSource,
		onName
	) => {
		let code = "";
		let mappings = "";
		let sources = [];
		let sourcesContent = [];
		let names = [];
		const addMapping = createMappingsSerializer(
			Object.assign({}, options, { columns: true })
		);
		const finalSource = !!(options && options.finalSource);
		const { generatedLine, generatedColumn, source } = streamChunks(
			inputSource,
			options,
			(
				chunk,
				generatedLine,
				generatedColumn,
				sourceIndex,
				originalLine,
				originalColumn,
				nameIndex
			) => {
				if (chunk !== undefined) code += chunk;
				mappings += addMapping(
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				);
				return onChunk(
					finalSource ? undefined : chunk,
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				);
			},
			(sourceIndex, source, sourceContent) => {
				while (sources.length < sourceIndex) {
					sources.push(null);
				}
				sources[sourceIndex] = source;
				if (sourceContent !== undefined) {
					while (sourcesContent.length < sourceIndex) {
						sourcesContent.push(null);
					}
					sourcesContent[sourceIndex] = sourceContent;
				}
				return onSource(sourceIndex, source, sourceContent);
			},
			(nameIndex, name) => {
				while (names.length < nameIndex) {
					names.push(null);
				}
				names[nameIndex] = name;
				return onName(nameIndex, name);
			}
		);
		const resultSource = source !== undefined ? source : code;
		return {
			result: {
				generatedLine,
				generatedColumn,
				source: finalSource ? resultSource : undefined
			},
			source: resultSource,
			map:
				mappings.length > 0
					? {
							version: 3,
							file: "x",
							mappings,
							sources,
							sourcesContent:
								sourcesContent.length > 0 ? sourcesContent : undefined,
							names
					  }
					: null
		};
	};

	streamAndGetSourceAndMap_1 = streamAndGetSourceAndMap;
	return streamAndGetSourceAndMap_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var CachedSource_1;
var hasRequiredCachedSource;

function requireCachedSource () {
	if (hasRequiredCachedSource) return CachedSource_1;
	hasRequiredCachedSource = 1;

	const Source = requireSource();
	const streamChunksOfSourceMap = requireStreamChunksOfSourceMap();
	const streamChunksOfRawSource = requireStreamChunksOfRawSource();
	const streamAndGetSourceAndMap = requireStreamAndGetSourceAndMap();

	const mapToBufferedMap = map => {
		if (typeof map !== "object" || !map) return map;
		const bufferedMap = Object.assign({}, map);
		if (map.mappings) {
			bufferedMap.mappings = Buffer.from(map.mappings, "utf-8");
		}
		if (map.sourcesContent) {
			bufferedMap.sourcesContent = map.sourcesContent.map(
				str => str && Buffer.from(str, "utf-8")
			);
		}
		return bufferedMap;
	};

	const bufferedMapToMap = bufferedMap => {
		if (typeof bufferedMap !== "object" || !bufferedMap) return bufferedMap;
		const map = Object.assign({}, bufferedMap);
		if (bufferedMap.mappings) {
			map.mappings = bufferedMap.mappings.toString("utf-8");
		}
		if (bufferedMap.sourcesContent) {
			map.sourcesContent = bufferedMap.sourcesContent.map(
				buffer => buffer && buffer.toString("utf-8")
			);
		}
		return map;
	};

	class CachedSource extends Source {
		constructor(source, cachedData) {
			super();
			this._source = source;
			this._cachedSourceType = cachedData ? cachedData.source : undefined;
			this._cachedSource = undefined;
			this._cachedBuffer = cachedData ? cachedData.buffer : undefined;
			this._cachedSize = cachedData ? cachedData.size : undefined;
			this._cachedMaps = cachedData ? cachedData.maps : new Map();
			this._cachedHashUpdate = cachedData ? cachedData.hash : undefined;
		}

		getCachedData() {
			const bufferedMaps = new Map();
			for (const pair of this._cachedMaps) {
				let cacheEntry = pair[1];
				if (cacheEntry.bufferedMap === undefined) {
					cacheEntry.bufferedMap = mapToBufferedMap(
						this._getMapFromCacheEntry(cacheEntry)
					);
				}
				bufferedMaps.set(pair[0], {
					map: undefined,
					bufferedMap: cacheEntry.bufferedMap
				});
			}
			// We don't want to cache strings
			// So if we have a caches sources
			// create a buffer from it and only store
			// if it was a Buffer or string
			if (this._cachedSource) {
				this.buffer();
			}
			return {
				buffer: this._cachedBuffer,
				source:
					this._cachedSourceType !== undefined
						? this._cachedSourceType
						: typeof this._cachedSource === "string"
						? true
						: Buffer.isBuffer(this._cachedSource)
						? false
						: undefined,
				size: this._cachedSize,
				maps: bufferedMaps,
				hash: this._cachedHashUpdate
			};
		}

		originalLazy() {
			return this._source;
		}

		original() {
			if (typeof this._source === "function") this._source = this._source();
			return this._source;
		}

		source() {
			const source = this._getCachedSource();
			if (source !== undefined) return source;
			return (this._cachedSource = this.original().source());
		}

		_getMapFromCacheEntry(cacheEntry) {
			if (cacheEntry.map !== undefined) {
				return cacheEntry.map;
			} else if (cacheEntry.bufferedMap !== undefined) {
				return (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));
			}
		}

		_getCachedSource() {
			if (this._cachedSource !== undefined) return this._cachedSource;
			if (this._cachedBuffer && this._cachedSourceType !== undefined) {
				return (this._cachedSource = this._cachedSourceType
					? this._cachedBuffer.toString("utf-8")
					: this._cachedBuffer);
			}
		}

		buffer() {
			if (this._cachedBuffer !== undefined) return this._cachedBuffer;
			if (this._cachedSource !== undefined) {
				if (Buffer.isBuffer(this._cachedSource)) {
					return (this._cachedBuffer = this._cachedSource);
				}
				return (this._cachedBuffer = Buffer.from(this._cachedSource, "utf-8"));
			}
			if (typeof this.original().buffer === "function") {
				return (this._cachedBuffer = this.original().buffer());
			}
			const bufferOrString = this.source();
			if (Buffer.isBuffer(bufferOrString)) {
				return (this._cachedBuffer = bufferOrString);
			}
			return (this._cachedBuffer = Buffer.from(bufferOrString, "utf-8"));
		}

		size() {
			if (this._cachedSize !== undefined) return this._cachedSize;
			if (this._cachedBuffer !== undefined) {
				return (this._cachedSize = this._cachedBuffer.length);
			}
			const source = this._getCachedSource();
			if (source !== undefined) {
				return (this._cachedSize = Buffer.byteLength(source));
			}
			return (this._cachedSize = this.original().size());
		}

		sourceAndMap(options) {
			const key = options ? JSON.stringify(options) : "{}";
			const cacheEntry = this._cachedMaps.get(key);
			// Look for a cached map
			if (cacheEntry !== undefined) {
				// We have a cached map in some representation
				const map = this._getMapFromCacheEntry(cacheEntry);
				// Either get the cached source or compute it
				return { source: this.source(), map };
			}
			// Look for a cached source
			let source = this._getCachedSource();
			// Compute the map
			let map;
			if (source !== undefined) {
				map = this.original().map(options);
			} else {
				// Compute the source and map together.
				const sourceAndMap = this.original().sourceAndMap(options);
				source = sourceAndMap.source;
				map = sourceAndMap.map;
				this._cachedSource = source;
			}
			this._cachedMaps.set(key, {
				map,
				bufferedMap: undefined
			});
			return { source, map };
		}

		streamChunks(options, onChunk, onSource, onName) {
			const key = options ? JSON.stringify(options) : "{}";
			if (
				this._cachedMaps.has(key) &&
				(this._cachedBuffer !== undefined || this._cachedSource !== undefined)
			) {
				const { source, map } = this.sourceAndMap(options);
				if (map) {
					return streamChunksOfSourceMap(
						source,
						map,
						onChunk,
						onSource,
						onName,
						!!(options && options.finalSource),
						true
					);
				} else {
					return streamChunksOfRawSource(
						source,
						onChunk,
						onSource,
						onName,
						!!(options && options.finalSource)
					);
				}
			}
			const { result, source, map } = streamAndGetSourceAndMap(
				this.original(),
				options,
				onChunk,
				onSource,
				onName
			);
			this._cachedSource = source;
			this._cachedMaps.set(key, {
				map,
				bufferedMap: undefined
			});
			return result;
		}

		map(options) {
			const key = options ? JSON.stringify(options) : "{}";
			const cacheEntry = this._cachedMaps.get(key);
			if (cacheEntry !== undefined) {
				return this._getMapFromCacheEntry(cacheEntry);
			}
			const map = this.original().map(options);
			this._cachedMaps.set(key, {
				map,
				bufferedMap: undefined
			});
			return map;
		}

		updateHash(hash) {
			if (this._cachedHashUpdate !== undefined) {
				for (const item of this._cachedHashUpdate) hash.update(item);
				return;
			}
			const update = [];
			let currentString = undefined;
			const tracker = {
				update: item => {
					if (typeof item === "string" && item.length < 10240) {
						if (currentString === undefined) {
							currentString = item;
						} else {
							currentString += item;
							if (currentString.length > 102400) {
								update.push(Buffer.from(currentString));
								currentString = undefined;
							}
						}
					} else {
						if (currentString !== undefined) {
							update.push(Buffer.from(currentString));
							currentString = undefined;
						}
						update.push(item);
					}
				}
			};
			this.original().updateHash(tracker);
			if (currentString !== undefined) {
				update.push(Buffer.from(currentString));
			}
			for (const item of update) hash.update(item);
			this._cachedHashUpdate = update;
		}
	}

	CachedSource_1 = CachedSource;
	return CachedSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var ConcatSource_1;
var hasRequiredConcatSource;

function requireConcatSource () {
	if (hasRequiredConcatSource) return ConcatSource_1;
	hasRequiredConcatSource = 1;

	const Source = requireSource();
	const RawSource = requireRawSource();
	const streamChunks = requireStreamChunks();
	const { getMap, getSourceAndMap } = requireGetFromStreamChunks();

	const stringsAsRawSources = new WeakSet();

	class ConcatSource extends Source {
		constructor() {
			super();
			this._children = [];
			for (let i = 0; i < arguments.length; i++) {
				const item = arguments[i];
				if (item instanceof ConcatSource) {
					for (const child of item._children) {
						this._children.push(child);
					}
				} else {
					this._children.push(item);
				}
			}
			this._isOptimized = arguments.length === 0;
		}

		getChildren() {
			if (!this._isOptimized) this._optimize();
			return this._children;
		}

		add(item) {
			if (item instanceof ConcatSource) {
				for (const child of item._children) {
					this._children.push(child);
				}
			} else {
				this._children.push(item);
			}
			this._isOptimized = false;
		}

		addAllSkipOptimizing(items) {
			for (const item of items) {
				this._children.push(item);
			}
		}

		buffer() {
			if (!this._isOptimized) this._optimize();
			const buffers = [];
			for (const child of this._children) {
				if (typeof child.buffer === "function") {
					buffers.push(child.buffer());
				} else {
					const bufferOrString = child.source();
					if (Buffer.isBuffer(bufferOrString)) {
						buffers.push(bufferOrString);
					} else {
						// This will not happen
						buffers.push(Buffer.from(bufferOrString, "utf-8"));
					}
				}
			}
			return Buffer.concat(buffers);
		}

		source() {
			if (!this._isOptimized) this._optimize();
			let source = "";
			for (const child of this._children) {
				source += child.source();
			}
			return source;
		}

		size() {
			if (!this._isOptimized) this._optimize();
			let size = 0;
			for (const child of this._children) {
				size += child.size();
			}
			return size;
		}

		map(options) {
			return getMap(this, options);
		}

		sourceAndMap(options) {
			return getSourceAndMap(this, options);
		}

		streamChunks(options, onChunk, onSource, onName) {
			if (!this._isOptimized) this._optimize();
			if (this._children.length === 1)
				return this._children[0].streamChunks(options, onChunk, onSource, onName);
			let currentLineOffset = 0;
			let currentColumnOffset = 0;
			let sourceMapping = new Map();
			let nameMapping = new Map();
			const finalSource = !!(options && options.finalSource);
			let code = "";
			let needToCloseMapping = false;
			for (const item of this._children) {
				const sourceIndexMapping = [];
				const nameIndexMapping = [];
				let lastMappingLine = 0;
				const { generatedLine, generatedColumn, source } = streamChunks(
					item,
					options,
					// eslint-disable-next-line no-loop-func
					(
						chunk,
						generatedLine,
						generatedColumn,
						sourceIndex,
						originalLine,
						originalColumn,
						nameIndex
					) => {
						const line = generatedLine + currentLineOffset;
						const column =
							generatedLine === 1
								? generatedColumn + currentColumnOffset
								: generatedColumn;
						if (needToCloseMapping) {
							if (generatedLine !== 1 || generatedColumn !== 0) {
								onChunk(
									undefined,
									currentLineOffset + 1,
									currentColumnOffset,
									-1,
									-1,
									-1,
									-1
								);
							}
							needToCloseMapping = false;
						}
						const resultSourceIndex =
							sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length
								? -1
								: sourceIndexMapping[sourceIndex];
						const resultNameIndex =
							nameIndex < 0 || nameIndex >= nameIndexMapping.length
								? -1
								: nameIndexMapping[nameIndex];
						lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;
						if (finalSource) {
							if (chunk !== undefined) code += chunk;
							if (resultSourceIndex >= 0) {
								onChunk(
									undefined,
									line,
									column,
									resultSourceIndex,
									originalLine,
									originalColumn,
									resultNameIndex
								);
							}
						} else {
							if (resultSourceIndex < 0) {
								onChunk(chunk, line, column, -1, -1, -1, -1);
							} else {
								onChunk(
									chunk,
									line,
									column,
									resultSourceIndex,
									originalLine,
									originalColumn,
									resultNameIndex
								);
							}
						}
					},
					(i, source, sourceContent) => {
						let globalIndex = sourceMapping.get(source);
						if (globalIndex === undefined) {
							sourceMapping.set(source, (globalIndex = sourceMapping.size));
							onSource(globalIndex, source, sourceContent);
						}
						sourceIndexMapping[i] = globalIndex;
					},
					(i, name) => {
						let globalIndex = nameMapping.get(name);
						if (globalIndex === undefined) {
							nameMapping.set(name, (globalIndex = nameMapping.size));
							onName(globalIndex, name);
						}
						nameIndexMapping[i] = globalIndex;
					}
				);
				if (source !== undefined) code += source;
				if (needToCloseMapping) {
					if (generatedLine !== 1 || generatedColumn !== 0) {
						onChunk(
							undefined,
							currentLineOffset + 1,
							currentColumnOffset,
							-1,
							-1,
							-1,
							-1
						);
						needToCloseMapping = false;
					}
				}
				if (generatedLine > 1) {
					currentColumnOffset = generatedColumn;
				} else {
					currentColumnOffset += generatedColumn;
				}
				needToCloseMapping =
					needToCloseMapping ||
					(finalSource && lastMappingLine === generatedLine);
				currentLineOffset += generatedLine - 1;
			}
			return {
				generatedLine: currentLineOffset + 1,
				generatedColumn: currentColumnOffset,
				source: finalSource ? code : undefined
			};
		}

		updateHash(hash) {
			if (!this._isOptimized) this._optimize();
			hash.update("ConcatSource");
			for (const item of this._children) {
				item.updateHash(hash);
			}
		}

		_optimize() {
			const newChildren = [];
			let currentString = undefined;
			let currentRawSources = undefined;
			const addStringToRawSources = string => {
				if (currentRawSources === undefined) {
					currentRawSources = string;
				} else if (Array.isArray(currentRawSources)) {
					currentRawSources.push(string);
				} else {
					currentRawSources = [
						typeof currentRawSources === "string"
							? currentRawSources
							: currentRawSources.source(),
						string
					];
				}
			};
			const addSourceToRawSources = source => {
				if (currentRawSources === undefined) {
					currentRawSources = source;
				} else if (Array.isArray(currentRawSources)) {
					currentRawSources.push(source.source());
				} else {
					currentRawSources = [
						typeof currentRawSources === "string"
							? currentRawSources
							: currentRawSources.source(),
						source.source()
					];
				}
			};
			const mergeRawSources = () => {
				if (Array.isArray(currentRawSources)) {
					const rawSource = new RawSource(currentRawSources.join(""));
					stringsAsRawSources.add(rawSource);
					newChildren.push(rawSource);
				} else if (typeof currentRawSources === "string") {
					const rawSource = new RawSource(currentRawSources);
					stringsAsRawSources.add(rawSource);
					newChildren.push(rawSource);
				} else {
					newChildren.push(currentRawSources);
				}
			};
			for (const child of this._children) {
				if (typeof child === "string") {
					if (currentString === undefined) {
						currentString = child;
					} else {
						currentString += child;
					}
				} else {
					if (currentString !== undefined) {
						addStringToRawSources(currentString);
						currentString = undefined;
					}
					if (stringsAsRawSources.has(child)) {
						addSourceToRawSources(child);
					} else {
						if (currentRawSources !== undefined) {
							mergeRawSources();
							currentRawSources = undefined;
						}
						newChildren.push(child);
					}
				}
			}
			if (currentString !== undefined) {
				addStringToRawSources(currentString);
			}
			if (currentRawSources !== undefined) {
				mergeRawSources();
			}
			this._children = newChildren;
			this._isOptimized = true;
		}
	}

	ConcatSource_1 = ConcatSource;
	return ConcatSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var ReplaceSource_1;
var hasRequiredReplaceSource;

function requireReplaceSource () {
	if (hasRequiredReplaceSource) return ReplaceSource_1;
	hasRequiredReplaceSource = 1;

	const { getMap, getSourceAndMap } = requireGetFromStreamChunks();
	const streamChunks = requireStreamChunks();
	const Source = requireSource();
	const splitIntoLines = requireSplitIntoLines();

	// since v8 7.0, Array.prototype.sort is stable
	const hasStableSort =
		typeof process === "object" &&
		process.versions &&
		typeof process.versions.v8 === "string" &&
		!/^[0-6]\./.test(process.versions.v8);

	// This is larger than max string length
	const MAX_SOURCE_POSITION = 0x20000000;

	class Replacement {
		constructor(start, end, content, name) {
			this.start = start;
			this.end = end;
			this.content = content;
			this.name = name;
			if (!hasStableSort) {
				this.index = -1;
			}
		}
	}

	class ReplaceSource extends Source {
		constructor(source, name) {
			super();
			this._source = source;
			this._name = name;
			/** @type {Replacement[]} */
			this._replacements = [];
			this._isSorted = true;
		}

		getName() {
			return this._name;
		}

		getReplacements() {
			this._sortReplacements();
			return this._replacements;
		}

		replace(start, end, newValue, name) {
			if (typeof newValue !== "string")
				throw new Error(
					"insertion must be a string, but is a " + typeof newValue
				);
			this._replacements.push(new Replacement(start, end, newValue, name));
			this._isSorted = false;
		}

		insert(pos, newValue, name) {
			if (typeof newValue !== "string")
				throw new Error(
					"insertion must be a string, but is a " +
						typeof newValue +
						": " +
						newValue
				);
			this._replacements.push(new Replacement(pos, pos - 1, newValue, name));
			this._isSorted = false;
		}

		source() {
			if (this._replacements.length === 0) {
				return this._source.source();
			}
			let current = this._source.source();
			let pos = 0;
			const result = [];

			this._sortReplacements();
			for (const replacement of this._replacements) {
				const start = Math.floor(replacement.start);
				const end = Math.floor(replacement.end + 1);
				if (pos < start) {
					const offset = start - pos;
					result.push(current.slice(0, offset));
					current = current.slice(offset);
					pos = start;
				}
				result.push(replacement.content);
				if (pos < end) {
					const offset = end - pos;
					current = current.slice(offset);
					pos = end;
				}
			}
			result.push(current);
			return result.join("");
		}

		map(options) {
			if (this._replacements.length === 0) {
				return this._source.map(options);
			}
			return getMap(this, options);
		}

		sourceAndMap(options) {
			if (this._replacements.length === 0) {
				return this._source.sourceAndMap(options);
			}
			return getSourceAndMap(this, options);
		}

		original() {
			return this._source;
		}

		_sortReplacements() {
			if (this._isSorted) return;
			if (hasStableSort) {
				this._replacements.sort(function (a, b) {
					const diff1 = a.start - b.start;
					if (diff1 !== 0) return diff1;
					const diff2 = a.end - b.end;
					if (diff2 !== 0) return diff2;
					return 0;
				});
			} else {
				this._replacements.forEach((repl, i) => (repl.index = i));
				this._replacements.sort(function (a, b) {
					const diff1 = a.start - b.start;
					if (diff1 !== 0) return diff1;
					const diff2 = a.end - b.end;
					if (diff2 !== 0) return diff2;
					return a.index - b.index;
				});
			}
			this._isSorted = true;
		}

		streamChunks(options, onChunk, onSource, onName) {
			this._sortReplacements();
			const repls = this._replacements;
			let pos = 0;
			let i = 0;
			let replacmentEnd = -1;
			let nextReplacement =
				i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
			let generatedLineOffset = 0;
			let generatedColumnOffset = 0;
			let generatedColumnOffsetLine = 0;
			const sourceContents = [];
			const nameMapping = new Map();
			const nameIndexMapping = [];
			const checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {
				let content =
					sourceIndex < sourceContents.length
						? sourceContents[sourceIndex]
						: undefined;
				if (content === undefined) return false;
				if (typeof content === "string") {
					content = splitIntoLines(content);
					sourceContents[sourceIndex] = content;
				}
				const contentLine = line <= content.length ? content[line - 1] : null;
				if (contentLine === null) return false;
				return (
					contentLine.slice(column, column + expectedChunk.length) ===
					expectedChunk
				);
			};
			let { generatedLine, generatedColumn } = streamChunks(
				this._source,
				Object.assign({}, options, { finalSource: false }),
				(
					chunk,
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				) => {
					let chunkPos = 0;
					let endPos = pos + chunk.length;

					// Skip over when it has been replaced
					if (replacmentEnd > pos) {
						// Skip over the whole chunk
						if (replacmentEnd >= endPos) {
							const line = generatedLine + generatedLineOffset;
							if (chunk.endsWith("\n")) {
								generatedLineOffset--;
								if (generatedColumnOffsetLine === line) {
									// undo exiting corrections form the current line
									generatedColumnOffset += generatedColumn;
								}
							} else if (generatedColumnOffsetLine === line) {
								generatedColumnOffset -= chunk.length;
							} else {
								generatedColumnOffset = -chunk.length;
								generatedColumnOffsetLine = line;
							}
							pos = endPos;
							return;
						}

						// Partially skip over chunk
						chunkPos = replacmentEnd - pos;
						if (
							checkOriginalContent(
								sourceIndex,
								originalLine,
								originalColumn,
								chunk.slice(0, chunkPos)
							)
						) {
							originalColumn += chunkPos;
						}
						pos += chunkPos;
						const line = generatedLine + generatedLineOffset;
						if (generatedColumnOffsetLine === line) {
							generatedColumnOffset -= chunkPos;
						} else {
							generatedColumnOffset = -chunkPos;
							generatedColumnOffsetLine = line;
						}
						generatedColumn += chunkPos;
					}

					// Is a replacement in the chunk?
					if (nextReplacement < endPos) {
						do {
							let line = generatedLine + generatedLineOffset;
							if (nextReplacement > pos) {
								// Emit chunk until replacement
								const offset = nextReplacement - pos;
								const chunkSlice = chunk.slice(chunkPos, chunkPos + offset);
								onChunk(
									chunkSlice,
									line,
									generatedColumn +
										(line === generatedColumnOffsetLine
											? generatedColumnOffset
											: 0),
									sourceIndex,
									originalLine,
									originalColumn,
									nameIndex < 0 || nameIndex >= nameIndexMapping.length
										? -1
										: nameIndexMapping[nameIndex]
								);
								generatedColumn += offset;
								chunkPos += offset;
								pos = nextReplacement;
								if (
									checkOriginalContent(
										sourceIndex,
										originalLine,
										originalColumn,
										chunkSlice
									)
								) {
									originalColumn += chunkSlice.length;
								}
							}

							// Insert replacement content splitted into chunks by lines
							const { content, name } = repls[i];
							let matches = splitIntoLines(content);
							let replacementNameIndex = nameIndex;
							if (sourceIndex >= 0 && name) {
								let globalIndex = nameMapping.get(name);
								if (globalIndex === undefined) {
									globalIndex = nameMapping.size;
									nameMapping.set(name, globalIndex);
									onName(globalIndex, name);
								}
								replacementNameIndex = globalIndex;
							}
							for (let m = 0; m < matches.length; m++) {
								const contentLine = matches[m];
								onChunk(
									contentLine,
									line,
									generatedColumn +
										(line === generatedColumnOffsetLine
											? generatedColumnOffset
											: 0),
									sourceIndex,
									originalLine,
									originalColumn,
									replacementNameIndex
								);

								// Only the first chunk has name assigned
								replacementNameIndex = -1;

								if (m === matches.length - 1 && !contentLine.endsWith("\n")) {
									if (generatedColumnOffsetLine === line) {
										generatedColumnOffset += contentLine.length;
									} else {
										generatedColumnOffset = contentLine.length;
										generatedColumnOffsetLine = line;
									}
								} else {
									generatedLineOffset++;
									line++;
									generatedColumnOffset = -generatedColumn;
									generatedColumnOffsetLine = line;
								}
							}

							// Remove replaced content by settings this variable
							replacmentEnd = Math.max(
								replacmentEnd,
								Math.floor(repls[i].end + 1)
							);

							// Move to next replacment
							i++;
							nextReplacement =
								i < repls.length
									? Math.floor(repls[i].start)
									: MAX_SOURCE_POSITION;

							// Skip over when it has been replaced
							const offset = chunk.length - endPos + replacmentEnd - chunkPos;
							if (offset > 0) {
								// Skip over whole chunk
								if (replacmentEnd >= endPos) {
									let line = generatedLine + generatedLineOffset;
									if (chunk.endsWith("\n")) {
										generatedLineOffset--;
										if (generatedColumnOffsetLine === line) {
											// undo exiting corrections form the current line
											generatedColumnOffset += generatedColumn;
										}
									} else if (generatedColumnOffsetLine === line) {
										generatedColumnOffset -= chunk.length - chunkPos;
									} else {
										generatedColumnOffset = chunkPos - chunk.length;
										generatedColumnOffsetLine = line;
									}
									pos = endPos;
									return;
								}

								// Partially skip over chunk
								const line = generatedLine + generatedLineOffset;
								if (
									checkOriginalContent(
										sourceIndex,
										originalLine,
										originalColumn,
										chunk.slice(chunkPos, chunkPos + offset)
									)
								) {
									originalColumn += offset;
								}
								chunkPos += offset;
								pos += offset;
								if (generatedColumnOffsetLine === line) {
									generatedColumnOffset -= offset;
								} else {
									generatedColumnOffset = -offset;
									generatedColumnOffsetLine = line;
								}
								generatedColumn += offset;
							}
						} while (nextReplacement < endPos);
					}

					// Emit remaining chunk
					if (chunkPos < chunk.length) {
						const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);
						const line = generatedLine + generatedLineOffset;
						onChunk(
							chunkSlice,
							line,
							generatedColumn +
								(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),
							sourceIndex,
							originalLine,
							originalColumn,
							nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]
						);
					}
					pos = endPos;
				},
				(sourceIndex, source, sourceContent) => {
					while (sourceContents.length < sourceIndex)
						sourceContents.push(undefined);
					sourceContents[sourceIndex] = sourceContent;
					onSource(sourceIndex, source, sourceContent);
				},
				(nameIndex, name) => {
					let globalIndex = nameMapping.get(name);
					if (globalIndex === undefined) {
						globalIndex = nameMapping.size;
						nameMapping.set(name, globalIndex);
						onName(globalIndex, name);
					}
					nameIndexMapping[nameIndex] = globalIndex;
				}
			);

			// Handle remaining replacements
			let remainer = "";
			for (; i < repls.length; i++) {
				remainer += repls[i].content;
			}

			// Insert remaining replacements content splitted into chunks by lines
			let line = generatedLine + generatedLineOffset;
			let matches = splitIntoLines(remainer);
			for (let m = 0; m < matches.length; m++) {
				const contentLine = matches[m];
				onChunk(
					contentLine,
					line,
					generatedColumn +
						(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),
					-1,
					-1,
					-1,
					-1
				);

				if (m === matches.length - 1 && !contentLine.endsWith("\n")) {
					if (generatedColumnOffsetLine === line) {
						generatedColumnOffset += contentLine.length;
					} else {
						generatedColumnOffset = contentLine.length;
						generatedColumnOffsetLine = line;
					}
				} else {
					generatedLineOffset++;
					line++;
					generatedColumnOffset = -generatedColumn;
					generatedColumnOffsetLine = line;
				}
			}

			return {
				generatedLine: line,
				generatedColumn:
					generatedColumn +
					(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)
			};
		}

		updateHash(hash) {
			this._sortReplacements();
			hash.update("ReplaceSource");
			this._source.updateHash(hash);
			hash.update(this._name || "");
			for (const repl of this._replacements) {
				hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);
			}
		}
	}

	ReplaceSource_1 = ReplaceSource;
	return ReplaceSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var PrefixSource_1;
var hasRequiredPrefixSource;

function requirePrefixSource () {
	if (hasRequiredPrefixSource) return PrefixSource_1;
	hasRequiredPrefixSource = 1;

	const Source = requireSource();
	const RawSource = requireRawSource();
	const streamChunks = requireStreamChunks();
	const { getMap, getSourceAndMap } = requireGetFromStreamChunks();

	const REPLACE_REGEX = /\n(?=.|\s)/g;

	class PrefixSource extends Source {
		constructor(prefix, source) {
			super();
			this._source =
				typeof source === "string" || Buffer.isBuffer(source)
					? new RawSource(source, true)
					: source;
			this._prefix = prefix;
		}

		getPrefix() {
			return this._prefix;
		}

		original() {
			return this._source;
		}

		source() {
			const node = this._source.source();
			const prefix = this._prefix;
			return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
		}

		// TODO efficient buffer() implementation

		map(options) {
			return getMap(this, options);
		}

		sourceAndMap(options) {
			return getSourceAndMap(this, options);
		}

		streamChunks(options, onChunk, onSource, onName) {
			const prefix = this._prefix;
			const prefixOffset = prefix.length;
			const linesOnly = !!(options && options.columns === false);
			const { generatedLine, generatedColumn, source } = streamChunks(
				this._source,
				options,
				(
					chunk,
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				) => {
					if (generatedColumn !== 0) {
						// In the middle of the line, we just adject the column
						generatedColumn += prefixOffset;
					} else if (chunk !== undefined) {
						// At the start of the line, when we have source content
						// add the prefix as generated mapping
						// (in lines only mode we just add it to the original mapping
						// for performance reasons)
						if (linesOnly || sourceIndex < 0) {
							chunk = prefix + chunk;
						} else if (prefixOffset > 0) {
							onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);
							generatedColumn += prefixOffset;
						}
					} else if (!linesOnly) {
						// Without source content, we only need to adject the column info
						// expect in lines only mode where prefix is added to original mapping
						generatedColumn += prefixOffset;
					}
					onChunk(
						chunk,
						generatedLine,
						generatedColumn,
						sourceIndex,
						originalLine,
						originalColumn,
						nameIndex
					);
				},
				onSource,
				onName
			);
			return {
				generatedLine,
				generatedColumn:
					generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,
				source:
					source !== undefined
						? prefix + source.replace(REPLACE_REGEX, "\n" + prefix)
						: undefined
			};
		}

		updateHash(hash) {
			hash.update("PrefixSource");
			this._source.updateHash(hash);
			hash.update(this._prefix);
		}
	}

	PrefixSource_1 = PrefixSource;
	return PrefixSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var SizeOnlySource_1;
var hasRequiredSizeOnlySource;

function requireSizeOnlySource () {
	if (hasRequiredSizeOnlySource) return SizeOnlySource_1;
	hasRequiredSizeOnlySource = 1;

	const Source = requireSource();

	class SizeOnlySource extends Source {
		constructor(size) {
			super();
			this._size = size;
		}

		_error() {
			return new Error(
				"Content and Map of this Source is not available (only size() is supported)"
			);
		}

		size() {
			return this._size;
		}

		source() {
			throw this._error();
		}

		buffer() {
			throw this._error();
		}

		map(options) {
			throw this._error();
		}

		updateHash() {
			throw this._error();
		}
	}

	SizeOnlySource_1 = SizeOnlySource;
	return SizeOnlySource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var CompatSource_1;
var hasRequiredCompatSource;

function requireCompatSource () {
	if (hasRequiredCompatSource) return CompatSource_1;
	hasRequiredCompatSource = 1;

	const Source = requireSource();

	class CompatSource extends Source {
		static from(sourceLike) {
			return sourceLike instanceof Source
				? sourceLike
				: new CompatSource(sourceLike);
		}

		constructor(sourceLike) {
			super();
			this._sourceLike = sourceLike;
		}

		source() {
			return this._sourceLike.source();
		}

		buffer() {
			if (typeof this._sourceLike.buffer === "function") {
				return this._sourceLike.buffer();
			}
			return super.buffer();
		}

		size() {
			if (typeof this._sourceLike.size === "function") {
				return this._sourceLike.size();
			}
			return super.size();
		}

		map(options) {
			if (typeof this._sourceLike.map === "function") {
				return this._sourceLike.map(options);
			}
			return super.map(options);
		}

		sourceAndMap(options) {
			if (typeof this._sourceLike.sourceAndMap === "function") {
				return this._sourceLike.sourceAndMap(options);
			}
			return super.sourceAndMap(options);
		}

		updateHash(hash) {
			if (typeof this._sourceLike.updateHash === "function") {
				return this._sourceLike.updateHash(hash);
			}
			if (typeof this._sourceLike.map === "function") {
				throw new Error(
					"A Source-like object with a 'map' method must also provide an 'updateHash' method"
				);
			}
			hash.update(this.buffer());
		}
	}

	CompatSource_1 = CompatSource;
	return CompatSource_1;
}

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

(function (exports) {
	const defineExport = (name, fn) => {
		let value;
		Object.defineProperty(exports, name, {
			get: () => {
				if (fn !== undefined) {
					value = fn();
					fn = undefined;
				}
				return value;
			},
			configurable: true
		});
	};

	defineExport("Source", () => requireSource());

	defineExport("RawSource", () => requireRawSource());
	defineExport("OriginalSource", () => requireOriginalSource());
	defineExport("SourceMapSource", () => requireSourceMapSource());
	defineExport("CachedSource", () => requireCachedSource());
	defineExport("ConcatSource", () => requireConcatSource());
	defineExport("ReplaceSource", () => requireReplaceSource());
	defineExport("PrefixSource", () => requirePrefixSource());
	defineExport("SizeOnlySource", () => requireSizeOnlySource());
	defineExport("CompatSource", () => requireCompatSource()); 
} (lib$b));

var sources2 = /*@__PURE__*/getDefaultExportFromCjs(lib$b);

var virtualStats = {};

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(virtualStats, "__esModule", { value: true });
virtualStats.VirtualStats = void 0;
const constants_1 = __importDefault$1(require$$0$3);
class VirtualStats {
    constructor(config) {
        for (const key in config) {
            if (!Object.prototype.hasOwnProperty.call(config, key)) {
                continue;
            }
            this[key] = config[key];
        }
    }
    _checkModeProperty(property) {
        return (this.mode & constants_1.default.S_IFMT) === property;
    }
    isDirectory() {
        return this._checkModeProperty(constants_1.default.S_IFDIR);
    }
    isFile() {
        return this._checkModeProperty(constants_1.default.S_IFREG);
    }
    isBlockDevice() {
        return this._checkModeProperty(constants_1.default.S_IFBLK);
    }
    isCharacterDevice() {
        return this._checkModeProperty(constants_1.default.S_IFCHR);
    }
    isSymbolicLink() {
        return this._checkModeProperty(constants_1.default.S_IFLNK);
    }
    isFIFO() {
        return this._checkModeProperty(constants_1.default.S_IFIFO);
    }
    isSocket() {
        return this._checkModeProperty(constants_1.default.S_IFSOCK);
    }
}
virtualStats.VirtualStats = VirtualStats;

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __importDefault(require$$0$4);
const virtual_stats_1 = virtualStats;
let inode = 45000000;
function checkActivation(instance) {
    if (!instance._compiler) {
        throw new Error('You must use this plugin only after creating webpack instance!');
    }
}
function getModulePath(filePath, compiler) {
    return path_1.default.isAbsolute(filePath) ? filePath : path_1.default.join(compiler.context, filePath);
}
function createWebpackData(result) {
    return (backendOrStorage) => {
        if (backendOrStorage._data) {
            const curLevelIdx = backendOrStorage._currentLevel;
            const curLevel = backendOrStorage._levels[curLevelIdx];
            return {
                result,
                level: curLevel,
            };
        }
        return [null, result];
    };
}
function getData(storage, key) {
    if (storage._data instanceof Map) {
        return storage._data.get(key);
    }
    else if (storage._data) {
        return storage.data[key];
    }
    else if (storage.data instanceof Map) {
        return storage.data.get(key);
    }
    else {
        return storage.data[key];
    }
}
function setData(backendOrStorage, key, valueFactory) {
    const value = valueFactory(backendOrStorage);
    if (backendOrStorage._data instanceof Map) {
        backendOrStorage._data.set(key, value);
    }
    else if (backendOrStorage._data) {
        backendOrStorage.data[key] = value;
    }
    else if (backendOrStorage.data instanceof Map) {
        backendOrStorage.data.set(key, value);
    }
    else {
        backendOrStorage.data[key] = value;
    }
}
function getStatStorage(fileSystem) {
    if (fileSystem._statStorage) {
        return fileSystem._statStorage;
    }
    else if (fileSystem._statBackend) {
        return fileSystem._statBackend;
    }
    else {
        throw new Error("Couldn't find a stat storage");
    }
}
function getFileStorage(fileSystem) {
    if (fileSystem._readFileStorage) {
        return fileSystem._readFileStorage;
    }
    else if (fileSystem._readFileBackend) {
        return fileSystem._readFileBackend;
    }
    else {
        throw new Error("Couldn't find a readFileStorage");
    }
}
function getReadDirBackend(fileSystem) {
    if (fileSystem._readdirBackend) {
        return fileSystem._readdirBackend;
    }
    else if (fileSystem._readdirStorage) {
        return fileSystem._readdirStorage;
    }
    else {
        throw new Error("Couldn't find a readDirStorage from Webpack Internals");
    }
}
class VirtualModulesPlugin {
    constructor(modules) {
        this._compiler = null;
        this._watcher = null;
        this._staticModules = modules || null;
    }
    writeModule(filePath, contents) {
        if (!this._compiler) {
            throw new Error(`Plugin has not been initialized`);
        }
        checkActivation(this);
        const len = contents ? contents.length : 0;
        const time = Date.now();
        const date = new Date(time);
        const stats = new virtual_stats_1.VirtualStats({
            dev: 8675309,
            nlink: 0,
            uid: 1000,
            gid: 1000,
            rdev: 0,
            blksize: 4096,
            ino: inode++,
            mode: 33188,
            size: len,
            blocks: Math.floor(len / 4096),
            atime: date,
            mtime: date,
            ctime: date,
            birthtime: date,
        });
        const modulePath = getModulePath(filePath, this._compiler);
        if (process.env.WVM_DEBUG)
            console.log(this._compiler.name, 'Write virtual module:', modulePath, contents);
        let finalWatchFileSystem = this._watcher && this._watcher.watchFileSystem;
        while (finalWatchFileSystem && finalWatchFileSystem.wfs) {
            finalWatchFileSystem = finalWatchFileSystem.wfs;
        }
        let finalInputFileSystem = this._compiler.inputFileSystem;
        while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {
            finalInputFileSystem = finalInputFileSystem._inputFileSystem;
        }
        finalInputFileSystem._writeVirtualFile(modulePath, stats, contents);
        if (finalWatchFileSystem &&
            (finalWatchFileSystem.watcher.fileWatchers.size || finalWatchFileSystem.watcher.fileWatchers.length)) {
            const fileWatchers = finalWatchFileSystem.watcher.fileWatchers instanceof Map
                ? Array.from(finalWatchFileSystem.watcher.fileWatchers.values())
                : finalWatchFileSystem.watcher.fileWatchers;
            for (let fileWatcher of fileWatchers) {
                if ('watcher' in fileWatcher) {
                    fileWatcher = fileWatcher.watcher;
                }
                if (fileWatcher.path === modulePath) {
                    if (process.env.DEBUG)
                        console.log(this._compiler.name, 'Emit file change:', modulePath, time);
                    delete fileWatcher.directoryWatcher._cachedTimeInfoEntries;
                    fileWatcher.emit('change', time, null);
                }
            }
        }
    }
    apply(compiler) {
        this._compiler = compiler;
        const afterEnvironmentHook = () => {
            let finalInputFileSystem = compiler.inputFileSystem;
            while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {
                finalInputFileSystem = finalInputFileSystem._inputFileSystem;
            }
            if (!finalInputFileSystem._writeVirtualFile) {
                const originalPurge = finalInputFileSystem.purge;
                finalInputFileSystem.purge = () => {
                    originalPurge.apply(finalInputFileSystem, []);
                    if (finalInputFileSystem._virtualFiles) {
                        Object.keys(finalInputFileSystem._virtualFiles).forEach((file) => {
                            const data = finalInputFileSystem._virtualFiles[file];
                            finalInputFileSystem._writeVirtualFile(file, data.stats, data.contents);
                        });
                    }
                };
                finalInputFileSystem._writeVirtualFile = (file, stats, contents) => {
                    const statStorage = getStatStorage(finalInputFileSystem);
                    const fileStorage = getFileStorage(finalInputFileSystem);
                    const readDirStorage = getReadDirBackend(finalInputFileSystem);
                    finalInputFileSystem._virtualFiles = finalInputFileSystem._virtualFiles || {};
                    finalInputFileSystem._virtualFiles[file] = { stats: stats, contents: contents };
                    setData(statStorage, file, createWebpackData(stats));
                    setData(fileStorage, file, createWebpackData(contents));
                    const segments = file.split(/[\\/]/);
                    let count = segments.length - 1;
                    const minCount = segments[0] ? 1 : 0;
                    while (count > minCount) {
                        const dir = segments.slice(0, count).join(path_1.default.sep) || path_1.default.sep;
                        try {
                            finalInputFileSystem.readdirSync(dir);
                        }
                        catch (e) {
                            const time = Date.now();
                            const dirStats = new virtual_stats_1.VirtualStats({
                                dev: 8675309,
                                nlink: 0,
                                uid: 1000,
                                gid: 1000,
                                rdev: 0,
                                blksize: 4096,
                                ino: inode++,
                                mode: 16877,
                                size: stats.size,
                                blocks: Math.floor(stats.size / 4096),
                                atime: time,
                                mtime: time,
                                ctime: time,
                                birthtime: time,
                            });
                            setData(readDirStorage, dir, createWebpackData([]));
                            setData(statStorage, dir, createWebpackData(dirStats));
                        }
                        let dirData = getData(getReadDirBackend(finalInputFileSystem), dir);
                        dirData = dirData[1] || dirData.result;
                        const filename = segments[count];
                        if (dirData.indexOf(filename) < 0) {
                            const files = dirData.concat([filename]).sort();
                            setData(getReadDirBackend(finalInputFileSystem), dir, createWebpackData(files));
                        }
                        else {
                            break;
                        }
                        count--;
                    }
                };
            }
        };
        const afterResolversHook = () => {
            if (this._staticModules) {
                for (const [filePath, contents] of Object.entries(this._staticModules)) {
                    this.writeModule(filePath, contents);
                }
                this._staticModules = null;
            }
        };
        const version = typeof compiler.webpack === 'undefined' ? 4 : 5;
        const watchRunHook = (watcher, callback) => {
            this._watcher = watcher.compiler || watcher;
            const virtualFiles = compiler.inputFileSystem._virtualFiles;
            const fts = compiler.fileTimestamps;
            if (virtualFiles && fts && typeof fts.set === 'function') {
                Object.keys(virtualFiles).forEach((file) => {
                    const mtime = +virtualFiles[file].stats.mtime;
                    fts.set(file, version === 4
                        ? mtime
                        : {
                            safeTime: mtime,
                            timestamp: mtime,
                        });
                });
            }
            callback();
        };
        if (compiler.hooks) {
            compiler.hooks.afterEnvironment.tap('VirtualModulesPlugin', afterEnvironmentHook);
            compiler.hooks.afterResolvers.tap('VirtualModulesPlugin', afterResolversHook);
            compiler.hooks.watchRun.tapAsync('VirtualModulesPlugin', watchRunHook);
        }
        else {
            compiler.plugin('after-environment', afterEnvironmentHook);
            compiler.plugin('after-resolvers', afterResolversHook);
            compiler.plugin('watch-run', watchRunHook);
        }
    }
}
var lib$a = VirtualModulesPlugin;


var VirtualModulesPlugin$1 = /*@__PURE__*/getDefaultExportFromCjs(lib$a);

// node_modules/.pnpm/tsup@7.2.0_typescript@5.2.2/node_modules/tsup/assets/esm_shims.js
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => require$$0$4.dirname(getFilename());
var __dirname$1 = /* @__PURE__ */ getDirname();

// node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.14/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma$1 = ",".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i2 = 0; i2 < chars.length; i2++) {
  const c = chars.charCodeAt(i2);
  intToChar[i2] = c;
  charToInt[c] = i2;
}
function decode$1(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let index = 0;
  do {
    const semi = indexOf(mappings, index);
    const line = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;
    for (let i2 = index; i2 < semi; i2++) {
      let seg;
      i2 = decodeInteger(mappings, i2, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (hasMoreVlq(mappings, i2, semi)) {
        i2 = decodeInteger(mappings, i2, state, 1);
        i2 = decodeInteger(mappings, i2, state, 2);
        i2 = decodeInteger(mappings, i2, state, 3);
        if (hasMoreVlq(mappings, i2, semi)) {
          i2 = decodeInteger(mappings, i2, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }
      line.push(seg);
    }
    if (!sorted)
      sort$1(line);
    decoded.push(line);
    index = semi + 1;
  } while (index <= mappings.length);
  return decoded;
}
function indexOf(mappings, index) {
  const idx = mappings.indexOf(";", index);
  return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = mappings.charCodeAt(pos++);
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  state[j] += value;
  return pos;
}
function hasMoreVlq(mappings, i2, length) {
  if (i2 >= length)
    return false;
  return mappings.charCodeAt(i2) !== comma$1;
}
function sort$1(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}

// node_modules/.pnpm/@jridgewell+resolve-uri@3.1.0/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function(UrlType2) {
  UrlType2[UrlType2["Empty"] = 1] = "Empty";
  UrlType2[UrlType2["Hash"] = 2] = "Hash";
  UrlType2[UrlType2["Query"] = 3] = "Query";
  UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
  UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input);
  const path4 = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path4) ? path4 : "/" + path4, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path4, query, hash) {
  return {
    scheme,
    user,
    host,
    port,
    path: path4,
    query,
    hash,
    type: UrlType.Absolute
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    const url2 = parseAbsoluteUrl("http:" + input);
    url2.scheme = "";
    url2.type = UrlType.SchemeRelative;
    return url2;
  }
  if (isAbsolutePath(input)) {
    const url2 = parseAbsoluteUrl("http://foo.com" + input);
    url2.scheme = "";
    url2.host = "";
    url2.type = UrlType.AbsolutePath;
    return url2;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url = parseAbsoluteUrl("http://foo.com/" + input);
  url.scheme = "";
  url.host = "";
  url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
  return url;
}
function stripPathFilename(path4) {
  if (path4.endsWith("/.."))
    return path4;
  const index = path4.lastIndexOf("/");
  return path4.slice(0, index + 1);
}
function mergePaths(url, base) {
  normalizePath(base, base.type);
  if (url.path === "/") {
    url.path = base.path;
  } else {
    url.path = stripPathFilename(base.path) + url.path;
  }
}
function normalizePath(url, type) {
  const rel = type <= UrlType.RelativePath;
  const pieces = url.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i2 = 1; i2 < pieces.length; i2++) {
    const piece = pieces[i2];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path4 = "";
  for (let i2 = 1; i2 < pointer; i2++) {
    path4 += "/" + pieces[i2];
  }
  if (!path4 || addTrailingSlash && !path4.endsWith("/..")) {
    path4 += "/";
  }
  url.path = path4;
}
function resolve(input, base) {
  if (!input && !base)
    return "";
  const url = parseUrl(input);
  let inputType = url.type;
  if (base && inputType !== UrlType.Absolute) {
    const baseUrl = parseUrl(base);
    const baseType = baseUrl.type;
    switch (inputType) {
      case UrlType.Empty:
        url.hash = baseUrl.hash;
      case UrlType.Hash:
        url.query = baseUrl.query;
      case UrlType.Query:
      case UrlType.RelativePath:
        mergePaths(url, baseUrl);
      case UrlType.AbsolutePath:
        url.user = baseUrl.user;
        url.host = baseUrl.host;
        url.port = baseUrl.port;
      case UrlType.SchemeRelative:
        url.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath(url, inputType);
  const queryHash = url.query + url.hash;
  switch (inputType) {
    case UrlType.Hash:
    case UrlType.Query:
      return queryHash;
    case UrlType.RelativePath: {
      const path4 = url.path.slice(1);
      if (!path4)
        return queryHash || ".";
      if (isRelative(base || input) && !isRelative(path4)) {
        return "./" + path4 + queryHash;
      }
      return path4 + queryHash;
    }
    case UrlType.AbsolutePath:
      return url.path + queryHash;
    default:
      return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
  }
}

// node_modules/.pnpm/@jridgewell+trace-mapping@0.3.17/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function resolve2(input, base) {
  if (base && !base.endsWith("/"))
    base += "/";
  return resolve(input, base);
}
function stripFilename(path4) {
  if (!path4)
    return "";
  const index = path4.lastIndexOf("/");
  return path4.slice(0, index + 1);
}
var COLUMN = 0;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
    mappings[i2] = sortSegments(mappings[i2], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i2 = start; i2 < mappings.length; i2++) {
    if (!isSorted(mappings[i2]))
      return i2;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch$1(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i2 = index + 1; i2 < haystack.length; index = i2++) {
    if (haystack[i2][COLUMN] !== needle)
      break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i2 = index - 1; i2 >= 0; index = i2--) {
    if (haystack[i2][COLUMN] !== needle)
      break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch$1(haystack, needle, low, high);
}
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var decodedMappings;
var traceSegment;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo)
      return map;
    const parsed = isString ? JSON.parse(map) : map;
    const { version, file, names, sourceRoot, sources: sources3, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources3;
    this.sourcesContent = sourcesContent;
    const from = resolve2(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources3.map((s) => resolve2(s || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
(() => {
  decodedMappings = (map) => {
    return map._decoded || (map._decoded = decode$1(map._encoded));
  };
  traceSegment = (map, line, column) => {
    const decoded = decodedMappings(map);
    if (line >= decoded.length)
      return null;
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
  };
})();
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND)
    index++;
  if (index === -1 || index === segments.length)
    return -1;
  return index;
}

// node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.mjs
var get;
var put;
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
(() => {
  get = (strarr, key) => strarr._indexes[key];
  put = (strarr, key) => {
    const index = get(strarr, key);
    if (index !== void 0)
      return index;
    const { array, _indexes: indexes } = strarr;
    return indexes[key] = array.push(key) - 1;
  };
})();

// node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma2 = ",".charCodeAt(0);
var semicolon2 = ";".charCodeAt(0);
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar2 = new Uint8Array(64);
var charToInt2 = new Uint8Array(128);
for (let i2 = 0; i2 < chars2.length; i2++) {
  const c = chars2.charCodeAt(i2);
  intToChar2[i2] = c;
  charToInt2[c] = i2;
}
var td2 = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i2 = 0; i2 < buf.length; i2++) {
      out += String.fromCharCode(buf[i2]);
    }
    return out;
  }
};
function encode2(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i2 = 0; i2 < decoded.length; i2++) {
    const line = decoded[i2];
    if (i2 > 0) {
      if (pos === bufLength) {
        out += td2.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon2;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td2.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma2;
      pos = encodeInteger2(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 1);
      pos = encodeInteger2(buf, pos, state, segment, 2);
      pos = encodeInteger2(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 4);
    }
  }
  return out + td2.decode(buf.subarray(0, pos));
}
function encodeInteger2(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar2[clamped];
  } while (num > 0);
  return pos;
}

// node_modules/.pnpm/@jridgewell+gen-mapping@0.3.2/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var NO_NAME = -1;
var maybeAddSegment;
var setSourceContent;
var toDecodedMap;
var toEncodedMap;
var addSegmentInternal;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  }
};
(() => {
  maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
  };
  setSourceContent = (map, source, content) => {
    const { _sources: sources3, _sourcesContent: sourcesContent } = map;
    sourcesContent[put(sources3, source)] = content;
  };
  toDecodedMap = (map) => {
    const { file, sourceRoot, _mappings: mappings, _sources: sources3, _sourcesContent: sourcesContent, _names: names } = map;
    removeEmptyFinalLines(mappings);
    return {
      version: 3,
      file: file || void 0,
      names: names.array,
      sourceRoot: sourceRoot || void 0,
      sources: sources3.array,
      sourcesContent,
      mappings
    };
  };
  toEncodedMap = (map) => {
    const decoded = toDecodedMap(map);
    return Object.assign(Object.assign({}, decoded), { mappings: encode2(decoded.mappings) });
  };
  addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
    const { _mappings: mappings, _sources: sources3, _sourcesContent: sourcesContent, _names: names } = map;
    const line = getLine(mappings, genLine);
    const index = getColumnIndex(line, genColumn);
    if (!source) {
      if (skipable && skipSourceless(line, index))
        return;
      return insert2(line, index, [genColumn]);
    }
    const sourcesIndex = put(sources3, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length)
      sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
      return;
    }
    return insert2(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
  };
})();
function getLine(mappings, index) {
  for (let i2 = mappings.length; i2 <= index; i2++) {
    mappings[i2] = [];
  }
  return mappings[index];
}
function getColumnIndex(line, genColumn) {
  let index = line.length;
  for (let i2 = index - 1; i2 >= 0; index = i2--) {
    const current = line[i2];
    if (genColumn >= current[COLUMN2])
      break;
  }
  return index;
}
function insert2(array, index, value) {
  for (let i2 = array.length; i2 > index; i2--) {
    array[i2] = array[i2 - 1];
  }
  array[index] = value;
}
function removeEmptyFinalLines(mappings) {
  const { length } = mappings;
  let len = length;
  for (let i2 = len - 1; i2 >= 0; len = i2, i2--) {
    if (mappings[i2].length > 0)
      break;
  }
  if (len < length)
    mappings.length = len;
}
function skipSourceless(line, index) {
  if (index === 0)
    return true;
  const prev = line[index - 1];
  return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
  if (index === 0)
    return false;
  const prev = line[index - 1];
  if (prev.length === 1)
    return false;
  return sourcesIndex === prev[SOURCES_INDEX2] && sourceLine === prev[SOURCE_LINE2] && sourceColumn === prev[SOURCE_COLUMN2] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
}

// node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.mjs
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null);
var EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content) {
  return { source, line, column, name, content };
}
function Source(map, sources3, source, content) {
  return {
    map,
    sources: sources3,
    source,
    content
  };
}
function MapSource(map, sources3) {
  return Source(map, sources3, "", null);
}
function OriginalSource(source, content) {
  return Source(null, EMPTY_SOURCES, source, content);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file });
  const { sources: rootSources, map } = tree;
  const rootNames = map.names;
  const rootMappings = decodedMappings(map);
  for (let i2 = 0; i2 < rootMappings.length; i2++) {
    const segments = rootMappings[i2];
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j];
      const genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        const source2 = rootSources[segment[1]];
        traced = originalPositionFor2(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
        if (traced == null)
          continue;
      }
      const { column, line, name, content, source } = traced;
      maybeAddSegment(gen, i2, genCol, source, line, column, name);
      if (source && content != null)
        setSourceContent(gen, source, content);
    }
  }
  return gen;
}
function originalPositionFor2(source, line, column, name) {
  if (!source.map) {
    return SegmentObject(source.source, line, column, name, source.content);
  }
  const segment = traceSegment(source.map, line, column);
  if (segment == null)
    return null;
  if (segment.length === 1)
    return SOURCELESS_MAPPING;
  return originalPositionFor2(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}
function asArray(value) {
  if (Array.isArray(value))
    return value;
  return [value];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map = maps.pop();
  for (let i2 = 0; i2 < maps.length; i2++) {
    if (maps[i2].sources.length > 1) {
      throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
  }
  let tree = build(map, loader, "", 0);
  for (let i2 = maps.length - 1; i2 >= 0; i2--) {
    tree = MapSource(maps[i2], [tree]);
  }
  return tree;
}
function build(map, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent } = map;
  const depth = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i2) => {
    const ctx = {
      importer,
      depth,
      source: sourceFile || "",
      content: void 0
    };
    const sourceMap = loader(ctx.source, ctx);
    const { source, content } = ctx;
    if (sourceMap)
      return build(new TraceMap(sourceMap, source), loader, source, depth);
    const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i2] : null;
    return OriginalSource(source, sourceContent);
  });
  return MapSource(map, children);
}
var SourceMap = class {
  constructor(map, options) {
    const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);
    this.version = out.version;
    this.file = out.file;
    this.mappings = out.mappings;
    this.names = out.names;
    this.sourceRoot = out.sourceRoot;
    this.sources = out.sources;
    if (!options.excludeContent) {
      this.sourcesContent = out.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options) {
  const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap(traceMappings(tree), opts);
}
function normalizeAbsolutePath(path4) {
  if (isAbsolute(path4))
    return normalize(path4);
  else
    return path4;
}
function toArray(array) {
  array = array || [];
  if (Array.isArray(array))
    return array;
  return [array];
}

// src/esbuild/utils.ts
var ExtToLoader = {
  ".js": "js",
  ".mjs": "js",
  ".cjs": "js",
  ".jsx": "jsx",
  ".ts": "ts",
  ".cts": "ts",
  ".mts": "ts",
  ".tsx": "tsx",
  ".css": "css",
  ".less": "css",
  ".stylus": "css",
  ".scss": "css",
  ".sass": "css",
  ".json": "json",
  ".txt": "text"
};
function guessLoader(code, id) {
  return ExtToLoader[require$$0$4.extname(id).toLowerCase()] || "js";
}
function unwrapLoader(loader, code, id) {
  if (typeof loader === "function")
    return loader(code, id);
  return loader;
}
function fixSourceMap(map) {
  if (!("toString" in map)) {
    Object.defineProperty(map, "toString", {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    });
  }
  if (!("toUrl" in map)) {
    Object.defineProperty(map, "toUrl", {
      enumerable: false,
      value: function toUrl() {
        return `data:application/json;charset=utf-8;base64,${Buffer$1.from(this.toString()).toString("base64")}`;
      }
    });
  }
  return map;
}
var nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList) {
  sourcemapList = sourcemapList.filter((m) => m.sources);
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0))
    return { ...nullSourceMap };
  let map;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map = remapping(sourcemapList, () => null, true);
  } else {
    map = remapping(
      sourcemapList[0],
      (sourcefile) => {
        if (sourcefile === filename && sourcemapList[mapIndex])
          return sourcemapList[mapIndex++];
        else
          return { ...nullSourceMap };
      },
      true
    );
  }
  if (!map.file)
    delete map.file;
  return map;
}
function createEsbuildContext(initialOptions) {
  return {
    parse(code, opts = {}) {
      return Parser$1.parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        ...opts
      });
    },
    addWatchFile() {
    },
    emitFile(emittedFile) {
      if (initialOptions.outdir && !fs$1.existsSync(initialOptions.outdir))
        fs$1.mkdirSync(initialOptions.outdir, { recursive: true });
      const outFileName = emittedFile.fileName || emittedFile.name;
      if (initialOptions.outdir && emittedFile.source && outFileName)
        fs$1.writeFileSync(require$$0$4.resolve(initialOptions.outdir, outFileName), emittedFile.source);
    },
    getWatchFiles() {
      return [];
    }
  };
}
function processCodeWithSourceMap(map, code) {
  if (map) {
    if (!map.sourcesContent || map.sourcesContent.length === 0)
      map.sourcesContent = [code];
    map = fixSourceMap(map);
    code += `
//# sourceMappingURL=${map.toUrl()}`;
  }
  return code;
}

// src/esbuild/index.ts
var i = 0;
function getEsbuildPlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "esbuild"
    };
    const plugins = toArray(factory(userOptions, meta));
    const setup = (plugin) => plugin.esbuild?.setup ?? ((build2) => {
      meta.build = build2;
      const { onStart, onEnd, onResolve, onLoad, initialOptions } = build2;
      const onResolveFilter = plugin.esbuild?.onResolveFilter ?? /.*/;
      const onLoadFilter = plugin.esbuild?.onLoadFilter ?? /.*/;
      const loader = plugin.esbuild?.loader ?? guessLoader;
      const context = createEsbuildContext(initialOptions);
      if (plugin.buildStart)
        onStart(() => plugin.buildStart.call(context));
      if (plugin.buildEnd || plugin.writeBundle) {
        onEnd(async () => {
          if (plugin.buildEnd)
            await plugin.buildEnd.call(context);
          if (plugin.writeBundle)
            await plugin.writeBundle();
        });
      }
      if (plugin.resolveId) {
        onResolve({ filter: onResolveFilter }, async (args) => {
          if (initialOptions.external?.includes(args.path)) {
            return void 0;
          }
          const isEntry = args.kind === "entry-point";
          const result = await plugin.resolveId(
            args.path,
            // We explicitly have this if statement here for consistency with the integration of other bundelers.
            // Here, `args.importer` is just an empty string on entry files whereas the euqivalent on other bundlers is `undefined.`
            isEntry ? void 0 : args.importer,
            { isEntry }
          );
          if (typeof result === "string")
            return { path: result, namespace: plugin.name };
          else if (typeof result === "object" && result !== null)
            return { path: result.id, external: result.external, namespace: plugin.name };
        });
      }
      if (plugin.load || plugin.transform) {
        onLoad({ filter: onLoadFilter }, async (args) => {
          const id = args.path + args.suffix;
          const errors = [];
          const warnings = [];
          const pluginContext = {
            error(message) {
              errors.push({ text: String(message) });
            },
            warn(message) {
              warnings.push({ text: String(message) });
            }
          };
          const resolveDir = require$$0$4.dirname(args.path);
          let code, map;
          if (plugin.load && (!plugin.loadInclude || plugin.loadInclude(id))) {
            const result = await plugin.load.call(Object.assign(context, pluginContext), id);
            if (typeof result === "string") {
              code = result;
            } else if (typeof result === "object" && result !== null) {
              code = result.code;
              map = result.map;
            }
          }
          if (!plugin.transform) {
            if (code === void 0)
              return null;
            if (map)
              code = processCodeWithSourceMap(map, code);
            return { contents: code, errors, warnings, loader: unwrapLoader(loader, code, args.path), resolveDir };
          }
          if (!plugin.transformInclude || plugin.transformInclude(id)) {
            if (!code) {
              code = await fs$1.promises.readFile(args.path, "utf8");
            }
            const result = await plugin.transform.call(Object.assign(context, pluginContext), code, id);
            if (typeof result === "string") {
              code = result;
            } else if (typeof result === "object" && result !== null) {
              code = result.code;
              if (map && result.map) {
                map = combineSourcemaps(args.path, [
                  result.map,
                  map
                ]);
              } else {
                map = result.map;
              }
            }
          }
          if (code) {
            if (map)
              code = processCodeWithSourceMap(map, code);
            return { contents: code, errors, warnings, loader: unwrapLoader(loader, code, args.path), resolveDir };
          }
        });
      }
    });
    const setupMultiplePlugins = () => (build2) => {
      for (const plugin of plugins)
        setup(plugin)(build2);
    };
    return plugins.length === 1 ? { name: plugins[0].name, setup: setup(plugins[0]) } : { name: meta.esbuildHostName ?? `unplugin-host-${i++}`, setup: setupMultiplePlugins() };
  };
}

// src/rollup/index.ts
function getRollupPlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "rollup"
    };
    const rawPlugins = toArray(factory(userOptions, meta));
    const plugins = rawPlugins.map((plugin) => toRollupPlugin(plugin));
    return plugins.length === 1 ? plugins[0] : plugins;
  };
}
function toRollupPlugin(plugin, containRollupOptions = true) {
  if (plugin.transform && plugin.transformInclude) {
    const _transform = plugin.transform;
    plugin.transform = function(code, id) {
      if (plugin.transformInclude && !plugin.transformInclude(id))
        return null;
      return _transform.call(this, code, id);
    };
  }
  if (plugin.load && plugin.loadInclude) {
    const _load = plugin.load;
    plugin.load = function(id) {
      if (plugin.loadInclude && !plugin.loadInclude(id))
        return null;
      return _load.call(this, id);
    };
  }
  if (plugin.rollup && containRollupOptions)
    Object.assign(plugin, plugin.rollup);
  return plugin;
}
function createRspackContext(compilation) {
  return {
    parse(code, opts = {}) {
      return Parser$1.parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        ...opts
      });
    },
    addWatchFile() {
    },
    emitFile(emittedFile) {
      const outFileName = emittedFile.fileName || emittedFile.name;
      if (emittedFile.source && outFileName) {
        compilation.emitAsset(
          outFileName,
          new sources2.RawSource(
            // @ts-expect-error types mismatch
            typeof emittedFile.source === "string" ? emittedFile.source : Buffer$1.from(emittedFile.source)
          )
        );
      }
    },
    getWatchFiles() {
      return [];
    }
  };
}

// src/rspack/index.ts
var TRANSFORM_LOADER = resolve$1(
  __dirname$1,
  "rspack/loaders/transform"
);
var LOAD_LOADER = resolve$1(
  __dirname$1,
  "rspack/loaders/load"
);
function getRspackPlugin(factory) {
  return (userOptions) => {
    return {
      apply(compiler) {
        const meta = {
          framework: "rspack",
          rspack: {
            compiler
          }
        };
        const rawPlugins = toArray(factory(userOptions, meta));
        for (const plugin of rawPlugins) {
          if (plugin.load) {
            const use = {
              loader: LOAD_LOADER,
              options: { plugin }
            };
            compiler.options.module.rules.unshift({
              enforce: plugin.enforce,
              include: /.*/,
              use
            });
          }
          if (plugin.transform) {
            const use = {
              loader: TRANSFORM_LOADER,
              options: { plugin }
            };
            compiler.options.module.rules.unshift({
              enforce: plugin.enforce,
              include: /.*/,
              use
            });
          }
          if (plugin.rspack)
            plugin.rspack(compiler);
          if (plugin.buildStart) {
            compiler.hooks.make.tapPromise(plugin.name, async (compilation) => {
              const context = createRspackContext(compilation);
              return plugin.buildStart.call(context);
            });
          }
          if (plugin.buildEnd) {
            compiler.hooks.emit.tapPromise(plugin.name, async (compilation) => {
              await plugin.buildEnd.call(createRspackContext(compilation));
            });
          }
          if (plugin.writeBundle) {
            compiler.hooks.afterEmit.tap(plugin.name, () => {
              plugin.writeBundle();
            });
          }
        }
      }
    };
  };
}

// src/vite/index.ts
function getVitePlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "vite"
    };
    const rawPlugins = toArray(factory(userOptions, meta));
    const plugins = rawPlugins.map((rawPlugin) => {
      const plugin = toRollupPlugin(rawPlugin, false);
      if (rawPlugin.vite)
        Object.assign(plugin, rawPlugin.vite);
      return plugin;
    });
    return plugins.length === 1 ? plugins[0] : plugins;
  };
}
function createContext(compilation) {
  return {
    parse(code, opts = {}) {
      return Parser$1.parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        ...opts
      });
    },
    addWatchFile(id) {
      (compilation.fileDependencies ?? compilation.compilationDependencies).add(
        resolve$1(process$1.cwd(), id)
      );
    },
    emitFile(emittedFile) {
      const outFileName = emittedFile.fileName || emittedFile.name;
      if (emittedFile.source && outFileName) {
        compilation.emitAsset(
          outFileName,
          sources2 ? new sources2.RawSource(
            // @ts-expect-error types mismatch
            typeof emittedFile.source === "string" ? emittedFile.source : Buffer$1.from(emittedFile.source)
          ) : {
            source: () => emittedFile.source,
            size: () => emittedFile.source.length
          }
        );
      }
    },
    getWatchFiles() {
      return Array.from(
        compilation.fileDependencies ?? compilation.compilationDependencies
      );
    }
  };
}

// src/webpack/index.ts
var TRANSFORM_LOADER2 = resolve$1(
  __dirname$1,
  "webpack/loaders/transform"
);
var LOAD_LOADER2 = resolve$1(
  __dirname$1,
  "webpack/loaders/load"
);
var VIRTUAL_MODULE_PREFIX = resolve$1(process$1.cwd(), "_virtual_");
function getWebpackPlugin(factory) {
  return (userOptions) => {
    return {
      apply(compiler) {
        const injected = compiler.$unpluginContext || {};
        compiler.$unpluginContext = injected;
        const meta = {
          framework: "webpack",
          webpack: {
            compiler
          }
        };
        const rawPlugins = toArray(factory(userOptions, meta));
        for (const rawPlugin of rawPlugins) {
          const plugin = Object.assign(
            rawPlugin,
            {
              __unpluginMeta: meta,
              __virtualModulePrefix: VIRTUAL_MODULE_PREFIX
            }
          );
          injected[plugin.name] = plugin;
          compiler.hooks.thisCompilation.tap(plugin.name, (compilation) => {
            compilation.hooks.childCompiler.tap(plugin.name, (childCompiler) => {
              childCompiler.$unpluginContext = injected;
            });
          });
          const externalModules = /* @__PURE__ */ new Set();
          if (plugin.resolveId) {
            let vfs = compiler.options.plugins.find((i2) => i2 instanceof VirtualModulesPlugin$1);
            if (!vfs) {
              vfs = new VirtualModulesPlugin$1();
              compiler.options.plugins.push(vfs);
            }
            plugin.__vfsModules = /* @__PURE__ */ new Set();
            plugin.__vfs = vfs;
            const resolverPlugin = {
              apply(resolver) {
                const target = resolver.ensureHook("resolve");
                resolver.getHook("resolve").tapAsync(plugin.name, async (request, resolveContext, callback) => {
                  if (!request.request)
                    return callback();
                  if (normalizeAbsolutePath(request.request).startsWith(plugin.__virtualModulePrefix))
                    return callback();
                  const id = normalizeAbsolutePath(request.request);
                  const requestContext = request.context;
                  const importer = requestContext.issuer !== "" ? requestContext.issuer : void 0;
                  const isEntry = requestContext.issuer === "";
                  const resolveIdResult = await plugin.resolveId(id, importer, { isEntry });
                  if (resolveIdResult == null)
                    return callback();
                  let resolved = typeof resolveIdResult === "string" ? resolveIdResult : resolveIdResult.id;
                  const isExternal = typeof resolveIdResult === "string" ? false : resolveIdResult.external === true;
                  if (isExternal)
                    externalModules.add(resolved);
                  if (!fs$1.existsSync(resolved)) {
                    resolved = normalizeAbsolutePath(
                      plugin.__virtualModulePrefix + encodeURIComponent(resolved)
                      // URI encode id so webpack doesn't think it's part of the path
                    );
                    if (!plugin.__vfsModules.has(resolved)) {
                      plugin.__vfs.writeModule(resolved, "");
                      plugin.__vfsModules.add(resolved);
                    }
                  }
                  const newRequest = {
                    ...request,
                    request: resolved
                  };
                  resolver.doResolve(target, newRequest, null, resolveContext, callback);
                });
              }
            };
            compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
            compiler.options.resolve.plugins.push(resolverPlugin);
          }
          if (plugin.load) {
            compiler.options.module.rules.unshift({
              include(id) {
                if (id.startsWith(plugin.__virtualModulePrefix))
                  id = decodeURIComponent(id.slice(plugin.__virtualModulePrefix.length));
                if (plugin.loadInclude && !plugin.loadInclude(id))
                  return false;
                return !externalModules.has(id);
              },
              enforce: plugin.enforce,
              use: [{
                loader: LOAD_LOADER2,
                options: {
                  unpluginName: plugin.name
                }
              }]
            });
          }
          if (plugin.transform) {
            const useLoader = [{
              loader: `${TRANSFORM_LOADER2}?unpluginName=${encodeURIComponent(plugin.name)}`
            }];
            const useNone = [];
            compiler.options.module.rules.unshift({
              enforce: plugin.enforce,
              use: (data) => {
                if (data.resource == null)
                  return useNone;
                const id = normalizeAbsolutePath(data.resource + (data.resourceQuery || ""));
                if (!plugin.transformInclude || plugin.transformInclude(id))
                  return useLoader;
                return useNone;
              }
            });
          }
          if (plugin.webpack)
            plugin.webpack(compiler);
          if (plugin.watchChange || plugin.buildStart) {
            compiler.hooks.make.tapPromise(plugin.name, async (compilation) => {
              const context = createContext(compilation);
              if (plugin.watchChange && (compiler.modifiedFiles || compiler.removedFiles)) {
                const promises = [];
                if (compiler.modifiedFiles) {
                  compiler.modifiedFiles.forEach(
                    (file) => promises.push(Promise.resolve(plugin.watchChange.call(context, file, { event: "update" })))
                  );
                }
                if (compiler.removedFiles) {
                  compiler.removedFiles.forEach(
                    (file) => promises.push(Promise.resolve(plugin.watchChange.call(context, file, { event: "delete" })))
                  );
                }
                await Promise.all(promises);
              }
              if (plugin.buildStart)
                return await plugin.buildStart.call(context);
            });
          }
          if (plugin.buildEnd) {
            compiler.hooks.emit.tapPromise(plugin.name, async (compilation) => {
              await plugin.buildEnd.call(createContext(compilation));
            });
          }
          if (plugin.writeBundle) {
            compiler.hooks.afterEmit.tap(plugin.name, () => {
              plugin.writeBundle();
            });
          }
        }
      }
    };
  };
}

// src/define.ts
function createUnplugin(factory) {
  return {
    get esbuild() {
      return getEsbuildPlugin(factory);
    },
    get rollup() {
      return getRollupPlugin(factory);
    },
    get vite() {
      return getVitePlugin(factory);
    },
    get webpack() {
      return getWebpackPlugin(factory);
    },
    /** @experimental do not use it in production */
    get rspack() {
      return getRspackPlugin(factory);
    },
    get raw() {
      return factory;
    }
  };
}

var lodash = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;

(function (module, exports) {
(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined$1;

	  /** Used as the semantic version number. */
	  var VERSION = '4.17.21';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function',
	      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;

	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;

	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading whitespace. */
	  var reTrimStart = /^\s+/;

	  /** Used to match a single whitespace character. */
	  var reWhitespace = /\s/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /**
	   * Used to validate the `validate` option in `_.template` variable.
	   *
	   * Forbids characters which could potentially change the meaning of the function argument definition:
	   * - "()," (modification of function parameters)
	   * - "=" (default value)
	   * - "[]{}" (destructuring of function parameters)
	   * - "/" (beginning of a comment)
	   * - whitespace
	   */
	  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined$1) {
	        result = result === undefined$1 ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.trim`.
	   *
	   * @private
	   * @param {string} string The string to trim.
	   * @returns {string} Returns the trimmed string.
	   */
	  function baseTrim(string) {
	    return string
	      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	      : string;
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined$1 : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedEndIndex(string) {
	    var index = string.length;

	    while (index-- && reWhitespace.test(string.charAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined$1,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
	        symIterator = Symbol ? Symbol.iterator : undefined$1,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
	        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined$1;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined$1;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined$1 : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined$1 : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined$1;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined$1 && !eq(object[key], value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined$1 : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined$1) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined$1) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined$1) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      if (isSet(value)) {
	        value.forEach(function(subValue) {
	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	        });
	      } else if (isMap(value)) {
	        value.forEach(function(subValue, key) {
	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	        });
	      }

	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);

	      var props = isArr ? undefined$1 : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined$1
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined$1 || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined$1;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined$1 ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined$1;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined$1 : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);

	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;

	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined$1 && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined$1
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined$1 && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        stack || (stack = new Stack);
	        if (isObject(srcValue)) {
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	            : undefined$1;

	          if (newValue === undefined$1) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = safeGet(object, key),
	          srcValue = safeGet(source, key),
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined$1;

	      var isCommon = newValue === undefined$1;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || isFunction(objValue)) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined$1;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      if (iteratees.length) {
	        iteratees = arrayMap(iteratees, function(iteratee) {
	          if (isArray(iteratee)) {
	            return function(value) {
	              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	            }
	          }
	          return iteratee;
	        });
	      } else {
	        iteratees = [identity];
	      }

	      var index = -1;
	      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};

	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);

	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	          return object;
	        }

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
	          if (newValue === undefined$1) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      var low = 0,
	          high = array == null ? 0 : array.length;
	      if (high === 0) {
	        return 0;
	      }

	      value = iteratee(value);
	      var valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined$1;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined$1,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined$1;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined$1 ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined$1,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined$1,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined$1;

	        if (newValue === undefined$1) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined$1,
	            guard = length > 2 ? sources[2] : undefined$1;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined$1;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined$1 : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined$1;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
	            args, holders, undefined$1, undefined$1, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined$1;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined$1 : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined$1 && other === undefined$1) {
	          return defaultValue;
	        }
	        if (value !== undefined$1) {
	          result = value;
	        }
	        if (other !== undefined$1) {
	          if (result === undefined$1) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined$1 ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined$1;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined$1) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined$1,
	          newHoldersRight = isCurry ? undefined$1 : holders,
	          newPartials = isCurry ? partials : undefined$1,
	          newPartialsRight = isCurry ? undefined$1 : partials;

	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined$1, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision && nativeIsFinite(number)) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined$1;
	      }
	      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined$1 ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined$1;
	      }
	      var data = isBindKey ? undefined$1 : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined$1
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined$1, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined$1 ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined$1 : value;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Check that cyclic values are equal.
	      var arrStacked = stack.get(array);
	      var othStacked = stack.get(other);
	      if (arrStacked && othStacked) {
	        return arrStacked == other && othStacked == array;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined$1) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Check that cyclic values are equal.
	      var objStacked = stack.get(object);
	      var othStacked = stack.get(other);
	      if (objStacked && othStacked) {
	        return objStacked == other && othStacked == object;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined$1
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined$1, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined$1;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined$1;
	        var unmasked = true;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };

	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined$1,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return new Ctor;

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return new Ctor;

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      var type = typeof value;
	      length = length == null ? MAX_SAFE_INTEGER : length;

	      return !!length &&
	        (type == 'number' ||
	          (type != 'symbol' && reIsUint.test(value))) &&
	            (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined$1 || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
	      }
	      return array;
	    }

	    /**
	     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to get.
	     * @returns {*} Returns the property value.
	     */
	    function safeGet(object, key) {
	      if (key === 'constructor' && typeof object[key] === 'function') {
	        return;
	      }

	      if (key == '__proto__') {
	        return;
	      }

	      return object[key];
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined$1, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined$1 ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (string.charCodeAt(0) === 46 /* . */) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, subString) {
	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined$1;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined$1;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined$1;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined$1, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined$1 ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined$1, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined$1
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined$1);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined$1) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined$1 : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined$1;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined$1
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     *
	     * // Combining several predicates using `_.overEvery` or `_.overSome`.
	     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	     * // => objects for ['fred', 'barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined$1 : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 30 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined$1 : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined$1;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined$1;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            timeWaiting = wait - timeSinceLastCall;

	        return maxing
	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	          : timeWaiting;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined$1;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined$1;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined$1) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
	      }

	      function flush() {
	        return timerId === undefined$1 ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined$1) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            clearTimeout(timerId);
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined$1) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined$1 ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      var result = customizer ? customizer(value, other) : undefined$1;
	      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined$1;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = baseTrim(value);
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(object, sources) {
	      object = Object(object);

	      var index = -1;
	      var length = sources.length;
	      var guard = length > 2 ? sources[2] : undefined$1;

	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	        length = 1;
	      }

	      while (++index < length) {
	        var source = sources[index];
	        var props = keysIn(source);
	        var propsIndex = -1;
	        var propsLength = props.length;

	        while (++propsIndex < propsLength) {
	          var key = props[propsIndex];
	          var value = object[key];

	          if (value === undefined$1 ||
	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	            object[key] = source[key];
	          }
	        }
	      }

	      return object;
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined$1, customDefaultsMerge);
	      return apply(mergeWith, undefined$1, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined$1 : baseGet(object, path);
	      return result === undefined$1 ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined$1;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined$1 : object[toKey(path[index])];
	        if (value === undefined$1) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined$1) {
	        upper = lower;
	        lower = undefined$1;
	      }
	      if (upper !== undefined$1) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined$1) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined$1) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined$1;
	      }
	      if (floating === undefined$1) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined$1;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined$1;
	        }
	      }
	      if (lower === undefined$1 && upper === undefined$1) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined$1) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined$1
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined$1;
	      }
	      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);

	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined$1;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      // The sourceURL gets injected into the source that's eval-ed, so be careful
	      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
	      // and escape the comment, thus injecting code that gets evaled.
	      var sourceURL = '//# sourceURL=' +
	        (hasOwnProperty.call(options, 'sourceURL')
	          ? (options.sourceURL + '').replace(/\s/g, ' ')
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Throw an error if a forbidden character was found in `variable`, to prevent
	      // potential command injection attacks.
	      else if (reForbiddenIdentifierChars.test(variable)) {
	        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
	      }

	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined$1, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return baseTrim(string);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.slice(0, trimmedEndIndex(string) + 1);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined$1) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined$1 : pattern;

	      if (pattern === undefined$1) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined$1, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     *
	     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
	     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined$1 : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined$1;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined$1;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();

	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined$1) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name + '';
	        if (!hasOwnProperty.call(realNames, key)) {
	          realNames[key] = [];
	        }
	        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined$1
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(commonjsGlobal)); 
} (lodash, lodash.exports));

var lodashExports = lodash.exports;

/**
 * @file
 * This file uses webpack to compile a template with a child compiler.
 *
 * [TEMPLATE] -> [JAVASCRIPT]
 *
 */

let instanceId = 0;
/**
 * The HtmlWebpackChildCompiler is a helper to allow reusing one childCompiler
 * for multiple HtmlWebpackPlugin instances to improve the compilation performance.
 */
let HtmlWebpackChildCompiler$1 = class HtmlWebpackChildCompiler {
  /**
   *
   * @param {string[]} templates
   */
  constructor (templates) {
    /** Id for this ChildCompiler */
    this.id = instanceId++;
    /**
     * @type {string[]} templateIds
     * The template array will allow us to keep track which input generated which output
     */
    this.templates = templates;
    /**
     * @type {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}
     */
    this.compilationPromise; // eslint-disable-line
    /**
     * @type {number}
     */
    this.compilationStartedTimestamp; // eslint-disable-line
    /**
     * @type {number}
     */
    this.compilationEndedTimestamp; // eslint-disable-line
    /**
     * All file dependencies of the child compiler
     * @type {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}}
     */
    this.fileDependencies = { fileDependencies: [], contextDependencies: [], missingDependencies: [] };
  }

  /**
   * Returns true if the childCompiler is currently compiling
   * @returns {boolean}
   */
  isCompiling () {
    return !this.didCompile() && this.compilationStartedTimestamp !== undefined;
  }

  /**
   * Returns true if the childCompiler is done compiling
   */
  didCompile () {
    return this.compilationEndedTimestamp !== undefined;
  }

  /**
   * This function will start the template compilation
   * once it is started no more templates can be added
   *
   * @param {import('webpack').Compilation} mainCompilation
   * @returns {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}
   */
  compileTemplates (mainCompilation) {
    const webpack = mainCompilation.compiler.webpack;
    const Compilation = webpack.Compilation;

    const NodeTemplatePlugin = webpack.node.NodeTemplatePlugin;
    const NodeTargetPlugin = webpack.node.NodeTargetPlugin;
    const LoaderTargetPlugin = webpack.LoaderTargetPlugin;
    const EntryPlugin = webpack.EntryPlugin;

    // To prevent multiple compilations for the same template
    // the compilation is cached in a promise.
    // If it already exists return
    if (this.compilationPromise) {
      return this.compilationPromise;
    }

    const outputOptions = {
      filename: '__child-[name]',
      publicPath: '',
      library: {
        type: 'var',
        name: 'HTML_WEBPACK_PLUGIN_RESULT'
      },
      scriptType: /** @type {'text/javascript'} */('text/javascript'),
      iife: true
    };
    const compilerName = 'HtmlWebpackCompiler';
    // Create an additional child compiler which takes the template
    // and turns it into an Node.JS html factory.
    // This allows us to use loaders during the compilation
    const childCompiler = mainCompilation.createChildCompiler(compilerName, outputOptions, [
      // Compile the template to nodejs javascript
      new NodeTargetPlugin(),
      new NodeTemplatePlugin(),
      new LoaderTargetPlugin('node'),
      new webpack.library.EnableLibraryPlugin('var')
    ]);
    // The file path context which webpack uses to resolve all relative files to
    childCompiler.context = mainCompilation.compiler.context;

    // Generate output file names
    const temporaryTemplateNames = this.templates.map((template, index) => `__child-HtmlWebpackPlugin_${index}-${this.id}`);

    // Add all templates
    this.templates.forEach((template, index) => {
      new EntryPlugin(childCompiler.context, 'data:text/javascript,__webpack_public_path__ = __webpack_base_uri__ = htmlWebpackPluginPublicPath;', `HtmlWebpackPlugin_${index}-${this.id}`).apply(childCompiler);
      new EntryPlugin(childCompiler.context, template, `HtmlWebpackPlugin_${index}-${this.id}`).apply(childCompiler);
    });

    // The templates are compiled and executed by NodeJS - similar to server side rendering
    // Unfortunately this causes issues as some loaders require an absolute URL to support ES Modules
    // The following config enables relative URL support for the child compiler
    childCompiler.options.module = { ...childCompiler.options.module };
    childCompiler.options.module.parser = { ...childCompiler.options.module.parser };
    childCompiler.options.module.parser.javascript = { ...childCompiler.options.module.parser.javascript,
      url: 'relative' };

    this.compilationStartedTimestamp = new Date().getTime();
    this.compilationPromise = new Promise((resolve, reject) => {
      const extractedAssets = [];
      childCompiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', (compilation) => {
        compilation.hooks.processAssets.tap(
          {
            name: 'HtmlWebpackPlugin',
            stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
          },
          (assets) => {
            temporaryTemplateNames.forEach((temporaryTemplateName) => {
              if (assets[temporaryTemplateName]) {
                extractedAssets.push(assets[temporaryTemplateName]);
                compilation.deleteAsset(temporaryTemplateName);
              }
            });
          }
        );
      });

      childCompiler.runAsChild((err, entries, childCompilation) => {
        // Extract templates
        const compiledTemplates = entries
          ? extractedAssets.map((asset) => asset.source())
          : [];
        // Extract file dependencies
        if (entries && childCompilation) {
          this.fileDependencies = { fileDependencies: Array.from(childCompilation.fileDependencies), contextDependencies: Array.from(childCompilation.contextDependencies), missingDependencies: Array.from(childCompilation.missingDependencies) };
        }
        // Reject the promise if the childCompilation contains error
        if (childCompilation && childCompilation.errors && childCompilation.errors.length) {
          const errorDetails = childCompilation.errors.map(error => {
            let message = error.message;
            if (error.stack) {
              message += '\n' + error.stack;
            }
            return message;
          }).join('\n');
          reject(new Error('Child compilation failed:\n' + errorDetails));
          return;
        }
        // Reject if the error object contains errors
        if (err) {
          reject(err);
          return;
        }
        if (!childCompilation || !entries) {
          reject(new Error('Empty child compilation'));
          return;
        }
        /**
         * @type {{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}}
         */
        const result = {};
        compiledTemplates.forEach((templateSource, entryIndex) => {
          // The compiledTemplates are generated from the entries added in
          // the addTemplate function.
          // Therefore the array index of this.templates should be the as entryIndex.
          result[this.templates[entryIndex]] = {
            content: templateSource,
            hash: childCompilation.hash || 'XXXX',
            entry: entries[entryIndex]
          };
        });
        this.compilationEndedTimestamp = new Date().getTime();
        resolve(result);
      });
    });

    return this.compilationPromise;
  }
};

var childCompiler = {
  HtmlWebpackChildCompiler: HtmlWebpackChildCompiler$1
};

/**
 *
 * @param {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} fileDependencies
 * @param {WebpackCompilation} mainCompilation
 * @param {number} startTime
 */
function createSnapshot (fileDependencies, mainCompilation, startTime) {
  return new Promise((resolve, reject) => {
    mainCompilation.fileSystemInfo.createSnapshot(
      startTime,
      fileDependencies.fileDependencies,
      fileDependencies.contextDependencies,
      fileDependencies.missingDependencies,
      null,
      (err, snapshot) => {
        if (err) {
          return reject(err);
        }
        resolve(snapshot);
      }
    );
  });
}

/**
 * Returns true if the files inside this snapshot
 * have not been changed
 *
 * @param {Snapshot} snapshot
 * @param {WebpackCompilation} mainCompilation
 * @returns {Promise<boolean>}
 */
function isSnapShotValid (snapshot, mainCompilation) {
  return new Promise((resolve, reject) => {
    mainCompilation.fileSystemInfo.checkSnapshotValid(
      snapshot,
      (err, isValid) => {
        if (err) {
          reject(err);
        }
        resolve(isValid);
      }
    );
  });
}

/**
 * Ensure that the files keep watched for changes
 * and will trigger a recompile
 *
 * @param {WebpackCompilation} mainCompilation
 * @param {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} fileDependencies
 */
function watchFiles (mainCompilation, fileDependencies) {
  Object.keys(fileDependencies).forEach((depencyTypes) => {
    fileDependencies[depencyTypes].forEach(fileDependency => {
      mainCompilation[depencyTypes].add(fileDependency);
    });
  });
}

var fileWatcherApi$1 = {
  createSnapshot,
  isSnapShotValid,
  watchFiles
};

const { HtmlWebpackChildCompiler } = childCompiler;
const fileWatcherApi = fileWatcherApi$1;

/**
 * This plugin is a singleton for performance reasons.
 * To keep track if a plugin does already exist for the compiler they are cached
 * in this map
 * @type {WeakMap<WebpackCompiler, PersistentChildCompilerSingletonPlugin>}}
 */
const compilerMap = new WeakMap();

let CachedChildCompilation$1 = class CachedChildCompilation {
  /**
   * @param {WebpackCompiler} compiler
   */
  constructor (compiler) {
    /**
     * @private
     * @type {WebpackCompiler}
     */
    this.compiler = compiler;
    // Create a singleton instance for the compiler
    // if there is none
    if (compilerMap.has(compiler)) {
      return;
    }
    const persistentChildCompilerSingletonPlugin = new PersistentChildCompilerSingletonPlugin();
    compilerMap.set(compiler, persistentChildCompilerSingletonPlugin);
    persistentChildCompilerSingletonPlugin.apply(compiler);
  }

  /**
   * apply is called by the webpack main compiler during the start phase
   * @param {string} entry
   */
  addEntry (entry) {
    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);
    if (!persistentChildCompilerSingletonPlugin) {
      throw new Error(
        'PersistentChildCompilerSingletonPlugin instance not found.'
      );
    }
    persistentChildCompilerSingletonPlugin.addEntry(entry);
  }

  getCompilationResult () {
    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);
    if (!persistentChildCompilerSingletonPlugin) {
      throw new Error(
        'PersistentChildCompilerSingletonPlugin instance not found.'
      );
    }
    return persistentChildCompilerSingletonPlugin.getLatestResult();
  }

  /**
   * Returns the result for the given entry
   * @param {string} entry
   * @returns {
      | { mainCompilationHash: string, error: Error }
      | { mainCompilationHash: string, compiledEntry: ChildCompilationResultEntry }
    }
   */
  getCompilationEntryResult (entry) {
    const latestResult = this.getCompilationResult();
    const compilationResult = latestResult.compilationResult;
    return 'error' in compilationResult ? {
      mainCompilationHash: latestResult.mainCompilationHash,
      error: compilationResult.error
    } : {
      mainCompilationHash: latestResult.mainCompilationHash,
      compiledEntry: compilationResult.compiledEntries[entry]
    };
  }
};

class PersistentChildCompilerSingletonPlugin {
  constructor () {
    /**
     * @private
     * @type {
      | {
        isCompiling: false,
        isVerifyingCache: false,
        entries: string[],
        compiledEntries: string[],
        mainCompilationHash: string,
        compilationResult: ChildCompilationResult
      }
    | Readonly<{
      isCompiling: false,
      isVerifyingCache: true,
      entries: string[],
      previousEntries: string[],
      previousResult: ChildCompilationResult
    }>
    | Readonly <{
      isVerifyingCache: false,
      isCompiling: true,
      entries: string[],
    }>
  } the internal compilation state */
    this.compilationState = {
      isCompiling: false,
      isVerifyingCache: false,
      entries: [],
      compiledEntries: [],
      mainCompilationHash: 'initial',
      compilationResult: {
        dependencies: {
          fileDependencies: [],
          contextDependencies: [],
          missingDependencies: []
        },
        compiledEntries: {}
      }
    };
  }

  /**
   * apply is called by the webpack main compiler during the start phase
   * @param {WebpackCompiler} compiler
   */
  apply (compiler) {
    /** @type Promise<ChildCompilationResult> */
    let childCompilationResultPromise = Promise.resolve({
      dependencies: {
        fileDependencies: [],
        contextDependencies: [],
        missingDependencies: []
      },
      compiledEntries: {}
    });
    /**
     * The main compilation hash which will only be updated
     * if the childCompiler changes
     */
    let mainCompilationHashOfLastChildRecompile = '';
    /** @typedef{Snapshot|undefined} */
    let previousFileSystemSnapshot;
    let compilationStartTime = new Date().getTime();

    compiler.hooks.make.tapAsync(
      'PersistentChildCompilerSingletonPlugin',
      (mainCompilation, callback) => {
        if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {
          return callback(new Error('Child compilation has already started'));
        }

        // Update the time to the current compile start time
        compilationStartTime = new Date().getTime();

        // The compilation starts - adding new templates is now not possible anymore
        this.compilationState = {
          isCompiling: false,
          isVerifyingCache: true,
          previousEntries: this.compilationState.compiledEntries,
          previousResult: this.compilationState.compilationResult,
          entries: this.compilationState.entries
        };

        // Validate cache:
        const isCacheValidPromise = this.isCacheValid(previousFileSystemSnapshot, mainCompilation);

        let cachedResult = childCompilationResultPromise;
        childCompilationResultPromise = isCacheValidPromise.then((isCacheValid) => {
          // Reuse cache
          if (isCacheValid) {
            return cachedResult;
          }
          // Start the compilation
          const compiledEntriesPromise = this.compileEntries(
            mainCompilation,
            this.compilationState.entries
          );
          // Update snapshot as soon as we know the filedependencies
          // this might possibly cause bugs if files were changed inbetween
          // compilation start and snapshot creation
          compiledEntriesPromise.then((childCompilationResult) => {
            return fileWatcherApi.createSnapshot(childCompilationResult.dependencies, mainCompilation, compilationStartTime);
          }).then((snapshot) => {
            previousFileSystemSnapshot = snapshot;
          });
          return compiledEntriesPromise;
        });

        // Add files to compilation which needs to be watched:
        mainCompilation.hooks.optimizeTree.tapAsync(
          'PersistentChildCompilerSingletonPlugin',
          (chunks, modules, callback) => {
            const handleCompilationDonePromise = childCompilationResultPromise.then(
              childCompilationResult => {
                this.watchFiles(
                  mainCompilation,
                  childCompilationResult.dependencies
                );
              });
            handleCompilationDonePromise.then(() => callback(null, chunks, modules), callback);
          }
        );

        // Store the final compilation once the main compilation hash is known
        mainCompilation.hooks.additionalAssets.tapAsync(
          'PersistentChildCompilerSingletonPlugin',
          (callback) => {
            const didRecompilePromise = Promise.all([childCompilationResultPromise, cachedResult]).then(
              ([childCompilationResult, cachedResult]) => {
                // Update if childCompilation changed
                return (cachedResult !== childCompilationResult);
              }
            );

            const handleCompilationDonePromise = Promise.all([childCompilationResultPromise, didRecompilePromise]).then(
              ([childCompilationResult, didRecompile]) => {
                // Update hash and snapshot if childCompilation changed
                if (didRecompile) {
                  mainCompilationHashOfLastChildRecompile = mainCompilation.hash;
                }
                this.compilationState = {
                  isCompiling: false,
                  isVerifyingCache: false,
                  entries: this.compilationState.entries,
                  compiledEntries: this.compilationState.entries,
                  compilationResult: childCompilationResult,
                  mainCompilationHash: mainCompilationHashOfLastChildRecompile
                };
              });
            handleCompilationDonePromise.then(() => callback(null), callback);
          }
        );

        // Continue compilation:
        callback(null);
      }
    );
  }

  /**
   * Add a new entry to the next compile run
   * @param {string} entry
   */
  addEntry (entry) {
    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {
      throw new Error(
        'The child compiler has already started to compile. ' +
        "Please add entries before the main compiler 'make' phase has started or " +
        'after the compilation is done.'
      );
    }
    if (this.compilationState.entries.indexOf(entry) === -1) {
      this.compilationState.entries = [...this.compilationState.entries, entry];
    }
  }

  getLatestResult () {
    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {
      throw new Error(
        'The child compiler is not done compiling. ' +
        "Please access the result after the compiler 'make' phase has started or " +
        'after the compilation is done.'
      );
    }
    return {
      mainCompilationHash: this.compilationState.mainCompilationHash,
      compilationResult: this.compilationState.compilationResult
    };
  }

  /**
   * Verify that the cache is still valid
   * @private
   * @param {Snapshot | undefined} snapshot
   * @param {WebpackCompilation} mainCompilation
   * @returns {Promise<boolean>}
   */
  isCacheValid (snapshot, mainCompilation) {
    if (!this.compilationState.isVerifyingCache) {
      return Promise.reject(new Error('Cache validation can only be done right before the compilation starts'));
    }
    // If there are no entries we don't need a new child compilation
    if (this.compilationState.entries.length === 0) {
      return Promise.resolve(true);
    }
    // If there are new entries the cache is invalid
    if (this.compilationState.entries !== this.compilationState.previousEntries) {
      return Promise.resolve(false);
    }
    // Mark the cache as invalid if there is no snapshot
    if (!snapshot) {
      return Promise.resolve(false);
    }
    return fileWatcherApi.isSnapShotValid(snapshot, mainCompilation);
  }

  /**
   * Start to compile all templates
   *
   * @private
   * @param {WebpackCompilation} mainCompilation
   * @param {string[]} entries
   * @returns {Promise<ChildCompilationResult>}
   */
  compileEntries (mainCompilation, entries) {
    const compiler = new HtmlWebpackChildCompiler(entries);
    return compiler.compileTemplates(mainCompilation).then((result) => {
      return {
      // The compiled sources to render the content
        compiledEntries: result,
        // The file dependencies to find out if a
        // recompilation is required
        dependencies: compiler.fileDependencies,
        // The main compilation hash can be used to find out
        // if this compilation was done during the current compilation
        mainCompilationHash: mainCompilation.hash
      };
    }, error => ({
      // The compiled sources to render the content
      error,
      // The file dependencies to find out if a
      // recompilation is required
      dependencies: compiler.fileDependencies,
      // The main compilation hash can be used to find out
      // if this compilation was done during the current compilation
      mainCompilationHash: mainCompilation.hash
    }));
  }

  /**
   * @private
   * @param {WebpackCompilation} mainCompilation
   * @param {FileDependencies} files
   */
  watchFiles (mainCompilation, files) {
    fileWatcherApi.watchFiles(mainCompilation, files);
  }
}

var cachedChildCompiler = {
  CachedChildCompilation: CachedChildCompilation$1
};

// @ts-check
/** @typedef {import("../typings").HtmlTagObject} HtmlTagObject */
/**
 * @file
 * This file provides to helper to create html as a object representation as
 * those objects are easier to modify than pure string representations
 *
 * Usage:
 * ```
 * const element = createHtmlTagObject('h1', {class: 'demo'}, 'Hello World');
 * const html = htmlTagObjectToString(element);
 * console.log(html) // -> <h1 class="demo">Hello World</h1>
 * ```
 */

/**
 * All html tag elements which must not contain innerHTML
 * @see https://www.w3.org/TR/html5/syntax.html#void-elements
 */
const voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

/**
 * Turn a tag definition into a html string
 * @param {HtmlTagObject} tagDefinition
 *  A tag element according to the htmlWebpackPlugin object notation
 *
 * @param xhtml {boolean}
 *   Whether the generated html should add closing slashes to be xhtml compliant
 */
function htmlTagObjectToString$1 (tagDefinition, xhtml) {
  const attributes = Object.keys(tagDefinition.attributes || {})
    .filter(function (attributeName) {
      return tagDefinition.attributes[attributeName] === '' || tagDefinition.attributes[attributeName];
    })
    .map(function (attributeName) {
      if (tagDefinition.attributes[attributeName] === true) {
        return xhtml ? attributeName + '="' + attributeName + '"' : attributeName;
      }
      return attributeName + '="' + tagDefinition.attributes[attributeName] + '"';
    });
  return '<' + [tagDefinition.tagName].concat(attributes).join(' ') + (tagDefinition.voidTag && xhtml ? '/' : '') + '>' +
    (tagDefinition.innerHTML || '') +
    (tagDefinition.voidTag ? '' : '</' + tagDefinition.tagName + '>');
}

/**
 * Static helper to create a tag object to be get injected into the dom
 *
 * @param {string} tagName
 * the name of the tag e.g. 'div'
 *
 * @param {{[attributeName: string]: string|boolean|null|undefined}} [attributes]
 * tag attributes e.g. `{ 'class': 'example', disabled: true }`
 *
 * @param {string} [innerHTML]
 *
 * @param {{[attributeName: string]: string|boolean|null|undefined}} [meta]
 * meta information about the tag e.g. `{ 'plugin': 'html-webpack-plugin' }`
 *
 * @returns {HtmlTagObject}
 */
function createHtmlTagObject$1 (tagName, attributes, innerHTML, meta) {
  return {
    tagName: tagName,
    voidTag: voidTags.indexOf(tagName) !== -1,
    attributes: attributes || {},
    meta: meta || {},
    innerHTML: innerHTML
  };
}

/**
 * The `HtmlTagArray Array with a custom `.toString()` method.
 *
 * This allows the following:
 * ```
 *   const tags = HtmlTagArray.from([tag1, tag2]);
 *   const scriptTags = tags.filter((tag) => tag.tagName === 'script');
 *   const html = scriptTags.toString();
 * ```
 *
 * Or inside a string literal:
 * ```
 *   const tags = HtmlTagArray.from([tag1, tag2]);
 *   const html = `<html><body>${tags.filter((tag) => tag.tagName === 'script')}</body></html>`;
 * ```
 *
 */
let HtmlTagArray$1 = class HtmlTagArray extends Array {
  toString () {
    return this.join('');
  }
};

var htmlTags = {
  HtmlTagArray: HtmlTagArray$1,
  createHtmlTagObject: createHtmlTagObject$1,
  htmlTagObjectToString: htmlTagObjectToString$1
};

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

var _overArg;
var hasRequired_overArg;

function require_overArg () {
	if (hasRequired_overArg) return _overArg;
	hasRequired_overArg = 1;
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	_overArg = overArg;
	return _overArg;
}

var _getPrototype;
var hasRequired_getPrototype;

function require_getPrototype () {
	if (hasRequired_getPrototype) return _getPrototype;
	hasRequired_getPrototype = 1;
	var overArg = require_overArg();

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	_getPrototype = getPrototype;
	return _getPrototype;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var isPlainObject_1;
var hasRequiredIsPlainObject;

function requireIsPlainObject () {
	if (hasRequiredIsPlainObject) return isPlainObject_1;
	hasRequiredIsPlainObject = 1;
	var baseGetTag = require_baseGetTag(),
	    getPrototype = require_getPrototype(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	isPlainObject_1 = isPlainObject;
	return isPlainObject_1;
}

var defaultStyle;
var hasRequiredDefaultStyle;

function requireDefaultStyle () {
	if (hasRequiredDefaultStyle) return defaultStyle;
	hasRequiredDefaultStyle = 1;
	// Generated by CoffeeScript 1.8.0
	defaultStyle = function() {
	  return {
	    'pretty-error': {
	      display: 'block',
	      marginLeft: '2'
	    },
	    'pretty-error > header': {
	      display: 'block'
	    },
	    'pretty-error > header > title > kind': {
	      background: 'red',
	      color: 'bright-white'
	    },
	    'pretty-error > header > title > wrapper': {
	      marginRight: '1',
	      color: 'grey'
	    },
	    'pretty-error > header > colon': {
	      color: 'grey',
	      marginRight: 1
	    },
	    'pretty-error > header > message': {
	      color: 'bright-white'
	    },
	    'pretty-error > trace': {
	      display: 'block',
	      marginTop: 1
	    },
	    'pretty-error > trace > item': {
	      display: 'block',
	      marginBottom: 1,
	      marginLeft: 2,
	      bullet: '"<grey>-</grey>"'
	    },
	    'pretty-error > trace > item > header': {
	      display: 'block'
	    },
	    'pretty-error > trace > item > header > pointer > file': {
	      color: 'bright-yellow'
	    },
	    'pretty-error > trace > item > header > pointer > colon': {
	      color: 'grey'
	    },
	    'pretty-error > trace > item > header > pointer > line': {
	      color: 'bright-yellow',
	      marginRight: 1
	    },
	    'pretty-error > trace > item > header > what': {
	      color: 'white'
	    },
	    'pretty-error > trace > item > footer': {
	      display: 'block'
	    },
	    'pretty-error > trace > item > footer > addr': {
	      display: 'block',
	      color: 'grey'
	    },
	    'pretty-error > trace > item > footer > extra': {
	      display: 'block',
	      color: 'grey'
	    }
	  };
	};
	return defaultStyle;
}

var ParsedError_1;
var hasRequiredParsedError;

function requireParsedError () {
	if (hasRequiredParsedError) return ParsedError_1;
	hasRequiredParsedError = 1;
	// Generated by CoffeeScript 1.8.0
	var ParsedError, prop, sysPath, _fn, _i, _len, _ref;

	sysPath = require$$0$4;

	ParsedError_1 = ParsedError = (function() {
	  function ParsedError(error) {
	    this.error = error;
	    this._parse();
	  }

	  ParsedError.prototype._parse = function() {
	    var m;
	    this._trace = [];
	    this._kind = 'Error';
	    this._wrapper = '';
	    if (this.error.wrapper != null) {
	      this._wrapper = String(this.error.wrapper);
	    }
	    if (typeof this.error !== 'object') {
	      this._message = String(this.error);
	    } else {
	      this._stack = this.error.stack;
	      if (this.error.kind != null) {
	        this._kind = String(this.error.kind);
	      } else if (typeof this._stack === 'string') {
	        if (m = this._stack.match(/^([a-zA-Z0-9\_\$]+):\ /)) {
	          this._kind = m[1];
	        }
	      }
	      this._message = (this.error.message != null) && String(this.error.message) || '';
	      if (typeof this._stack === 'string') {
	        this._parseStack();
	      }
	    }
	  };

	  ParsedError.prototype._parseStack = function() {
	    var line, message, messageLines, reachedTrace, _i, _len, _ref;
	    messageLines = [];
	    reachedTrace = false;
	    _ref = this._stack.split('\n');
	    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	      line = _ref[_i];
	      if (line.trim() === '') {
	        continue;
	      }
	      if (reachedTrace) {
	        this._trace.push(this._parseTraceItem(line));
	      } else {
	        if (line.match(/^\s*at\s.+/)) {
	          reachedTrace = true;
	          this._trace.push(this._parseTraceItem(line));
	        } else if (!this._message.split('\n'.indexOf(line))) {
	          messageLines.push(line);
	        }
	      }
	    }
	    message = messageLines.join('\n');
	    if (message.substr(0, this._kind.length) === this._kind) {
	      message = message.substr(this._kind.length, message.length).replace(/^\:\s+/, '');
	    }
	    if (message.length) {
	      this._message = this._message.length ? [this._message, message].join('\n') : message;
	    }
	  };

	  ParsedError.prototype._parseTraceItem = function(text) {
	    var addr, col, d, dir, file, jsCol, jsLine, line, m, original, packageName, packages, path, r, remaining, shortenedAddr, shortenedPath, what;
	    text = text.trim();
	    if (text === '') {
	      return;
	    }
	    if (!text.match(/^at\ /)) {
	      return text;
	    }
	    text = text.replace(/^at /, '');
	    if (text === 'Error (<anonymous>)' || text === 'Error (<anonymous>:null:null)') {
	      return;
	    }
	    original = text;
	    what = null;
	    addr = null;
	    path = null;
	    dir = null;
	    file = null;
	    line = null;
	    col = null;
	    jsLine = null;
	    jsCol = null;
	    shortenedPath = null;
	    shortenedAddr = null;
	    packageName = '[current]';
	    if (m = text.match(/\(([^\)]+)\)$/)) {
	      addr = m[1].trim();
	    }
	    if (addr != null) {
	      what = text.substr(0, text.length - addr.length - 2);
	      what = what.trim();
	    }
	    if (addr == null) {
	      addr = text.trim();
	    }
	    addr = this._fixPath(addr);
	    remaining = addr;
	    if (m = remaining.match(/\,\ <js>:(\d+):(\d+)$/)) {
	      jsLine = m[1];
	      jsCol = m[2];
	      remaining = remaining.substr(0, remaining.length - m[0].length);
	    }
	    if (m = remaining.match(/:(\d+):(\d+)$/)) {
	      line = m[1];
	      col = m[2];
	      remaining = remaining.substr(0, remaining.length - m[0].length);
	      path = remaining;
	    }
	    if (path != null) {
	      file = sysPath.basename(path);
	      dir = sysPath.dirname(path);
	      if (dir === '.') {
	        dir = '';
	      }
	      path = this._fixPath(path);
	      file = this._fixPath(file);
	      dir = this._fixPath(dir);
	    }
	    if (dir != null) {
	      d = dir.replace(/[\\]{1,2}/g, '/');
	      if (m = d.match(/node_modules\/([^\/]+)(?!.*node_modules.*)/)) {
	        packageName = m[1];
	      }
	    }
	    if (jsLine == null) {
	      jsLine = line;
	      jsCol = col;
	    }
	    if (path != null) {
	      r = this._rectifyPath(path);
	      shortenedPath = r.path;
	      shortenedAddr = shortenedPath + addr.substr(path.length, addr.length);
	      packages = r.packages;
	    }
	    return {
	      original: original,
	      what: what,
	      addr: addr,
	      path: path,
	      dir: dir,
	      file: file,
	      line: parseInt(line),
	      col: parseInt(col),
	      jsLine: parseInt(jsLine),
	      jsCol: parseInt(jsCol),
	      packageName: packageName,
	      shortenedPath: shortenedPath,
	      shortenedAddr: shortenedAddr,
	      packages: packages || []
	    };
	  };

	  ParsedError.prototype._getMessage = function() {
	    return this._message;
	  };

	  ParsedError.prototype._getKind = function() {
	    return this._kind;
	  };

	  ParsedError.prototype._getWrapper = function() {
	    return this._wrapper;
	  };

	  ParsedError.prototype._getStack = function() {
	    return this._stack;
	  };

	  ParsedError.prototype._getArguments = function() {
	    return this.error["arguments"];
	  };

	  ParsedError.prototype._getType = function() {
	    return this.error.type;
	  };

	  ParsedError.prototype._getTrace = function() {
	    return this._trace;
	  };

	  ParsedError.prototype._fixPath = function(path) {
	    return path.replace(/[\\]{1,2}/g, '/');
	  };

	  ParsedError.prototype._rectifyPath = function(path, nameForCurrentPackage) {
	    var m, packages, parts, rest;
	    path = String(path);
	    if (!(m = path.match(/^(.+?)\/node_modules\/(.+)$/))) {
	      return {
	        path: path,
	        packages: []
	      };
	    }
	    parts = [];
	    packages = [];
	    if (typeof nameForCurrentPackage === 'string') {
	      parts.push("[" + nameForCurrentPackage + "]");
	      packages.push("[" + nameForCurrentPackage + "]");
	    } else {
	      parts.push("[" + (m[1].match(/([^\/]+)$/)[1]) + "]");
	      packages.push(m[1].match(/([^\/]+)$/)[1]);
	    }
	    rest = m[2];
	    while (m = rest.match(/([^\/]+)\/node_modules\/(.+)$/)) {
	      parts.push("[" + m[1] + "]");
	      packages.push(m[1]);
	      rest = m[2];
	    }
	    if (m = rest.match(/([^\/]+)\/(.+)$/)) {
	      parts.push("[" + m[1] + "]");
	      packages.push(m[1]);
	      rest = m[2];
	    }
	    parts.push(rest);
	    return {
	      path: parts.join("/"),
	      packages: packages
	    };
	  };

	  return ParsedError;

	})();

	_ref = ['message', 'kind', 'arguments', 'type', 'stack', 'trace', 'wrapper'];
	_fn = function() {
	  var methodName;
	  methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length);
	  return Object.defineProperty(ParsedError.prototype, prop, {
	    get: function() {
	      return this[methodName]();
	    }
	  });
	};
	for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	  prop = _ref[_i];
	  _fn();
	}
	return ParsedError_1;
}

var nodePaths;
var hasRequiredNodePaths;

function requireNodePaths () {
	if (hasRequiredNodePaths) return nodePaths;
	hasRequiredNodePaths = 1;
	// Generated by CoffeeScript 1.8.0
	nodePaths = ['_debugger.js', '_http_agent.js', '_http_client.js', '_http_common.js', '_http_incoming.js', '_http_outgoing.js', '_http_server.js', '_linklist.js', '_stream_duplex.js', '_stream_passthrough.js', '_stream_readable.js', '_stream_transform.js', '_stream_writable.js', '_tls_legacy.js', '_tls_wrap.js', 'assert.js', 'buffer.js', 'child_process.js', 'cluster.js', 'console.js', 'constants.js', 'crypto.js', 'dgram.js', 'dns.js', 'domain.js', 'events.js', 'freelist.js', 'fs.js', 'http.js', 'https.js', 'module.js', 'net.js', 'os.js', 'path.js', 'punycode.js', 'querystring.js', 'readline.js', 'repl.js', 'smalloc.js', 'stream.js', 'string_decoder.js', 'sys.js', 'timers.js', 'tls.js', 'tty.js', 'url.js', 'util.js', 'vm.js', 'zlib.js', 'node.js'];
	return nodePaths;
}

var lib$9 = {};

var Parser = {};

var Tokenizer = {};

var decode_codepoint = {};

var require$$0$2 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var hasRequiredDecode_codepoint;

function requireDecode_codepoint () {
	if (hasRequiredDecode_codepoint) return decode_codepoint;
	hasRequiredDecode_codepoint = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(decode_codepoint, "__esModule", { value: true });
	var decode_json_1 = __importDefault(require$$0$2);
	// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
	var fromCodePoint = 
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	String.fromCodePoint ||
	    function (codePoint) {
	        var output = "";
	        if (codePoint > 0xffff) {
	            codePoint -= 0x10000;
	            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
	            codePoint = 0xdc00 | (codePoint & 0x3ff);
	        }
	        output += String.fromCharCode(codePoint);
	        return output;
	    };
	function decodeCodePoint(codePoint) {
	    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
	        return "\uFFFD";
	    }
	    if (codePoint in decode_json_1.default) {
	        codePoint = decode_json_1.default[codePoint];
	    }
	    return fromCodePoint(codePoint);
	}
	decode_codepoint.default = decodeCodePoint;
	return decode_codepoint;
}

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block$1 = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$1 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker$1 = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$1 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block$1,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$1,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker$1,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$1,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$0$1 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return Tokenizer;
	hasRequiredTokenizer = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(Tokenizer, "__esModule", { value: true });
	var decode_codepoint_1 = __importDefault(requireDecode_codepoint());
	var entities_json_1 = __importDefault(require$$1$1);
	var legacy_json_1 = __importDefault(require$$1);
	var xml_json_1 = __importDefault(require$$0$1);
	function whitespace(c) {
	    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
	}
	function isASCIIAlpha(c) {
	    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
	}
	function ifElseState(upper, SUCCESS, FAILURE) {
	    var lower = upper.toLowerCase();
	    if (upper === lower) {
	        return function (t, c) {
	            if (c === lower) {
	                t._state = SUCCESS;
	            }
	            else {
	                t._state = FAILURE;
	                t._index--;
	            }
	        };
	    }
	    return function (t, c) {
	        if (c === lower || c === upper) {
	            t._state = SUCCESS;
	        }
	        else {
	            t._state = FAILURE;
	            t._index--;
	        }
	    };
	}
	function consumeSpecialNameChar(upper, NEXT_STATE) {
	    var lower = upper.toLowerCase();
	    return function (t, c) {
	        if (c === lower || c === upper) {
	            t._state = NEXT_STATE;
	        }
	        else {
	            t._state = 3 /* InTagName */;
	            t._index--; // Consume the token again
	        }
	    };
	}
	var stateBeforeCdata1 = ifElseState("C", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);
	var stateBeforeCdata2 = ifElseState("D", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);
	var stateBeforeCdata3 = ifElseState("A", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);
	var stateBeforeCdata4 = ifElseState("T", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);
	var stateBeforeCdata5 = ifElseState("A", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);
	var stateBeforeScript1 = consumeSpecialNameChar("R", 35 /* BeforeScript2 */);
	var stateBeforeScript2 = consumeSpecialNameChar("I", 36 /* BeforeScript3 */);
	var stateBeforeScript3 = consumeSpecialNameChar("P", 37 /* BeforeScript4 */);
	var stateBeforeScript4 = consumeSpecialNameChar("T", 38 /* BeforeScript5 */);
	var stateAfterScript1 = ifElseState("R", 40 /* AfterScript2 */, 1 /* Text */);
	var stateAfterScript2 = ifElseState("I", 41 /* AfterScript3 */, 1 /* Text */);
	var stateAfterScript3 = ifElseState("P", 42 /* AfterScript4 */, 1 /* Text */);
	var stateAfterScript4 = ifElseState("T", 43 /* AfterScript5 */, 1 /* Text */);
	var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45 /* BeforeStyle2 */);
	var stateBeforeStyle2 = consumeSpecialNameChar("L", 46 /* BeforeStyle3 */);
	var stateBeforeStyle3 = consumeSpecialNameChar("E", 47 /* BeforeStyle4 */);
	var stateAfterStyle1 = ifElseState("Y", 49 /* AfterStyle2 */, 1 /* Text */);
	var stateAfterStyle2 = ifElseState("L", 50 /* AfterStyle3 */, 1 /* Text */);
	var stateAfterStyle3 = ifElseState("E", 51 /* AfterStyle4 */, 1 /* Text */);
	var stateBeforeSpecialT = consumeSpecialNameChar("I", 54 /* BeforeTitle1 */);
	var stateBeforeTitle1 = consumeSpecialNameChar("T", 55 /* BeforeTitle2 */);
	var stateBeforeTitle2 = consumeSpecialNameChar("L", 56 /* BeforeTitle3 */);
	var stateBeforeTitle3 = consumeSpecialNameChar("E", 57 /* BeforeTitle4 */);
	var stateAfterSpecialTEnd = ifElseState("I", 58 /* AfterTitle1 */, 1 /* Text */);
	var stateAfterTitle1 = ifElseState("T", 59 /* AfterTitle2 */, 1 /* Text */);
	var stateAfterTitle2 = ifElseState("L", 60 /* AfterTitle3 */, 1 /* Text */);
	var stateAfterTitle3 = ifElseState("E", 61 /* AfterTitle4 */, 1 /* Text */);
	var stateBeforeEntity = ifElseState("#", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);
	var stateBeforeNumericEntity = ifElseState("X", 66 /* InHexEntity */, 65 /* InNumericEntity */);
	var Tokenizer$1 = /** @class */ (function () {
	    function Tokenizer(options, cbs) {
	        var _a;
	        /** The current state the tokenizer is in. */
	        this._state = 1 /* Text */;
	        /** The read buffer. */
	        this.buffer = "";
	        /** The beginning of the section that is currently being read. */
	        this.sectionStart = 0;
	        /** The index within the buffer that we are currently looking at. */
	        this._index = 0;
	        /**
	         * Data that has already been processed will be removed from the buffer occasionally.
	         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
	         */
	        this.bufferOffset = 0;
	        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
	        this.baseState = 1 /* Text */;
	        /** For special parsing behavior inside of script and style tags. */
	        this.special = 1 /* None */;
	        /** Indicates whether the tokenizer has been paused. */
	        this.running = true;
	        /** Indicates whether the tokenizer has finished running / `.end` has been called. */
	        this.ended = false;
	        this.cbs = cbs;
	        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
	        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
	    }
	    Tokenizer.prototype.reset = function () {
	        this._state = 1 /* Text */;
	        this.buffer = "";
	        this.sectionStart = 0;
	        this._index = 0;
	        this.bufferOffset = 0;
	        this.baseState = 1 /* Text */;
	        this.special = 1 /* None */;
	        this.running = true;
	        this.ended = false;
	    };
	    Tokenizer.prototype.write = function (chunk) {
	        if (this.ended)
	            this.cbs.onerror(Error(".write() after done!"));
	        this.buffer += chunk;
	        this.parse();
	    };
	    Tokenizer.prototype.end = function (chunk) {
	        if (this.ended)
	            this.cbs.onerror(Error(".end() after done!"));
	        if (chunk)
	            this.write(chunk);
	        this.ended = true;
	        if (this.running)
	            this.finish();
	    };
	    Tokenizer.prototype.pause = function () {
	        this.running = false;
	    };
	    Tokenizer.prototype.resume = function () {
	        this.running = true;
	        if (this._index < this.buffer.length) {
	            this.parse();
	        }
	        if (this.ended) {
	            this.finish();
	        }
	    };
	    /**
	     * The current index within all of the written data.
	     */
	    Tokenizer.prototype.getAbsoluteIndex = function () {
	        return this.bufferOffset + this._index;
	    };
	    Tokenizer.prototype.stateText = function (c) {
	        if (c === "<") {
	            if (this._index > this.sectionStart) {
	                this.cbs.ontext(this.getSection());
	            }
	            this._state = 2 /* BeforeTagName */;
	            this.sectionStart = this._index;
	        }
	        else if (this.decodeEntities &&
	            c === "&" &&
	            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {
	            if (this._index > this.sectionStart) {
	                this.cbs.ontext(this.getSection());
	            }
	            this.baseState = 1 /* Text */;
	            this._state = 62 /* BeforeEntity */;
	            this.sectionStart = this._index;
	        }
	    };
	    /**
	     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
	     *
	     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
	     * We allow anything that wouldn't end the tag.
	     */
	    Tokenizer.prototype.isTagStartChar = function (c) {
	        return (isASCIIAlpha(c) ||
	            (this.xmlMode && !whitespace(c) && c !== "/" && c !== ">"));
	    };
	    Tokenizer.prototype.stateBeforeTagName = function (c) {
	        if (c === "/") {
	            this._state = 5 /* BeforeClosingTagName */;
	        }
	        else if (c === "<") {
	            this.cbs.ontext(this.getSection());
	            this.sectionStart = this._index;
	        }
	        else if (c === ">" ||
	            this.special !== 1 /* None */ ||
	            whitespace(c)) {
	            this._state = 1 /* Text */;
	        }
	        else if (c === "!") {
	            this._state = 15 /* BeforeDeclaration */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (c === "?") {
	            this._state = 17 /* InProcessingInstruction */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (!this.isTagStartChar(c)) {
	            this._state = 1 /* Text */;
	        }
	        else {
	            this._state =
	                !this.xmlMode && (c === "s" || c === "S")
	                    ? 32 /* BeforeSpecialS */
	                    : !this.xmlMode && (c === "t" || c === "T")
	                        ? 52 /* BeforeSpecialT */
	                        : 3 /* InTagName */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateInTagName = function (c) {
	        if (c === "/" || c === ">" || whitespace(c)) {
	            this.emitToken("onopentagname");
	            this._state = 8 /* BeforeAttributeName */;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
	        if (whitespace(c)) ;
	        else if (c === ">") {
	            this._state = 1 /* Text */;
	        }
	        else if (this.special !== 1 /* None */) {
	            if (this.special !== 4 /* Title */ && (c === "s" || c === "S")) {
	                this._state = 33 /* BeforeSpecialSEnd */;
	            }
	            else if (this.special === 4 /* Title */ &&
	                (c === "t" || c === "T")) {
	                this._state = 53 /* BeforeSpecialTEnd */;
	            }
	            else {
	                this._state = 1 /* Text */;
	                this._index--;
	            }
	        }
	        else if (!this.isTagStartChar(c)) {
	            this._state = 20 /* InSpecialComment */;
	            this.sectionStart = this._index;
	        }
	        else {
	            this._state = 6 /* InClosingTagName */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateInClosingTagName = function (c) {
	        if (c === ">" || whitespace(c)) {
	            this.emitToken("onclosetag");
	            this._state = 7 /* AfterClosingTagName */;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
	        // Skip everything until ">"
	        if (c === ">") {
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	    };
	    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
	        if (c === ">") {
	            this.cbs.onopentagend();
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (c === "/") {
	            this._state = 4 /* InSelfClosingTag */;
	        }
	        else if (!whitespace(c)) {
	            this._state = 9 /* InAttributeName */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
	        if (c === ">") {
	            this.cbs.onselfclosingtag();
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags
	        }
	        else if (!whitespace(c)) {
	            this._state = 8 /* BeforeAttributeName */;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateInAttributeName = function (c) {
	        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
	            this.cbs.onattribname(this.getSection());
	            this.sectionStart = -1;
	            this._state = 10 /* AfterAttributeName */;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateAfterAttributeName = function (c) {
	        if (c === "=") {
	            this._state = 11 /* BeforeAttributeValue */;
	        }
	        else if (c === "/" || c === ">") {
	            this.cbs.onattribend(undefined);
	            this._state = 8 /* BeforeAttributeName */;
	            this._index--;
	        }
	        else if (!whitespace(c)) {
	            this.cbs.onattribend(undefined);
	            this._state = 9 /* InAttributeName */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
	        if (c === '"') {
	            this._state = 12 /* InAttributeValueDq */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (c === "'") {
	            this._state = 13 /* InAttributeValueSq */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (!whitespace(c)) {
	            this._state = 14 /* InAttributeValueNq */;
	            this.sectionStart = this._index;
	            this._index--; // Reconsume token
	        }
	    };
	    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
	        if (c === quote) {
	            this.emitToken("onattribdata");
	            this.cbs.onattribend(quote);
	            this._state = 8 /* BeforeAttributeName */;
	        }
	        else if (this.decodeEntities && c === "&") {
	            this.emitToken("onattribdata");
	            this.baseState = this._state;
	            this._state = 62 /* BeforeEntity */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
	        this.handleInAttributeValue(c, '"');
	    };
	    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
	        this.handleInAttributeValue(c, "'");
	    };
	    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
	        if (whitespace(c) || c === ">") {
	            this.emitToken("onattribdata");
	            this.cbs.onattribend(null);
	            this._state = 8 /* BeforeAttributeName */;
	            this._index--;
	        }
	        else if (this.decodeEntities && c === "&") {
	            this.emitToken("onattribdata");
	            this.baseState = this._state;
	            this._state = 62 /* BeforeEntity */;
	            this.sectionStart = this._index;
	        }
	    };
	    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
	        this._state =
	            c === "["
	                ? 23 /* BeforeCdata1 */
	                : c === "-"
	                    ? 18 /* BeforeComment */
	                    : 16 /* InDeclaration */;
	    };
	    Tokenizer.prototype.stateInDeclaration = function (c) {
	        if (c === ">") {
	            this.cbs.ondeclaration(this.getSection());
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	    };
	    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
	        if (c === ">") {
	            this.cbs.onprocessinginstruction(this.getSection());
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	    };
	    Tokenizer.prototype.stateBeforeComment = function (c) {
	        if (c === "-") {
	            this._state = 19 /* InComment */;
	            this.sectionStart = this._index + 1;
	        }
	        else {
	            this._state = 16 /* InDeclaration */;
	        }
	    };
	    Tokenizer.prototype.stateInComment = function (c) {
	        if (c === "-")
	            this._state = 21 /* AfterComment1 */;
	    };
	    Tokenizer.prototype.stateInSpecialComment = function (c) {
	        if (c === ">") {
	            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	    };
	    Tokenizer.prototype.stateAfterComment1 = function (c) {
	        if (c === "-") {
	            this._state = 22 /* AfterComment2 */;
	        }
	        else {
	            this._state = 19 /* InComment */;
	        }
	    };
	    Tokenizer.prototype.stateAfterComment2 = function (c) {
	        if (c === ">") {
	            // Remove 2 trailing chars
	            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (c !== "-") {
	            this._state = 19 /* InComment */;
	        }
	        // Else: stay in AFTER_COMMENT_2 (`--->`)
	    };
	    Tokenizer.prototype.stateBeforeCdata6 = function (c) {
	        if (c === "[") {
	            this._state = 29 /* InCdata */;
	            this.sectionStart = this._index + 1;
	        }
	        else {
	            this._state = 16 /* InDeclaration */;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateInCdata = function (c) {
	        if (c === "]")
	            this._state = 30 /* AfterCdata1 */;
	    };
	    Tokenizer.prototype.stateAfterCdata1 = function (c) {
	        if (c === "]")
	            this._state = 31 /* AfterCdata2 */;
	        else
	            this._state = 29 /* InCdata */;
	    };
	    Tokenizer.prototype.stateAfterCdata2 = function (c) {
	        if (c === ">") {
	            // Remove 2 trailing chars
	            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
	            this._state = 1 /* Text */;
	            this.sectionStart = this._index + 1;
	        }
	        else if (c !== "]") {
	            this._state = 29 /* InCdata */;
	        }
	        // Else: stay in AFTER_CDATA_2 (`]]]>`)
	    };
	    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
	        if (c === "c" || c === "C") {
	            this._state = 34 /* BeforeScript1 */;
	        }
	        else if (c === "t" || c === "T") {
	            this._state = 44 /* BeforeStyle1 */;
	        }
	        else {
	            this._state = 3 /* InTagName */;
	            this._index--; // Consume the token again
	        }
	    };
	    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
	        if (this.special === 2 /* Script */ && (c === "c" || c === "C")) {
	            this._state = 39 /* AfterScript1 */;
	        }
	        else if (this.special === 3 /* Style */ && (c === "t" || c === "T")) {
	            this._state = 48 /* AfterStyle1 */;
	        }
	        else
	            this._state = 1 /* Text */;
	    };
	    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
	        if (c === "/" || c === ">" || whitespace(c)) {
	            this.special = special;
	        }
	        this._state = 3 /* InTagName */;
	        this._index--; // Consume the token again
	    };
	    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
	        if (c === ">" || whitespace(c)) {
	            this.special = 1 /* None */;
	            this._state = 6 /* InClosingTagName */;
	            this.sectionStart = this._index - sectionStartOffset;
	            this._index--; // Reconsume the token
	        }
	        else
	            this._state = 1 /* Text */;
	    };
	    // For entities terminated with a semicolon
	    Tokenizer.prototype.parseFixedEntity = function (map) {
	        if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }
	        // Offset = 1
	        if (this.sectionStart + 1 < this._index) {
	            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
	            if (Object.prototype.hasOwnProperty.call(map, entity)) {
	                this.emitPartial(map[entity]);
	                this.sectionStart = this._index + 1;
	            }
	        }
	    };
	    // Parses legacy entities (without trailing semicolon)
	    Tokenizer.prototype.parseLegacyEntity = function () {
	        var start = this.sectionStart + 1;
	        // The max length of legacy entities is 6
	        var limit = Math.min(this._index - start, 6);
	        while (limit >= 2) {
	            // The min length of legacy entities is 2
	            var entity = this.buffer.substr(start, limit);
	            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
	                this.emitPartial(legacy_json_1.default[entity]);
	                this.sectionStart += limit + 1;
	                return;
	            }
	            limit--;
	        }
	    };
	    Tokenizer.prototype.stateInNamedEntity = function (c) {
	        if (c === ";") {
	            this.parseFixedEntity();
	            // Retry as legacy entity if entity wasn't parsed
	            if (this.baseState === 1 /* Text */ &&
	                this.sectionStart + 1 < this._index &&
	                !this.xmlMode) {
	                this.parseLegacyEntity();
	            }
	            this._state = this.baseState;
	        }
	        else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
	            if (this.xmlMode || this.sectionStart + 1 === this._index) ;
	            else if (this.baseState !== 1 /* Text */) {
	                if (c !== "=") {
	                    // Parse as legacy entity, without allowing additional characters.
	                    this.parseFixedEntity(legacy_json_1.default);
	                }
	            }
	            else {
	                this.parseLegacyEntity();
	            }
	            this._state = this.baseState;
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
	        var sectionStart = this.sectionStart + offset;
	        if (sectionStart !== this._index) {
	            // Parse entity
	            var entity = this.buffer.substring(sectionStart, this._index);
	            var parsed = parseInt(entity, base);
	            this.emitPartial(decode_codepoint_1.default(parsed));
	            this.sectionStart = strict ? this._index + 1 : this._index;
	        }
	        this._state = this.baseState;
	    };
	    Tokenizer.prototype.stateInNumericEntity = function (c) {
	        if (c === ";") {
	            this.decodeNumericEntity(2, 10, true);
	        }
	        else if (c < "0" || c > "9") {
	            if (!this.xmlMode) {
	                this.decodeNumericEntity(2, 10, false);
	            }
	            else {
	                this._state = this.baseState;
	            }
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.stateInHexEntity = function (c) {
	        if (c === ";") {
	            this.decodeNumericEntity(3, 16, true);
	        }
	        else if ((c < "a" || c > "f") &&
	            (c < "A" || c > "F") &&
	            (c < "0" || c > "9")) {
	            if (!this.xmlMode) {
	                this.decodeNumericEntity(3, 16, false);
	            }
	            else {
	                this._state = this.baseState;
	            }
	            this._index--;
	        }
	    };
	    Tokenizer.prototype.cleanup = function () {
	        if (this.sectionStart < 0) {
	            this.buffer = "";
	            this.bufferOffset += this._index;
	            this._index = 0;
	        }
	        else if (this.running) {
	            if (this._state === 1 /* Text */) {
	                if (this.sectionStart !== this._index) {
	                    this.cbs.ontext(this.buffer.substr(this.sectionStart));
	                }
	                this.buffer = "";
	                this.bufferOffset += this._index;
	                this._index = 0;
	            }
	            else if (this.sectionStart === this._index) {
	                // The section just started
	                this.buffer = "";
	                this.bufferOffset += this._index;
	                this._index = 0;
	            }
	            else {
	                // Remove everything unnecessary
	                this.buffer = this.buffer.substr(this.sectionStart);
	                this._index -= this.sectionStart;
	                this.bufferOffset += this.sectionStart;
	            }
	            this.sectionStart = 0;
	        }
	    };
	    /**
	     * Iterates through the buffer, calling the function corresponding to the current state.
	     *
	     * States that are more likely to be hit are higher up, as a performance improvement.
	     */
	    Tokenizer.prototype.parse = function () {
	        while (this._index < this.buffer.length && this.running) {
	            var c = this.buffer.charAt(this._index);
	            if (this._state === 1 /* Text */) {
	                this.stateText(c);
	            }
	            else if (this._state === 12 /* InAttributeValueDq */) {
	                this.stateInAttributeValueDoubleQuotes(c);
	            }
	            else if (this._state === 9 /* InAttributeName */) {
	                this.stateInAttributeName(c);
	            }
	            else if (this._state === 19 /* InComment */) {
	                this.stateInComment(c);
	            }
	            else if (this._state === 20 /* InSpecialComment */) {
	                this.stateInSpecialComment(c);
	            }
	            else if (this._state === 8 /* BeforeAttributeName */) {
	                this.stateBeforeAttributeName(c);
	            }
	            else if (this._state === 3 /* InTagName */) {
	                this.stateInTagName(c);
	            }
	            else if (this._state === 6 /* InClosingTagName */) {
	                this.stateInClosingTagName(c);
	            }
	            else if (this._state === 2 /* BeforeTagName */) {
	                this.stateBeforeTagName(c);
	            }
	            else if (this._state === 10 /* AfterAttributeName */) {
	                this.stateAfterAttributeName(c);
	            }
	            else if (this._state === 13 /* InAttributeValueSq */) {
	                this.stateInAttributeValueSingleQuotes(c);
	            }
	            else if (this._state === 11 /* BeforeAttributeValue */) {
	                this.stateBeforeAttributeValue(c);
	            }
	            else if (this._state === 5 /* BeforeClosingTagName */) {
	                this.stateBeforeClosingTagName(c);
	            }
	            else if (this._state === 7 /* AfterClosingTagName */) {
	                this.stateAfterClosingTagName(c);
	            }
	            else if (this._state === 32 /* BeforeSpecialS */) {
	                this.stateBeforeSpecialS(c);
	            }
	            else if (this._state === 21 /* AfterComment1 */) {
	                this.stateAfterComment1(c);
	            }
	            else if (this._state === 14 /* InAttributeValueNq */) {
	                this.stateInAttributeValueNoQuotes(c);
	            }
	            else if (this._state === 4 /* InSelfClosingTag */) {
	                this.stateInSelfClosingTag(c);
	            }
	            else if (this._state === 16 /* InDeclaration */) {
	                this.stateInDeclaration(c);
	            }
	            else if (this._state === 15 /* BeforeDeclaration */) {
	                this.stateBeforeDeclaration(c);
	            }
	            else if (this._state === 22 /* AfterComment2 */) {
	                this.stateAfterComment2(c);
	            }
	            else if (this._state === 18 /* BeforeComment */) {
	                this.stateBeforeComment(c);
	            }
	            else if (this._state === 33 /* BeforeSpecialSEnd */) {
	                this.stateBeforeSpecialSEnd(c);
	            }
	            else if (this._state === 53 /* BeforeSpecialTEnd */) {
	                stateAfterSpecialTEnd(this, c);
	            }
	            else if (this._state === 39 /* AfterScript1 */) {
	                stateAfterScript1(this, c);
	            }
	            else if (this._state === 40 /* AfterScript2 */) {
	                stateAfterScript2(this, c);
	            }
	            else if (this._state === 41 /* AfterScript3 */) {
	                stateAfterScript3(this, c);
	            }
	            else if (this._state === 34 /* BeforeScript1 */) {
	                stateBeforeScript1(this, c);
	            }
	            else if (this._state === 35 /* BeforeScript2 */) {
	                stateBeforeScript2(this, c);
	            }
	            else if (this._state === 36 /* BeforeScript3 */) {
	                stateBeforeScript3(this, c);
	            }
	            else if (this._state === 37 /* BeforeScript4 */) {
	                stateBeforeScript4(this, c);
	            }
	            else if (this._state === 38 /* BeforeScript5 */) {
	                this.stateBeforeSpecialLast(c, 2 /* Script */);
	            }
	            else if (this._state === 42 /* AfterScript4 */) {
	                stateAfterScript4(this, c);
	            }
	            else if (this._state === 43 /* AfterScript5 */) {
	                this.stateAfterSpecialLast(c, 6);
	            }
	            else if (this._state === 44 /* BeforeStyle1 */) {
	                stateBeforeStyle1(this, c);
	            }
	            else if (this._state === 29 /* InCdata */) {
	                this.stateInCdata(c);
	            }
	            else if (this._state === 45 /* BeforeStyle2 */) {
	                stateBeforeStyle2(this, c);
	            }
	            else if (this._state === 46 /* BeforeStyle3 */) {
	                stateBeforeStyle3(this, c);
	            }
	            else if (this._state === 47 /* BeforeStyle4 */) {
	                this.stateBeforeSpecialLast(c, 3 /* Style */);
	            }
	            else if (this._state === 48 /* AfterStyle1 */) {
	                stateAfterStyle1(this, c);
	            }
	            else if (this._state === 49 /* AfterStyle2 */) {
	                stateAfterStyle2(this, c);
	            }
	            else if (this._state === 50 /* AfterStyle3 */) {
	                stateAfterStyle3(this, c);
	            }
	            else if (this._state === 51 /* AfterStyle4 */) {
	                this.stateAfterSpecialLast(c, 5);
	            }
	            else if (this._state === 52 /* BeforeSpecialT */) {
	                stateBeforeSpecialT(this, c);
	            }
	            else if (this._state === 54 /* BeforeTitle1 */) {
	                stateBeforeTitle1(this, c);
	            }
	            else if (this._state === 55 /* BeforeTitle2 */) {
	                stateBeforeTitle2(this, c);
	            }
	            else if (this._state === 56 /* BeforeTitle3 */) {
	                stateBeforeTitle3(this, c);
	            }
	            else if (this._state === 57 /* BeforeTitle4 */) {
	                this.stateBeforeSpecialLast(c, 4 /* Title */);
	            }
	            else if (this._state === 58 /* AfterTitle1 */) {
	                stateAfterTitle1(this, c);
	            }
	            else if (this._state === 59 /* AfterTitle2 */) {
	                stateAfterTitle2(this, c);
	            }
	            else if (this._state === 60 /* AfterTitle3 */) {
	                stateAfterTitle3(this, c);
	            }
	            else if (this._state === 61 /* AfterTitle4 */) {
	                this.stateAfterSpecialLast(c, 5);
	            }
	            else if (this._state === 17 /* InProcessingInstruction */) {
	                this.stateInProcessingInstruction(c);
	            }
	            else if (this._state === 64 /* InNamedEntity */) {
	                this.stateInNamedEntity(c);
	            }
	            else if (this._state === 23 /* BeforeCdata1 */) {
	                stateBeforeCdata1(this, c);
	            }
	            else if (this._state === 62 /* BeforeEntity */) {
	                stateBeforeEntity(this, c);
	            }
	            else if (this._state === 24 /* BeforeCdata2 */) {
	                stateBeforeCdata2(this, c);
	            }
	            else if (this._state === 25 /* BeforeCdata3 */) {
	                stateBeforeCdata3(this, c);
	            }
	            else if (this._state === 30 /* AfterCdata1 */) {
	                this.stateAfterCdata1(c);
	            }
	            else if (this._state === 31 /* AfterCdata2 */) {
	                this.stateAfterCdata2(c);
	            }
	            else if (this._state === 26 /* BeforeCdata4 */) {
	                stateBeforeCdata4(this, c);
	            }
	            else if (this._state === 27 /* BeforeCdata5 */) {
	                stateBeforeCdata5(this, c);
	            }
	            else if (this._state === 28 /* BeforeCdata6 */) {
	                this.stateBeforeCdata6(c);
	            }
	            else if (this._state === 66 /* InHexEntity */) {
	                this.stateInHexEntity(c);
	            }
	            else if (this._state === 65 /* InNumericEntity */) {
	                this.stateInNumericEntity(c);
	                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	            }
	            else if (this._state === 63 /* BeforeNumericEntity */) {
	                stateBeforeNumericEntity(this, c);
	            }
	            else {
	                this.cbs.onerror(Error("unknown _state"), this._state);
	            }
	            this._index++;
	        }
	        this.cleanup();
	    };
	    Tokenizer.prototype.finish = function () {
	        // If there is remaining data, emit it in a reasonable way
	        if (this.sectionStart < this._index) {
	            this.handleTrailingData();
	        }
	        this.cbs.onend();
	    };
	    Tokenizer.prototype.handleTrailingData = function () {
	        var data = this.buffer.substr(this.sectionStart);
	        if (this._state === 29 /* InCdata */ ||
	            this._state === 30 /* AfterCdata1 */ ||
	            this._state === 31 /* AfterCdata2 */) {
	            this.cbs.oncdata(data);
	        }
	        else if (this._state === 19 /* InComment */ ||
	            this._state === 21 /* AfterComment1 */ ||
	            this._state === 22 /* AfterComment2 */) {
	            this.cbs.oncomment(data);
	        }
	        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {
	            this.parseLegacyEntity();
	            if (this.sectionStart < this._index) {
	                this._state = this.baseState;
	                this.handleTrailingData();
	            }
	        }
	        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {
	            this.decodeNumericEntity(2, 10, false);
	            if (this.sectionStart < this._index) {
	                this._state = this.baseState;
	                this.handleTrailingData();
	            }
	        }
	        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {
	            this.decodeNumericEntity(3, 16, false);
	            if (this.sectionStart < this._index) {
	                this._state = this.baseState;
	                this.handleTrailingData();
	            }
	        }
	        else if (this._state !== 3 /* InTagName */ &&
	            this._state !== 8 /* BeforeAttributeName */ &&
	            this._state !== 11 /* BeforeAttributeValue */ &&
	            this._state !== 10 /* AfterAttributeName */ &&
	            this._state !== 9 /* InAttributeName */ &&
	            this._state !== 13 /* InAttributeValueSq */ &&
	            this._state !== 12 /* InAttributeValueDq */ &&
	            this._state !== 14 /* InAttributeValueNq */ &&
	            this._state !== 6 /* InClosingTagName */) {
	            this.cbs.ontext(data);
	        }
	        /*
	         * Else, ignore remaining data
	         * TODO add a way to remove current tag
	         */
	    };
	    Tokenizer.prototype.getSection = function () {
	        return this.buffer.substring(this.sectionStart, this._index);
	    };
	    Tokenizer.prototype.emitToken = function (name) {
	        this.cbs[name](this.getSection());
	        this.sectionStart = -1;
	    };
	    Tokenizer.prototype.emitPartial = function (value) {
	        if (this.baseState !== 1 /* Text */) {
	            this.cbs.onattribdata(value); // TODO implement the new event
	        }
	        else {
	            this.cbs.ontext(value);
	        }
	    };
	    return Tokenizer;
	}());
	Tokenizer.default = Tokenizer$1;
	return Tokenizer;
}

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return Parser;
	hasRequiredParser = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(Parser, "__esModule", { value: true });
	Parser.Parser = void 0;
	var Tokenizer_1 = __importDefault(requireTokenizer());
	var formTags = new Set([
	    "input",
	    "option",
	    "optgroup",
	    "select",
	    "button",
	    "datalist",
	    "textarea",
	]);
	var pTag = new Set(["p"]);
	var openImpliesClose = {
	    tr: new Set(["tr", "th", "td"]),
	    th: new Set(["th"]),
	    td: new Set(["thead", "th", "td"]),
	    body: new Set(["head", "link", "script"]),
	    li: new Set(["li"]),
	    p: pTag,
	    h1: pTag,
	    h2: pTag,
	    h3: pTag,
	    h4: pTag,
	    h5: pTag,
	    h6: pTag,
	    select: formTags,
	    input: formTags,
	    output: formTags,
	    button: formTags,
	    datalist: formTags,
	    textarea: formTags,
	    option: new Set(["option"]),
	    optgroup: new Set(["optgroup", "option"]),
	    dd: new Set(["dt", "dd"]),
	    dt: new Set(["dt", "dd"]),
	    address: pTag,
	    article: pTag,
	    aside: pTag,
	    blockquote: pTag,
	    details: pTag,
	    div: pTag,
	    dl: pTag,
	    fieldset: pTag,
	    figcaption: pTag,
	    figure: pTag,
	    footer: pTag,
	    form: pTag,
	    header: pTag,
	    hr: pTag,
	    main: pTag,
	    nav: pTag,
	    ol: pTag,
	    pre: pTag,
	    section: pTag,
	    table: pTag,
	    ul: pTag,
	    rt: new Set(["rt", "rp"]),
	    rp: new Set(["rt", "rp"]),
	    tbody: new Set(["thead", "tbody"]),
	    tfoot: new Set(["thead", "tbody"]),
	};
	var voidElements = new Set([
	    "area",
	    "base",
	    "basefont",
	    "br",
	    "col",
	    "command",
	    "embed",
	    "frame",
	    "hr",
	    "img",
	    "input",
	    "isindex",
	    "keygen",
	    "link",
	    "meta",
	    "param",
	    "source",
	    "track",
	    "wbr",
	]);
	var foreignContextElements = new Set(["math", "svg"]);
	var htmlIntegrationElements = new Set([
	    "mi",
	    "mo",
	    "mn",
	    "ms",
	    "mtext",
	    "annotation-xml",
	    "foreignObject",
	    "desc",
	    "title",
	]);
	var reNameEnd = /\s|\//;
	var Parser$1 = /** @class */ (function () {
	    function Parser(cbs, options) {
	        if (options === void 0) { options = {}; }
	        var _a, _b, _c, _d, _e;
	        /** The start index of the last event. */
	        this.startIndex = 0;
	        /** The end index of the last event. */
	        this.endIndex = null;
	        this.tagname = "";
	        this.attribname = "";
	        this.attribvalue = "";
	        this.attribs = null;
	        this.stack = [];
	        this.foreignContext = [];
	        this.options = options;
	        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
	        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
	        this.lowerCaseAttributeNames =
	            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
	        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
	        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
	    }
	    Parser.prototype.updatePosition = function (initialOffset) {
	        if (this.endIndex === null) {
	            if (this.tokenizer.sectionStart <= initialOffset) {
	                this.startIndex = 0;
	            }
	            else {
	                this.startIndex = this.tokenizer.sectionStart - initialOffset;
	            }
	        }
	        else {
	            this.startIndex = this.endIndex + 1;
	        }
	        this.endIndex = this.tokenizer.getAbsoluteIndex();
	    };
	    // Tokenizer event handlers
	    Parser.prototype.ontext = function (data) {
	        var _a, _b;
	        this.updatePosition(1);
	        this.endIndex--;
	        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
	    };
	    Parser.prototype.onopentagname = function (name) {
	        var _a, _b;
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        this.tagname = name;
	        if (!this.options.xmlMode &&
	            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
	            var el = void 0;
	            while (this.stack.length > 0 &&
	                openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {
	                this.onclosetag(el);
	            }
	        }
	        if (this.options.xmlMode || !voidElements.has(name)) {
	            this.stack.push(name);
	            if (foreignContextElements.has(name)) {
	                this.foreignContext.push(true);
	            }
	            else if (htmlIntegrationElements.has(name)) {
	                this.foreignContext.push(false);
	            }
	        }
	        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
	        if (this.cbs.onopentag)
	            this.attribs = {};
	    };
	    Parser.prototype.onopentagend = function () {
	        var _a, _b;
	        this.updatePosition(1);
	        if (this.attribs) {
	            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
	            this.attribs = null;
	        }
	        if (!this.options.xmlMode &&
	            this.cbs.onclosetag &&
	            voidElements.has(this.tagname)) {
	            this.cbs.onclosetag(this.tagname);
	        }
	        this.tagname = "";
	    };
	    Parser.prototype.onclosetag = function (name) {
	        this.updatePosition(1);
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        if (foreignContextElements.has(name) ||
	            htmlIntegrationElements.has(name)) {
	            this.foreignContext.pop();
	        }
	        if (this.stack.length &&
	            (this.options.xmlMode || !voidElements.has(name))) {
	            var pos = this.stack.lastIndexOf(name);
	            if (pos !== -1) {
	                if (this.cbs.onclosetag) {
	                    pos = this.stack.length - pos;
	                    while (pos--) {
	                        // We know the stack has sufficient elements.
	                        this.cbs.onclosetag(this.stack.pop());
	                    }
	                }
	                else
	                    this.stack.length = pos;
	            }
	            else if (name === "p" && !this.options.xmlMode) {
	                this.onopentagname(name);
	                this.closeCurrentTag();
	            }
	        }
	        else if (!this.options.xmlMode && (name === "br" || name === "p")) {
	            this.onopentagname(name);
	            this.closeCurrentTag();
	        }
	    };
	    Parser.prototype.onselfclosingtag = function () {
	        if (this.options.xmlMode ||
	            this.options.recognizeSelfClosing ||
	            this.foreignContext[this.foreignContext.length - 1]) {
	            this.closeCurrentTag();
	        }
	        else {
	            this.onopentagend();
	        }
	    };
	    Parser.prototype.closeCurrentTag = function () {
	        var _a, _b;
	        var name = this.tagname;
	        this.onopentagend();
	        /*
	         * Self-closing tags will be on the top of the stack
	         * (cheaper check than in onclosetag)
	         */
	        if (this.stack[this.stack.length - 1] === name) {
	            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
	            this.stack.pop();
	        }
	    };
	    Parser.prototype.onattribname = function (name) {
	        if (this.lowerCaseAttributeNames) {
	            name = name.toLowerCase();
	        }
	        this.attribname = name;
	    };
	    Parser.prototype.onattribdata = function (value) {
	        this.attribvalue += value;
	    };
	    Parser.prototype.onattribend = function (quote) {
	        var _a, _b;
	        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
	        if (this.attribs &&
	            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
	            this.attribs[this.attribname] = this.attribvalue;
	        }
	        this.attribname = "";
	        this.attribvalue = "";
	    };
	    Parser.prototype.getInstructionName = function (value) {
	        var idx = value.search(reNameEnd);
	        var name = idx < 0 ? value : value.substr(0, idx);
	        if (this.lowerCaseTagNames) {
	            name = name.toLowerCase();
	        }
	        return name;
	    };
	    Parser.prototype.ondeclaration = function (value) {
	        if (this.cbs.onprocessinginstruction) {
	            var name_1 = this.getInstructionName(value);
	            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
	        }
	    };
	    Parser.prototype.onprocessinginstruction = function (value) {
	        if (this.cbs.onprocessinginstruction) {
	            var name_2 = this.getInstructionName(value);
	            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
	        }
	    };
	    Parser.prototype.oncomment = function (value) {
	        var _a, _b, _c, _d;
	        this.updatePosition(4);
	        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
	    };
	    Parser.prototype.oncdata = function (value) {
	        var _a, _b, _c, _d, _e, _f;
	        this.updatePosition(1);
	        if (this.options.xmlMode || this.options.recognizeCDATA) {
	            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
	            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
	            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
	        }
	        else {
	            this.oncomment("[CDATA[" + value + "]]");
	        }
	    };
	    Parser.prototype.onerror = function (err) {
	        var _a, _b;
	        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	    };
	    Parser.prototype.onend = function () {
	        var _a, _b;
	        if (this.cbs.onclosetag) {
	            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
	                ;
	        }
	        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
	    };
	    /**
	     * Resets the parser to a blank state, ready to parse a new HTML document
	     */
	    Parser.prototype.reset = function () {
	        var _a, _b, _c, _d;
	        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
	        this.tokenizer.reset();
	        this.tagname = "";
	        this.attribname = "";
	        this.attribs = null;
	        this.stack = [];
	        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
	    };
	    /**
	     * Resets the parser, then parses a complete document and
	     * pushes it to the handler.
	     *
	     * @param data Document to parse.
	     */
	    Parser.prototype.parseComplete = function (data) {
	        this.reset();
	        this.end(data);
	    };
	    /**
	     * Parses a chunk of data and calls the corresponding callbacks.
	     *
	     * @param chunk Chunk to parse.
	     */
	    Parser.prototype.write = function (chunk) {
	        this.tokenizer.write(chunk);
	    };
	    /**
	     * Parses the end of the buffer and clears the stack, calls onend.
	     *
	     * @param chunk Optional final chunk to parse.
	     */
	    Parser.prototype.end = function (chunk) {
	        this.tokenizer.end(chunk);
	    };
	    /**
	     * Pauses parsing. The parser won't emit events until `resume` is called.
	     */
	    Parser.prototype.pause = function () {
	        this.tokenizer.pause();
	    };
	    /**
	     * Resumes parsing after `pause` was called.
	     */
	    Parser.prototype.resume = function () {
	        this.tokenizer.resume();
	    };
	    /**
	     * Alias of `write`, for backwards compatibility.
	     *
	     * @param chunk Chunk to parse.
	     * @deprecated
	     */
	    Parser.prototype.parseChunk = function (chunk) {
	        this.write(chunk);
	    };
	    /**
	     * Alias of `end`, for backwards compatibility.
	     *
	     * @param chunk Optional final chunk to parse.
	     * @deprecated
	     */
	    Parser.prototype.done = function (chunk) {
	        this.end(chunk);
	    };
	    return Parser;
	}());
	Parser.Parser = Parser$1;
	return Parser;
}

var lib$8 = {};

var lib$7 = {};

var hasRequiredLib$8;

function requireLib$8 () {
	if (hasRequiredLib$8) return lib$7;
	hasRequiredLib$8 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
		/** Types of elements found in htmlparser2's DOM */
		var ElementType;
		(function (ElementType) {
		    /** Type for the root element of a document */
		    ElementType["Root"] = "root";
		    /** Type for Text */
		    ElementType["Text"] = "text";
		    /** Type for <? ... ?> */
		    ElementType["Directive"] = "directive";
		    /** Type for <!-- ... --> */
		    ElementType["Comment"] = "comment";
		    /** Type for <script> tags */
		    ElementType["Script"] = "script";
		    /** Type for <style> tags */
		    ElementType["Style"] = "style";
		    /** Type for Any tag */
		    ElementType["Tag"] = "tag";
		    /** Type for <![CDATA[ ... ]]> */
		    ElementType["CDATA"] = "cdata";
		    /** Type for <!doctype ...> */
		    ElementType["Doctype"] = "doctype";
		})(ElementType = exports.ElementType || (exports.ElementType = {}));
		/**
		 * Tests whether an element is a tag or not.
		 *
		 * @param elem Element to test
		 */
		function isTag(elem) {
		    return (elem.type === ElementType.Tag ||
		        elem.type === ElementType.Script ||
		        elem.type === ElementType.Style);
		}
		exports.isTag = isTag;
		// Exports for backwards compatibility
		/** Type for the root element of a document */
		exports.Root = ElementType.Root;
		/** Type for Text */
		exports.Text = ElementType.Text;
		/** Type for <? ... ?> */
		exports.Directive = ElementType.Directive;
		/** Type for <!-- ... --> */
		exports.Comment = ElementType.Comment;
		/** Type for <script> tags */
		exports.Script = ElementType.Script;
		/** Type for <style> tags */
		exports.Style = ElementType.Style;
		/** Type for Any tag */
		exports.Tag = ElementType.Tag;
		/** Type for <![CDATA[ ... ]]> */
		exports.CDATA = ElementType.CDATA;
		/** Type for <!doctype ...> */
		exports.Doctype = ElementType.Doctype; 
	} (lib$7));
	return lib$7;
}

var node = {};

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(node, "__esModule", { value: true });
	node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
	var domelementtype_1 = requireLib$8();
	var nodeTypes = new Map([
	    [domelementtype_1.ElementType.Tag, 1],
	    [domelementtype_1.ElementType.Script, 1],
	    [domelementtype_1.ElementType.Style, 1],
	    [domelementtype_1.ElementType.Directive, 1],
	    [domelementtype_1.ElementType.Text, 3],
	    [domelementtype_1.ElementType.CDATA, 4],
	    [domelementtype_1.ElementType.Comment, 8],
	    [domelementtype_1.ElementType.Root, 9],
	]);
	/**
	 * This object will be used as the prototype for Nodes when creating a
	 * DOM-Level-1-compliant structure.
	 */
	var Node = /** @class */ (function () {
	    /**
	     *
	     * @param type The type of the node.
	     */
	    function Node(type) {
	        this.type = type;
	        /** Parent of the node */
	        this.parent = null;
	        /** Previous sibling */
	        this.prev = null;
	        /** Next sibling */
	        this.next = null;
	        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
	        this.startIndex = null;
	        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
	        this.endIndex = null;
	    }
	    Object.defineProperty(Node.prototype, "nodeType", {
	        // Read-only aliases
	        /**
	         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
	         * node {@link type}.
	         */
	        get: function () {
	            var _a;
	            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "parentNode", {
	        // Read-write aliases for properties
	        /**
	         * Same as {@link parent}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.parent;
	        },
	        set: function (parent) {
	            this.parent = parent;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "previousSibling", {
	        /**
	         * Same as {@link prev}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.prev;
	        },
	        set: function (prev) {
	            this.prev = prev;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "nextSibling", {
	        /**
	         * Same as {@link next}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.next;
	        },
	        set: function (next) {
	            this.next = next;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Clone this node, and optionally its children.
	     *
	     * @param recursive Clone child nodes as well.
	     * @returns A clone of the node.
	     */
	    Node.prototype.cloneNode = function (recursive) {
	        if (recursive === void 0) { recursive = false; }
	        return cloneNode(this, recursive);
	    };
	    return Node;
	}());
	node.Node = Node;
	/**
	 * A node that contains some data.
	 */
	var DataNode = /** @class */ (function (_super) {
	    __extends(DataNode, _super);
	    /**
	     * @param type The type of the node
	     * @param data The content of the data node
	     */
	    function DataNode(type, data) {
	        var _this = _super.call(this, type) || this;
	        _this.data = data;
	        return _this;
	    }
	    Object.defineProperty(DataNode.prototype, "nodeValue", {
	        /**
	         * Same as {@link data}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.data;
	        },
	        set: function (data) {
	            this.data = data;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return DataNode;
	}(Node));
	node.DataNode = DataNode;
	/**
	 * Text within the document.
	 */
	var Text = /** @class */ (function (_super) {
	    __extends(Text, _super);
	    function Text(data) {
	        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
	    }
	    return Text;
	}(DataNode));
	node.Text = Text;
	/**
	 * Comments within the document.
	 */
	var Comment = /** @class */ (function (_super) {
	    __extends(Comment, _super);
	    function Comment(data) {
	        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
	    }
	    return Comment;
	}(DataNode));
	node.Comment = Comment;
	/**
	 * Processing instructions, including doc types.
	 */
	var ProcessingInstruction = /** @class */ (function (_super) {
	    __extends(ProcessingInstruction, _super);
	    function ProcessingInstruction(name, data) {
	        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
	        _this.name = name;
	        return _this;
	    }
	    return ProcessingInstruction;
	}(DataNode));
	node.ProcessingInstruction = ProcessingInstruction;
	/**
	 * A `Node` that can have children.
	 */
	var NodeWithChildren = /** @class */ (function (_super) {
	    __extends(NodeWithChildren, _super);
	    /**
	     * @param type Type of the node.
	     * @param children Children of the node. Only certain node types can have children.
	     */
	    function NodeWithChildren(type, children) {
	        var _this = _super.call(this, type) || this;
	        _this.children = children;
	        return _this;
	    }
	    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
	        // Aliases
	        /** First child of the node. */
	        get: function () {
	            var _a;
	            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
	        /** Last child of the node. */
	        get: function () {
	            return this.children.length > 0
	                ? this.children[this.children.length - 1]
	                : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
	        /**
	         * Same as {@link children}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.children;
	        },
	        set: function (children) {
	            this.children = children;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return NodeWithChildren;
	}(Node));
	node.NodeWithChildren = NodeWithChildren;
	/**
	 * The root node of the document.
	 */
	var Document = /** @class */ (function (_super) {
	    __extends(Document, _super);
	    function Document(children) {
	        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
	    }
	    return Document;
	}(NodeWithChildren));
	node.Document = Document;
	/**
	 * An element within the DOM.
	 */
	var Element = /** @class */ (function (_super) {
	    __extends(Element, _super);
	    /**
	     * @param name Name of the tag, eg. `div`, `span`.
	     * @param attribs Object mapping attribute names to attribute values.
	     * @param children Children of the node.
	     */
	    function Element(name, attribs, children, type) {
	        if (children === void 0) { children = []; }
	        if (type === void 0) { type = name === "script"
	            ? domelementtype_1.ElementType.Script
	            : name === "style"
	                ? domelementtype_1.ElementType.Style
	                : domelementtype_1.ElementType.Tag; }
	        var _this = _super.call(this, type, children) || this;
	        _this.name = name;
	        _this.attribs = attribs;
	        return _this;
	    }
	    Object.defineProperty(Element.prototype, "tagName", {
	        // DOM Level 1 aliases
	        /**
	         * Same as {@link name}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.name;
	        },
	        set: function (name) {
	            this.name = name;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "attributes", {
	        get: function () {
	            var _this = this;
	            return Object.keys(this.attribs).map(function (name) {
	                var _a, _b;
	                return ({
	                    name: name,
	                    value: _this.attribs[name],
	                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
	                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
	                });
	            });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return Element;
	}(NodeWithChildren));
	node.Element = Element;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `Element`, `false` otherwise.
	 */
	function isTag(node) {
	    return (0, domelementtype_1.isTag)(node);
	}
	node.isTag = isTag;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
	 */
	function isCDATA(node) {
	    return node.type === domelementtype_1.ElementType.CDATA;
	}
	node.isCDATA = isCDATA;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Text`, `false` otherwise.
	 */
	function isText(node) {
	    return node.type === domelementtype_1.ElementType.Text;
	}
	node.isText = isText;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Comment`, `false` otherwise.
	 */
	function isComment(node) {
	    return node.type === domelementtype_1.ElementType.Comment;
	}
	node.isComment = isComment;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDirective(node) {
	    return node.type === domelementtype_1.ElementType.Directive;
	}
	node.isDirective = isDirective;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDocument(node) {
	    return node.type === domelementtype_1.ElementType.Root;
	}
	node.isDocument = isDocument;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
	 */
	function hasChildren(node) {
	    return Object.prototype.hasOwnProperty.call(node, "children");
	}
	node.hasChildren = hasChildren;
	/**
	 * Clone a node, and optionally its children.
	 *
	 * @param recursive Clone child nodes as well.
	 * @returns A clone of the node.
	 */
	function cloneNode(node, recursive) {
	    if (recursive === void 0) { recursive = false; }
	    var result;
	    if (isText(node)) {
	        result = new Text(node.data);
	    }
	    else if (isComment(node)) {
	        result = new Comment(node.data);
	    }
	    else if (isTag(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
	        children.forEach(function (child) { return (child.parent = clone_1); });
	        if (node.namespace != null) {
	            clone_1.namespace = node.namespace;
	        }
	        if (node["x-attribsNamespace"]) {
	            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
	        }
	        if (node["x-attribsPrefix"]) {
	            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
	        }
	        result = clone_1;
	    }
	    else if (isCDATA(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
	        children.forEach(function (child) { return (child.parent = clone_2); });
	        result = clone_2;
	    }
	    else if (isDocument(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_3 = new Document(children);
	        children.forEach(function (child) { return (child.parent = clone_3); });
	        if (node["x-mode"]) {
	            clone_3["x-mode"] = node["x-mode"];
	        }
	        result = clone_3;
	    }
	    else if (isDirective(node)) {
	        var instruction = new ProcessingInstruction(node.name, node.data);
	        if (node["x-name"] != null) {
	            instruction["x-name"] = node["x-name"];
	            instruction["x-publicId"] = node["x-publicId"];
	            instruction["x-systemId"] = node["x-systemId"];
	        }
	        result = instruction;
	    }
	    else {
	        throw new Error("Not implemented yet: ".concat(node.type));
	    }
	    result.startIndex = node.startIndex;
	    result.endIndex = node.endIndex;
	    if (node.sourceCodeLocation != null) {
	        result.sourceCodeLocation = node.sourceCodeLocation;
	    }
	    return result;
	}
	node.cloneNode = cloneNode;
	function cloneChildren(childs) {
	    var children = childs.map(function (child) { return cloneNode(child, true); });
	    for (var i = 1; i < children.length; i++) {
	        children[i].prev = children[i - 1];
	        children[i - 1].next = children[i];
	    }
	    return children;
	}
	return node;
}

var hasRequiredLib$7;

function requireLib$7 () {
	if (hasRequiredLib$7) return lib$8;
	hasRequiredLib$7 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DomHandler = void 0;
		var domelementtype_1 = requireLib$8();
		var node_1 = requireNode();
		__exportStar(requireNode(), exports);
		var reWhitespace = /\s+/g;
		// Default options
		var defaultOpts = {
		    normalizeWhitespace: false,
		    withStartIndices: false,
		    withEndIndices: false,
		    xmlMode: false,
		};
		var DomHandler = /** @class */ (function () {
		    /**
		     * @param callback Called once parsing has completed.
		     * @param options Settings for the handler.
		     * @param elementCB Callback whenever a tag is closed.
		     */
		    function DomHandler(callback, options, elementCB) {
		        /** The elements of the DOM */
		        this.dom = [];
		        /** The root element for the DOM */
		        this.root = new node_1.Document(this.dom);
		        /** Indicated whether parsing has been completed. */
		        this.done = false;
		        /** Stack of open tags. */
		        this.tagStack = [this.root];
		        /** A data node that is still being written to. */
		        this.lastNode = null;
		        /** Reference to the parser instance. Used for location information. */
		        this.parser = null;
		        // Make it possible to skip arguments, for backwards-compatibility
		        if (typeof options === "function") {
		            elementCB = options;
		            options = defaultOpts;
		        }
		        if (typeof callback === "object") {
		            options = callback;
		            callback = undefined;
		        }
		        this.callback = callback !== null && callback !== void 0 ? callback : null;
		        this.options = options !== null && options !== void 0 ? options : defaultOpts;
		        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
		    }
		    DomHandler.prototype.onparserinit = function (parser) {
		        this.parser = parser;
		    };
		    // Resets the handler back to starting state
		    DomHandler.prototype.onreset = function () {
		        this.dom = [];
		        this.root = new node_1.Document(this.dom);
		        this.done = false;
		        this.tagStack = [this.root];
		        this.lastNode = null;
		        this.parser = null;
		    };
		    // Signals the handler that parsing is done
		    DomHandler.prototype.onend = function () {
		        if (this.done)
		            return;
		        this.done = true;
		        this.parser = null;
		        this.handleCallback(null);
		    };
		    DomHandler.prototype.onerror = function (error) {
		        this.handleCallback(error);
		    };
		    DomHandler.prototype.onclosetag = function () {
		        this.lastNode = null;
		        var elem = this.tagStack.pop();
		        if (this.options.withEndIndices) {
		            elem.endIndex = this.parser.endIndex;
		        }
		        if (this.elementCB)
		            this.elementCB(elem);
		    };
		    DomHandler.prototype.onopentag = function (name, attribs) {
		        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
		        var element = new node_1.Element(name, attribs, undefined, type);
		        this.addNode(element);
		        this.tagStack.push(element);
		    };
		    DomHandler.prototype.ontext = function (data) {
		        var normalizeWhitespace = this.options.normalizeWhitespace;
		        var lastNode = this.lastNode;
		        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
		            if (normalizeWhitespace) {
		                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
		            }
		            else {
		                lastNode.data += data;
		            }
		            if (this.options.withEndIndices) {
		                lastNode.endIndex = this.parser.endIndex;
		            }
		        }
		        else {
		            if (normalizeWhitespace) {
		                data = data.replace(reWhitespace, " ");
		            }
		            var node = new node_1.Text(data);
		            this.addNode(node);
		            this.lastNode = node;
		        }
		    };
		    DomHandler.prototype.oncomment = function (data) {
		        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
		            this.lastNode.data += data;
		            return;
		        }
		        var node = new node_1.Comment(data);
		        this.addNode(node);
		        this.lastNode = node;
		    };
		    DomHandler.prototype.oncommentend = function () {
		        this.lastNode = null;
		    };
		    DomHandler.prototype.oncdatastart = function () {
		        var text = new node_1.Text("");
		        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
		        this.addNode(node);
		        text.parent = node;
		        this.lastNode = text;
		    };
		    DomHandler.prototype.oncdataend = function () {
		        this.lastNode = null;
		    };
		    DomHandler.prototype.onprocessinginstruction = function (name, data) {
		        var node = new node_1.ProcessingInstruction(name, data);
		        this.addNode(node);
		    };
		    DomHandler.prototype.handleCallback = function (error) {
		        if (typeof this.callback === "function") {
		            this.callback(error, this.dom);
		        }
		        else if (error) {
		            throw error;
		        }
		    };
		    DomHandler.prototype.addNode = function (node) {
		        var parent = this.tagStack[this.tagStack.length - 1];
		        var previousSibling = parent.children[parent.children.length - 1];
		        if (this.options.withStartIndices) {
		            node.startIndex = this.parser.startIndex;
		        }
		        if (this.options.withEndIndices) {
		            node.endIndex = this.parser.endIndex;
		        }
		        parent.children.push(node);
		        if (previousSibling) {
		            node.prev = previousSibling;
		            previousSibling.next = node;
		        }
		        node.parent = parent;
		        this.lastNode = null;
		    };
		    return DomHandler;
		}());
		exports.DomHandler = DomHandler;
		exports.default = DomHandler; 
	} (lib$8));
	return lib$8;
}

var FeedHandler = {};

var lib$6 = {};

var stringify$1 = {};

var lib$5 = {};

var lib$4 = {};

var decode = {};

var hasRequiredDecode;

function requireDecode () {
	if (hasRequiredDecode) return decode;
	hasRequiredDecode = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(decode, "__esModule", { value: true });
	decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
	var entities_json_1 = __importDefault(require$$1$1);
	var legacy_json_1 = __importDefault(require$$1);
	var xml_json_1 = __importDefault(require$$0$1);
	var decode_codepoint_1 = __importDefault(requireDecode_codepoint());
	var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
	decode.decodeXML = getStrictDecoder(xml_json_1.default);
	decode.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
	function getStrictDecoder(map) {
	    var replace = getReplacer(map);
	    return function (str) { return String(str).replace(strictEntityRe, replace); };
	}
	var sorter = function (a, b) { return (a < b ? 1 : -1); };
	decode.decodeHTML = (function () {
	    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
	    var keys = Object.keys(entities_json_1.default).sort(sorter);
	    for (var i = 0, j = 0; i < keys.length; i++) {
	        if (legacy[j] === keys[i]) {
	            keys[i] += ";?";
	            j++;
	        }
	        else {
	            keys[i] += ";";
	        }
	    }
	    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
	    var replace = getReplacer(entities_json_1.default);
	    function replacer(str) {
	        if (str.substr(-1) !== ";")
	            str += ";";
	        return replace(str);
	    }
	    // TODO consider creating a merged map
	    return function (str) { return String(str).replace(re, replacer); };
	})();
	function getReplacer(map) {
	    return function replace(str) {
	        if (str.charAt(1) === "#") {
	            var secondChar = str.charAt(2);
	            if (secondChar === "X" || secondChar === "x") {
	                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
	            }
	            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
	        }
	        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	        return map[str.slice(1, -1)] || str;
	    };
	}
	return decode;
}

var encode = {};

var hasRequiredEncode;

function requireEncode () {
	if (hasRequiredEncode) return encode;
	hasRequiredEncode = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(encode, "__esModule", { value: true });
	encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
	var xml_json_1 = __importDefault(require$$0$1);
	var inverseXML = getInverseObj(xml_json_1.default);
	var xmlReplacer = getInverseReplacer(inverseXML);
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in XML
	 * documents using XML entities.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeXML = getASCIIEncoder(inverseXML);
	var entities_json_1 = __importDefault(require$$1$1);
	var inverseHTML = getInverseObj(entities_json_1.default);
	var htmlReplacer = getInverseReplacer(inverseHTML);
	/**
	 * Encodes all entities and non-ASCII characters in the input.
	 *
	 * This includes characters that are valid ASCII characters in HTML documents.
	 * For example `#` will be encoded as `&num;`. To get a more compact output,
	 * consider using the `encodeNonAsciiHTML` function.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in HTML
	 * documents using HTML entities.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
	function getInverseObj(obj) {
	    return Object.keys(obj)
	        .sort()
	        .reduce(function (inverse, name) {
	        inverse[obj[name]] = "&" + name + ";";
	        return inverse;
	    }, {});
	}
	function getInverseReplacer(inverse) {
	    var single = [];
	    var multiple = [];
	    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
	        var k = _a[_i];
	        if (k.length === 1) {
	            // Add value to single array
	            single.push("\\" + k);
	        }
	        else {
	            // Add value to multiple array
	            multiple.push(k);
	        }
	    }
	    // Add ranges to single characters.
	    single.sort();
	    for (var start = 0; start < single.length - 1; start++) {
	        // Find the end of a run of characters
	        var end = start;
	        while (end < single.length - 1 &&
	            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
	            end += 1;
	        }
	        var count = 1 + end - start;
	        // We want to replace at least three characters
	        if (count < 3)
	            continue;
	        single.splice(start, count, single[start] + "-" + single[end]);
	    }
	    multiple.unshift("[" + single.join("") + "]");
	    return new RegExp(multiple.join("|"), "g");
	}
	// /[^\0-\x7F]/gu
	var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
	var getCodePoint = 
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	String.prototype.codePointAt != null
	    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        function (str) { return str.codePointAt(0); }
	    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	        function (c) {
	            return (c.charCodeAt(0) - 0xd800) * 0x400 +
	                c.charCodeAt(1) -
	                0xdc00 +
	                0x10000;
	        };
	function singleCharReplacer(c) {
	    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
	        .toString(16)
	        .toUpperCase() + ";";
	}
	function getInverse(inverse, re) {
	    return function (data) {
	        return data
	            .replace(re, function (name) { return inverse[name]; })
	            .replace(reNonASCII, singleCharReplacer);
	    };
	}
	var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in XML
	 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
	 *
	 * Have a look at `escapeUTF8` if you want a more concise output at the expense
	 * of reduced transportability.
	 *
	 * @param data String to escape.
	 */
	function escape(data) {
	    return data.replace(reEscapeChars, singleCharReplacer);
	}
	encode.escape = escape;
	/**
	 * Encodes all characters not valid in XML documents using numeric hexadecimal
	 * reference (eg. `&#xfc;`).
	 *
	 * Note that the output will be character-set dependent.
	 *
	 * @param data String to escape.
	 */
	function escapeUTF8(data) {
	    return data.replace(xmlReplacer, singleCharReplacer);
	}
	encode.escapeUTF8 = escapeUTF8;
	function getASCIIEncoder(obj) {
	    return function (data) {
	        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
	    };
	}
	return encode;
}

var hasRequiredLib$6;

function requireLib$6 () {
	if (hasRequiredLib$6) return lib$4;
	hasRequiredLib$6 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
		var decode_1 = requireDecode();
		var encode_1 = requireEncode();
		/**
		 * Decodes a string with entities.
		 *
		 * @param data String to decode.
		 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `decodeXML` or `decodeHTML` directly.
		 */
		function decode(data, level) {
		    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
		}
		exports.decode = decode;
		/**
		 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
		 *
		 * @param data String to decode.
		 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
		 */
		function decodeStrict(data, level) {
		    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
		}
		exports.decodeStrict = decodeStrict;
		/**
		 * Encodes a string with entities.
		 *
		 * @param data String to encode.
		 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
		 */
		function encode(data, level) {
		    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
		}
		exports.encode = encode;
		var encode_2 = requireEncode();
		Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
		Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
		Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
		// Legacy aliases (deprecated)
		Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		var decode_2 = requireDecode();
		Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
		Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		// Legacy aliases (deprecated)
		Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } }); 
	} (lib$4));
	return lib$4;
}

var foreignNames = {};

var hasRequiredForeignNames;

function requireForeignNames () {
	if (hasRequiredForeignNames) return foreignNames;
	hasRequiredForeignNames = 1;
	Object.defineProperty(foreignNames, "__esModule", { value: true });
	foreignNames.attributeNames = foreignNames.elementNames = void 0;
	foreignNames.elementNames = new Map([
	    ["altglyph", "altGlyph"],
	    ["altglyphdef", "altGlyphDef"],
	    ["altglyphitem", "altGlyphItem"],
	    ["animatecolor", "animateColor"],
	    ["animatemotion", "animateMotion"],
	    ["animatetransform", "animateTransform"],
	    ["clippath", "clipPath"],
	    ["feblend", "feBlend"],
	    ["fecolormatrix", "feColorMatrix"],
	    ["fecomponenttransfer", "feComponentTransfer"],
	    ["fecomposite", "feComposite"],
	    ["feconvolvematrix", "feConvolveMatrix"],
	    ["fediffuselighting", "feDiffuseLighting"],
	    ["fedisplacementmap", "feDisplacementMap"],
	    ["fedistantlight", "feDistantLight"],
	    ["fedropshadow", "feDropShadow"],
	    ["feflood", "feFlood"],
	    ["fefunca", "feFuncA"],
	    ["fefuncb", "feFuncB"],
	    ["fefuncg", "feFuncG"],
	    ["fefuncr", "feFuncR"],
	    ["fegaussianblur", "feGaussianBlur"],
	    ["feimage", "feImage"],
	    ["femerge", "feMerge"],
	    ["femergenode", "feMergeNode"],
	    ["femorphology", "feMorphology"],
	    ["feoffset", "feOffset"],
	    ["fepointlight", "fePointLight"],
	    ["fespecularlighting", "feSpecularLighting"],
	    ["fespotlight", "feSpotLight"],
	    ["fetile", "feTile"],
	    ["feturbulence", "feTurbulence"],
	    ["foreignobject", "foreignObject"],
	    ["glyphref", "glyphRef"],
	    ["lineargradient", "linearGradient"],
	    ["radialgradient", "radialGradient"],
	    ["textpath", "textPath"],
	]);
	foreignNames.attributeNames = new Map([
	    ["definitionurl", "definitionURL"],
	    ["attributename", "attributeName"],
	    ["attributetype", "attributeType"],
	    ["basefrequency", "baseFrequency"],
	    ["baseprofile", "baseProfile"],
	    ["calcmode", "calcMode"],
	    ["clippathunits", "clipPathUnits"],
	    ["diffuseconstant", "diffuseConstant"],
	    ["edgemode", "edgeMode"],
	    ["filterunits", "filterUnits"],
	    ["glyphref", "glyphRef"],
	    ["gradienttransform", "gradientTransform"],
	    ["gradientunits", "gradientUnits"],
	    ["kernelmatrix", "kernelMatrix"],
	    ["kernelunitlength", "kernelUnitLength"],
	    ["keypoints", "keyPoints"],
	    ["keysplines", "keySplines"],
	    ["keytimes", "keyTimes"],
	    ["lengthadjust", "lengthAdjust"],
	    ["limitingconeangle", "limitingConeAngle"],
	    ["markerheight", "markerHeight"],
	    ["markerunits", "markerUnits"],
	    ["markerwidth", "markerWidth"],
	    ["maskcontentunits", "maskContentUnits"],
	    ["maskunits", "maskUnits"],
	    ["numoctaves", "numOctaves"],
	    ["pathlength", "pathLength"],
	    ["patterncontentunits", "patternContentUnits"],
	    ["patterntransform", "patternTransform"],
	    ["patternunits", "patternUnits"],
	    ["pointsatx", "pointsAtX"],
	    ["pointsaty", "pointsAtY"],
	    ["pointsatz", "pointsAtZ"],
	    ["preservealpha", "preserveAlpha"],
	    ["preserveaspectratio", "preserveAspectRatio"],
	    ["primitiveunits", "primitiveUnits"],
	    ["refx", "refX"],
	    ["refy", "refY"],
	    ["repeatcount", "repeatCount"],
	    ["repeatdur", "repeatDur"],
	    ["requiredextensions", "requiredExtensions"],
	    ["requiredfeatures", "requiredFeatures"],
	    ["specularconstant", "specularConstant"],
	    ["specularexponent", "specularExponent"],
	    ["spreadmethod", "spreadMethod"],
	    ["startoffset", "startOffset"],
	    ["stddeviation", "stdDeviation"],
	    ["stitchtiles", "stitchTiles"],
	    ["surfacescale", "surfaceScale"],
	    ["systemlanguage", "systemLanguage"],
	    ["tablevalues", "tableValues"],
	    ["targetx", "targetX"],
	    ["targety", "targetY"],
	    ["textlength", "textLength"],
	    ["viewbox", "viewBox"],
	    ["viewtarget", "viewTarget"],
	    ["xchannelselector", "xChannelSelector"],
	    ["ychannelselector", "yChannelSelector"],
	    ["zoomandpan", "zoomAndPan"],
	]);
	return foreignNames;
}

var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$5;
	hasRequiredLib$5 = 1;
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(lib$5, "__esModule", { value: true });
	/*
	 * Module dependencies
	 */
	var ElementType = __importStar(requireLib$8());
	var entities_1 = requireLib$6();
	/**
	 * Mixed-case SVG and MathML tags & attributes
	 * recognized by the HTML parser.
	 *
	 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
	 */
	var foreignNames_1 = requireForeignNames();
	var unencodedElements = new Set([
	    "style",
	    "script",
	    "xmp",
	    "iframe",
	    "noembed",
	    "noframes",
	    "plaintext",
	    "noscript",
	]);
	/**
	 * Format attributes
	 */
	function formatAttributes(attributes, opts) {
	    if (!attributes)
	        return;
	    return Object.keys(attributes)
	        .map(function (key) {
	        var _a, _b;
	        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
	        if (opts.xmlMode === "foreign") {
	            /* Fix up mixed-case attribute names */
	            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
	        }
	        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
	            return key;
	        }
	        return key + "=\"" + (opts.decodeEntities !== false
	            ? entities_1.encodeXML(value)
	            : value.replace(/"/g, "&quot;")) + "\"";
	    })
	        .join(" ");
	}
	/**
	 * Self-enclosing tags
	 */
	var singleTag = new Set([
	    "area",
	    "base",
	    "basefont",
	    "br",
	    "col",
	    "command",
	    "embed",
	    "frame",
	    "hr",
	    "img",
	    "input",
	    "isindex",
	    "keygen",
	    "link",
	    "meta",
	    "param",
	    "source",
	    "track",
	    "wbr",
	]);
	/**
	 * Renders a DOM node or an array of DOM nodes to a string.
	 *
	 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
	 *
	 * @param node Node to be rendered.
	 * @param options Changes serialization behavior
	 */
	function render(node, options) {
	    if (options === void 0) { options = {}; }
	    var nodes = "length" in node ? node : [node];
	    var output = "";
	    for (var i = 0; i < nodes.length; i++) {
	        output += renderNode(nodes[i], options);
	    }
	    return output;
	}
	lib$5.default = render;
	function renderNode(node, options) {
	    switch (node.type) {
	        case ElementType.Root:
	            return render(node.children, options);
	        case ElementType.Directive:
	        case ElementType.Doctype:
	            return renderDirective(node);
	        case ElementType.Comment:
	            return renderComment(node);
	        case ElementType.CDATA:
	            return renderCdata(node);
	        case ElementType.Script:
	        case ElementType.Style:
	        case ElementType.Tag:
	            return renderTag(node, options);
	        case ElementType.Text:
	            return renderText(node, options);
	    }
	}
	var foreignModeIntegrationPoints = new Set([
	    "mi",
	    "mo",
	    "mn",
	    "ms",
	    "mtext",
	    "annotation-xml",
	    "foreignObject",
	    "desc",
	    "title",
	]);
	var foreignElements = new Set(["svg", "math"]);
	function renderTag(elem, opts) {
	    var _a;
	    // Handle SVG / MathML in HTML
	    if (opts.xmlMode === "foreign") {
	        /* Fix up mixed-case element names */
	        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
	        /* Exit foreign mode at integration points */
	        if (elem.parent &&
	            foreignModeIntegrationPoints.has(elem.parent.name)) {
	            opts = __assign(__assign({}, opts), { xmlMode: false });
	        }
	    }
	    if (!opts.xmlMode && foreignElements.has(elem.name)) {
	        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
	    }
	    var tag = "<" + elem.name;
	    var attribs = formatAttributes(elem.attribs, opts);
	    if (attribs) {
	        tag += " " + attribs;
	    }
	    if (elem.children.length === 0 &&
	        (opts.xmlMode
	            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
	                opts.selfClosingTags !== false
	            : // User explicitly asked for self-closing tags, even in HTML mode
	                opts.selfClosingTags && singleTag.has(elem.name))) {
	        if (!opts.xmlMode)
	            tag += " ";
	        tag += "/>";
	    }
	    else {
	        tag += ">";
	        if (elem.children.length > 0) {
	            tag += render(elem.children, opts);
	        }
	        if (opts.xmlMode || !singleTag.has(elem.name)) {
	            tag += "</" + elem.name + ">";
	        }
	    }
	    return tag;
	}
	function renderDirective(elem) {
	    return "<" + elem.data + ">";
	}
	function renderText(elem, opts) {
	    var data = elem.data || "";
	    // If entities weren't decoded, no need to encode them back
	    if (opts.decodeEntities !== false &&
	        !(!opts.xmlMode &&
	            elem.parent &&
	            unencodedElements.has(elem.parent.name))) {
	        data = entities_1.encodeXML(data);
	    }
	    return data;
	}
	function renderCdata(elem) {
	    return "<![CDATA[" + elem.children[0].data + "]]>";
	}
	function renderComment(elem) {
	    return "<!--" + elem.data + "-->";
	}
	return lib$5;
}

var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify$1;
	hasRequiredStringify = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(stringify$1, "__esModule", { value: true });
	stringify$1.innerText = stringify$1.textContent = stringify$1.getText = stringify$1.getInnerHTML = stringify$1.getOuterHTML = void 0;
	var domhandler_1 = requireLib$7();
	var dom_serializer_1 = __importDefault(requireLib$5());
	var domelementtype_1 = requireLib$8();
	/**
	 * @param node Node to get the outer HTML of.
	 * @param options Options for serialization.
	 * @deprecated Use the `dom-serializer` module directly.
	 * @returns `node`'s outer HTML.
	 */
	function getOuterHTML(node, options) {
	    return (0, dom_serializer_1.default)(node, options);
	}
	stringify$1.getOuterHTML = getOuterHTML;
	/**
	 * @param node Node to get the inner HTML of.
	 * @param options Options for serialization.
	 * @deprecated Use the `dom-serializer` module directly.
	 * @returns `node`'s inner HTML.
	 */
	function getInnerHTML(node, options) {
	    return (0, domhandler_1.hasChildren)(node)
	        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
	        : "";
	}
	stringify$1.getInnerHTML = getInnerHTML;
	/**
	 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
	 *
	 * @deprecated Use `textContent` instead.
	 * @param node Node to get the inner text of.
	 * @returns `node`'s inner text.
	 */
	function getText(node) {
	    if (Array.isArray(node))
	        return node.map(getText).join("");
	    if ((0, domhandler_1.isTag)(node))
	        return node.name === "br" ? "\n" : getText(node.children);
	    if ((0, domhandler_1.isCDATA)(node))
	        return getText(node.children);
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.getText = getText;
	/**
	 * Get a node's text content.
	 *
	 * @param node Node to get the text content of.
	 * @returns `node`'s text content.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
	 */
	function textContent(node) {
	    if (Array.isArray(node))
	        return node.map(textContent).join("");
	    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
	        return textContent(node.children);
	    }
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.textContent = textContent;
	/**
	 * Get a node's inner text.
	 *
	 * @param node Node to get the inner text of.
	 * @returns `node`'s inner text.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
	 */
	function innerText(node) {
	    if (Array.isArray(node))
	        return node.map(innerText).join("");
	    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
	        return innerText(node.children);
	    }
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.innerText = innerText;
	return stringify$1;
}

var traversal = {};

var hasRequiredTraversal;

function requireTraversal () {
	if (hasRequiredTraversal) return traversal;
	hasRequiredTraversal = 1;
	Object.defineProperty(traversal, "__esModule", { value: true });
	traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
	var domhandler_1 = requireLib$7();
	var emptyArray = [];
	/**
	 * Get a node's children.
	 *
	 * @param elem Node to get the children of.
	 * @returns `elem`'s children, or an empty array.
	 */
	function getChildren(elem) {
	    var _a;
	    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
	}
	traversal.getChildren = getChildren;
	/**
	 * Get a node's parent.
	 *
	 * @param elem Node to get the parent of.
	 * @returns `elem`'s parent node.
	 */
	function getParent(elem) {
	    return elem.parent || null;
	}
	traversal.getParent = getParent;
	/**
	 * Gets an elements siblings, including the element itself.
	 *
	 * Attempts to get the children through the element's parent first.
	 * If we don't have a parent (the element is a root node),
	 * we walk the element's `prev` & `next` to get all remaining nodes.
	 *
	 * @param elem Element to get the siblings of.
	 * @returns `elem`'s siblings.
	 */
	function getSiblings(elem) {
	    var _a, _b;
	    var parent = getParent(elem);
	    if (parent != null)
	        return getChildren(parent);
	    var siblings = [elem];
	    var prev = elem.prev, next = elem.next;
	    while (prev != null) {
	        siblings.unshift(prev);
	        (_a = prev, prev = _a.prev);
	    }
	    while (next != null) {
	        siblings.push(next);
	        (_b = next, next = _b.next);
	    }
	    return siblings;
	}
	traversal.getSiblings = getSiblings;
	/**
	 * Gets an attribute from an element.
	 *
	 * @param elem Element to check.
	 * @param name Attribute name to retrieve.
	 * @returns The element's attribute value, or `undefined`.
	 */
	function getAttributeValue(elem, name) {
	    var _a;
	    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
	}
	traversal.getAttributeValue = getAttributeValue;
	/**
	 * Checks whether an element has an attribute.
	 *
	 * @param elem Element to check.
	 * @param name Attribute name to look for.
	 * @returns Returns whether `elem` has the attribute `name`.
	 */
	function hasAttrib(elem, name) {
	    return (elem.attribs != null &&
	        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
	        elem.attribs[name] != null);
	}
	traversal.hasAttrib = hasAttrib;
	/**
	 * Get the tag name of an element.
	 *
	 * @param elem The element to get the name for.
	 * @returns The tag name of `elem`.
	 */
	function getName(elem) {
	    return elem.name;
	}
	traversal.getName = getName;
	/**
	 * Returns the next element sibling of a node.
	 *
	 * @param elem The element to get the next sibling of.
	 * @returns `elem`'s next sibling that is a tag.
	 */
	function nextElementSibling(elem) {
	    var _a;
	    var next = elem.next;
	    while (next !== null && !(0, domhandler_1.isTag)(next))
	        (_a = next, next = _a.next);
	    return next;
	}
	traversal.nextElementSibling = nextElementSibling;
	/**
	 * Returns the previous element sibling of a node.
	 *
	 * @param elem The element to get the previous sibling of.
	 * @returns `elem`'s previous sibling that is a tag.
	 */
	function prevElementSibling(elem) {
	    var _a;
	    var prev = elem.prev;
	    while (prev !== null && !(0, domhandler_1.isTag)(prev))
	        (_a = prev, prev = _a.prev);
	    return prev;
	}
	traversal.prevElementSibling = prevElementSibling;
	return traversal;
}

var manipulation = {};

var hasRequiredManipulation;

function requireManipulation () {
	if (hasRequiredManipulation) return manipulation;
	hasRequiredManipulation = 1;
	Object.defineProperty(manipulation, "__esModule", { value: true });
	manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
	/**
	 * Remove an element from the dom
	 *
	 * @param elem The element to be removed
	 */
	function removeElement(elem) {
	    if (elem.prev)
	        elem.prev.next = elem.next;
	    if (elem.next)
	        elem.next.prev = elem.prev;
	    if (elem.parent) {
	        var childs = elem.parent.children;
	        childs.splice(childs.lastIndexOf(elem), 1);
	    }
	}
	manipulation.removeElement = removeElement;
	/**
	 * Replace an element in the dom
	 *
	 * @param elem The element to be replaced
	 * @param replacement The element to be added
	 */
	function replaceElement(elem, replacement) {
	    var prev = (replacement.prev = elem.prev);
	    if (prev) {
	        prev.next = replacement;
	    }
	    var next = (replacement.next = elem.next);
	    if (next) {
	        next.prev = replacement;
	    }
	    var parent = (replacement.parent = elem.parent);
	    if (parent) {
	        var childs = parent.children;
	        childs[childs.lastIndexOf(elem)] = replacement;
	    }
	}
	manipulation.replaceElement = replaceElement;
	/**
	 * Append a child to an element.
	 *
	 * @param elem The element to append to.
	 * @param child The element to be added as a child.
	 */
	function appendChild(elem, child) {
	    removeElement(child);
	    child.next = null;
	    child.parent = elem;
	    if (elem.children.push(child) > 1) {
	        var sibling = elem.children[elem.children.length - 2];
	        sibling.next = child;
	        child.prev = sibling;
	    }
	    else {
	        child.prev = null;
	    }
	}
	manipulation.appendChild = appendChild;
	/**
	 * Append an element after another.
	 *
	 * @param elem The element to append after.
	 * @param next The element be added.
	 */
	function append(elem, next) {
	    removeElement(next);
	    var parent = elem.parent;
	    var currNext = elem.next;
	    next.next = currNext;
	    next.prev = elem;
	    elem.next = next;
	    next.parent = parent;
	    if (currNext) {
	        currNext.prev = next;
	        if (parent) {
	            var childs = parent.children;
	            childs.splice(childs.lastIndexOf(currNext), 0, next);
	        }
	    }
	    else if (parent) {
	        parent.children.push(next);
	    }
	}
	manipulation.append = append;
	/**
	 * Prepend a child to an element.
	 *
	 * @param elem The element to prepend before.
	 * @param child The element to be added as a child.
	 */
	function prependChild(elem, child) {
	    removeElement(child);
	    child.parent = elem;
	    child.prev = null;
	    if (elem.children.unshift(child) !== 1) {
	        var sibling = elem.children[1];
	        sibling.prev = child;
	        child.next = sibling;
	    }
	    else {
	        child.next = null;
	    }
	}
	manipulation.prependChild = prependChild;
	/**
	 * Prepend an element before another.
	 *
	 * @param elem The element to prepend before.
	 * @param prev The element be added.
	 */
	function prepend(elem, prev) {
	    removeElement(prev);
	    var parent = elem.parent;
	    if (parent) {
	        var childs = parent.children;
	        childs.splice(childs.indexOf(elem), 0, prev);
	    }
	    if (elem.prev) {
	        elem.prev.next = prev;
	    }
	    prev.parent = parent;
	    prev.prev = elem.prev;
	    prev.next = elem;
	    elem.prev = prev;
	}
	manipulation.prepend = prepend;
	return manipulation;
}

var querying = {};

var hasRequiredQuerying;

function requireQuerying () {
	if (hasRequiredQuerying) return querying;
	hasRequiredQuerying = 1;
	Object.defineProperty(querying, "__esModule", { value: true });
	querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
	var domhandler_1 = requireLib$7();
	/**
	 * Search a node and its children for nodes passing a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param node Node to search. Will be included in the result set if it matches.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes passing `test`.
	 */
	function filter(test, node, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    if (!Array.isArray(node))
	        node = [node];
	    return find(test, node, recurse, limit);
	}
	querying.filter = filter;
	/**
	 * Search an array of node and its children for nodes passing a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes passing `test`.
	 */
	function find(test, nodes, recurse, limit) {
	    var result = [];
	    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
	        var elem = nodes_1[_i];
	        if (test(elem)) {
	            result.push(elem);
	            if (--limit <= 0)
	                break;
	        }
	        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
	            var children = find(test, elem.children, recurse, limit);
	            result.push.apply(result, children);
	            limit -= children.length;
	            if (limit <= 0)
	                break;
	        }
	    }
	    return result;
	}
	querying.find = find;
	/**
	 * Finds the first element inside of an array that matches a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns The first node in the array that passes `test`.
	 */
	function findOneChild(test, nodes) {
	    return nodes.find(test);
	}
	querying.findOneChild = findOneChild;
	/**
	 * Finds one element in a tree that passes a test.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @param recurse Also consider child nodes.
	 * @returns The first child node that passes `test`.
	 */
	function findOne(test, nodes, recurse) {
	    if (recurse === void 0) { recurse = true; }
	    var elem = null;
	    for (var i = 0; i < nodes.length && !elem; i++) {
	        var checked = nodes[i];
	        if (!(0, domhandler_1.isTag)(checked)) {
	            continue;
	        }
	        else if (test(checked)) {
	            elem = checked;
	        }
	        else if (recurse && checked.children.length > 0) {
	            elem = findOne(test, checked.children);
	        }
	    }
	    return elem;
	}
	querying.findOne = findOne;
	/**
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns Whether a tree of nodes contains at least one node passing a test.
	 */
	function existsOne(test, nodes) {
	    return nodes.some(function (checked) {
	        return (0, domhandler_1.isTag)(checked) &&
	            (test(checked) ||
	                (checked.children.length > 0 &&
	                    existsOne(test, checked.children)));
	    });
	}
	querying.existsOne = existsOne;
	/**
	 * Search and array of nodes and its children for nodes passing a test function.
	 *
	 * Same as `find`, only with less options, leading to reduced complexity.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns All nodes passing `test`.
	 */
	function findAll(test, nodes) {
	    var _a;
	    var result = [];
	    var stack = nodes.filter(domhandler_1.isTag);
	    var elem;
	    while ((elem = stack.shift())) {
	        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
	        if (children && children.length > 0) {
	            stack.unshift.apply(stack, children);
	        }
	        if (test(elem))
	            result.push(elem);
	    }
	    return result;
	}
	querying.findAll = findAll;
	return querying;
}

var legacy = {};

var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;
	Object.defineProperty(legacy, "__esModule", { value: true });
	legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
	var domhandler_1 = requireLib$7();
	var querying_1 = requireQuerying();
	var Checks = {
	    tag_name: function (name) {
	        if (typeof name === "function") {
	            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
	        }
	        else if (name === "*") {
	            return domhandler_1.isTag;
	        }
	        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
	    },
	    tag_type: function (type) {
	        if (typeof type === "function") {
	            return function (elem) { return type(elem.type); };
	        }
	        return function (elem) { return elem.type === type; };
	    },
	    tag_contains: function (data) {
	        if (typeof data === "function") {
	            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
	        }
	        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
	    },
	};
	/**
	 * @param attrib Attribute to check.
	 * @param value Attribute value to look for.
	 * @returns A function to check whether the a node has an attribute with a particular value.
	 */
	function getAttribCheck(attrib, value) {
	    if (typeof value === "function") {
	        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
	    }
	    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
	}
	/**
	 * @param a First function to combine.
	 * @param b Second function to combine.
	 * @returns A function taking a node and returning `true` if either
	 * of the input functions returns `true` for the node.
	 */
	function combineFuncs(a, b) {
	    return function (elem) { return a(elem) || b(elem); };
	}
	/**
	 * @param options An object describing nodes to look for.
	 * @returns A function executing all checks in `options` and returning `true`
	 * if any of them match a node.
	 */
	function compileTest(options) {
	    var funcs = Object.keys(options).map(function (key) {
	        var value = options[key];
	        return Object.prototype.hasOwnProperty.call(Checks, key)
	            ? Checks[key](value)
	            : getAttribCheck(key, value);
	    });
	    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
	}
	/**
	 * @param options An object describing nodes to look for.
	 * @param node The element to test.
	 * @returns Whether the element matches the description in `options`.
	 */
	function testElement(options, node) {
	    var test = compileTest(options);
	    return test ? test(node) : true;
	}
	legacy.testElement = testElement;
	/**
	 * @param options An object describing nodes to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes that match `options`.
	 */
	function getElements(options, nodes, recurse, limit) {
	    if (limit === void 0) { limit = Infinity; }
	    var test = compileTest(options);
	    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
	}
	legacy.getElements = getElements;
	/**
	 * @param id The unique ID attribute value to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @returns The node with the supplied ID.
	 */
	function getElementById(id, nodes, recurse) {
	    if (recurse === void 0) { recurse = true; }
	    if (!Array.isArray(nodes))
	        nodes = [nodes];
	    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
	}
	legacy.getElementById = getElementById;
	/**
	 * @param tagName Tag name to search for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes with the supplied `tagName`.
	 */
	function getElementsByTagName(tagName, nodes, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
	}
	legacy.getElementsByTagName = getElementsByTagName;
	/**
	 * @param type Element type to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes with the supplied `type`.
	 */
	function getElementsByTagType(type, nodes, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
	}
	legacy.getElementsByTagType = getElementsByTagType;
	return legacy;
}

var helpers$1 = {};

var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers$1;
	hasRequiredHelpers$1 = 1;
	Object.defineProperty(helpers$1, "__esModule", { value: true });
	helpers$1.uniqueSort = helpers$1.compareDocumentPosition = helpers$1.removeSubsets = void 0;
	var domhandler_1 = requireLib$7();
	/**
	 * Given an array of nodes, remove any member that is contained by another.
	 *
	 * @param nodes Nodes to filter.
	 * @returns Remaining nodes that aren't subtrees of each other.
	 */
	function removeSubsets(nodes) {
	    var idx = nodes.length;
	    /*
	     * Check if each node (or one of its ancestors) is already contained in the
	     * array.
	     */
	    while (--idx >= 0) {
	        var node = nodes[idx];
	        /*
	         * Remove the node if it is not unique.
	         * We are going through the array from the end, so we only
	         * have to check nodes that preceed the node under consideration in the array.
	         */
	        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
	            nodes.splice(idx, 1);
	            continue;
	        }
	        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
	            if (nodes.includes(ancestor)) {
	                nodes.splice(idx, 1);
	                break;
	            }
	        }
	    }
	    return nodes;
	}
	helpers$1.removeSubsets = removeSubsets;
	/**
	 * Compare the position of one node against another node in any other document.
	 * The return value is a bitmask with the following values:
	 *
	 * Document order:
	 * > There is an ordering, document order, defined on all the nodes in the
	 * > document corresponding to the order in which the first character of the
	 * > XML representation of each node occurs in the XML representation of the
	 * > document after expansion of general entities. Thus, the document element
	 * > node will be the first node. Element nodes occur before their children.
	 * > Thus, document order orders element nodes in order of the occurrence of
	 * > their start-tag in the XML (after expansion of entities). The attribute
	 * > nodes of an element occur after the element and before its children. The
	 * > relative order of attribute nodes is implementation-dependent./
	 *
	 * Source:
	 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
	 *
	 * @param nodeA The first node to use in the comparison
	 * @param nodeB The second node to use in the comparison
	 * @returns A bitmask describing the input nodes' relative position.
	 *
	 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
	 * a description of these values.
	 */
	function compareDocumentPosition(nodeA, nodeB) {
	    var aParents = [];
	    var bParents = [];
	    if (nodeA === nodeB) {
	        return 0;
	    }
	    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
	    while (current) {
	        aParents.unshift(current);
	        current = current.parent;
	    }
	    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
	    while (current) {
	        bParents.unshift(current);
	        current = current.parent;
	    }
	    var maxIdx = Math.min(aParents.length, bParents.length);
	    var idx = 0;
	    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
	        idx++;
	    }
	    if (idx === 0) {
	        return 1 /* DISCONNECTED */;
	    }
	    var sharedParent = aParents[idx - 1];
	    var siblings = sharedParent.children;
	    var aSibling = aParents[idx];
	    var bSibling = bParents[idx];
	    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
	        if (sharedParent === nodeB) {
	            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
	        }
	        return 4 /* FOLLOWING */;
	    }
	    if (sharedParent === nodeA) {
	        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
	    }
	    return 2 /* PRECEDING */;
	}
	helpers$1.compareDocumentPosition = compareDocumentPosition;
	/**
	 * Sort an array of nodes based on their relative position in the document and
	 * remove any duplicate nodes. If the array contains nodes that do not belong
	 * to the same document, sort order is unspecified.
	 *
	 * @param nodes Array of DOM nodes.
	 * @returns Collection of unique nodes, sorted in document order.
	 */
	function uniqueSort(nodes) {
	    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
	    nodes.sort(function (a, b) {
	        var relative = compareDocumentPosition(a, b);
	        if (relative & 2 /* PRECEDING */) {
	            return -1;
	        }
	        else if (relative & 4 /* FOLLOWING */) {
	            return 1;
	        }
	        return 0;
	    });
	    return nodes;
	}
	helpers$1.uniqueSort = uniqueSort;
	return helpers$1;
}

var feeds = {};

var hasRequiredFeeds;

function requireFeeds () {
	if (hasRequiredFeeds) return feeds;
	hasRequiredFeeds = 1;
	Object.defineProperty(feeds, "__esModule", { value: true });
	feeds.getFeed = void 0;
	var stringify_1 = requireStringify();
	var legacy_1 = requireLegacy();
	/**
	 * Get the feed object from the root of a DOM tree.
	 *
	 * @param doc - The DOM to to extract the feed from.
	 * @returns The feed.
	 */
	function getFeed(doc) {
	    var feedRoot = getOneElement(isValidFeed, doc);
	    return !feedRoot
	        ? null
	        : feedRoot.name === "feed"
	            ? getAtomFeed(feedRoot)
	            : getRssFeed(feedRoot);
	}
	feeds.getFeed = getFeed;
	/**
	 * Parse an Atom feed.
	 *
	 * @param feedRoot The root of the feed.
	 * @returns The parsed feed.
	 */
	function getAtomFeed(feedRoot) {
	    var _a;
	    var childs = feedRoot.children;
	    var feed = {
	        type: "atom",
	        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
	            var _a;
	            var children = item.children;
	            var entry = { media: getMediaElements(children) };
	            addConditionally(entry, "id", "id", children);
	            addConditionally(entry, "title", "title", children);
	            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
	            if (href) {
	                entry.link = href;
	            }
	            var description = fetch("summary", children) || fetch("content", children);
	            if (description) {
	                entry.description = description;
	            }
	            var pubDate = fetch("updated", children);
	            if (pubDate) {
	                entry.pubDate = new Date(pubDate);
	            }
	            return entry;
	        }),
	    };
	    addConditionally(feed, "id", "id", childs);
	    addConditionally(feed, "title", "title", childs);
	    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
	    if (href) {
	        feed.link = href;
	    }
	    addConditionally(feed, "description", "subtitle", childs);
	    var updated = fetch("updated", childs);
	    if (updated) {
	        feed.updated = new Date(updated);
	    }
	    addConditionally(feed, "author", "email", childs, true);
	    return feed;
	}
	/**
	 * Parse a RSS feed.
	 *
	 * @param feedRoot The root of the feed.
	 * @returns The parsed feed.
	 */
	function getRssFeed(feedRoot) {
	    var _a, _b;
	    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
	    var feed = {
	        type: feedRoot.name.substr(0, 3),
	        id: "",
	        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
	            var children = item.children;
	            var entry = { media: getMediaElements(children) };
	            addConditionally(entry, "id", "guid", children);
	            addConditionally(entry, "title", "title", children);
	            addConditionally(entry, "link", "link", children);
	            addConditionally(entry, "description", "description", children);
	            var pubDate = fetch("pubDate", children);
	            if (pubDate)
	                entry.pubDate = new Date(pubDate);
	            return entry;
	        }),
	    };
	    addConditionally(feed, "title", "title", childs);
	    addConditionally(feed, "link", "link", childs);
	    addConditionally(feed, "description", "description", childs);
	    var updated = fetch("lastBuildDate", childs);
	    if (updated) {
	        feed.updated = new Date(updated);
	    }
	    addConditionally(feed, "author", "managingEditor", childs, true);
	    return feed;
	}
	var MEDIA_KEYS_STRING = ["url", "type", "lang"];
	var MEDIA_KEYS_INT = [
	    "fileSize",
	    "bitrate",
	    "framerate",
	    "samplingrate",
	    "channels",
	    "duration",
	    "height",
	    "width",
	];
	/**
	 * Get all media elements of a feed item.
	 *
	 * @param where Nodes to search in.
	 * @returns Media elements.
	 */
	function getMediaElements(where) {
	    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
	        var attribs = elem.attribs;
	        var media = {
	            medium: attribs.medium,
	            isDefault: !!attribs.isDefault,
	        };
	        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
	            var attrib = MEDIA_KEYS_STRING_1[_i];
	            if (attribs[attrib]) {
	                media[attrib] = attribs[attrib];
	            }
	        }
	        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
	            var attrib = MEDIA_KEYS_INT_1[_a];
	            if (attribs[attrib]) {
	                media[attrib] = parseInt(attribs[attrib], 10);
	            }
	        }
	        if (attribs.expression) {
	            media.expression =
	                attribs.expression;
	        }
	        return media;
	    });
	}
	/**
	 * Get one element by tag name.
	 *
	 * @param tagName Tag name to look for
	 * @param node Node to search in
	 * @returns The element or null
	 */
	function getOneElement(tagName, node) {
	    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
	}
	/**
	 * Get the text content of an element with a certain tag name.
	 *
	 * @param tagName Tag name to look for.
	 * @param where  Node to search in.
	 * @param recurse Whether to recurse into child nodes.
	 * @returns The text content of the element.
	 */
	function fetch(tagName, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
	}
	/**
	 * Adds a property to an object if it has a value.
	 *
	 * @param obj Object to be extended
	 * @param prop Property name
	 * @param tagName Tag name that contains the conditionally added property
	 * @param where Element to search for the property
	 * @param recurse Whether to recurse into child nodes.
	 */
	function addConditionally(obj, prop, tagName, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    var val = fetch(tagName, where, recurse);
	    if (val)
	        obj[prop] = val;
	}
	/**
	 * Checks if an element is a feed root node.
	 *
	 * @param value The name of the element to check.
	 * @returns Whether an element is a feed root node.
	 */
	function isValidFeed(value) {
	    return value === "rss" || value === "feed" || value === "rdf:RDF";
	}
	return feeds;
}

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$6;
	hasRequiredLib$4 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
		__exportStar(requireStringify(), exports);
		__exportStar(requireTraversal(), exports);
		__exportStar(requireManipulation(), exports);
		__exportStar(requireQuerying(), exports);
		__exportStar(requireLegacy(), exports);
		__exportStar(requireHelpers$1(), exports);
		__exportStar(requireFeeds(), exports);
		/** @deprecated Use these methods from `domhandler` directly. */
		var domhandler_1 = requireLib$7();
		Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
		Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
		Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
		Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
		Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
		Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } }); 
	} (lib$6));
	return lib$6;
}

var hasRequiredFeedHandler;

function requireFeedHandler () {
	if (hasRequiredFeedHandler) return FeedHandler;
	hasRequiredFeedHandler = 1;
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(FeedHandler, "__esModule", { value: true });
	FeedHandler.parseFeed = FeedHandler.FeedHandler = void 0;
	var domhandler_1 = __importDefault(requireLib$7());
	var DomUtils = __importStar(requireLib$4());
	var Parser_1 = requireParser();
	var FeedItemMediaMedium;
	(function (FeedItemMediaMedium) {
	    FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
	    FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
	    FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
	    FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
	    FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
	})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
	var FeedItemMediaExpression;
	(function (FeedItemMediaExpression) {
	    FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
	    FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
	    FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
	})(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
	// TODO: Consume data as it is coming in
	var FeedHandler$1 = /** @class */ (function (_super) {
	    __extends(FeedHandler, _super);
	    /**
	     *
	     * @param callback
	     * @param options
	     */
	    function FeedHandler(callback, options) {
	        var _this = this;
	        if (typeof callback === "object") {
	            callback = undefined;
	            options = callback;
	        }
	        _this = _super.call(this, callback, options) || this;
	        return _this;
	    }
	    FeedHandler.prototype.onend = function () {
	        var _a, _b;
	        var feedRoot = getOneElement(isValidFeed, this.dom);
	        if (!feedRoot) {
	            this.handleCallback(new Error("couldn't find root of feed"));
	            return;
	        }
	        var feed = {};
	        if (feedRoot.name === "feed") {
	            var childs = feedRoot.children;
	            feed.type = "atom";
	            addConditionally(feed, "id", "id", childs);
	            addConditionally(feed, "title", "title", childs);
	            var href = getAttribute("href", getOneElement("link", childs));
	            if (href) {
	                feed.link = href;
	            }
	            addConditionally(feed, "description", "subtitle", childs);
	            var updated = fetch("updated", childs);
	            if (updated) {
	                feed.updated = new Date(updated);
	            }
	            addConditionally(feed, "author", "email", childs, true);
	            feed.items = getElements("entry", childs).map(function (item) {
	                var entry = {};
	                var children = item.children;
	                addConditionally(entry, "id", "id", children);
	                addConditionally(entry, "title", "title", children);
	                var href = getAttribute("href", getOneElement("link", children));
	                if (href) {
	                    entry.link = href;
	                }
	                var description = fetch("summary", children) || fetch("content", children);
	                if (description) {
	                    entry.description = description;
	                }
	                var pubDate = fetch("updated", children);
	                if (pubDate) {
	                    entry.pubDate = new Date(pubDate);
	                }
	                entry.media = getMediaElements(children);
	                return entry;
	            });
	        }
	        else {
	            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
	            feed.type = feedRoot.name.substr(0, 3);
	            feed.id = "";
	            addConditionally(feed, "title", "title", childs);
	            addConditionally(feed, "link", "link", childs);
	            addConditionally(feed, "description", "description", childs);
	            var updated = fetch("lastBuildDate", childs);
	            if (updated) {
	                feed.updated = new Date(updated);
	            }
	            addConditionally(feed, "author", "managingEditor", childs, true);
	            feed.items = getElements("item", feedRoot.children).map(function (item) {
	                var entry = {};
	                var children = item.children;
	                addConditionally(entry, "id", "guid", children);
	                addConditionally(entry, "title", "title", children);
	                addConditionally(entry, "link", "link", children);
	                addConditionally(entry, "description", "description", children);
	                var pubDate = fetch("pubDate", children);
	                if (pubDate)
	                    entry.pubDate = new Date(pubDate);
	                entry.media = getMediaElements(children);
	                return entry;
	            });
	        }
	        this.feed = feed;
	        this.handleCallback(null);
	    };
	    return FeedHandler;
	}(domhandler_1.default));
	FeedHandler.FeedHandler = FeedHandler$1;
	function getMediaElements(where) {
	    return getElements("media:content", where).map(function (elem) {
	        var media = {
	            medium: elem.attribs.medium,
	            isDefault: !!elem.attribs.isDefault,
	        };
	        if (elem.attribs.url) {
	            media.url = elem.attribs.url;
	        }
	        if (elem.attribs.fileSize) {
	            media.fileSize = parseInt(elem.attribs.fileSize, 10);
	        }
	        if (elem.attribs.type) {
	            media.type = elem.attribs.type;
	        }
	        if (elem.attribs.expression) {
	            media.expression = elem.attribs
	                .expression;
	        }
	        if (elem.attribs.bitrate) {
	            media.bitrate = parseInt(elem.attribs.bitrate, 10);
	        }
	        if (elem.attribs.framerate) {
	            media.framerate = parseInt(elem.attribs.framerate, 10);
	        }
	        if (elem.attribs.samplingrate) {
	            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
	        }
	        if (elem.attribs.channels) {
	            media.channels = parseInt(elem.attribs.channels, 10);
	        }
	        if (elem.attribs.duration) {
	            media.duration = parseInt(elem.attribs.duration, 10);
	        }
	        if (elem.attribs.height) {
	            media.height = parseInt(elem.attribs.height, 10);
	        }
	        if (elem.attribs.width) {
	            media.width = parseInt(elem.attribs.width, 10);
	        }
	        if (elem.attribs.lang) {
	            media.lang = elem.attribs.lang;
	        }
	        return media;
	    });
	}
	function getElements(tagName, where) {
	    return DomUtils.getElementsByTagName(tagName, where, true);
	}
	function getOneElement(tagName, node) {
	    return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
	}
	function fetch(tagName, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
	}
	function getAttribute(name, elem) {
	    if (!elem) {
	        return null;
	    }
	    var attribs = elem.attribs;
	    return attribs[name];
	}
	function addConditionally(obj, prop, what, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    var tmp = fetch(what, where, recurse);
	    if (tmp)
	        obj[prop] = tmp;
	}
	function isValidFeed(value) {
	    return value === "rss" || value === "feed" || value === "rdf:RDF";
	}
	/**
	 * Parse a feed.
	 *
	 * @param feed The feed that should be parsed, as a string.
	 * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.
	 */
	function parseFeed(feed, options) {
	    if (options === void 0) { options = { xmlMode: true }; }
	    var handler = new FeedHandler$1(options);
	    new Parser_1.Parser(handler, options).end(feed);
	    return handler.feed;
	}
	FeedHandler.parseFeed = parseFeed;
	return FeedHandler;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$9;
	hasRequiredLib$3 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
		var Parser_1 = requireParser();
		Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });
		var domhandler_1 = requireLib$7();
		Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
		Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
		// Helper methods
		/**
		 * Parses the data, returns the resulting document.
		 *
		 * @param data The data that should be parsed.
		 * @param options Optional options for the parser and DOM builder.
		 */
		function parseDocument(data, options) {
		    var handler = new domhandler_1.DomHandler(undefined, options);
		    new Parser_1.Parser(handler, options).end(data);
		    return handler.root;
		}
		exports.parseDocument = parseDocument;
		/**
		 * Parses data, returns an array of the root nodes.
		 *
		 * Note that the root nodes still have a `Document` node as their parent.
		 * Use `parseDocument` to get the `Document` node instead.
		 *
		 * @param data The data that should be parsed.
		 * @param options Optional options for the parser and DOM builder.
		 * @deprecated Use `parseDocument` instead.
		 */
		function parseDOM(data, options) {
		    return parseDocument(data, options).children;
		}
		exports.parseDOM = parseDOM;
		/**
		 * Creates a parser instance, with an attached DOM handler.
		 *
		 * @param cb A callback that will be called once parsing has been completed.
		 * @param options Optional options for the parser and DOM builder.
		 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
		 */
		function createDomStream(cb, options, elementCb) {
		    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
		    return new Parser_1.Parser(handler, options);
		}
		exports.createDomStream = createDomStream;
		var Tokenizer_1 = requireTokenizer();
		Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } });
		var ElementType = __importStar(requireLib$8());
		exports.ElementType = ElementType;
		/*
		 * All of the following exports exist for backwards-compatibility.
		 * They should probably be removed eventually.
		 */
		__exportStar(requireFeedHandler(), exports);
		exports.DomUtils = __importStar(requireLib$4());
		var FeedHandler_1 = requireFeedHandler();
		Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } }); 
	} (lib$9));
	return lib$9;
}

var array_1;
var hasRequiredArray;

function requireArray () {
	if (hasRequiredArray) return array_1;
	hasRequiredArray = 1;

	array_1 = {
	  /*
	  	Tries to turn anything into an array.
	  */

	  from: function(r) {
	    return Array.prototype.slice.call(r);
	  },
	  /*
	  	Clone of an array. Properties will be shallow copies.
	  */

	  simpleClone: function(a) {
	    return a.slice(0);
	  },
	  shallowEqual: function(a1, a2) {
	    var i, val, _i, _len;
	    if (!(Array.isArray(a1) && Array.isArray(a2) && a1.length === a2.length)) {
	      return false;
	    }
	    for (i = _i = 0, _len = a1.length; _i < _len; i = ++_i) {
	      val = a1[i];
	      if (a2[i] !== val) {
	        return false;
	      }
	    }
	    return true;
	  },
	  pluck: function(a, i) {
	    var index, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      a[index];
	      if (index > i) {
	        a[index - 1] = a[index];
	      }
	    }
	    a.length = a.length - 1;
	    return a;
	  },
	  pluckItem: function(a, item) {
	    var index, removed, value, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    removed = 0;
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      value = a[index];
	      if (value === item) {
	        removed++;
	        continue;
	      }
	      if (removed !== 0) {
	        a[index - removed] = a[index];
	      }
	    }
	    if (removed > 0) {
	      a.length = a.length - removed;
	    }
	    return a;
	  },
	  pluckOneItem: function(a, item) {
	    var index, reached, value, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    reached = false;
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      value = a[index];
	      if (!reached) {
	        if (value === item) {
	          reached = true;
	          continue;
	        }
	      } else {
	        a[index - 1] = a[index];
	      }
	    }
	    if (reached) {
	      a.length = a.length - 1;
	    }
	    return a;
	  },
	  pluckByCallback: function(a, cb) {
	    var index, removed, value, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    removed = 0;
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      value = a[index];
	      if (cb(value, index)) {
	        removed++;
	        continue;
	      }
	      if (removed !== 0) {
	        a[index - removed] = a[index];
	      }
	    }
	    if (removed > 0) {
	      a.length = a.length - removed;
	    }
	    return a;
	  },
	  pluckMultiple: function(array, indexesToRemove) {
	    var i, removedSoFar, _i, _len;
	    if (array.length < 1) {
	      return array;
	    }
	    removedSoFar = 0;
	    indexesToRemove.sort();
	    for (_i = 0, _len = indexesToRemove.length; _i < _len; _i++) {
	      i = indexesToRemove[_i];
	      this.pluck(array, i - removedSoFar);
	      removedSoFar++;
	    }
	    return array;
	  },
	  injectByCallback: function(a, toInject, shouldInject) {
	    var i, len, val, valA, valB, _i, _len;
	    valA = null;
	    valB = null;
	    len = a.length;
	    if (len < 1) {
	      a.push(toInject);
	      return a;
	    }
	    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
	      val = a[i];
	      valA = valB;
	      valB = val;
	      if (shouldInject(valA, valB, toInject)) {
	        return a.splice(i, 0, toInject);
	      }
	    }
	    a.push(toInject);
	    return a;
	  },
	  injectInIndex: function(a, index, toInject) {
	    var i, len, toPut, toPutNext;
	    len = a.length;
	    i = index;
	    if (len < 1) {
	      a.push(toInject);
	      return a;
	    }
	    toPut = toInject;
	    toPutNext = null;
	    for(; i <= len; i++){

				toPutNext = a[i];

				a[i] = toPut;

				toPut = toPutNext;

			}	    return null;
	  }
	};
	return array_1;
}

var classic_1;
var hasRequiredClassic;

function requireClassic () {
	if (hasRequiredClassic) return classic_1;
	hasRequiredClassic = 1;
	// Generated by CoffeeScript 1.6.3
	var classic,
	  __slice = [].slice;

	classic_1 = classic = {};

	classic.implement = function() {
	  var classProto, classReference, desc, member, mixin, mixins, _i, _j, _len;
	  mixins = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), classReference = arguments[_i++];
	  for (_j = 0, _len = mixins.length; _j < _len; _j++) {
	    mixin = mixins[_j];
	    classProto = classReference.prototype;
	    for (member in mixin.prototype) {
	      if (!Object.getOwnPropertyDescriptor(classProto, member)) {
	        desc = Object.getOwnPropertyDescriptor(mixin.prototype, member);
	        Object.defineProperty(classProto, member, desc);
	      }
	    }
	  }
	  return classReference;
	};

	classic.mix = function() {
	  var classProto, classReference, desc, member, mixin, mixins, _i, _j, _len;
	  mixins = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), classReference = arguments[_i++];
	  classProto = classReference.prototype;
	  classReference.__mixinCloners = [];
	  classReference.__applyClonersFor = function(instance, args) {
	    var cloner, _j, _len, _ref;
	    if (args == null) {
	      args = null;
	    }
	    _ref = classReference.__mixinCloners;
	    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	      cloner = _ref[_j];
	      cloner.apply(instance, args);
	    }
	  };
	  classReference.__mixinInitializers = [];
	  classReference.__initMixinsFor = function(instance, args) {
	    var initializer, _j, _len, _ref;
	    if (args == null) {
	      args = null;
	    }
	    _ref = classReference.__mixinInitializers;
	    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	      initializer = _ref[_j];
	      initializer.apply(instance, args);
	    }
	  };
	  classReference.__mixinQuitters = [];
	  classReference.__applyQuittersFor = function(instance, args) {
	    var quitter, _j, _len, _ref;
	    if (args == null) {
	      args = null;
	    }
	    _ref = classReference.__mixinQuitters;
	    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	      quitter = _ref[_j];
	      quitter.apply(instance, args);
	    }
	  };
	  for (_j = 0, _len = mixins.length; _j < _len; _j++) {
	    mixin = mixins[_j];
	    if (!(mixin.constructor instanceof Function)) {
	      throw Error("Mixin should be a function");
	    }
	    for (member in mixin.prototype) {
	      if (member.substr(0, 11) === '__initMixin') {
	        classReference.__mixinInitializers.push(mixin.prototype[member]);
	        continue;
	      } else if (member.substr(0, 11) === '__clonerFor') {
	        classReference.__mixinCloners.push(mixin.prototype[member]);
	        continue;
	      } else if (member.substr(0, 12) === '__quitterFor') {
	        classReference.__mixinQuitters.push(mixin.prototype[member]);
	        continue;
	      }
	      if (!Object.getOwnPropertyDescriptor(classProto, member)) {
	        desc = Object.getOwnPropertyDescriptor(mixin.prototype, member);
	        Object.defineProperty(classProto, member, desc);
	      }
	    }
	  }
	  return classReference;
	};
	return classic_1;
}

var _common;
var hasRequired_common$1;

function require_common$1 () {
	if (hasRequired_common$1) return _common;
	hasRequired_common$1 = 1;
	// Generated by CoffeeScript 1.6.3
	var common;

	_common = common = {
	  /*
	  	Checks to see if o is an object, and it isn't an instance
	  	of some class.
	  */

	  isBareObject: function(o) {
	    if ((o != null) && o.constructor === Object) {
	      return true;
	    }
	    return false;
	  },
	  /*
	  	Returns type of an object, including:
	  	undefined, null, string, number, array,
	  	arguments, element, textnode, whitespace, and object
	  */

	  typeOf: function(item) {
	    var _ref;
	    if (item === null) {
	      return 'null';
	    }
	    if (typeof item !== 'object') {
	      return typeof item;
	    }
	    if (Array.isArray(item)) {
	      return 'array';
	    }
	    if (item.nodeName) {
	      if (item.nodeType === 1) {
	        return 'element';
	      }
	      if (item.nodeType === 3) {
	        return (_ref = /\S/.test(item.nodeValue)) != null ? _ref : {
	          'textnode': 'whitespace'
	        };
	      }
	    } else if (typeof item.length === 'number') {
	      if (item.callee) {
	        return 'arguments';
	      }
	    }
	    return typeof item;
	  },
	  clone: function(item, includePrototype) {
	    if (includePrototype == null) {
	      includePrototype = false;
	    }
	    switch (common.typeOf(item)) {
	      case 'array':
	        return common._cloneArray(item, includePrototype);
	      case 'object':
	        return common._cloneObject(item, includePrototype);
	      default:
	        return item;
	    }
	  },
	  /*
	  	Deep clone of an object.
	  	From MooTools
	  */

	  _cloneObject: function(o, includePrototype) {
	    var clone, key;
	    if (includePrototype == null) {
	      includePrototype = false;
	    }
	    if (common.isBareObject(o)) {
	      clone = {};
	      for (key in o) {
	        clone[key] = common.clone(o[key], includePrototype);
	      }
	      return clone;
	    } else {
	      if (!includePrototype) {
	        return o;
	      }
	      if (o instanceof Function) {
	        return o;
	      }
	      clone = Object.create(o.constructor.prototype);
	      for (key in o) {
	        if (o.hasOwnProperty(key)) {
	          clone[key] = common.clone(o[key], includePrototype);
	        }
	      }
	      return clone;
	    }
	  },
	  /*
	  	Deep clone of an array.
	  	From MooTools
	  */

	  _cloneArray: function(a, includePrototype) {
	    var clone, i;
	    if (includePrototype == null) {
	      includePrototype = false;
	    }
	    i = a.length;
	    clone = new Array(i);
	    while (i--) {
	      clone[i] = common.clone(a[i], includePrototype);
	    }
	    return clone;
	  }
	};
	return _common;
}

var object_1;
var hasRequiredObject$1;

function requireObject$1 () {
	if (hasRequiredObject$1) return object_1;
	hasRequiredObject$1 = 1;
	// Generated by CoffeeScript 1.6.3
	var _common,
	  __hasProp = {}.hasOwnProperty;

	_common = require_common$1();

	object_1 = {
	  isBareObject: _common.isBareObject.bind(_common),
	  /*
	  	if object is an instance of a class
	  */

	  isInstance: function(what) {
	    return !this.isBareObject(what);
	  },
	  /*
	  	Alias to _common.typeOf
	  */

	  typeOf: _common.typeOf.bind(_common),
	  /*
	  	Alias to _common.clone
	  */

	  clone: _common.clone.bind(_common),
	  /*
	  	Empties an object of its properties.
	  */

	  empty: function(o) {
	    var prop;
	    for (prop in o) {
	      if (o.hasOwnProperty(prop)) {
	        delete o[prop];
	      }
	    }
	    return o;
	  },
	  /*
	  	Empties an object. Doesn't check for hasOwnProperty, so it's a tiny
	  	bit faster. Use it for plain objects.
	  */

	  fastEmpty: function(o) {
	    var property;
	    for (property in o) {
	      delete o[property];
	    }
	    return o;
	  },
	  /*
	  	Overrides values fomr `newValues` on `base`, as long as they
	  	already exist in base.
	  */

	  overrideOnto: function(base, newValues) {
	    var key, newVal, oldVal;
	    if (!this.isBareObject(newValues) || !this.isBareObject(base)) {
	      return base;
	    }
	    for (key in base) {
	      oldVal = base[key];
	      newVal = newValues[key];
	      if (newVal === void 0) {
	        continue;
	      }
	      if (typeof newVal !== 'object' || this.isInstance(newVal)) {
	        base[key] = this.clone(newVal);
	      } else {
	        if (typeof oldVal !== 'object' || this.isInstance(oldVal)) {
	          base[key] = this.clone(newVal);
	        } else {
	          this.overrideOnto(oldVal, newVal);
	        }
	      }
	    }
	    return base;
	  },
	  /*
	  	Takes a clone of 'base' and runs #overrideOnto on it
	  */

	  override: function(base, newValues) {
	    return this.overrideOnto(this.clone(base), newValues);
	  },
	  append: function(base, toAppend) {
	    return this.appendOnto(this.clone(base), toAppend);
	  },
	  appendOnto: function(base, toAppend) {
	    var key, newVal, oldVal;
	    if (!this.isBareObject(toAppend) || !this.isBareObject(base)) {
	      return base;
	    }
	    for (key in toAppend) {
	      if (!__hasProp.call(toAppend, key)) continue;
	      newVal = toAppend[key];
	      if (newVal === void 0) {
	        continue;
	      }
	      if (typeof newVal !== 'object' || this.isInstance(newVal)) {
	        base[key] = newVal;
	      } else {
	        oldVal = base[key];
	        if (typeof oldVal !== 'object' || this.isInstance(oldVal)) {
	          base[key] = this.clone(newVal);
	        } else {
	          this.appendOnto(oldVal, newVal);
	        }
	      }
	    }
	    return base;
	  },
	  groupProps: function(obj, groups) {
	    var def, defs, grouped, key, name, shouldAdd, val, _i, _len;
	    grouped = {};
	    for (name in groups) {
	      defs = groups[name];
	      grouped[name] = {};
	    }
	    grouped['rest'] = {};
	    top: //;
	    for (key in obj) {
	      val = obj[key];
	      shouldAdd = false;
	      for (name in groups) {
	        defs = groups[name];
	        if (!Array.isArray(defs)) {
	          defs = [defs];
	        }
	        for (_i = 0, _len = defs.length; _i < _len; _i++) {
	          def = defs[_i];
	          if (typeof def === 'string') {
	            if (key === def) {
	              shouldAdd = true;
	            }
	          } else if (def instanceof RegExp) {
	            if (def.test(key)) {
	              shouldAdd = true;
	            }
	          } else if (def instanceof Function) {
	            if (def(key)) {
	              shouldAdd = true;
	            }
	          } else {
	            throw Error('Group definitions must either\
							be strings, regexes, or functions.');
	          }
	          if (shouldAdd) {
	            grouped[name][key] = val;
	            continue top;
	          }
	        }
	      }
	      grouped['rest'][key] = val;
	    }
	    return grouped;
	  }
	};
	return object_1;
}

var string;
var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string;
	hasRequiredString = 1;
	// Generated by CoffeeScript 1.6.3
	string = {
	  pad: function(n, width, z) {
	    if (z == null) {
	      z = '0';
	    }
	    n = n + '';
	    if (n.length >= width) {
	      return n;
	    } else {
	      return new Array(width - n.length + 1).join(z) + n;
	    }
	  }
	};
	return string;
}

var Emitter_1;
var hasRequiredEmitter;

function requireEmitter () {
	if (hasRequiredEmitter) return Emitter_1;
	hasRequiredEmitter = 1;
	// Generated by CoffeeScript 1.6.3
	var array;

	array = requireArray();

	Emitter_1 = (function() {
	  function Emitter() {
	    this._listeners = {};
	    this._listenersForAnyEvent = [];
	    this._disabledEmitters = {};
	  }

	  Emitter.prototype.on = function(eventName, listener) {
	    if (this._listeners[eventName] == null) {
	      this._listeners[eventName] = [];
	    }
	    this._listeners[eventName].push(listener);
	    return this;
	  };

	  Emitter.prototype.once = function(eventName, listener) {
	    var cb, ran,
	      _this = this;
	    ran = false;
	    cb = function() {
	      if (ran) {
	        return;
	      }
	      ran = true;
	      listener();
	      return setTimeout(function() {
	        return _this.removeEvent(eventName, cb);
	      }, 0);
	    };
	    this.on(eventName, cb);
	    return this;
	  };

	  Emitter.prototype.onAnyEvent = function(listener) {
	    this._listenersForAnyEvent.push(listener);
	    return this;
	  };

	  Emitter.prototype.removeEvent = function(eventName, listener) {
	    if (this._listeners[eventName] == null) {
	      return this;
	    }
	    array.pluckOneItem(this._listeners[eventName], listener);
	    return this;
	  };

	  Emitter.prototype.removeListeners = function(eventName) {
	    if (this._listeners[eventName] == null) {
	      return this;
	    }
	    this._listeners[eventName].length = 0;
	    return this;
	  };

	  Emitter.prototype.removeAllListeners = function() {
	    var listeners, name, _ref;
	    _ref = this._listeners;
	    for (name in _ref) {
	      listeners = _ref[name];
	      listeners.length = 0;
	    }
	    return this;
	  };

	  Emitter.prototype._emit = function(eventName, data) {
	    var listener, _i, _j, _len, _len1, _ref, _ref1;
	    _ref = this._listenersForAnyEvent;
	    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	      listener = _ref[_i];
	      listener.call(this, data, eventName);
	    }
	    if (this._listeners[eventName] == null) {
	      return;
	    }
	    _ref1 = this._listeners[eventName];
	    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
	      listener = _ref1[_j];
	      listener.call(this, data);
	    }
	  };

	  Emitter.prototype._throttleEmitterMethod = function(fnName, time) {
	    var lastCallArgs, originalFn, pend, pending, runIt, timer,
	      _this = this;
	    if (time == null) {
	      time = 1000;
	    }
	    originalFn = this[fnName];
	    if (typeof originalFn !== 'function') {
	      throw Error("this class does not have a method called '" + fnName + "'");
	    }
	    lastCallArgs = null;
	    pending = false;
	    timer = null;
	    this[fnName] = function() {
	      lastCallArgs = arguments;
	      return pend();
	    };
	    pend = function() {
	      if (pending) {
	        clearTimeout(timer);
	      }
	      timer = setTimeout(runIt, time);
	      return pending = true;
	    };
	    return runIt = function() {
	      pending = false;
	      return originalFn.apply(_this, lastCallArgs);
	    };
	  };

	  Emitter.prototype._disableEmitter = function(fnName) {
	    if (this._disabledEmitters[fnName] != null) {
	      throw Error("" + fnName + " is already a disabled emitter");
	    }
	    this._disabledEmitters[fnName] = this[fnName];
	    return this[fnName] = function() {};
	  };

	  Emitter.prototype._enableEmitter = function(fnName) {
	    var fn;
	    fn = this._disabledEmitters[fnName];
	    if (fn == null) {
	      throw Error("" + fnName + " is not a disabled emitter");
	    }
	    this[fnName] = fn;
	    return delete this._disabledEmitters[fnName];
	  };

	  return Emitter;

	})();
	return Emitter_1;
}

var utila_1;
var hasRequiredUtila;

function requireUtila () {
	if (hasRequiredUtila) return utila_1;
	hasRequiredUtila = 1;

	utila_1 = {
	  array: requireArray(),
	  classic: requireClassic(),
	  object: requireObject$1(),
	  string: requireString(),
	  Emitter: requireEmitter()
	};
	return utila_1;
}

var objectToSaneObject;
var hasRequiredObjectToSaneObject;

function requireObjectToSaneObject () {
	if (hasRequiredObjectToSaneObject) return objectToSaneObject;
	hasRequiredObjectToSaneObject = 1;
	// Generated by CoffeeScript 1.12.7
	var object, self,
	  hasProp = {}.hasOwnProperty;

	object = requireUtila().object;

	objectToSaneObject = self = {
	  sanitize: function(val) {
	    return self._toChildren(val);
	  },
	  _toChildren: function(val) {
	    var ref;
	    if (object.isBareObject(val)) {
	      return self._objectToChildren(val);
	    } else if (Array.isArray(val)) {
	      return self._arrayToChildren(val);
	    } else if (val === null || typeof val === 'undefined') {
	      return [];
	    } else if ((ref = typeof val) === 'string' || ref === 'number') {
	      return [String(val)];
	    } else {
	      throw Error("not a valid child node: `" + val);
	    }
	  },
	  _objectToChildren: function(o) {
	    var a, cur, key, val;
	    a = [];
	    for (key in o) {
	      if (!hasProp.call(o, key)) continue;
	      val = o[key];
	      cur = {};
	      cur[key] = self.sanitize(val);
	      a.push(cur);
	    }
	    return a;
	  },
	  _arrayToChildren: function(a) {
	    var i, len, ret, v;
	    ret = [];
	    for (i = 0, len = a.length; i < len; i++) {
	      v = a[i];
	      ret.push(self._toNode(v));
	    }
	    return ret;
	  },
	  _toNode: function(o) {
	    var key, keys, obj, ref;
	    if ((ref = typeof o) === 'string' || ref === 'number') {
	      return String(o);
	    } else if (object.isBareObject(o)) {
	      keys = Object.keys(o);
	      if (keys.length !== 1) {
	        throw Error("a node must only have one key as tag name");
	      }
	      key = keys[0];
	      obj = {};
	      obj[key] = self._toChildren(o[key]);
	      return obj;
	    } else {
	      throw Error("not a valid node: `" + o + "`");
	    }
	  }
	};
	return objectToSaneObject;
}

var saneObjectToDom;
var hasRequiredSaneObjectToDom;

function requireSaneObjectToDom () {
	if (hasRequiredSaneObjectToDom) return saneObjectToDom;
	hasRequiredSaneObjectToDom = 1;
	// Generated by CoffeeScript 1.12.7
	var self,
	  hasProp = {}.hasOwnProperty;

	saneObjectToDom = self = {
	  convert: function(obj) {
	    return self._arrayToChildren(obj);
	  },
	  _arrayToChildren: function(a, parent) {
	    var children, j, len, node, prev, v;
	    if (parent == null) {
	      parent = null;
	    }
	    children = [];
	    prev = null;
	    for (j = 0, len = a.length; j < len; j++) {
	      v = a[j];
	      if (typeof v === 'string') {
	        node = self._getTextNodeFor(v);
	      } else {
	        node = self._objectToNode(v, parent);
	        node.prev = null;
	        node.next = null;
	        node.parent = parent;
	        if (prev != null) {
	          node.prev = prev;
	          prev.next = node;
	        }
	        prev = node;
	      }
	      children.push(node);
	    }
	    return children;
	  },
	  _objectToNode: function(o) {
	    var attribs, children, i, k, key, name, node, ref, v, val;
	    i = 0;
	    for (k in o) {
	      if (!hasProp.call(o, k)) continue;
	      v = o[k];
	      if (i > 0) {
	        throw Error("_objectToNode() only accepts an object with one key/value");
	      }
	      key = k;
	      val = v;
	      i++;
	    }
	    node = {};
	    if (typeof key !== 'string') {
	      throw Error("_objectToNode()'s key must be a string of tag name and classes");
	    }
	    if (typeof val === 'string') {
	      children = [self._getTextNodeFor(val)];
	    } else if (Array.isArray(val)) {
	      children = self._arrayToChildren(val, node);
	    } else {
	      inspect(o);
	      throw Error("_objectToNode()'s key's value must only be a string or an array");
	    }
	    node.type = 'tag';
	    ref = self._parseTag(key), name = ref.name, attribs = ref.attribs;
	    node.name = name;
	    node.attribs = attribs;
	    node.children = children;
	    return node;
	  },
	  _getTextNodeFor: function(s) {
	    return {
	      type: 'text',
	      data: s
	    };
	  },
	  _nameRx: /^[a-zA-Z\-\_]{1}[a-zA-Z0-9\-\_]*$/,
	  _parseTag: function(k) {
	    var attribs, classes, cls, id, m, name, parts;
	    if (!k.match(/^[a-zA-Z0-9\#\-\_\.\[\]\"\'\=\,\s]+$/) || k.match(/^[0-9]+/)) {
	      throw Error("cannot parse tag `" + k + "`");
	    }
	    attribs = {};
	    parts = {
	      name: '',
	      attribs: attribs
	    };
	    if (m = k.match(/^([^\.#]+)/)) {
	      name = m[1];
	      if (!name.match(self._nameRx)) {
	        throw Error("tag name `" + name + "` is not valid");
	      }
	      parts.name = name;
	      k = k.substr(name.length, k.length);
	    }
	    if (m = k.match(/^#([a-zA-Z0-9\-]+)/)) {
	      id = m[1];
	      if (!id.match(self._nameRx)) {
	        throw Error("tag id `" + id + "` is not valid");
	      }
	      attribs.id = id;
	      k = k.substr(id.length + 1, k.length);
	    }
	    classes = [];
	    while (m = k.match(/\.([a-zA-Z0-9\-\_]+)/)) {
	      cls = m[1];
	      if (!cls.match(self._nameRx)) {
	        throw Error("tag class `" + cls + "` is not valid");
	      }
	      classes.push(cls);
	      k = k.replace('.' + cls, '');
	    }
	    if (classes.length) {
	      attribs["class"] = classes.join(" ");
	    }
	    return parts;
	  }
	};
	return saneObjectToDom;
}

var domToMarkup = {};

var hasRequiredDomToMarkup;

function requireDomToMarkup () {
	if (hasRequiredDomToMarkup) return domToMarkup;
	hasRequiredDomToMarkup = 1;
	// Generated by CoffeeScript 1.12.7
	return domToMarkup;
}

var domConverter;
var hasRequiredDomConverter;

function requireDomConverter () {
	if (hasRequiredDomConverter) return domConverter;
	hasRequiredDomConverter = 1;
	// Generated by CoffeeScript 1.12.7
	var domToMarkup, object, objectToSaneObject, saneObjectToDom, self;

	objectToSaneObject = requireObjectToSaneObject();

	saneObjectToDom = requireSaneObjectToDom();

	domToMarkup = requireDomToMarkup();

	object = requireUtila().object;

	domConverter = self = {
	  objectToDom: function(o) {
	    o = self._object2SaneObject(o);
	    return saneObjectToDom.convert(o);
	  },
	  object2markup: function(o) {
	    var dom;
	    dom = self.objectToDom(o);
	    return domToMarkup.convert(dom);
	  },
	  domToMarkup: function(dom) {
	    return domToMarkup.convert(dom);
	  },
	  _object2SaneObject: function(o) {
	    if (!Array.isArray(o)) {
	      if (!object.isBareObject(o)) {
	        throw Error("toDom() only accepts arrays and bare objects as input");
	      }
	    }
	    return objectToSaneObject.sanitize(o);
	  }
	};
	return domConverter;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _stackClear;
var hasRequired_stackClear;

function require_stackClear () {
	if (hasRequired_stackClear) return _stackClear;
	hasRequired_stackClear = 1;
	var ListCache = require_ListCache();

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	_stackClear = stackClear;
	return _stackClear;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _stackDelete;
var hasRequired_stackDelete;

function require_stackDelete () {
	if (hasRequired_stackDelete) return _stackDelete;
	hasRequired_stackDelete = 1;
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	_stackDelete = stackDelete;
	return _stackDelete;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

var _stackGet;
var hasRequired_stackGet;

function require_stackGet () {
	if (hasRequired_stackGet) return _stackGet;
	hasRequired_stackGet = 1;
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	_stackGet = stackGet;
	return _stackGet;
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _stackHas;
var hasRequired_stackHas;

function require_stackHas () {
	if (hasRequired_stackHas) return _stackHas;
	hasRequired_stackHas = 1;
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	_stackHas = stackHas;
	return _stackHas;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction_1;
	hasRequiredIsFunction = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var _stackSet;
var hasRequired_stackSet;

function require_stackSet () {
	if (hasRequired_stackSet) return _stackSet;
	hasRequired_stackSet = 1;
	var ListCache = require_ListCache(),
	    Map = require_Map(),
	    MapCache = require_MapCache();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	_stackSet = stackSet;
	return _stackSet;
}

var _Stack;
var hasRequired_Stack;

function require_Stack () {
	if (hasRequired_Stack) return _Stack;
	hasRequired_Stack = 1;
	var ListCache = require_ListCache(),
	    stackClear = require_stackClear(),
	    stackDelete = require_stackDelete(),
	    stackGet = require_stackGet(),
	    stackHas = require_stackHas(),
	    stackSet = require_stackSet();

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	_Stack = Stack;
	return _Stack;
}

var _defineProperty;
var hasRequired_defineProperty;

function require_defineProperty () {
	if (hasRequired_defineProperty) return _defineProperty;
	hasRequired_defineProperty = 1;
	var getNative = require_getNative();

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	_defineProperty = defineProperty;
	return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;

function require_baseAssignValue () {
	if (hasRequired_baseAssignValue) return _baseAssignValue;
	hasRequired_baseAssignValue = 1;
	var defineProperty = require_defineProperty();

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	_baseAssignValue = baseAssignValue;
	return _baseAssignValue;
}

var _assignMergeValue;
var hasRequired_assignMergeValue;

function require_assignMergeValue () {
	if (hasRequired_assignMergeValue) return _assignMergeValue;
	hasRequired_assignMergeValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignMergeValue = assignMergeValue;
	return _assignMergeValue;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

var _createBaseFor;
var hasRequired_createBaseFor;

function require_createBaseFor () {
	if (hasRequired_createBaseFor) return _createBaseFor;
	hasRequired_createBaseFor = 1;
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	_createBaseFor = createBaseFor;
	return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;

function require_baseFor () {
	if (hasRequired_baseFor) return _baseFor;
	hasRequired_baseFor = 1;
	var createBaseFor = require_createBaseFor();

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	_baseFor = baseFor;
	return _baseFor;
}

var _cloneBuffer = {exports: {}};

_cloneBuffer.exports;

var hasRequired_cloneBuffer;

function require_cloneBuffer () {
	if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
	hasRequired_cloneBuffer = 1;
	(function (module, exports) {
		var root = require_root();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));
	return _cloneBuffer.exports;
}

var _Uint8Array;
var hasRequired_Uint8Array;

function require_Uint8Array () {
	if (hasRequired_Uint8Array) return _Uint8Array;
	hasRequired_Uint8Array = 1;
	var root = require_root();

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	_Uint8Array = Uint8Array;
	return _Uint8Array;
}

var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;

function require_cloneArrayBuffer () {
	if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
	hasRequired_cloneArrayBuffer = 1;
	var Uint8Array = require_Uint8Array();

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	_cloneArrayBuffer = cloneArrayBuffer;
	return _cloneArrayBuffer;
}

var _cloneTypedArray;
var hasRequired_cloneTypedArray;

function require_cloneTypedArray () {
	if (hasRequired_cloneTypedArray) return _cloneTypedArray;
	hasRequired_cloneTypedArray = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	_cloneTypedArray = cloneTypedArray;
	return _cloneTypedArray;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

var _copyArray;
var hasRequired_copyArray;

function require_copyArray () {
	if (hasRequired_copyArray) return _copyArray;
	hasRequired_copyArray = 1;
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	_copyArray = copyArray;
	return _copyArray;
}

var _baseCreate;
var hasRequired_baseCreate;

function require_baseCreate () {
	if (hasRequired_baseCreate) return _baseCreate;
	hasRequired_baseCreate = 1;
	var isObject = requireIsObject();

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	_baseCreate = baseCreate;
	return _baseCreate;
}

/** Used for built-in method references. */

var _isPrototype;
var hasRequired_isPrototype;

function require_isPrototype () {
	if (hasRequired_isPrototype) return _isPrototype;
	hasRequired_isPrototype = 1;
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	_isPrototype = isPrototype;
	return _isPrototype;
}

var _initCloneObject;
var hasRequired_initCloneObject;

function require_initCloneObject () {
	if (hasRequired_initCloneObject) return _initCloneObject;
	hasRequired_initCloneObject = 1;
	var baseCreate = require_baseCreate(),
	    getPrototype = require_getPrototype(),
	    isPrototype = require_isPrototype();

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	_initCloneObject = initCloneObject;
	return _initCloneObject;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;

function require_baseIsArguments () {
	if (hasRequired_baseIsArguments) return _baseIsArguments;
	hasRequired_baseIsArguments = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	_baseIsArguments = baseIsArguments;
	return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments_1;
	hasRequiredIsArguments = 1;
	var baseIsArguments = require_baseIsArguments(),
	    isObjectLike = requireIsObjectLike();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	isArguments_1 = isArguments;
	return isArguments_1;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

/** Used as references for various `Number` constants. */

var isLength_1;
var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength_1;
	hasRequiredIsLength = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	isLength_1 = isLength;
	return isLength_1;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike_1;
	hasRequiredIsArrayLike = 1;
	var isFunction = requireIsFunction(),
	    isLength = requireIsLength();

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	isArrayLike_1 = isArrayLike;
	return isArrayLike_1;
}

var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;

function requireIsArrayLikeObject () {
	if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
	hasRequiredIsArrayLikeObject = 1;
	var isArrayLike = requireIsArrayLike(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	isArrayLikeObject_1 = isArrayLikeObject;
	return isArrayLikeObject_1;
}

var isBuffer = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

var stubFalse_1;
var hasRequiredStubFalse;

function requireStubFalse () {
	if (hasRequiredStubFalse) return stubFalse_1;
	hasRequiredStubFalse = 1;
	function stubFalse() {
	  return false;
	}

	stubFalse_1 = stubFalse;
	return stubFalse_1;
}

isBuffer.exports;

var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer.exports;
	hasRequiredIsBuffer = 1;
	(function (module, exports) {
		var root = require_root(),
		    stubFalse = requireStubFalse();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer, isBuffer.exports));
	return isBuffer.exports;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;

function require_baseIsTypedArray () {
	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
	hasRequired_baseIsTypedArray = 1;
	var baseGetTag = require_baseGetTag(),
	    isLength = requireIsLength(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	_baseIsTypedArray = baseIsTypedArray;
	return _baseIsTypedArray;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

var _baseUnary;
var hasRequired_baseUnary;

function require_baseUnary () {
	if (hasRequired_baseUnary) return _baseUnary;
	hasRequired_baseUnary = 1;
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	_baseUnary = baseUnary;
	return _baseUnary;
}

var _nodeUtil = {exports: {}};

_nodeUtil.exports;

var hasRequired_nodeUtil;

function require_nodeUtil () {
	if (hasRequired_nodeUtil) return _nodeUtil.exports;
	hasRequired_nodeUtil = 1;
	(function (module, exports) {
		var freeGlobal = require_freeGlobal();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));
	return _nodeUtil.exports;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray_1;
	hasRequiredIsTypedArray = 1;
	var baseIsTypedArray = require_baseIsTypedArray(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	isTypedArray_1 = isTypedArray;
	return isTypedArray_1;
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _safeGet;
var hasRequired_safeGet;

function require_safeGet () {
	if (hasRequired_safeGet) return _safeGet;
	hasRequired_safeGet = 1;
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	_safeGet = safeGet;
	return _safeGet;
}

var _assignValue;
var hasRequired_assignValue;

function require_assignValue () {
	if (hasRequired_assignValue) return _assignValue;
	hasRequired_assignValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignValue = assignValue;
	return _assignValue;
}

var _copyObject;
var hasRequired_copyObject;

function require_copyObject () {
	if (hasRequired_copyObject) return _copyObject;
	hasRequired_copyObject = 1;
	var assignValue = require_assignValue(),
	    baseAssignValue = require_baseAssignValue();

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	_copyObject = copyObject;
	return _copyObject;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

var _baseTimes;
var hasRequired_baseTimes;

function require_baseTimes () {
	if (hasRequired_baseTimes) return _baseTimes;
	hasRequired_baseTimes = 1;
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	_baseTimes = baseTimes;
	return _baseTimes;
}

/** Used as references for various `Number` constants. */

var _isIndex;
var hasRequired_isIndex;

function require_isIndex () {
	if (hasRequired_isIndex) return _isIndex;
	hasRequired_isIndex = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	_isIndex = isIndex;
	return _isIndex;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;

function require_arrayLikeKeys () {
	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
	hasRequired_arrayLikeKeys = 1;
	var baseTimes = require_baseTimes(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isIndex = require_isIndex(),
	    isTypedArray = requireIsTypedArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_arrayLikeKeys = arrayLikeKeys;
	return _arrayLikeKeys;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

var _nativeKeysIn;
var hasRequired_nativeKeysIn;

function require_nativeKeysIn () {
	if (hasRequired_nativeKeysIn) return _nativeKeysIn;
	hasRequired_nativeKeysIn = 1;
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_nativeKeysIn = nativeKeysIn;
	return _nativeKeysIn;
}

var _baseKeysIn;
var hasRequired_baseKeysIn;

function require_baseKeysIn () {
	if (hasRequired_baseKeysIn) return _baseKeysIn;
	hasRequired_baseKeysIn = 1;
	var isObject = requireIsObject(),
	    isPrototype = require_isPrototype(),
	    nativeKeysIn = require_nativeKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeysIn = baseKeysIn;
	return _baseKeysIn;
}

var keysIn_1;
var hasRequiredKeysIn;

function requireKeysIn () {
	if (hasRequiredKeysIn) return keysIn_1;
	hasRequiredKeysIn = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeysIn = require_baseKeysIn(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	keysIn_1 = keysIn;
	return keysIn_1;
}

var toPlainObject_1;
var hasRequiredToPlainObject;

function requireToPlainObject () {
	if (hasRequiredToPlainObject) return toPlainObject_1;
	hasRequiredToPlainObject = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	toPlainObject_1 = toPlainObject;
	return toPlainObject_1;
}

var _baseMergeDeep;
var hasRequired_baseMergeDeep;

function require_baseMergeDeep () {
	if (hasRequired_baseMergeDeep) return _baseMergeDeep;
	hasRequired_baseMergeDeep = 1;
	var assignMergeValue = require_assignMergeValue(),
	    cloneBuffer = require_cloneBuffer(),
	    cloneTypedArray = require_cloneTypedArray(),
	    copyArray = require_copyArray(),
	    initCloneObject = require_initCloneObject(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isArrayLikeObject = requireIsArrayLikeObject(),
	    isBuffer = requireIsBuffer(),
	    isFunction = requireIsFunction(),
	    isObject = requireIsObject(),
	    isPlainObject = requireIsPlainObject(),
	    isTypedArray = requireIsTypedArray(),
	    safeGet = require_safeGet(),
	    toPlainObject = requireToPlainObject();

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	_baseMergeDeep = baseMergeDeep;
	return _baseMergeDeep;
}

var _baseMerge;
var hasRequired_baseMerge;

function require_baseMerge () {
	if (hasRequired_baseMerge) return _baseMerge;
	hasRequired_baseMerge = 1;
	var Stack = require_Stack(),
	    assignMergeValue = require_assignMergeValue(),
	    baseFor = require_baseFor(),
	    baseMergeDeep = require_baseMergeDeep(),
	    isObject = requireIsObject(),
	    keysIn = requireKeysIn(),
	    safeGet = require_safeGet();

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	_baseMerge = baseMerge;
	return _baseMerge;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

var identity_1;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity_1;
	hasRequiredIdentity = 1;
	function identity(value) {
	  return value;
	}

	identity_1 = identity;
	return identity_1;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

var _apply;
var hasRequired_apply;

function require_apply () {
	if (hasRequired_apply) return _apply;
	hasRequired_apply = 1;
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	_apply = apply;
	return _apply;
}

var _overRest;
var hasRequired_overRest;

function require_overRest () {
	if (hasRequired_overRest) return _overRest;
	hasRequired_overRest = 1;
	var apply = require_apply();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	_overRest = overRest;
	return _overRest;
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

var constant_1;
var hasRequiredConstant;

function requireConstant () {
	if (hasRequiredConstant) return constant_1;
	hasRequiredConstant = 1;
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	constant_1 = constant;
	return constant_1;
}

var _baseSetToString;
var hasRequired_baseSetToString;

function require_baseSetToString () {
	if (hasRequired_baseSetToString) return _baseSetToString;
	hasRequired_baseSetToString = 1;
	var constant = requireConstant(),
	    defineProperty = require_defineProperty(),
	    identity = requireIdentity();

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	_baseSetToString = baseSetToString;
	return _baseSetToString;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */

var _shortOut;
var hasRequired_shortOut;

function require_shortOut () {
	if (hasRequired_shortOut) return _shortOut;
	hasRequired_shortOut = 1;
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	_shortOut = shortOut;
	return _shortOut;
}

var _setToString;
var hasRequired_setToString;

function require_setToString () {
	if (hasRequired_setToString) return _setToString;
	hasRequired_setToString = 1;
	var baseSetToString = require_baseSetToString(),
	    shortOut = require_shortOut();

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	_setToString = setToString;
	return _setToString;
}

var _baseRest;
var hasRequired_baseRest;

function require_baseRest () {
	if (hasRequired_baseRest) return _baseRest;
	hasRequired_baseRest = 1;
	var identity = requireIdentity(),
	    overRest = require_overRest(),
	    setToString = require_setToString();

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	_baseRest = baseRest;
	return _baseRest;
}

var _isIterateeCall;
var hasRequired_isIterateeCall;

function require_isIterateeCall () {
	if (hasRequired_isIterateeCall) return _isIterateeCall;
	hasRequired_isIterateeCall = 1;
	var eq = requireEq(),
	    isArrayLike = requireIsArrayLike(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject();

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	_isIterateeCall = isIterateeCall;
	return _isIterateeCall;
}

var _createAssigner;
var hasRequired_createAssigner;

function require_createAssigner () {
	if (hasRequired_createAssigner) return _createAssigner;
	hasRequired_createAssigner = 1;
	var baseRest = require_baseRest(),
	    isIterateeCall = require_isIterateeCall();

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	_createAssigner = createAssigner;
	return _createAssigner;
}

var merge_1;
var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge_1;
	hasRequiredMerge = 1;
	var baseMerge = require_baseMerge(),
	    createAssigner = require_createAssigner();

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	merge_1 = merge;
	return merge_1;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

var _arrayEach;
var hasRequired_arrayEach;

function require_arrayEach () {
	if (hasRequired_arrayEach) return _arrayEach;
	hasRequired_arrayEach = 1;
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	_arrayEach = arrayEach;
	return _arrayEach;
}

var _nativeKeys;
var hasRequired_nativeKeys;

function require_nativeKeys () {
	if (hasRequired_nativeKeys) return _nativeKeys;
	hasRequired_nativeKeys = 1;
	var overArg = require_overArg();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	_nativeKeys = nativeKeys;
	return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;

function require_baseKeys () {
	if (hasRequired_baseKeys) return _baseKeys;
	hasRequired_baseKeys = 1;
	var isPrototype = require_isPrototype(),
	    nativeKeys = require_nativeKeys();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeys = baseKeys;
	return _baseKeys;
}

var keys_1;
var hasRequiredKeys;

function requireKeys () {
	if (hasRequiredKeys) return keys_1;
	hasRequiredKeys = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeys = require_baseKeys(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	keys_1 = keys;
	return keys_1;
}

var _baseAssign;
var hasRequired_baseAssign;

function require_baseAssign () {
	if (hasRequired_baseAssign) return _baseAssign;
	hasRequired_baseAssign = 1;
	var copyObject = require_copyObject(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	_baseAssign = baseAssign;
	return _baseAssign;
}

var _baseAssignIn;
var hasRequired_baseAssignIn;

function require_baseAssignIn () {
	if (hasRequired_baseAssignIn) return _baseAssignIn;
	hasRequired_baseAssignIn = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	_baseAssignIn = baseAssignIn;
	return _baseAssignIn;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

var _arrayFilter;
var hasRequired_arrayFilter;

function require_arrayFilter () {
	if (hasRequired_arrayFilter) return _arrayFilter;
	hasRequired_arrayFilter = 1;
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	_arrayFilter = arrayFilter;
	return _arrayFilter;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

var stubArray_1;
var hasRequiredStubArray;

function requireStubArray () {
	if (hasRequiredStubArray) return stubArray_1;
	hasRequiredStubArray = 1;
	function stubArray() {
	  return [];
	}

	stubArray_1 = stubArray;
	return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;

function require_getSymbols () {
	if (hasRequired_getSymbols) return _getSymbols;
	hasRequired_getSymbols = 1;
	var arrayFilter = require_arrayFilter(),
	    stubArray = requireStubArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	_getSymbols = getSymbols;
	return _getSymbols;
}

var _copySymbols;
var hasRequired_copySymbols;

function require_copySymbols () {
	if (hasRequired_copySymbols) return _copySymbols;
	hasRequired_copySymbols = 1;
	var copyObject = require_copyObject(),
	    getSymbols = require_getSymbols();

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	_copySymbols = copySymbols;
	return _copySymbols;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

var _arrayPush;
var hasRequired_arrayPush;

function require_arrayPush () {
	if (hasRequired_arrayPush) return _arrayPush;
	hasRequired_arrayPush = 1;
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	_arrayPush = arrayPush;
	return _arrayPush;
}

var _getSymbolsIn;
var hasRequired_getSymbolsIn;

function require_getSymbolsIn () {
	if (hasRequired_getSymbolsIn) return _getSymbolsIn;
	hasRequired_getSymbolsIn = 1;
	var arrayPush = require_arrayPush(),
	    getPrototype = require_getPrototype(),
	    getSymbols = require_getSymbols(),
	    stubArray = requireStubArray();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	_getSymbolsIn = getSymbolsIn;
	return _getSymbolsIn;
}

var _copySymbolsIn;
var hasRequired_copySymbolsIn;

function require_copySymbolsIn () {
	if (hasRequired_copySymbolsIn) return _copySymbolsIn;
	hasRequired_copySymbolsIn = 1;
	var copyObject = require_copyObject(),
	    getSymbolsIn = require_getSymbolsIn();

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	_copySymbolsIn = copySymbolsIn;
	return _copySymbolsIn;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;

function require_baseGetAllKeys () {
	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
	hasRequired_baseGetAllKeys = 1;
	var arrayPush = require_arrayPush(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	_baseGetAllKeys = baseGetAllKeys;
	return _baseGetAllKeys;
}

var _getAllKeys;
var hasRequired_getAllKeys;

function require_getAllKeys () {
	if (hasRequired_getAllKeys) return _getAllKeys;
	hasRequired_getAllKeys = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbols = require_getSymbols(),
	    keys = requireKeys();

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	_getAllKeys = getAllKeys;
	return _getAllKeys;
}

var _getAllKeysIn;
var hasRequired_getAllKeysIn;

function require_getAllKeysIn () {
	if (hasRequired_getAllKeysIn) return _getAllKeysIn;
	hasRequired_getAllKeysIn = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbolsIn = require_getSymbolsIn(),
	    keysIn = requireKeysIn();

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}

	_getAllKeysIn = getAllKeysIn;
	return _getAllKeysIn;
}

var _DataView;
var hasRequired_DataView;

function require_DataView () {
	if (hasRequired_DataView) return _DataView;
	hasRequired_DataView = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	_DataView = DataView;
	return _DataView;
}

var _Promise;
var hasRequired_Promise;

function require_Promise () {
	if (hasRequired_Promise) return _Promise;
	hasRequired_Promise = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	_Promise = Promise;
	return _Promise;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	_Set = Set;
	return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;

function require_WeakMap () {
	if (hasRequired_WeakMap) return _WeakMap;
	hasRequired_WeakMap = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	_WeakMap = WeakMap;
	return _WeakMap;
}

var _getTag;
var hasRequired_getTag;

function require_getTag () {
	if (hasRequired_getTag) return _getTag;
	hasRequired_getTag = 1;
	var DataView = require_DataView(),
	    Map = require_Map(),
	    Promise = require_Promise(),
	    Set = require_Set(),
	    WeakMap = require_WeakMap(),
	    baseGetTag = require_baseGetTag(),
	    toSource = require_toSource();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	_getTag = getTag;
	return _getTag;
}

/** Used for built-in method references. */

var _initCloneArray;
var hasRequired_initCloneArray;

function require_initCloneArray () {
	if (hasRequired_initCloneArray) return _initCloneArray;
	hasRequired_initCloneArray = 1;
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	_initCloneArray = initCloneArray;
	return _initCloneArray;
}

var _cloneDataView;
var hasRequired_cloneDataView;

function require_cloneDataView () {
	if (hasRequired_cloneDataView) return _cloneDataView;
	hasRequired_cloneDataView = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	_cloneDataView = cloneDataView;
	return _cloneDataView;
}

/** Used to match `RegExp` flags from their coerced string values. */

var _cloneRegExp;
var hasRequired_cloneRegExp;

function require_cloneRegExp () {
	if (hasRequired_cloneRegExp) return _cloneRegExp;
	hasRequired_cloneRegExp = 1;
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	_cloneRegExp = cloneRegExp;
	return _cloneRegExp;
}

var _cloneSymbol;
var hasRequired_cloneSymbol;

function require_cloneSymbol () {
	if (hasRequired_cloneSymbol) return _cloneSymbol;
	hasRequired_cloneSymbol = 1;
	var Symbol = require_Symbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	_cloneSymbol = cloneSymbol;
	return _cloneSymbol;
}

var _initCloneByTag;
var hasRequired_initCloneByTag;

function require_initCloneByTag () {
	if (hasRequired_initCloneByTag) return _initCloneByTag;
	hasRequired_initCloneByTag = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer(),
	    cloneDataView = require_cloneDataView(),
	    cloneRegExp = require_cloneRegExp(),
	    cloneSymbol = require_cloneSymbol(),
	    cloneTypedArray = require_cloneTypedArray();

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return new Ctor;

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return new Ctor;

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	_initCloneByTag = initCloneByTag;
	return _initCloneByTag;
}

var _baseIsMap;
var hasRequired_baseIsMap;

function require_baseIsMap () {
	if (hasRequired_baseIsMap) return _baseIsMap;
	hasRequired_baseIsMap = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag(value) == mapTag;
	}

	_baseIsMap = baseIsMap;
	return _baseIsMap;
}

var isMap_1;
var hasRequiredIsMap;

function requireIsMap () {
	if (hasRequiredIsMap) return isMap_1;
	hasRequiredIsMap = 1;
	var baseIsMap = require_baseIsMap(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	isMap_1 = isMap;
	return isMap_1;
}

var _baseIsSet;
var hasRequired_baseIsSet;

function require_baseIsSet () {
	if (hasRequired_baseIsSet) return _baseIsSet;
	hasRequired_baseIsSet = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var setTag = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag(value) == setTag;
	}

	_baseIsSet = baseIsSet;
	return _baseIsSet;
}

var isSet_1;
var hasRequiredIsSet;

function requireIsSet () {
	if (hasRequiredIsSet) return isSet_1;
	hasRequiredIsSet = 1;
	var baseIsSet = require_baseIsSet(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	isSet_1 = isSet;
	return isSet_1;
}

var _baseClone;
var hasRequired_baseClone;

function require_baseClone () {
	if (hasRequired_baseClone) return _baseClone;
	hasRequired_baseClone = 1;
	var Stack = require_Stack(),
	    arrayEach = require_arrayEach(),
	    assignValue = require_assignValue(),
	    baseAssign = require_baseAssign(),
	    baseAssignIn = require_baseAssignIn(),
	    cloneBuffer = require_cloneBuffer(),
	    copyArray = require_copyArray(),
	    copySymbols = require_copySymbols(),
	    copySymbolsIn = require_copySymbolsIn(),
	    getAllKeys = require_getAllKeys(),
	    getAllKeysIn = require_getAllKeysIn(),
	    getTag = require_getTag(),
	    initCloneArray = require_initCloneArray(),
	    initCloneByTag = require_initCloneByTag(),
	    initCloneObject = require_initCloneObject(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isMap = requireIsMap(),
	    isObject = requireIsObject(),
	    isSet = requireIsSet(),
	    keys = requireKeys(),
	    keysIn = requireKeysIn();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	_baseClone = baseClone;
	return _baseClone;
}

var cloneDeep_1;
var hasRequiredCloneDeep;

function requireCloneDeep () {
	if (hasRequiredCloneDeep) return cloneDeep_1;
	hasRequiredCloneDeep = 1;
	var baseClone = require_baseClone();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	cloneDeep_1 = cloneDeep;
	return cloneDeep_1;
}

var tools;
var hasRequiredTools;

function requireTools () {
	if (hasRequiredTools) return tools;
	hasRequiredTools = 1;

	// Generated by CoffeeScript 2.5.1
	var cloneDeep, htmlparser, isPlainObject, merge, _objectToDom, self;

	htmlparser = requireLib$3();

	var _require = requireDomConverter();

	_objectToDom = _require.objectToDom;
	merge = requireMerge();
	cloneDeep = requireCloneDeep();
	isPlainObject = requireIsPlainObject();
	tools = self = {
	  repeatString: function repeatString(str, times) {
	    var j, output, ref;
	    output = '';

	    for (j = 0, ref = times; 0 <= ref ? j < ref : j > ref; 0 <= ref ? ++j : --j) {
	      output += str;
	    }

	    return output;
	  },
	  cloneAndMergeDeep: function cloneAndMergeDeep(base, toAppend) {
	    return merge(cloneDeep(base), toAppend);
	  },
	  toDom: function toDom(subject) {
	    if (typeof subject === 'string') {
	      return self.stringToDom(subject);
	    } else if (isPlainObject(subject)) {
	      return self._objectToDom(subject);
	    } else {
	      throw Error("tools.toDom() only supports strings and objects");
	    }
	  },
	  stringToDom: function stringToDom(string) {
	    var handler, parser;
	    handler = new htmlparser.DomHandler();
	    parser = new htmlparser.Parser(handler);
	    parser.write(string);
	    parser.end();
	    return handler.dom;
	  },
	  _fixQuotesInDom: function _fixQuotesInDom(input) {
	    var j, len, node;

	    if (Array.isArray(input)) {
	      for (j = 0, len = input.length; j < len; j++) {
	        node = input[j];

	        self._fixQuotesInDom(node);
	      }

	      return input;
	    }

	    node = input;

	    if (node.type === 'text') {
	      return node.data = self._quoteNodeText(node.data);
	    } else {
	      return self._fixQuotesInDom(node.children);
	    }
	  },
	  objectToDom: function objectToDom(o) {
	    if (!Array.isArray(o)) {
	      if (!isPlainObject(o)) {
	        throw Error("objectToDom() only accepts a bare object or an array");
	      }
	    }

	    return self._fixQuotesInDom(_objectToDom(o));
	  },
	  quote: function quote(str) {
	    return String(str).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\ /g, '&sp;').replace(/\n/g, '<br />');
	  },
	  _quoteNodeText: function _quoteNodeText(text) {
	    return String(text).replace(/\&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\ /g, '&sp;').replace(/\n/g, "&nl;");
	  },
	  getCols: function getCols() {
	    var cols, tty; // Based on https://github.com/jonschlinkert/window-size

	    tty = require$$5;

	    cols = function () {
	      try {
	        if (tty.isatty(1) && tty.isatty(2)) {
	          if (process.stdout.getWindowSize) {
	            return process.stdout.getWindowSize(1)[0];
	          } else if (tty.getWindowSize) {
	            return tty.getWindowSize()[1];
	          } else if (process.stdout.columns) {
	            return process.stdout.columns;
	          }
	        }
	      } catch (error) {}
	    }();

	    if (typeof cols === 'number' && cols > 30) {
	      return cols;
	    } else {
	      return 80;
	    }
	  }
	};
	return tools;
}

var tags_1;
var hasRequiredTags;

function requireTags () {
	if (hasRequiredTags) return tags_1;
	hasRequiredTags = 1;

	// Generated by CoffeeScript 2.5.1
	var color, colors, i, len, tags;
	tags_1 = tags = {
	  'none': {
	    color: 'none',
	    bg: 'none'
	  },
	  'bg-none': {
	    color: 'inherit',
	    bg: 'none'
	  },
	  'color-none': {
	    color: 'none',
	    bg: 'inherit'
	  }
	};
	colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'grey', 'bright-red', 'bright-green', 'bright-yellow', 'bright-blue', 'bright-magenta', 'bright-cyan', 'bright-white'];

	for (i = 0, len = colors.length; i < len; i++) {
	  color = colors[i];
	  tags[color] = {
	    color: color,
	    bg: 'inherit'
	  };
	  tags["color-".concat(color)] = {
	    color: color,
	    bg: 'inherit'
	  };
	  tags["bg-".concat(color)] = {
	    color: 'inherit',
	    bg: color
	  };
	}
	return tags_1;
}

var styles_1;
var hasRequiredStyles$1;

function requireStyles$1 () {
	if (hasRequiredStyles$1) return styles_1;
	hasRequiredStyles$1 = 1;

	// Generated by CoffeeScript 2.5.1
	var codes, styles;
	styles_1 = styles = {};
	styles.codes = codes = {
	  'none': 0,
	  'black': 30,
	  'red': 31,
	  'green': 32,
	  'yellow': 33,
	  'blue': 34,
	  'magenta': 35,
	  'cyan': 36,
	  'white': 37,
	  'grey': 90,
	  'bright-red': 91,
	  'bright-green': 92,
	  'bright-yellow': 93,
	  'bright-blue': 94,
	  'bright-magenta': 95,
	  'bright-cyan': 96,
	  'bright-white': 97,
	  'bg-black': 40,
	  'bg-red': 41,
	  'bg-green': 42,
	  'bg-yellow': 43,
	  'bg-blue': 44,
	  'bg-magenta': 45,
	  'bg-cyan': 46,
	  'bg-white': 47,
	  'bg-grey': 100,
	  'bg-bright-red': 101,
	  'bg-bright-green': 102,
	  'bg-bright-yellow': 103,
	  'bg-bright-blue': 104,
	  'bg-bright-magenta': 105,
	  'bg-bright-cyan': 106,
	  'bg-bright-white': 107
	};

	styles.color = function (str) {
	  var code;

	  if (str === 'none') {
	    return '';
	  }

	  code = codes[str];

	  if (code == null) {
	    throw Error("Unknown color `".concat(str, "`"));
	  }

	  return "\x1b[" + code + "m";
	};

	styles.bg = function (str) {
	  var code;

	  if (str === 'none') {
	    return '';
	  }

	  code = codes['bg-' + str];

	  if (code == null) {
	    throw Error("Unknown bg color `".concat(str, "`"));
	  }

	  return "\x1B[" + code + "m";
	};

	styles.none = function (str) {
	  return "\x1B[" + codes.none + "m";
	};
	return styles_1;
}

var AnsiPainter_1;
var hasRequiredAnsiPainter;

function requireAnsiPainter () {
	if (hasRequiredAnsiPainter) return AnsiPainter_1;
	hasRequiredAnsiPainter = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var styles,
	    tags,
	    tools,
	    hasProp = {}.hasOwnProperty;
	tools = requireTools();
	tags = requireTags();
	styles = requireStyles$1();

	AnsiPainter_1 = function () {
	  var self;

	  var AnsiPainter = /*#__PURE__*/function () {
	    function AnsiPainter() {
	      _classCallCheck(this, AnsiPainter);
	    }

	    _createClass(AnsiPainter, [{
	      key: "paint",
	      value: function paint(s) {
	        return this._replaceSpecialStrings(this._renderDom(this._parse(s)));
	      }
	    }, {
	      key: "_replaceSpecialStrings",
	      value: function _replaceSpecialStrings(str) {
	        return str.replace(/&sp;/g, ' ').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&amp;/g, '&');
	      }
	    }, {
	      key: "_parse",
	      value: function _parse(string) {
	        var injectFakeRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	        if (injectFakeRoot) {
	          string = '<none>' + string + '</none>';
	        }

	        return tools.toDom(string);
	      }
	    }, {
	      key: "_renderDom",
	      value: function _renderDom(dom) {
	        var parentStyles;
	        parentStyles = {
	          bg: 'none',
	          color: 'none'
	        };
	        return this._renderChildren(dom, parentStyles);
	      }
	    }, {
	      key: "_renderChildren",
	      value: function _renderChildren(children, parentStyles) {
	        var child, n, ret;
	        ret = '';

	        for (n in children) {
	          if (!hasProp.call(children, n)) continue;
	          child = children[n];
	          ret += this._renderNode(child, parentStyles);
	        }

	        return ret;
	      }
	    }, {
	      key: "_renderNode",
	      value: function _renderNode(node, parentStyles) {
	        if (node.type === 'text') {
	          return this._renderTextNode(node, parentStyles);
	        } else {
	          return this._renderTag(node, parentStyles);
	        }
	      }
	    }, {
	      key: "_renderTextNode",
	      value: function _renderTextNode(node, parentStyles) {
	        return this._wrapInStyle(node.data, parentStyles);
	      }
	    }, {
	      key: "_wrapInStyle",
	      value: function _wrapInStyle(str, style) {
	        return styles.color(style.color) + styles.bg(style.bg) + str + styles.none();
	      }
	    }, {
	      key: "_renderTag",
	      value: function _renderTag(node, parentStyles) {
	        var currentStyles, tagStyles;
	        tagStyles = this._getStylesForTagName(node.name);
	        currentStyles = this._mixStyles(parentStyles, tagStyles);
	        return this._renderChildren(node.children, currentStyles);
	      }
	    }, {
	      key: "_mixStyles",
	      value: function _mixStyles() {
	        var final, i, key, len, style, val;
	        final = {};

	        for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
	          styles[_key] = arguments[_key];
	        }

	        for (i = 0, len = styles.length; i < len; i++) {
	          style = styles[i];

	          for (key in style) {
	            if (!hasProp.call(style, key)) continue;
	            val = style[key];

	            if (final[key] == null || val !== 'inherit') {
	              final[key] = val;
	            }
	          }
	        }

	        return final;
	      }
	    }, {
	      key: "_getStylesForTagName",
	      value: function _getStylesForTagName(name) {
	        if (tags[name] == null) {
	          throw Error("Unknown tag name `".concat(name, "`"));
	        }

	        return tags[name];
	      }
	    }], [{
	      key: "getInstance",
	      value: function getInstance() {
	        if (self._instance == null) {
	          self._instance = new self();
	        }

	        return self._instance;
	      }
	    }, {
	      key: "paint",
	      value: function paint(str) {
	        return self.getInstance().paint(str);
	      }
	    }, {
	      key: "strip",
	      value: function strip(s) {
	        return s.replace(/\x1b\[[0-9]+m/g, '');
	      }
	    }]);

	    return AnsiPainter;
	  }();
	  AnsiPainter.tags = tags;
	  self = AnsiPainter;
	  return AnsiPainter;
	}.call(void 0);
	return AnsiPainter_1;
}

var _common_1;
var hasRequired_common;

function require_common () {
	if (hasRequired_common) return _common_1;
	hasRequired_common = 1;

	// Generated by CoffeeScript 2.5.1
	var AnsiPainter;

	AnsiPainter = requireAnsiPainter();
	_common_1 = {
	  getStyleTagsFor: function getStyleTagsFor(style) {
	    var i, len, ret, tag, tagName, tagsToAdd;
	    tagsToAdd = [];

	    if (style.color != null) {
	      tagName = 'color-' + style.color;

	      if (AnsiPainter.tags[tagName] == null) {
	        throw Error("Unknown color `".concat(style.color, "`"));
	      }

	      tagsToAdd.push(tagName);
	    }

	    if (style.background != null) {
	      tagName = 'bg-' + style.background;

	      if (AnsiPainter.tags[tagName] == null) {
	        throw Error("Unknown background `".concat(style.background, "`"));
	      }

	      tagsToAdd.push(tagName);
	    }

	    ret = {
	      before: '',
	      after: ''
	    };

	    for (i = 0, len = tagsToAdd.length; i < len; i++) {
	      tag = tagsToAdd[i];
	      ret.before = "<".concat(tag, ">") + ret.before;
	      ret.after = ret.after + "</".concat(tag, ">");
	    }

	    return ret;
	  }
	};
	return _common_1;
}

var inline$1;
var hasRequiredInline$1;

function requireInline$1 () {
	if (hasRequiredInline$1) return inline$1;
	hasRequiredInline$1 = 1;

	// Generated by CoffeeScript 2.5.1
	var _common, tools;

	tools = requireTools();
	_common = require_common();
	inline$1 = {
	  applyTo: function applyTo(el, style) {
	    var ret;
	    ret = _common.getStyleTagsFor(style);

	    if (style.marginLeft != null) {
	      ret.before = tools.repeatString("&sp;", parseInt(style.marginLeft)) + ret.before;
	    }

	    if (style.marginRight != null) {
	      ret.after += tools.repeatString("&sp;", parseInt(style.marginRight));
	    }

	    if (style.paddingLeft != null) {
	      ret.before += tools.repeatString("&sp;", parseInt(style.paddingLeft));
	    }

	    if (style.paddingRight != null) {
	      ret.after = tools.repeatString("&sp;", parseInt(style.paddingRight)) + ret.after;
	    }

	    return ret;
	  }
	};
	return inline$1;
}

var block;
var hasRequiredBlock$1;

function requireBlock$1 () {
	if (hasRequiredBlock$1) return block;
	hasRequiredBlock$1 = 1;

	// Generated by CoffeeScript 2.5.1
	var _common, merge;

	_common = require_common();
	merge = requireMerge();
	block = {
	  applyTo: function applyTo(el, style) {
	    var config, ret;
	    ret = _common.getStyleTagsFor(style);
	    ret.blockConfig = config = {};

	    this._margins(style, config);

	    this._bullet(style, config);

	    this._dims(style, config);

	    return ret;
	  },
	  _margins: function _margins(style, config) {
	    if (style.marginLeft != null) {
	      merge(config, {
	        linePrependor: {
	          options: {
	            amount: parseInt(style.marginLeft)
	          }
	        }
	      });
	    }

	    if (style.marginRight != null) {
	      merge(config, {
	        lineAppendor: {
	          options: {
	            amount: parseInt(style.marginRight)
	          }
	        }
	      });
	    }

	    if (style.marginTop != null) {
	      merge(config, {
	        blockPrependor: {
	          options: {
	            amount: parseInt(style.marginTop)
	          }
	        }
	      });
	    }

	    if (style.marginBottom != null) {
	      merge(config, {
	        blockAppendor: {
	          options: {
	            amount: parseInt(style.marginBottom)
	          }
	        }
	      });
	    }
	  },
	  _bullet: function _bullet(style, config) {
	    var after, before, bullet, conf;

	    if (style.bullet != null && style.bullet.enabled) {
	      bullet = style.bullet;
	      conf = {};
	      conf.alignment = style.bullet.alignment;

	      var _common$getStyleTagsF = _common.getStyleTagsFor({
	        color: bullet.color,
	        background: bullet.background
	      });

	      before = _common$getStyleTagsF.before;
	      after = _common$getStyleTagsF.after;
	      conf.char = before + bullet.char + after;
	      merge(config, {
	        linePrependor: {
	          options: {
	            bullet: conf
	          }
	        }
	      });
	    }
	  },
	  _dims: function _dims(style, config) {
	    var w;

	    if (style.width != null) {
	      w = parseInt(style.width);
	      config.width = w;
	    }
	  }
	};
	return block;
}

var lib$3 = {};

var boolbase;
var hasRequiredBoolbase;

function requireBoolbase () {
	if (hasRequiredBoolbase) return boolbase;
	hasRequiredBoolbase = 1;
	boolbase = {
		trueFunc: function trueFunc(){
			return true;
		},
		falseFunc: function falseFunc(){
			return false;
		}
	};
	return boolbase;
}

var compile$1 = {};

var SelectorType;
(function (SelectorType) {
    SelectorType["Attribute"] = "attribute";
    SelectorType["Pseudo"] = "pseudo";
    SelectorType["PseudoElement"] = "pseudo-element";
    SelectorType["Tag"] = "tag";
    SelectorType["Universal"] = "universal";
    // Traversals
    SelectorType["Adjacent"] = "adjacent";
    SelectorType["Child"] = "child";
    SelectorType["Descendant"] = "descendant";
    SelectorType["Parent"] = "parent";
    SelectorType["Sibling"] = "sibling";
    SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false,
};
var AttributeAction;
(function (AttributeAction) {
    AttributeAction["Any"] = "any";
    AttributeAction["Element"] = "element";
    AttributeAction["End"] = "end";
    AttributeAction["Equals"] = "equals";
    AttributeAction["Exists"] = "exists";
    AttributeAction["Hyphen"] = "hyphen";
    AttributeAction["Not"] = "not";
    AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([
    [126 /* Tilde */, AttributeAction.Element],
    [94 /* Circumflex */, AttributeAction.Start],
    [36 /* Dollar */, AttributeAction.End],
    [42 /* Asterisk */, AttributeAction.Any],
    [33 /* ExclamationMark */, AttributeAction.Not],
    [124 /* Pipe */, AttributeAction.Hyphen],
]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    switch (selector.type) {
        case SelectorType.Adjacent:
        case SelectorType.Child:
        case SelectorType.Descendant:
        case SelectorType.Parent:
        case SelectorType.Sibling:
        case SelectorType.ColumnCombinator:
            return true;
        default:
            return false;
    }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    const high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isQuote(c) {
    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}
function isWhitespace(c) {
    return (c === 32 /* Space */ ||
        c === 9 /* Tab */ ||
        c === 10 /* NewLine */ ||
        c === 12 /* FormFeed */ ||
        c === 13 /* CarriageReturn */);
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$2(selector) {
    const subselects = [];
    const endIndex = parseSelector(subselects, `${selector}`, 0);
    if (endIndex < selector.length) {
        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
    }
    return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
    let tokens = [];
    function getName(offset) {
        const match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
        }
        const [name] = match;
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))) {
            selectorIndex++;
        }
    }
    function readValueWithParenthesis() {
        selectorIndex += 1;
        const start = selectorIndex;
        let counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
            if (selector.charCodeAt(selectorIndex) ===
                40 /* LeftParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter++;
            }
            else if (selector.charCodeAt(selectorIndex) ===
                41 /* RightParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter--;
            }
        }
        if (counter) {
            throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
        let slashCount = 0;
        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    function addTraversal(type) {
        if (tokens.length > 0 &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens[tokens.length - 1].type = type;
            return;
        }
        ensureNotTraversal();
        tokens.push({ type });
    }
    function addSpecialAttribute(name, action) {
        tokens.push({
            type: SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
        });
    }
    /**
     * We have finished parsing the current part of the selector.
     *
     * Remove descendant tokens at the end if they exist,
     * and return the last index, so that parsing can be
     * picked up from here.
     */
    function finalizeSubselector() {
        if (tokens.length &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens.pop();
        }
        if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
        return selectorIndex;
    }
    loop: while (selectorIndex < selector.length) {
        const firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
            case 10 /* NewLine */:
            case 12 /* FormFeed */:
            case 13 /* CarriageReturn */: {
                if (tokens.length === 0 ||
                    tokens[0].type !== SelectorType.Descendant) {
                    ensureNotTraversal();
                    tokens.push({ type: SelectorType.Descendant });
                }
                stripWhitespace(1);
                break;
            }
            // Traversals
            case 62 /* GreaterThan */: {
                addTraversal(SelectorType.Child);
                stripWhitespace(1);
                break;
            }
            case 60 /* LessThan */: {
                addTraversal(SelectorType.Parent);
                stripWhitespace(1);
                break;
            }
            case 126 /* Tilde */: {
                addTraversal(SelectorType.Sibling);
                stripWhitespace(1);
                break;
            }
            case 43 /* Plus */: {
                addTraversal(SelectorType.Adjacent);
                stripWhitespace(1);
                break;
            }
            // Special attribute selectors: .class, #id
            case 46 /* Period */: {
                addSpecialAttribute("class", AttributeAction.Element);
                break;
            }
            case 35 /* Hash */: {
                addSpecialAttribute("id", AttributeAction.Equals);
                break;
            }
            case 91 /* LeftSquareBracket */: {
                stripWhitespace(1);
                // Determine attribute name and namespace
                let name;
                let namespace = null;
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                    // Equivalent to no namespace
                    name = getName(1);
                }
                else if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    name = getName(2);
                }
                else {
                    name = getName(0);
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                        selector.charCodeAt(selectorIndex + 1) !==
                            61 /* Equal */) {
                        namespace = name;
                        name = getName(1);
                    }
                }
                stripWhitespace(0);
                // Determine comparison operation
                let action = AttributeAction.Exists;
                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charCodeAt(selectorIndex + 1) !==
                        61 /* Equal */) {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                    action = AttributeAction.Equals;
                    stripWhitespace(1);
                }
                // Determine value
                let value = "";
                let ignoreCase = null;
                if (action !== "exists") {
                    if (isQuote(selector.charCodeAt(selectorIndex))) {
                        const quote = selector.charCodeAt(selectorIndex);
                        let sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charCodeAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charCodeAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        const valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                selector.charCodeAt(selectorIndex) !==
                                    93 /* RightSquareBracket */) ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === 115 /* LowerS */) {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === 105 /* LowerI */) {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                if (selector.charCodeAt(selectorIndex) !==
                    93 /* RightSquareBracket */) {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                const attributeSelector = {
                    type: SelectorType.Attribute,
                    name,
                    action,
                    value,
                    namespace,
                    ignoreCase,
                };
                tokens.push(attributeSelector);
                break;
            }
            case 58 /* Colon */: {
                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                    tokens.push({
                        type: SelectorType.PseudoElement,
                        name: getName(2).toLowerCase(),
                        data: selector.charCodeAt(selectorIndex) ===
                            40 /* LeftParenthesis */
                            ? readValueWithParenthesis()
                            : null,
                    });
                    continue;
                }
                const name = getName(1).toLowerCase();
                let data = null;
                if (selector.charCodeAt(selectorIndex) ===
                    40 /* LeftParenthesis */) {
                    if (unpackPseudos.has(name)) {
                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                        if (selector.charCodeAt(selectorIndex) !==
                            41 /* RightParenthesis */) {
                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                        }
                        selectorIndex += 1;
                    }
                    else {
                        data = readValueWithParenthesis();
                        if (stripQuotesFromPseudos.has(name)) {
                            const quot = data.charCodeAt(0);
                            if (quot === data.charCodeAt(data.length - 1) &&
                                isQuote(quot)) {
                                data = data.slice(1, -1);
                            }
                        }
                        data = unescapeCSS(data);
                    }
                }
                tokens.push({ type: SelectorType.Pseudo, name, data });
                break;
            }
            case 44 /* Comma */: {
                finalizeSubselector();
                tokens = [];
                stripWhitespace(1);
                break;
            }
            default: {
                if (selector.startsWith("/*", selectorIndex)) {
                    const endIndex = selector.indexOf("*/", selectorIndex + 2);
                    if (endIndex < 0) {
                        throw new Error("Comment was not terminated");
                    }
                    selectorIndex = endIndex + 2;
                    // Remove leading whitespace
                    if (tokens.length === 0) {
                        stripWhitespace(0);
                    }
                    break;
                }
                let namespace = null;
                let name;
                if (firstChar === 42 /* Asterisk */) {
                    selectorIndex += 1;
                    name = "*";
                }
                else if (firstChar === 124 /* Pipe */) {
                    name = "";
                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                        addTraversal(SelectorType.ColumnCombinator);
                        stripWhitespace(2);
                        break;
                    }
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    name = getName(0);
                }
                else {
                    break loop;
                }
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                    namespace = name;
                    if (selector.charCodeAt(selectorIndex + 1) ===
                        42 /* Asterisk */) {
                        name = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name = getName(1);
                    }
                }
                tokens.push(name === "*"
                    ? { type: SelectorType.Universal, namespace }
                    : { type: SelectorType.Tag, name, namespace });
            }
        }
    }
    finalizeSubselector();
    return selectorIndex;
}

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInName = new Set([
    ...pseudoValChars,
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    ".",
].map((c) => c.charCodeAt(0)));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector
        .map((token) => token.map(stringifyToken).join(""))
        .join(", ");
}
function stringifyToken(token, index, arr) {
    switch (token.type) {
        // Simple types
        case SelectorType.Child:
            return index === 0 ? "> " : " > ";
        case SelectorType.Parent:
            return index === 0 ? "< " : " < ";
        case SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
        case SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
        case SelectorType.Descendant:
            return " ";
        case SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
        case SelectorType.Universal:
            // Return an empty string if the selector isn't needed.
            return token.namespace === "*" &&
                index + 1 < arr.length &&
                "name" in arr[index + 1]
                ? ""
                : `${getNamespace(token.namespace)}*`;
        case SelectorType.Tag:
            return getNamespacedName(token);
        case SelectorType.PseudoElement:
            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
        case SelectorType.Pseudo:
            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${typeof token.data === "string"
                    ? escapeName(token.data, charsToEscapeInPseudoValue)
                    : stringify(token.data)})`}`;
        case SelectorType.Attribute: {
            if (token.name === "id" &&
                token.action === AttributeAction.Equals &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `#${escapeName(token.value, charsToEscapeInName)}`;
            }
            if (token.name === "class" &&
                token.action === AttributeAction.Element &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `.${escapeName(token.value, charsToEscapeInName)}`;
            }
            const name = getNamespacedName(token);
            if (token.action === AttributeAction.Exists) {
                return `[${name}]`;
            }
            return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
        }
    }
}
function getActionValue(action) {
    switch (action) {
        case AttributeAction.Equals:
            return "";
        case AttributeAction.Element:
            return "~";
        case AttributeAction.Start:
            return "^";
        case AttributeAction.End:
            return "$";
        case AttributeAction.Any:
            return "*";
        case AttributeAction.Not:
            return "!";
        case AttributeAction.Hyphen:
            return "|";
        case AttributeAction.Exists:
            throw new Error("Shouldn't be here");
    }
}
function getNamespacedName(token) {
    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
    return namespace !== null
        ? `${namespace === "*"
            ? "*"
            : escapeName(namespace, charsToEscapeInName)}|`
        : "";
}
function escapeName(str, charsToEscape) {
    let lastIdx = 0;
    let ret = "";
    for (let i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
            ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
            lastIdx = i + 1;
        }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

var es = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get AttributeAction () { return AttributeAction; },
  IgnoreCaseMode: IgnoreCaseMode,
  get SelectorType () { return SelectorType; },
  isTraversal: isTraversal,
  parse: parse$2,
  stringify: stringify
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(es);

var sort = {};

var procedure = {};

var hasRequiredProcedure;

function requireProcedure () {
	if (hasRequiredProcedure) return procedure;
	hasRequiredProcedure = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isTraversal = exports.procedure = void 0;
		exports.procedure = {
		    universal: 50,
		    tag: 30,
		    attribute: 1,
		    pseudo: 0,
		    "pseudo-element": 0,
		    "column-combinator": -1,
		    descendant: -1,
		    child: -1,
		    parent: -1,
		    sibling: -1,
		    adjacent: -1,
		    _flexibleDescendant: -1,
		};
		function isTraversal(t) {
		    return exports.procedure[t.type] < 0;
		}
		exports.isTraversal = isTraversal; 
	} (procedure));
	return procedure;
}

var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort;
	hasRequiredSort = 1;
	Object.defineProperty(sort, "__esModule", { value: true });
	var css_what_1 = require$$0;
	var procedure_1 = requireProcedure();
	var attributes = {
	    exists: 10,
	    equals: 8,
	    not: 7,
	    start: 6,
	    end: 6,
	    any: 5,
	    hyphen: 4,
	    element: 4,
	};
	/**
	 * Sort the parts of the passed selector,
	 * as there is potential for optimization
	 * (some types of selectors are faster than others)
	 *
	 * @param arr Selector to sort
	 */
	function sortByProcedure(arr) {
	    var procs = arr.map(getProcedure);
	    for (var i = 1; i < arr.length; i++) {
	        var procNew = procs[i];
	        if (procNew < 0)
	            continue;
	        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
	            var token = arr[j + 1];
	            arr[j + 1] = arr[j];
	            arr[j] = token;
	            procs[j + 1] = procs[j];
	            procs[j] = procNew;
	        }
	    }
	}
	sort.default = sortByProcedure;
	function getProcedure(token) {
	    var proc = procedure_1.procedure[token.type];
	    if (token.type === css_what_1.SelectorType.Attribute) {
	        proc = attributes[token.action];
	        if (proc === attributes.equals && token.name === "id") {
	            // Prefer ID selectors (eg. #ID)
	            proc = 9;
	        }
	        if (token.ignoreCase) {
	            /*
	             * IgnoreCase adds some overhead, prefer "normal" token
	             * this is a binary operation, to ensure it's still an int
	             */
	            proc >>= 1;
	        }
	    }
	    else if (token.type === css_what_1.SelectorType.Pseudo) {
	        if (!token.data) {
	            proc = 3;
	        }
	        else if (token.name === "has" || token.name === "contains") {
	            proc = 0; // Expensive in any case
	        }
	        else if (Array.isArray(token.data)) {
	            // "matches" and "not"
	            proc = 0;
	            for (var i = 0; i < token.data.length; i++) {
	                // TODO better handling of complex selectors
	                if (token.data[i].length !== 1)
	                    continue;
	                var cur = getProcedure(token.data[i][0]);
	                // Avoid executing :has or :contains
	                if (cur === 0) {
	                    proc = 0;
	                    break;
	                }
	                if (cur > proc)
	                    proc = cur;
	            }
	            if (token.data.length > 1 && proc > 0)
	                proc -= 1;
	        }
	        else {
	            proc = 1;
	        }
	    }
	    return proc;
	}
	return sort;
}

var general = {};

var attributes = {};

var hasRequiredAttributes;

function requireAttributes () {
	if (hasRequiredAttributes) return attributes;
	hasRequiredAttributes = 1;
	Object.defineProperty(attributes, "__esModule", { value: true });
	attributes.attributeRules = void 0;
	var boolbase_1 = requireBoolbase();
	/**
	 * All reserved characters in a regex, used for escaping.
	 *
	 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
	 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
	 */
	var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
	function escapeRegex(value) {
	    return value.replace(reChars, "\\$&");
	}
	/**
	 * Attributes that are case-insensitive in HTML.
	 *
	 * @private
	 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
	 */
	var caseInsensitiveAttributes = new Set([
	    "accept",
	    "accept-charset",
	    "align",
	    "alink",
	    "axis",
	    "bgcolor",
	    "charset",
	    "checked",
	    "clear",
	    "codetype",
	    "color",
	    "compact",
	    "declare",
	    "defer",
	    "dir",
	    "direction",
	    "disabled",
	    "enctype",
	    "face",
	    "frame",
	    "hreflang",
	    "http-equiv",
	    "lang",
	    "language",
	    "link",
	    "media",
	    "method",
	    "multiple",
	    "nohref",
	    "noresize",
	    "noshade",
	    "nowrap",
	    "readonly",
	    "rel",
	    "rev",
	    "rules",
	    "scope",
	    "scrolling",
	    "selected",
	    "shape",
	    "target",
	    "text",
	    "type",
	    "valign",
	    "valuetype",
	    "vlink",
	]);
	function shouldIgnoreCase(selector, options) {
	    return typeof selector.ignoreCase === "boolean"
	        ? selector.ignoreCase
	        : selector.ignoreCase === "quirks"
	            ? !!options.quirksMode
	            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
	}
	/**
	 * Attribute selectors
	 */
	attributes.attributeRules = {
	    equals: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length === value.length &&
	                    attr.toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) === value && next(elem);
	        };
	    },
	    hyphen: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function hyphenIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    (attr.length === len || attr.charAt(len) === "-") &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function hyphen(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                (attr.length === len || attr.charAt(len) === "-") &&
	                attr.substr(0, len) === value &&
	                next(elem));
	        };
	    },
	    element: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (/\s/.test(value)) {
	            return boolbase_1.falseFunc;
	        }
	        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
	        return function element(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                attr.length >= value.length &&
	                regex.test(attr) &&
	                next(elem));
	        };
	    },
	    exists: function (next, _a, _b) {
	        var name = _a.name;
	        var adapter = _b.adapter;
	        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
	    },
	    start: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (len === 0) {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= len &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
	                next(elem);
	        };
	    },
	    end: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = -value.length;
	        if (len === 0) {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var _a;
	                return ((_a = adapter
	                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
	                next(elem);
	        };
	    },
	    any: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (value === "") {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            var regex_1 = new RegExp(escapeRegex(value), "i");
	            return function anyIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= value.length &&
	                    regex_1.test(attr) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
	                next(elem);
	        };
	    },
	    not: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (value === "") {
	            return function (elem) {
	                return !!adapter.getAttributeValue(elem, name) && next(elem);
	            };
	        }
	        else if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return ((attr == null ||
	                    attr.length !== value.length ||
	                    attr.toLowerCase() !== value) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) !== value && next(elem);
	        };
	    },
	};
	return attributes;
}

var pseudoSelectors = {};

var filters = {};

var lib$2 = {};

var parse$1 = {};

var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse$1;
	hasRequiredParse$1 = 1;
	// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
	Object.defineProperty(parse$1, "__esModule", { value: true });
	parse$1.parse = void 0;
	// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
	var whitespace = new Set([9, 10, 12, 13, 32]);
	var ZERO = "0".charCodeAt(0);
	var NINE = "9".charCodeAt(0);
	/**
	 * Parses an expression.
	 *
	 * @throws An `Error` if parsing fails.
	 * @returns An array containing the integer step size and the integer offset of the nth rule.
	 * @example nthCheck.parse("2n+3"); // returns [2, 3]
	 */
	function parse(formula) {
	    formula = formula.trim().toLowerCase();
	    if (formula === "even") {
	        return [2, 0];
	    }
	    else if (formula === "odd") {
	        return [2, 1];
	    }
	    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
	    var idx = 0;
	    var a = 0;
	    var sign = readSign();
	    var number = readNumber();
	    if (idx < formula.length && formula.charAt(idx) === "n") {
	        idx++;
	        a = sign * (number !== null && number !== void 0 ? number : 1);
	        skipWhitespace();
	        if (idx < formula.length) {
	            sign = readSign();
	            skipWhitespace();
	            number = readNumber();
	        }
	        else {
	            sign = number = 0;
	        }
	    }
	    // Throw if there is anything else
	    if (number === null || idx < formula.length) {
	        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
	    }
	    return [a, sign * number];
	    function readSign() {
	        if (formula.charAt(idx) === "-") {
	            idx++;
	            return -1;
	        }
	        if (formula.charAt(idx) === "+") {
	            idx++;
	        }
	        return 1;
	    }
	    function readNumber() {
	        var start = idx;
	        var value = 0;
	        while (idx < formula.length &&
	            formula.charCodeAt(idx) >= ZERO &&
	            formula.charCodeAt(idx) <= NINE) {
	            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
	            idx++;
	        }
	        // Return `null` if we didn't read anything.
	        return idx === start ? null : value;
	    }
	    function skipWhitespace() {
	        while (idx < formula.length &&
	            whitespace.has(formula.charCodeAt(idx))) {
	            idx++;
	        }
	    }
	}
	parse$1.parse = parse;
	
	return parse$1;
}

var compile = {};

var hasRequiredCompile$1;

function requireCompile$1 () {
	if (hasRequiredCompile$1) return compile;
	hasRequiredCompile$1 = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.generate = compile.compile = void 0;
	var boolbase_1 = __importDefault(requireBoolbase());
	/**
	 * Returns a function that checks if an elements index matches the given rule
	 * highly optimized to return the fastest solution.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A highly optimized function that returns whether an index matches the nth-check.
	 * @example
	 *
	 * ```js
	 * const check = nthCheck.compile([2, 3]);
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 * ```
	 */
	function compile$1(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    /*
	     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
	     * Besides, the specification states that no elements are
	     * matched when `a` and `b` are 0.
	     *
	     * `b < 0` here as we subtracted 1 from `b` above.
	     */
	    if (b < 0 && a <= 0)
	        return boolbase_1.default.falseFunc;
	    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
	    if (a === -1)
	        return function (index) { return index <= b; };
	    if (a === 0)
	        return function (index) { return index === b; };
	    // When `b <= 0` and `a === 1`, they match any element.
	    if (a === 1)
	        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };
	    /*
	     * Otherwise, modulo can be used to check if there is a match.
	     *
	     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
	     */
	    var absA = Math.abs(a);
	    // Get `b mod a`, + a if this is negative.
	    var bMod = ((b % absA) + absA) % absA;
	    return a > 1
	        ? function (index) { return index >= b && index % absA === bMod; }
	        : function (index) { return index <= b && index % absA === bMod; };
	}
	compile.compile = compile$1;
	/**
	 * Returns a function that produces a monotonously increasing sequence of indices.
	 *
	 * If the sequence has an end, the returned function will return `null` after
	 * the last index in the sequence.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A function that produces a sequence of indices.
	 * @example <caption>Always increasing (2n+3)</caption>
	 *
	 * ```js
	 * const gen = nthCheck.generate([2, 3])
	 *
	 * gen() // `1`
	 * gen() // `3`
	 * gen() // `5`
	 * gen() // `8`
	 * gen() // `11`
	 * ```
	 *
	 * @example <caption>With end value (-2n+10)</caption>
	 *
	 * ```js
	 *
	 * const gen = nthCheck.generate([-2, 5]);
	 *
	 * gen() // 0
	 * gen() // 2
	 * gen() // 4
	 * gen() // null
	 * ```
	 */
	function generate(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    var n = 0;
	    // Make sure to always return an increasing sequence
	    if (a < 0) {
	        var aPos_1 = -a;
	        // Get `b mod a`
	        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
	        return function () {
	            var val = minValue_1 + aPos_1 * n++;
	            return val > b ? null : val;
	        };
	    }
	    if (a === 0)
	        return b < 0
	            ? // There are no result — always return `null`
	                function () { return null; }
	            : // Return `b` exactly once
	                function () { return (n++ === 0 ? b : null); };
	    if (b < 0) {
	        b += a * Math.ceil(-b / a);
	    }
	    return function () { return a * n++ + b; };
	}
	compile.generate = generate;
	
	return compile;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
		var parse_js_1 = requireParse$1();
		Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_js_1.parse; } });
		var compile_js_1 = requireCompile$1();
		Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_js_1.compile; } });
		Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return compile_js_1.generate; } });
		/**
		 * Parses and compiles a formula to a highly optimized function.
		 * Combination of {@link parse} and {@link compile}.
		 *
		 * If the formula doesn't match any elements,
		 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
		 * Otherwise, a function accepting an _index_ is returned, which returns
		 * whether or not the passed _index_ matches the formula.
		 *
		 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
		 *
		 * @param formula The formula to compile.
		 * @example
		 * const check = nthCheck("2n+3");
		 *
		 * check(0); // `false`
		 * check(1); // `false`
		 * check(2); // `true`
		 * check(3); // `false`
		 * check(4); // `true`
		 * check(5); // `false`
		 * check(6); // `true`
		 */
		function nthCheck(formula) {
		    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
		}
		exports.default = nthCheck;
		/**
		 * Parses and compiles a formula to a generator that produces a sequence of indices.
		 * Combination of {@link parse} and {@link generate}.
		 *
		 * @param formula The formula to compile.
		 * @returns A function that produces a sequence of indices.
		 * @example <caption>Always increasing</caption>
		 *
		 * ```js
		 * const gen = nthCheck.sequence('2n+3')
		 *
		 * gen() // `1`
		 * gen() // `3`
		 * gen() // `5`
		 * gen() // `8`
		 * gen() // `11`
		 * ```
		 *
		 * @example <caption>With end value</caption>
		 *
		 * ```js
		 *
		 * const gen = nthCheck.sequence('-2n+5');
		 *
		 * gen() // 0
		 * gen() // 2
		 * gen() // 4
		 * gen() // null
		 * ```
		 */
		function sequence(formula) {
		    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
		}
		exports.sequence = sequence;
		
	} (lib$2));
	return lib$2;
}

var hasRequiredFilters;

function requireFilters () {
	if (hasRequiredFilters) return filters;
	hasRequiredFilters = 1;
	(function (exports) {
		var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.filters = void 0;
		var nth_check_1 = __importDefault(requireLib$2());
		var boolbase_1 = requireBoolbase();
		function getChildFunc(next, adapter) {
		    return function (elem) {
		        var parent = adapter.getParent(elem);
		        return parent != null && adapter.isTag(parent) && next(elem);
		    };
		}
		exports.filters = {
		    contains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        return function contains(elem) {
		            return next(elem) && adapter.getText(elem).includes(text);
		        };
		    },
		    icontains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        var itext = text.toLowerCase();
		        return function icontains(elem) {
		            return (next(elem) &&
		                adapter.getText(elem).toLowerCase().includes(itext));
		        };
		    },
		    // Location specific methods
		    "nth-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    // TODO determine the actual root element
		    root: function (next, _rule, _a) {
		        var adapter = _a.adapter;
		        return function (elem) {
		            var parent = adapter.getParent(elem);
		            return (parent == null || !adapter.isTag(parent)) && next(elem);
		        };
		    },
		    scope: function (next, rule, options, context) {
		        var equals = options.equals;
		        if (!context || context.length === 0) {
		            // Equivalent to :root
		            return exports.filters.root(next, rule, options);
		        }
		        if (context.length === 1) {
		            // NOTE: can't be unpacked, as :has uses this for side-effects
		            return function (elem) { return equals(context[0], elem) && next(elem); };
		        }
		        return function (elem) { return context.includes(elem) && next(elem); };
		    },
		    hover: dynamicStatePseudo("isHovered"),
		    visited: dynamicStatePseudo("isVisited"),
		    active: dynamicStatePseudo("isActive"),
		};
		/**
		 * Dynamic state pseudos. These depend on optional Adapter methods.
		 *
		 * @param name The name of the adapter method to call.
		 * @returns Pseudo for the `filters` object.
		 */
		function dynamicStatePseudo(name) {
		    return function dynamicPseudo(next, _rule, _a) {
		        var adapter = _a.adapter;
		        var func = adapter[name];
		        if (typeof func !== "function") {
		            return boolbase_1.falseFunc;
		        }
		        return function active(elem) {
		            return func(elem) && next(elem);
		        };
		    };
		} 
	} (filters));
	return filters;
}

var pseudos = {};

var hasRequiredPseudos;

function requirePseudos () {
	if (hasRequiredPseudos) return pseudos;
	hasRequiredPseudos = 1;
	Object.defineProperty(pseudos, "__esModule", { value: true });
	pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
	// While filters are precompiled, pseudos get called when they are needed
	pseudos.pseudos = {
	    empty: function (elem, _a) {
	        var adapter = _a.adapter;
	        return !adapter.getChildren(elem).some(function (elem) {
	            // FIXME: `getText` call is potentially expensive.
	            return adapter.isTag(elem) || adapter.getText(elem) !== "";
	        });
	    },
	    "first-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var firstChild = adapter
	            .getSiblings(elem)
	            .find(function (elem) { return adapter.isTag(elem); });
	        return firstChild != null && equals(elem, firstChild);
	    },
	    "last-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            if (equals(elem, siblings[i]))
	                return true;
	            if (adapter.isTag(siblings[i]))
	                break;
	        }
	        return false;
	    },
	    "first-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = 0; i < siblings.length; i++) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "last-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "only-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var elemName = adapter.getName(elem);
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) {
	            return equals(elem, sibling) ||
	                !adapter.isTag(sibling) ||
	                adapter.getName(sibling) !== elemName;
	        });
	    },
	    "only-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
	    },
	};
	function verifyPseudoArgs(func, name, subselect) {
	    if (subselect === null) {
	        if (func.length > 2) {
	            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
	        }
	    }
	    else if (func.length === 2) {
	        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
	    }
	}
	pseudos.verifyPseudoArgs = verifyPseudoArgs;
	return pseudos;
}

var aliases = {};

var hasRequiredAliases;

function requireAliases () {
	if (hasRequiredAliases) return aliases;
	hasRequiredAliases = 1;
	Object.defineProperty(aliases, "__esModule", { value: true });
	aliases.aliases = void 0;
	/**
	 * Aliases are pseudos that are expressed as selectors.
	 */
	aliases.aliases = {
	    // Links
	    "any-link": ":is(a, area, link)[href]",
	    link: ":any-link:not(:visited)",
	    // Forms
	    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
	    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
	    enabled: ":not(:disabled)",
	    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
	    required: ":is(input, select, textarea)[required]",
	    optional: ":is(input, select, textarea):not([required])",
	    // JQuery extensions
	    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
	    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
	    checkbox: "[type=checkbox]",
	    file: "[type=file]",
	    password: "[type=password]",
	    radio: "[type=radio]",
	    reset: "[type=reset]",
	    image: "[type=image]",
	    submit: "[type=submit]",
	    parent: ":not(:empty)",
	    header: ":is(h1, h2, h3, h4, h5, h6)",
	    button: ":is(button, input[type=button])",
	    input: ":is(input, textarea, select, button)",
	    text: "input:is(:not([type!='']), [type=text])",
	};
	return aliases;
}

var subselects = {};

var hasRequiredSubselects;

function requireSubselects () {
	if (hasRequiredSubselects) return subselects;
	hasRequiredSubselects = 1;
	(function (exports) {
		var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
		var boolbase_1 = requireBoolbase();
		var procedure_1 = requireProcedure();
		/** Used as a placeholder for :has. Will be replaced with the actual element. */
		exports.PLACEHOLDER_ELEMENT = {};
		function ensureIsTag(next, adapter) {
		    if (next === boolbase_1.falseFunc)
		        return boolbase_1.falseFunc;
		    return function (elem) { return adapter.isTag(elem) && next(elem); };
		}
		exports.ensureIsTag = ensureIsTag;
		function getNextSiblings(elem, adapter) {
		    var siblings = adapter.getSiblings(elem);
		    if (siblings.length <= 1)
		        return [];
		    var elemIndex = siblings.indexOf(elem);
		    if (elemIndex < 0 || elemIndex === siblings.length - 1)
		        return [];
		    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
		}
		exports.getNextSiblings = getNextSiblings;
		var is = function (next, token, options, context, compileToken) {
		    var opts = {
		        xmlMode: !!options.xmlMode,
		        adapter: options.adapter,
		        equals: options.equals,
		    };
		    var func = compileToken(token, opts, context);
		    return function (elem) { return func(elem) && next(elem); };
		};
		/*
		 * :not, :has, :is, :matches and :where have to compile selectors
		 * doing this in src/pseudos.ts would lead to circular dependencies,
		 * so we add them here
		 */
		exports.subselects = {
		    is: is,
		    /**
		     * `:matches` and `:where` are aliases for `:is`.
		     */
		    matches: is,
		    where: is,
		    not: function (next, token, options, context, compileToken) {
		        var opts = {
		            xmlMode: !!options.xmlMode,
		            adapter: options.adapter,
		            equals: options.equals,
		        };
		        var func = compileToken(token, opts, context);
		        if (func === boolbase_1.falseFunc)
		            return next;
		        if (func === boolbase_1.trueFunc)
		            return boolbase_1.falseFunc;
		        return function not(elem) {
		            return !func(elem) && next(elem);
		        };
		    },
		    has: function (next, subselect, options, _context, compileToken) {
		        var adapter = options.adapter;
		        var opts = {
		            xmlMode: !!options.xmlMode,
		            adapter: adapter,
		            equals: options.equals,
		        };
		        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
		        var context = subselect.some(function (s) {
		            return s.some(procedure_1.isTraversal);
		        })
		            ? [exports.PLACEHOLDER_ELEMENT]
		            : undefined;
		        var compiled = compileToken(subselect, opts, context);
		        if (compiled === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (compiled === boolbase_1.trueFunc) {
		            return function (elem) {
		                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
		            };
		        }
		        var hasElement = ensureIsTag(compiled, adapter);
		        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
		        /*
		         * `shouldTestNextSiblings` will only be true if the query starts with
		         * a traversal (sibling or adjacent). That means we will always have a context.
		         */
		        if (context) {
		            return function (elem) {
		                context[0] = elem;
		                var childs = adapter.getChildren(elem);
		                var nextElements = shouldTestNextSiblings
		                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
		                return (next(elem) && adapter.existsOne(hasElement, nextElements));
		            };
		        }
		        return function (elem) {
		            return next(elem) &&
		                adapter.existsOne(hasElement, adapter.getChildren(elem));
		        };
		    },
		}; 
	} (subselects));
	return subselects;
}

var hasRequiredPseudoSelectors;

function requirePseudoSelectors () {
	if (hasRequiredPseudoSelectors) return pseudoSelectors;
	hasRequiredPseudoSelectors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
		/*
		 * Pseudo selectors
		 *
		 * Pseudo selectors are available in three forms:
		 *
		 * 1. Filters are called when the selector is compiled and return a function
		 *  that has to return either false, or the results of `next()`.
		 * 2. Pseudos are called on execution. They have to return a boolean.
		 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
		 *
		 * Filters are great if you want to do some pre-processing, or change the call order
		 * of `next()` and your code.
		 * Pseudos should be used to implement simple checks.
		 */
		var boolbase_1 = requireBoolbase();
		var css_what_1 = require$$0;
		var filters_1 = requireFilters();
		Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
		var pseudos_1 = requirePseudos();
		Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
		var aliases_1 = requireAliases();
		Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
		var subselects_1 = requireSubselects();
		function compilePseudoSelector(next, selector, options, context, compileToken) {
		    var name = selector.name, data = selector.data;
		    if (Array.isArray(data)) {
		        return subselects_1.subselects[name](next, data, options, context, compileToken);
		    }
		    if (name in aliases_1.aliases) {
		        if (data != null) {
		            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
		        }
		        // The alias has to be parsed here, to make sure options are respected.
		        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
		        return subselects_1.subselects.is(next, alias, options, context, compileToken);
		    }
		    if (name in filters_1.filters) {
		        return filters_1.filters[name](next, data, options, context);
		    }
		    if (name in pseudos_1.pseudos) {
		        var pseudo_1 = pseudos_1.pseudos[name];
		        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
		        return pseudo_1 === boolbase_1.falseFunc
		            ? boolbase_1.falseFunc
		            : next === boolbase_1.trueFunc
		                ? function (elem) { return pseudo_1(elem, options, data); }
		                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
		    }
		    throw new Error("unmatched pseudo-class :".concat(name));
		}
		exports.compilePseudoSelector = compilePseudoSelector; 
	} (pseudoSelectors));
	return pseudoSelectors;
}

var hasRequiredGeneral;

function requireGeneral () {
	if (hasRequiredGeneral) return general;
	hasRequiredGeneral = 1;
	Object.defineProperty(general, "__esModule", { value: true });
	general.compileGeneralSelector = void 0;
	var attributes_1 = requireAttributes();
	var pseudo_selectors_1 = requirePseudoSelectors();
	var css_what_1 = require$$0;
	/*
	 * All available rules
	 */
	function compileGeneralSelector(next, selector, options, context, compileToken) {
	    var adapter = options.adapter, equals = options.equals;
	    switch (selector.type) {
	        case css_what_1.SelectorType.PseudoElement: {
	            throw new Error("Pseudo-elements are not supported by css-select");
	        }
	        case css_what_1.SelectorType.ColumnCombinator: {
	            throw new Error("Column combinators are not yet supported by css-select");
	        }
	        case css_what_1.SelectorType.Attribute: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced attributes are not yet supported by css-select");
	            }
	            if (!options.xmlMode || options.lowerCaseAttributeNames) {
	                selector.name = selector.name.toLowerCase();
	            }
	            return attributes_1.attributeRules[selector.action](next, selector, options);
	        }
	        case css_what_1.SelectorType.Pseudo: {
	            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
	        }
	        // Tags
	        case css_what_1.SelectorType.Tag: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced tag names are not yet supported by css-select");
	            }
	            var name_1 = selector.name;
	            if (!options.xmlMode || options.lowerCaseTags) {
	                name_1 = name_1.toLowerCase();
	            }
	            return function tag(elem) {
	                return adapter.getName(elem) === name_1 && next(elem);
	            };
	        }
	        // Traversal
	        case css_what_1.SelectorType.Descendant: {
	            if (options.cacheResults === false ||
	                typeof WeakSet === "undefined") {
	                return function descendant(elem) {
	                    var current = elem;
	                    while ((current = adapter.getParent(current))) {
	                        if (adapter.isTag(current) && next(current)) {
	                            return true;
	                        }
	                    }
	                    return false;
	                };
	            }
	            // @ts-expect-error `ElementNode` is not extending object
	            var isFalseCache_1 = new WeakSet();
	            return function cachedDescendant(elem) {
	                var current = elem;
	                while ((current = adapter.getParent(current))) {
	                    if (!isFalseCache_1.has(current)) {
	                        if (adapter.isTag(current) && next(current)) {
	                            return true;
	                        }
	                        isFalseCache_1.add(current);
	                    }
	                }
	                return false;
	            };
	        }
	        case "_flexibleDescendant": {
	            // Include element itself, only used while querying an array
	            return function flexibleDescendant(elem) {
	                var current = elem;
	                do {
	                    if (adapter.isTag(current) && next(current))
	                        return true;
	                } while ((current = adapter.getParent(current)));
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Parent: {
	            return function parent(elem) {
	                return adapter
	                    .getChildren(elem)
	                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
	            };
	        }
	        case css_what_1.SelectorType.Child: {
	            return function child(elem) {
	                var parent = adapter.getParent(elem);
	                return parent != null && adapter.isTag(parent) && next(parent);
	            };
	        }
	        case css_what_1.SelectorType.Sibling: {
	            return function sibling(elem) {
	                var siblings = adapter.getSiblings(elem);
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Adjacent: {
	            if (adapter.prevElementSibling) {
	                return function adjacent(elem) {
	                    var previous = adapter.prevElementSibling(elem);
	                    return previous != null && next(previous);
	                };
	            }
	            return function adjacent(elem) {
	                var siblings = adapter.getSiblings(elem);
	                var lastElement;
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling)) {
	                        lastElement = currentSibling;
	                    }
	                }
	                return !!lastElement && next(lastElement);
	            };
	        }
	        case css_what_1.SelectorType.Universal: {
	            if (selector.namespace != null && selector.namespace !== "*") {
	                throw new Error("Namespaced universal selectors are not yet supported by css-select");
	            }
	            return next;
	        }
	    }
	}
	general.compileGeneralSelector = compileGeneralSelector;
	return general;
}

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile$1;
	hasRequiredCompile = 1;
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile$1, "__esModule", { value: true });
	compile$1.compileToken = compile$1.compileUnsafe = compile$1.compile = void 0;
	var css_what_1 = require$$0;
	var boolbase_1 = requireBoolbase();
	var sort_1 = __importDefault(requireSort());
	var procedure_1 = requireProcedure();
	var general_1 = requireGeneral();
	var subselects_1 = requireSubselects();
	/**
	 * Compiles a selector to an executable function.
	 *
	 * @param selector Selector to compile.
	 * @param options Compilation options.
	 * @param context Optional context for the selector.
	 */
	function compile(selector, options, context) {
	    var next = compileUnsafe(selector, options, context);
	    return (0, subselects_1.ensureIsTag)(next, options.adapter);
	}
	compile$1.compile = compile;
	function compileUnsafe(selector, options, context) {
	    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
	    return compileToken(token, options, context);
	}
	compile$1.compileUnsafe = compileUnsafe;
	function includesScopePseudo(t) {
	    return (t.type === "pseudo" &&
	        (t.name === "scope" ||
	            (Array.isArray(t.data) &&
	                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
	}
	var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
	var FLEXIBLE_DESCENDANT_TOKEN = {
	    type: "_flexibleDescendant",
	};
	var SCOPE_TOKEN = {
	    type: css_what_1.SelectorType.Pseudo,
	    name: "scope",
	    data: null,
	};
	/*
	 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
	 * http://www.w3.org/TR/selectors4/#absolutizing
	 */
	function absolutize(token, _a, context) {
	    var adapter = _a.adapter;
	    // TODO Use better check if the context is a document
	    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
	        var parent = adapter.isTag(e) && adapter.getParent(e);
	        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
	    }));
	    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
	        var t = token_1[_i];
	        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") ;
	        else if (hasContext && !t.some(includesScopePseudo)) {
	            t.unshift(DESCENDANT_TOKEN);
	        }
	        else {
	            continue;
	        }
	        t.unshift(SCOPE_TOKEN);
	    }
	}
	function compileToken(token, options, context) {
	    var _a;
	    token = token.filter(function (t) { return t.length > 0; });
	    token.forEach(sort_1.default);
	    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
	    var isArrayContext = Array.isArray(context);
	    var finalContext = context && (Array.isArray(context) ? context : [context]);
	    absolutize(token, options, finalContext);
	    var shouldTestNextSiblings = false;
	    var query = token
	        .map(function (rules) {
	        if (rules.length >= 2) {
	            var first = rules[0], second = rules[1];
	            if (first.type !== "pseudo" || first.name !== "scope") ;
	            else if (isArrayContext && second.type === "descendant") {
	                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
	            }
	            else if (second.type === "adjacent" ||
	                second.type === "sibling") {
	                shouldTestNextSiblings = true;
	            }
	        }
	        return compileRules(rules, options, finalContext);
	    })
	        .reduce(reduceRules, boolbase_1.falseFunc);
	    query.shouldTestNextSiblings = shouldTestNextSiblings;
	    return query;
	}
	compile$1.compileToken = compileToken;
	function compileRules(rules, options, context) {
	    var _a;
	    return rules.reduce(function (previous, rule) {
	        return previous === boolbase_1.falseFunc
	            ? boolbase_1.falseFunc
	            : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
	    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
	}
	function reduceRules(a, b) {
	    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
	        return a;
	    }
	    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
	        return b;
	    }
	    return function combine(elem) {
	        return a(elem) || b(elem);
	    };
	}
	return compile$1;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$3;
	hasRequiredLib$1 = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
		var DomUtils = __importStar(requireLib$4());
		var boolbase_1 = requireBoolbase();
		var compile_1 = requireCompile();
		var subselects_1 = requireSubselects();
		var defaultEquals = function (a, b) { return a === b; };
		var defaultOptions = {
		    adapter: DomUtils,
		    equals: defaultEquals,
		};
		function convertOptionFormats(options) {
		    var _a, _b, _c, _d;
		    /*
		     * We force one format of options to the other one.
		     */
		    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
		    var opts = options !== null && options !== void 0 ? options : defaultOptions;
		    // @ts-expect-error Same as above.
		    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
		    // @ts-expect-error `equals` does not exist on `Options`
		    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
		    return opts;
		}
		function wrapCompile(func) {
		    return function addAdapter(selector, options, context) {
		        var opts = convertOptionFormats(options);
		        return func(selector, opts, context);
		    };
		}
		/**
		 * Compiles the query, returns a function.
		 */
		exports.compile = wrapCompile(compile_1.compile);
		exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
		exports._compileToken = wrapCompile(compile_1.compileToken);
		function getSelectorFunc(searchFunc) {
		    return function select(query, elements, options) {
		        var opts = convertOptionFormats(options);
		        if (typeof query !== "function") {
		            query = (0, compile_1.compileUnsafe)(query, opts, elements);
		        }
		        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
		        return searchFunc(query, filteredElements, opts);
		    };
		}
		function prepareContext(elems, adapter, shouldTestNextSiblings) {
		    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
		    /*
		     * Add siblings if the query requires them.
		     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
		     */
		    if (shouldTestNextSiblings) {
		        elems = appendNextSiblings(elems, adapter);
		    }
		    return Array.isArray(elems)
		        ? adapter.removeSubsets(elems)
		        : adapter.getChildren(elems);
		}
		exports.prepareContext = prepareContext;
		function appendNextSiblings(elem, adapter) {
		    // Order matters because jQuery seems to check the children before the siblings
		    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
		    var elemsLength = elems.length;
		    for (var i = 0; i < elemsLength; i++) {
		        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
		        elems.push.apply(elems, nextSiblings);
		    }
		    return elems;
		}
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns All matching elements.
		 *
		 */
		exports.selectAll = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.falseFunc || !elems || elems.length === 0
		        ? []
		        : options.adapter.findAll(query, elems);
		});
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns the first match, or null if there was no match.
		 */
		exports.selectOne = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.falseFunc || !elems || elems.length === 0
		        ? null
		        : options.adapter.findOne(query, elems);
		});
		/**
		 * Tests whether or not an element is matched by query.
		 *
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elem The element to test if it matches the query.
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns
		 */
		function is(elem, query, options) {
		    var opts = convertOptionFormats(options);
		    return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
		}
		exports.is = is;
		/**
		 * Alias for selectAll(query, elems, options).
		 * @see [compile] for supported selector queries.
		 */
		exports.default = exports.selectAll;
		// Export filters, pseudos and aliases to allow users to supply their own.
		var pseudo_selectors_1 = requirePseudoSelectors();
		Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
		Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
		Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } }); 
	} (lib$3));
	return lib$3;
}

var Selector_1;
var hasRequiredSelector;

function requireSelector () {
	if (hasRequiredSelector) return Selector_1;
	hasRequiredSelector = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var CSSSelect;
	CSSSelect = requireLib$1();

	Selector_1 = function () {
	  var self;

	  var Selector = /*#__PURE__*/function () {
	    function Selector(text1) {
	      _classCallCheck(this, Selector);

	      this.text = text1;
	      this._fn = CSSSelect.compile(this.text);
	      this.priority = self.calculatePriority(this.text);
	    }

	    _createClass(Selector, [{
	      key: "matches",
	      value: function matches(elem) {
	        return CSSSelect.is(elem, this._fn);
	      } // This stupid piece of code is supposed to calculate
	      // selector priority, somehow according to
	      // http://www.w3.org/wiki/CSS/Training/Priority_level_of_selector

	    }], [{
	      key: "calculatePriority",
	      value: function calculatePriority(text) {
	        var n, priotrity;
	        priotrity = 0;

	        if (n = text.match(/[\#]{1}/g)) {
	          priotrity += 100 * n.length;
	        }

	        if (n = text.match(/[a-zA-Z]+/g)) {
	          priotrity += 2 * n.length;
	        }

	        if (n = text.match(/\*/g)) {
	          priotrity += 1 * n.length;
	        }

	        return priotrity;
	      }
	    }]);

	    return Selector;
	  }();
	  self = Selector;
	  return Selector;
	}.call(void 0);
	return Selector_1;
}

var _Declaration_1;
var hasRequired_Declaration;

function require_Declaration () {
	if (hasRequired_Declaration) return _Declaration_1;
	hasRequired_Declaration = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_Declaration_1 = function () {
	  var self;

	  var _Declaration = /*#__PURE__*/function () {
	    function _Declaration(prop1, val) {
	      _classCallCheck(this, _Declaration);

	      this.prop = prop1;
	      this.important = false;
	      this.set(val);
	    }

	    _createClass(_Declaration, [{
	      key: "get",
	      value: function get() {
	        return this._get();
	      }
	    }, {
	      key: "_get",
	      value: function _get() {
	        return this.val;
	      }
	    }, {
	      key: "_pickImportantClause",
	      value: function _pickImportantClause(val) {
	        if (self.importantClauseRx.test(String(val))) {
	          this.important = true;
	          return val.replace(self.importantClauseRx, '');
	        } else {
	          this.important = false;
	          return val;
	        }
	      }
	    }, {
	      key: "set",
	      value: function set(val) {
	        val = self.sanitizeValue(val);
	        val = this._pickImportantClause(val);
	        val = val.trim();

	        if (this._handleNullOrInherit(val)) {
	          return this;
	        }

	        this._set(val);

	        return this;
	      }
	    }, {
	      key: "_set",
	      value: function _set(val) {
	        return this.val = val;
	      }
	    }, {
	      key: "_handleNullOrInherit",
	      value: function _handleNullOrInherit(val) {
	        if (val === '') {
	          this.val = '';
	          return true;
	        }

	        if (val === 'inherit') {
	          if (this.constructor.inheritAllowed) {
	            this.val = 'inherit';
	          } else {
	            throw Error("Inherit is not allowed for `".concat(this.prop, "`"));
	          }

	          return true;
	        } else {
	          return false;
	        }
	      }
	    }], [{
	      key: "setOnto",
	      value: function setOnto(declarations, prop, val) {
	        var dec;

	        if (!(dec = declarations[prop])) {
	          return declarations[prop] = new this(prop, val);
	        } else {
	          return dec.set(val);
	        }
	      }
	    }, {
	      key: "sanitizeValue",
	      value: function sanitizeValue(val) {
	        return String(val).trim().replace(/[\s]+/g, ' ');
	      }
	    }]);

	    return _Declaration;
	  }();
	  self = _Declaration;
	  _Declaration.importantClauseRx = /(\s\!important)$/;
	  _Declaration.inheritAllowed = false;
	  return _Declaration;
	}.call(void 0);
	return _Declaration_1;
}

var Arbitrary_1;
var hasRequiredArbitrary;

function requireArbitrary () {
	if (hasRequiredArbitrary) return Arbitrary_1;
	hasRequiredArbitrary = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration;

	_Declaration = require_Declaration();

	Arbitrary_1 = /*#__PURE__*/function (_Declaration2) {
	  _inherits(Arbitrary, _Declaration2);

	  var _super = _createSuper(Arbitrary);

	  function Arbitrary() {
	    _classCallCheck(this, Arbitrary);

	    return _super.apply(this, arguments);
	  }

	  return Arbitrary;
	}(_Declaration);
	return Arbitrary_1;
}

var Color_1;
var hasRequiredColor$1;

function requireColor$1 () {
	if (hasRequiredColor$1) return Color_1;
	hasRequiredColor$1 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration;

	_Declaration = require_Declaration();

	Color_1 = /*#__PURE__*/function (_Declaration2) {
	  _inherits(Color, _Declaration2);

	  var _super = _createSuper(Color);

	  function Color() {
	    _classCallCheck(this, Color);

	    return _super.apply(this, arguments);
	  }

	  return Color;
	}(_Declaration);
	return Color_1;
}

var Background_1;
var hasRequiredBackground$1;

function requireBackground$1 () {
	if (hasRequiredBackground$1) return Background_1;
	hasRequiredBackground$1 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration;

	_Declaration = require_Declaration();

	Background_1 = /*#__PURE__*/function (_Declaration2) {
	  _inherits(Background, _Declaration2);

	  var _super = _createSuper(Background);

	  function Background() {
	    _classCallCheck(this, Background);

	    return _super.apply(this, arguments);
	  }

	  return Background;
	}(_Declaration);
	return Background_1;
}

var _Length_1;
var hasRequired_Length;

function require_Length () {
	if (hasRequired_Length) return _Length_1;
	hasRequired_Length = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration;

	_Declaration = require_Declaration();

	_Length_1 = /*#__PURE__*/function (_Declaration2) {
	  _inherits(_Length, _Declaration2);

	  var _super = _createSuper(_Length);

	  function _Length() {
	    _classCallCheck(this, _Length);

	    return _super.apply(this, arguments);
	  }

	  _createClass(_Length, [{
	    key: "_set",
	    value: function _set(val) {
	      if (!/^[0-9]+$/.test(String(val))) {
	        throw Error("`".concat(this.prop, "` only takes an integer for value"));
	      }

	      return this.val = parseInt(val);
	    }
	  }]);

	  return _Length;
	}(_Declaration);
	return _Length_1;
}

var Width_1;
var hasRequiredWidth;

function requireWidth () {
	if (hasRequiredWidth) return Width_1;
	hasRequiredWidth = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	Width_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(Width, _Length2);

	  var _super = _createSuper(Width);

	  function Width() {
	    _classCallCheck(this, Width);

	    return _super.apply(this, arguments);
	  }

	  return Width;
	}(_Length);
	return Width_1;
}

var Height_1;
var hasRequiredHeight;

function requireHeight () {
	if (hasRequiredHeight) return Height_1;
	hasRequiredHeight = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	Height_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(Height, _Length2);

	  var _super = _createSuper(Height);

	  function Height() {
	    _classCallCheck(this, Height);

	    return _super.apply(this, arguments);
	  }

	  return Height;
	}(_Length);
	return Height_1;
}

var Bullet_1;
var hasRequiredBullet;

function requireBullet () {
	if (hasRequiredBullet) return Bullet_1;
	hasRequiredBullet = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration;

	_Declaration = require_Declaration();

	Bullet_1 = function () {

	  var Bullet = /*#__PURE__*/function (_Declaration2) {
	    _inherits(Bullet, _Declaration2);

	    var _super = _createSuper(Bullet);

	    function Bullet() {
	      _classCallCheck(this, Bullet);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Bullet, [{
	      key: "_set",
	      value: function _set(val) {
	        var alignment, bg, char, color, enabled, m, original;
	        val = String(val);
	        original = val;
	        char = null;
	        enabled = false;
	        color = 'none';
	        bg = 'none';

	        if (m = val.match(/\"([^"]+)\"/) || (m = val.match(/\'([^']+)\'/))) {
	          char = m[1];
	          val = val.replace(m[0], '');
	          enabled = true;
	        }

	        if (m = val.match(/(none|left|right|center)/)) {
	          alignment = m[1];
	          val = val.replace(m[0], '');
	        } else {
	          alignment = 'left';
	        }

	        if (alignment === 'none') {
	          enabled = false;
	        }

	        if (m = val.match(/color\:([\w\-]+)/)) {
	          color = m[1];
	          val = val.replace(m[0], '');
	        }

	        if (m = val.match(/bg\:([\w\-]+)/)) {
	          bg = m[1];
	          val = val.replace(m[0], '');
	        }

	        if (val.trim() !== '') {
	          throw Error("Unrecognizable value `".concat(original, "` for `").concat(this.prop, "`"));
	        }

	        return this.val = {
	          enabled: enabled,
	          char: char,
	          alignment: alignment,
	          background: bg,
	          color: color
	        };
	      }
	    }]);

	    return Bullet;
	  }(_Declaration);
	  return Bullet;
	}.call(void 0);
	return Bullet_1;
}

var Display_1;
var hasRequiredDisplay;

function requireDisplay () {
	if (hasRequiredDisplay) return Display_1;
	hasRequiredDisplay = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Declaration,
	    indexOf = [].indexOf;

	_Declaration = require_Declaration();

	Display_1 = function () {
	  var self;

	  var Display = /*#__PURE__*/function (_Declaration2) {
	    _inherits(Display, _Declaration2);

	    var _super = _createSuper(Display);

	    function Display() {
	      _classCallCheck(this, Display);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Display, [{
	      key: "_set",
	      value: function _set(val) {
	        val = String(val).toLowerCase();

	        if (indexOf.call(self._allowed, val) < 0) {
	          throw Error("Unrecognizable value `".concat(val, "` for `").concat(this.prop, "`"));
	        }

	        return this.val = val;
	      }
	    }]);

	    return Display;
	  }(_Declaration);
	  self = Display;
	  Display._allowed = ['inline', 'block', 'none'];
	  return Display;
	}.call(void 0);
	return Display_1;
}

var MarginTop_1;
var hasRequiredMarginTop;

function requireMarginTop () {
	if (hasRequiredMarginTop) return MarginTop_1;
	hasRequiredMarginTop = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	MarginTop_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(MarginTop, _Length2);

	  var _super = _createSuper(MarginTop);

	  function MarginTop() {
	    _classCallCheck(this, MarginTop);

	    return _super.apply(this, arguments);
	  }

	  return MarginTop;
	}(_Length);
	return MarginTop_1;
}

var MarginLeft_1;
var hasRequiredMarginLeft;

function requireMarginLeft () {
	if (hasRequiredMarginLeft) return MarginLeft_1;
	hasRequiredMarginLeft = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	MarginLeft_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(MarginLeft, _Length2);

	  var _super = _createSuper(MarginLeft);

	  function MarginLeft() {
	    _classCallCheck(this, MarginLeft);

	    return _super.apply(this, arguments);
	  }

	  return MarginLeft;
	}(_Length);
	return MarginLeft_1;
}

var MarginRight_1;
var hasRequiredMarginRight;

function requireMarginRight () {
	if (hasRequiredMarginRight) return MarginRight_1;
	hasRequiredMarginRight = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	MarginRight_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(MarginRight, _Length2);

	  var _super = _createSuper(MarginRight);

	  function MarginRight() {
	    _classCallCheck(this, MarginRight);

	    return _super.apply(this, arguments);
	  }

	  return MarginRight;
	}(_Length);
	return MarginRight_1;
}

var MarginBottom_1;
var hasRequiredMarginBottom;

function requireMarginBottom () {
	if (hasRequiredMarginBottom) return MarginBottom_1;
	hasRequiredMarginBottom = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	MarginBottom_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(MarginBottom, _Length2);

	  var _super = _createSuper(MarginBottom);

	  function MarginBottom() {
	    _classCallCheck(this, MarginBottom);

	    return _super.apply(this, arguments);
	  }

	  return MarginBottom;
	}(_Length);
	return MarginBottom_1;
}

var Margin_1;
var hasRequiredMargin$1;

function requireMargin$1 () {
	if (hasRequiredMargin$1) return Margin_1;
	hasRequiredMargin$1 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var MarginTop, _Declaration;

	_Declaration = require_Declaration();
	MarginTop = requireMarginTop();
	requireMarginLeft();
	requireMarginRight();
	requireMarginBottom();

	Margin_1 = function () {
	  var self;

	  var Margin = /*#__PURE__*/function (_Declaration2) {
	    _inherits(Margin, _Declaration2);

	    var _super = _createSuper(Margin);

	    function Margin() {
	      _classCallCheck(this, Margin);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Margin, null, [{
	      key: "setOnto",
	      value: function setOnto(declarations, prop, originalValue) {
	        var append, val, vals;
	        append = '';
	        val = _Declaration.sanitizeValue(originalValue);

	        if (_Declaration.importantClauseRx.test(String(val))) {
	          append = ' !important';
	          val = val.replace(_Declaration.importantClauseRx, '');
	        }

	        val = val.trim();

	        if (val.length === 0) {
	          return self._setAllDirections(declarations, append, append, append, append);
	        }

	        vals = val.split(" ").map(function (val) {
	          return val + append;
	        });

	        if (vals.length === 1) {
	          return self._setAllDirections(declarations, vals[0], vals[0], vals[0], vals[0]);
	        } else if (vals.length === 2) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[0], vals[1]);
	        } else if (vals.length === 3) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[1]);
	        } else if (vals.length === 4) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[3]);
	        } else {
	          throw Error("Can't understand value for margin: `".concat(originalValue, "`"));
	        }
	      }
	    }, {
	      key: "_setAllDirections",
	      value: function _setAllDirections(declarations, top, right, bottom, left) {
	        MarginTop.setOnto(declarations, 'marginTop', top);
	        MarginTop.setOnto(declarations, 'marginRight', right);
	        MarginTop.setOnto(declarations, 'marginBottom', bottom);
	        MarginTop.setOnto(declarations, 'marginLeft', left);
	      }
	    }]);

	    return Margin;
	  }(_Declaration);
	  self = Margin;
	  return Margin;
	}.call(void 0);
	return Margin_1;
}

var PaddingTop_1;
var hasRequiredPaddingTop;

function requirePaddingTop () {
	if (hasRequiredPaddingTop) return PaddingTop_1;
	hasRequiredPaddingTop = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	PaddingTop_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(PaddingTop, _Length2);

	  var _super = _createSuper(PaddingTop);

	  function PaddingTop() {
	    _classCallCheck(this, PaddingTop);

	    return _super.apply(this, arguments);
	  }

	  return PaddingTop;
	}(_Length);
	return PaddingTop_1;
}

var PaddingLeft_1;
var hasRequiredPaddingLeft;

function requirePaddingLeft () {
	if (hasRequiredPaddingLeft) return PaddingLeft_1;
	hasRequiredPaddingLeft = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	PaddingLeft_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(PaddingLeft, _Length2);

	  var _super = _createSuper(PaddingLeft);

	  function PaddingLeft() {
	    _classCallCheck(this, PaddingLeft);

	    return _super.apply(this, arguments);
	  }

	  return PaddingLeft;
	}(_Length);
	return PaddingLeft_1;
}

var PaddingRight_1;
var hasRequiredPaddingRight;

function requirePaddingRight () {
	if (hasRequiredPaddingRight) return PaddingRight_1;
	hasRequiredPaddingRight = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	PaddingRight_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(PaddingRight, _Length2);

	  var _super = _createSuper(PaddingRight);

	  function PaddingRight() {
	    _classCallCheck(this, PaddingRight);

	    return _super.apply(this, arguments);
	  }

	  return PaddingRight;
	}(_Length);
	return PaddingRight_1;
}

var PaddingBottom_1;
var hasRequiredPaddingBottom;

function requirePaddingBottom () {
	if (hasRequiredPaddingBottom) return PaddingBottom_1;
	hasRequiredPaddingBottom = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var _Length;

	_Length = require_Length();

	PaddingBottom_1 = /*#__PURE__*/function (_Length2) {
	  _inherits(PaddingBottom, _Length2);

	  var _super = _createSuper(PaddingBottom);

	  function PaddingBottom() {
	    _classCallCheck(this, PaddingBottom);

	    return _super.apply(this, arguments);
	  }

	  return PaddingBottom;
	}(_Length);
	return PaddingBottom_1;
}

var Padding_1;
var hasRequiredPadding$1;

function requirePadding$1 () {
	if (hasRequiredPadding$1) return Padding_1;
	hasRequiredPadding$1 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var PaddingTop, _Declaration;

	_Declaration = require_Declaration();
	PaddingTop = requirePaddingTop();
	requirePaddingLeft();
	requirePaddingRight();
	requirePaddingBottom();

	Padding_1 = function () {
	  var self;

	  var Padding = /*#__PURE__*/function (_Declaration2) {
	    _inherits(Padding, _Declaration2);

	    var _super = _createSuper(Padding);

	    function Padding() {
	      _classCallCheck(this, Padding);

	      return _super.apply(this, arguments);
	    }

	    _createClass(Padding, null, [{
	      key: "setOnto",
	      value: function setOnto(declarations, prop, originalValue) {
	        var append, val, vals;
	        append = '';
	        val = _Declaration.sanitizeValue(originalValue);

	        if (_Declaration.importantClauseRx.test(String(val))) {
	          append = ' !important';
	          val = val.replace(_Declaration.importantClauseRx, '');
	        }

	        val = val.trim();

	        if (val.length === 0) {
	          return self._setAllDirections(declarations, append, append, append, append);
	        }

	        vals = val.split(" ").map(function (val) {
	          return val + append;
	        });

	        if (vals.length === 1) {
	          return self._setAllDirections(declarations, vals[0], vals[0], vals[0], vals[0]);
	        } else if (vals.length === 2) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[0], vals[1]);
	        } else if (vals.length === 3) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[1]);
	        } else if (vals.length === 4) {
	          return self._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[3]);
	        } else {
	          throw Error("Can't understand value for padding: `".concat(originalValue, "`"));
	        }
	      }
	    }, {
	      key: "_setAllDirections",
	      value: function _setAllDirections(declarations, top, right, bottom, left) {
	        PaddingTop.setOnto(declarations, 'paddingTop', top);
	        PaddingTop.setOnto(declarations, 'paddingRight', right);
	        PaddingTop.setOnto(declarations, 'paddingBottom', bottom);
	        PaddingTop.setOnto(declarations, 'paddingLeft', left);
	      }
	    }]);

	    return Padding;
	  }(_Declaration);
	  self = Padding;
	  return Padding;
	}.call(void 0);
	return Padding_1;
}

var DeclarationBlock_1;
var hasRequiredDeclarationBlock;

function requireDeclarationBlock () {
	if (hasRequiredDeclarationBlock) return DeclarationBlock_1;
	hasRequiredDeclarationBlock = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var Arbitrary, declarationClasses;

	DeclarationBlock_1 = function () {
	  var self;

	  var DeclarationBlock = /*#__PURE__*/function () {
	    function DeclarationBlock() {
	      _classCallCheck(this, DeclarationBlock);

	      this._declarations = {};
	    }

	    _createClass(DeclarationBlock, [{
	      key: "set",
	      value: function set(prop, value) {
	        var key, val;

	        if (_typeof(prop) === 'object') {
	          for (key in prop) {
	            val = prop[key];
	            this.set(key, val);
	          }

	          return this;
	        }

	        prop = self.sanitizeProp(prop);

	        this._getDeclarationClass(prop).setOnto(this._declarations, prop, value);

	        return this;
	      }
	    }, {
	      key: "_getDeclarationClass",
	      value: function _getDeclarationClass(prop) {
	        var cls;

	        if (prop[0] === '_') {
	          return Arbitrary;
	        }

	        if (!(cls = declarationClasses[prop])) {
	          throw Error("Unknown property `".concat(prop, "`. Write it as `_").concat(prop, "` if you're defining a custom property"));
	        }

	        return cls;
	      }
	    }], [{
	      key: "sanitizeProp",
	      value: function sanitizeProp(prop) {
	        return String(prop).trim();
	      }
	    }]);

	    return DeclarationBlock;
	  }();
	  self = DeclarationBlock;
	  return DeclarationBlock;
	}.call(void 0);

	Arbitrary = requireArbitrary();
	declarationClasses = {
	  color: requireColor$1(),
	  background: requireBackground$1(),
	  width: requireWidth(),
	  height: requireHeight(),
	  bullet: requireBullet(),
	  display: requireDisplay(),
	  margin: requireMargin$1(),
	  marginTop: requireMarginTop(),
	  marginLeft: requireMarginLeft(),
	  marginRight: requireMarginRight(),
	  marginBottom: requireMarginBottom(),
	  padding: requirePadding$1(),
	  paddingTop: requirePaddingTop(),
	  paddingLeft: requirePaddingLeft(),
	  paddingRight: requirePaddingRight(),
	  paddingBottom: requirePaddingBottom()
	};
	return DeclarationBlock_1;
}

var Rule_1;
var hasRequiredRule;

function requireRule () {
	if (hasRequiredRule) return Rule_1;
	hasRequiredRule = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var DeclarationBlock, Selector;
	Selector = requireSelector();
	DeclarationBlock = requireDeclarationBlock();

	Rule_1 = /*#__PURE__*/function () {
	  function Rule(selector) {
	    _classCallCheck(this, Rule);

	    this.selector = new Selector(selector);
	    this.styles = new DeclarationBlock();
	  }

	  _createClass(Rule, [{
	    key: "setStyles",
	    value: function setStyles(styles) {
	      this.styles.set(styles);
	      return this;
	    }
	  }]);

	  return Rule;
	}();
	return Rule_1;
}

var StyleSheet_1;
var hasRequiredStyleSheet;

function requireStyleSheet () {
	if (hasRequiredStyleSheet) return StyleSheet_1;
	hasRequiredStyleSheet = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var Rule;
	Rule = requireRule();

	StyleSheet_1 = function () {
	  var self;

	  var StyleSheet = /*#__PURE__*/function () {
	    function StyleSheet() {
	      _classCallCheck(this, StyleSheet);

	      this._rulesBySelector = {};
	    }

	    _createClass(StyleSheet, [{
	      key: "setRule",
	      value: function setRule(selector, styles) {
	        var key, val;

	        if (typeof selector === 'string') {
	          this._setRule(selector, styles);
	        } else if (_typeof(selector) === 'object') {
	          for (key in selector) {
	            val = selector[key];

	            this._setRule(key, val);
	          }
	        }

	        return this;
	      }
	    }, {
	      key: "_setRule",
	      value: function _setRule(s, styles) {
	        var i, len, ref, selector;
	        ref = self.splitSelectors(s);

	        for (i = 0, len = ref.length; i < len; i++) {
	          selector = ref[i];

	          this._setSingleRule(selector, styles);
	        }

	        return this;
	      }
	    }, {
	      key: "_setSingleRule",
	      value: function _setSingleRule(s, styles) {
	        var rule, selector;
	        selector = self.normalizeSelector(s);

	        if (!(rule = this._rulesBySelector[selector])) {
	          rule = new Rule(selector);
	          this._rulesBySelector[selector] = rule;
	        }

	        rule.setStyles(styles);
	        return this;
	      }
	    }, {
	      key: "getRulesFor",
	      value: function getRulesFor(el) {
	        var ref, rule, rules, selector;
	        rules = [];
	        ref = this._rulesBySelector;

	        for (selector in ref) {
	          rule = ref[selector];

	          if (rule.selector.matches(el)) {
	            rules.push(rule);
	          }
	        }

	        return rules;
	      }
	    }], [{
	      key: "normalizeSelector",
	      value: function normalizeSelector(selector) {
	        return selector.replace(/[\s]+/g, ' ').replace(/[\s]*([>\,\+]{1})[\s]*/g, '$1').trim();
	      }
	    }, {
	      key: "splitSelectors",
	      value: function splitSelectors(s) {
	        return s.trim().split(',');
	      }
	    }]);

	    return StyleSheet;
	  }();
	  self = StyleSheet;
	  return StyleSheet;
	}.call(void 0);
	return StyleSheet_1;
}

var MixedDeclarationSet_1;
var hasRequiredMixedDeclarationSet;

function requireMixedDeclarationSet () {
	if (hasRequiredMixedDeclarationSet) return MixedDeclarationSet_1;
	hasRequiredMixedDeclarationSet = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	MixedDeclarationSet_1 = function () {
	  var self;

	  var MixedDeclarationSet = /*#__PURE__*/function () {
	    function MixedDeclarationSet() {
	      _classCallCheck(this, MixedDeclarationSet);

	      this._declarations = {};
	    }

	    _createClass(MixedDeclarationSet, [{
	      key: "mixWithList",
	      value: function mixWithList(rules) {
	        var i, len, rule;
	        rules.sort(function (a, b) {
	          return a.selector.priority > b.selector.priority;
	        });

	        for (i = 0, len = rules.length; i < len; i++) {
	          rule = rules[i];

	          this._mixWithRule(rule);
	        }

	        return this;
	      }
	    }, {
	      key: "_mixWithRule",
	      value: function _mixWithRule(rule) {
	        var dec, prop, ref;
	        ref = rule.styles._declarations;

	        for (prop in ref) {
	          dec = ref[prop];

	          this._mixWithDeclaration(dec);
	        }
	      }
	    }, {
	      key: "_mixWithDeclaration",
	      value: function _mixWithDeclaration(dec) {
	        var cur;
	        cur = this._declarations[dec.prop];

	        if (cur != null && cur.important && !dec.important) {
	          return;
	        }

	        this._declarations[dec.prop] = dec;
	      }
	    }, {
	      key: "get",
	      value: function get(prop) {
	        if (prop == null) {
	          return this._declarations;
	        }

	        if (this._declarations[prop] == null) {
	          return null;
	        }

	        return this._declarations[prop].val;
	      }
	    }, {
	      key: "toObject",
	      value: function toObject() {
	        var dec, obj, prop, ref;
	        obj = {};
	        ref = this._declarations;

	        for (prop in ref) {
	          dec = ref[prop];
	          obj[prop] = dec.val;
	        }

	        return obj;
	      }
	    }], [{
	      key: "mix",
	      value: function mix() {
	        var i, len, mixed, rules;
	        mixed = new self();

	        for (var _len = arguments.length, ruleSets = new Array(_len), _key = 0; _key < _len; _key++) {
	          ruleSets[_key] = arguments[_key];
	        }

	        for (i = 0, len = ruleSets.length; i < len; i++) {
	          rules = ruleSets[i];
	          mixed.mixWithList(rules);
	        }

	        return mixed;
	      }
	    }]);

	    return MixedDeclarationSet;
	  }();
	  self = MixedDeclarationSet;
	  return MixedDeclarationSet;
	}.call(void 0);
	return MixedDeclarationSet_1;
}

var Styles_1;
var hasRequiredStyles;

function requireStyles () {
	if (hasRequiredStyles) return Styles_1;
	hasRequiredStyles = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var MixedDeclarationSet, StyleSheet, terminalWidth;
	StyleSheet = requireStyleSheet();
	MixedDeclarationSet = requireMixedDeclarationSet();
	terminalWidth = requireTools().getCols();

	Styles_1 = function () {
	  var self;

	  var Styles = /*#__PURE__*/function () {
	    function Styles() {
	      _classCallCheck(this, Styles);

	      this._defaultStyles = new StyleSheet();
	      this._userStyles = new StyleSheet();

	      this._setDefaultStyles();
	    }

	    _createClass(Styles, [{
	      key: "_setDefaultStyles",
	      value: function _setDefaultStyles() {
	        this._defaultStyles.setRule(self.defaultRules);
	      }
	    }, {
	      key: "setRule",
	      value: function setRule(selector, rules) {
	        this._userStyles.setRule.apply(this._userStyles, arguments);

	        return this;
	      }
	    }, {
	      key: "getStyleFor",
	      value: function getStyleFor(el) {
	        var styles;
	        styles = el.styles;

	        if (styles == null) {
	          el.styles = styles = this._getComputedStyleFor(el);
	        }

	        return styles;
	      }
	    }, {
	      key: "_getRawStyleFor",
	      value: function _getRawStyleFor(el) {
	        var def, user;
	        def = this._defaultStyles.getRulesFor(el);
	        user = this._userStyles.getRulesFor(el);
	        return MixedDeclarationSet.mix(def, user).toObject();
	      }
	    }, {
	      key: "_getComputedStyleFor",
	      value: function _getComputedStyleFor(el) {
	        var decs, prop, ref, val;
	        decs = {};
	        el.parent;
	        ref = this._getRawStyleFor(el);

	        for (prop in ref) {
	          val = ref[prop];

	          if (val !== 'inherit') {
	            decs[prop] = val;
	          } else {
	            throw Error("Inherited styles are not supported yet.");
	          }
	        }

	        return decs;
	      }
	    }]);

	    return Styles;
	  }();
	  self = Styles;
	  Styles.defaultRules = {
	    '*': {
	      display: 'inline'
	    },
	    'body': {
	      background: 'none',
	      color: 'white',
	      display: 'block',
	      width: terminalWidth + ' !important'
	    }
	  };
	  return Styles;
	}.call(void 0);
	return Styles_1;
}

var SpecialString_1;
var hasRequiredSpecialString;

function requireSpecialString () {
	if (hasRequiredSpecialString) return SpecialString_1;
	hasRequiredSpecialString = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var SpecialString, i, len, prop, ref;

	SpecialString_1 = SpecialString = function () {
	  var self;

	  var SpecialString = /*#__PURE__*/function () {
	    function SpecialString(str) {
	      _classCallCheck(this, SpecialString);

	      if (!(this instanceof self)) {
	        return new self(str);
	      }

	      this._str = String(str);
	      this._len = 0;
	    }

	    _createClass(SpecialString, [{
	      key: "_getStr",
	      value: function _getStr() {
	        return this._str;
	      }
	    }, {
	      key: "set",
	      value: function set(str) {
	        this._str = String(str);
	        return this;
	      }
	    }, {
	      key: "clone",
	      value: function clone() {
	        return new SpecialString(this._str);
	      }
	    }, {
	      key: "isEmpty",
	      value: function isEmpty() {
	        return this._str === '';
	      }
	    }, {
	      key: "isOnlySpecialChars",
	      value: function isOnlySpecialChars() {
	        return !this.isEmpty() && this.length === 0;
	      }
	    }, {
	      key: "_reset",
	      value: function _reset() {
	        return this._len = 0;
	      }
	    }, {
	      key: "splitIn",
	      value: function splitIn(limit) {
	        var trimLeftEachLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	        var buffer, bufferLength, justSkippedSkipChar, lines;
	        buffer = '';
	        bufferLength = 0;
	        lines = [];
	        justSkippedSkipChar = false;

	        self._countChars(this._str, function (char, charLength) {
	          if (bufferLength > limit || bufferLength + charLength > limit) {
	            lines.push(buffer);
	            buffer = '';
	            bufferLength = 0;
	          }

	          if (bufferLength === 0 && char === ' ' && !justSkippedSkipChar && trimLeftEachLine) {
	            return justSkippedSkipChar = true;
	          } else {
	            buffer += char;
	            bufferLength += charLength;
	            return justSkippedSkipChar = false;
	          }
	        });

	        if (buffer.length > 0) {
	          lines.push(buffer);
	        }

	        return lines;
	      }
	    }, {
	      key: "trim",
	      value: function trim() {
	        return new SpecialString(this.str.trim());
	      }
	    }, {
	      key: "_getLength",
	      value: function _getLength() {
	        var sum;
	        sum = 0;

	        self._countChars(this._str, function (char, charLength) {
	          sum += charLength;
	        });

	        return sum;
	      }
	    }, {
	      key: "cut",
	      value: function cut(from, to) {
	        var _this = this;

	        var trimLeft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	        var after, before, cur, cut;

	        if (to == null) {
	          to = this.length;
	        }

	        from = parseInt(from);

	        if (from >= to) {
	          throw Error("`from` shouldn't be larger than `to`");
	        }

	        before = '';
	        after = '';
	        cut = '';
	        cur = 0;

	        self._countChars(this._str, function (char, charLength) {
	          if (_this.str === 'ab<tag>') {
	            console.log(charLength, char);
	          }

	          if (cur === from && char.match(/^\s+$/) && trimLeft) {
	            return;
	          }

	          if (cur < from) {
	            before += char; // let's be greedy
	          } else if (cur < to || cur + charLength <= to) {
	            cut += char;
	          } else {
	            after += char;
	          }

	          cur += charLength;
	        });

	        this._str = before + after;

	        this._reset();

	        return new SpecialString(cut);
	      }
	    }], [{
	      key: "_countChars",
	      value: function _countChars(text, cb) {
	        var char, charLength, m;

	        while (text.length !== 0) {
	          if (m = text.match(self._tagRx)) {
	            char = m[0];
	            charLength = 0;
	            text = text.substr(char.length, text.length);
	          } else if (m = text.match(self._quotedHtmlRx)) {
	            char = m[0];
	            charLength = 1;
	            text = text.substr(char.length, text.length);
	          } else if (text.match(self._tabRx)) {
	            char = "\t";
	            charLength = 8;
	            text = text.substr(1, text.length);
	          } else {
	            char = text[0];
	            charLength = 1;
	            text = text.substr(1, text.length);
	          }

	          cb.call(null, char, charLength);
	        }
	      }
	    }]);

	    return SpecialString;
	  }();
	  self = SpecialString;
	  SpecialString._tabRx = /^\t/;
	  SpecialString._tagRx = /^<[^>]+>/;
	  SpecialString._quotedHtmlRx = /^&(gt|lt|quot|amp|apos|sp);/;
	  return SpecialString;
	}.call(void 0);

	ref = ['str', 'length'];

	for (i = 0, len = ref.length; i < len; i++) {
	  prop = ref[i];

	  (function () {
	    var methodName;
	    methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length);
	    return SpecialString.prototype.__defineGetter__(prop, function () {
	      return this[methodName]();
	    });
	  })();
	}
	return SpecialString_1;
}

var _BlockPrependor_1;
var hasRequired_BlockPrependor;

function require_BlockPrependor () {
	if (hasRequired_BlockPrependor) return _BlockPrependor_1;
	hasRequired_BlockPrependor = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_BlockPrependor_1 = /*#__PURE__*/function () {
	  function _BlockPrependor(_config) {
	    _classCallCheck(this, _BlockPrependor);

	    this._config = _config;
	  }

	  _createClass(_BlockPrependor, [{
	    key: "render",
	    value: function render(options) {
	      return this._render(options);
	    }
	  }]);

	  return _BlockPrependor;
	}();
	return _BlockPrependor_1;
}

var Default$4;
var hasRequiredDefault$4;

function requireDefault$4 () {
	if (hasRequiredDefault$4) return Default$4;
	hasRequiredDefault$4 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var tools;
	tools = requireTools();

	Default$4 = /*#__PURE__*/function (_require) {
	  _inherits(DefaultBlockPrependor, _require);

	  var _super = _createSuper(DefaultBlockPrependor);

	  function DefaultBlockPrependor() {
	    _classCallCheck(this, DefaultBlockPrependor);

	    return _super.apply(this, arguments);
	  }

	  _createClass(DefaultBlockPrependor, [{
	    key: "_render",
	    value: function _render(options) {
	      return tools.repeatString("\n", this._config.amount);
	    }
	  }]);

	  return DefaultBlockPrependor;
	}(require_BlockPrependor());
	return Default$4;
}

var _BlockAppendor_1;
var hasRequired_BlockAppendor;

function require_BlockAppendor () {
	if (hasRequired_BlockAppendor) return _BlockAppendor_1;
	hasRequired_BlockAppendor = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_BlockAppendor_1 = /*#__PURE__*/function () {
	  function _BlockAppendor(_config) {
	    _classCallCheck(this, _BlockAppendor);

	    this._config = _config;
	  }

	  _createClass(_BlockAppendor, [{
	    key: "render",
	    value: function render(options) {
	      return this._render(options);
	    }
	  }]);

	  return _BlockAppendor;
	}();
	return _BlockAppendor_1;
}

var Default$3;
var hasRequiredDefault$3;

function requireDefault$3 () {
	if (hasRequiredDefault$3) return Default$3;
	hasRequiredDefault$3 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var tools;
	tools = requireTools();

	Default$3 = /*#__PURE__*/function (_require) {
	  _inherits(DefaultBlockAppendor, _require);

	  var _super = _createSuper(DefaultBlockAppendor);

	  function DefaultBlockAppendor() {
	    _classCallCheck(this, DefaultBlockAppendor);

	    return _super.apply(this, arguments);
	  }

	  _createClass(DefaultBlockAppendor, [{
	    key: "_render",
	    value: function _render(options) {
	      return tools.repeatString("\n", this._config.amount);
	    }
	  }]);

	  return DefaultBlockAppendor;
	}(require_BlockAppendor());
	return Default$3;
}

var _LinePrependor_1;
var hasRequired_LinePrependor;

function require_LinePrependor () {
	if (hasRequired_LinePrependor) return _LinePrependor_1;
	hasRequired_LinePrependor = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_LinePrependor_1 = /*#__PURE__*/function () {
	  function _LinePrependor(_config) {
	    _classCallCheck(this, _LinePrependor);

	    this._config = _config;
	    this._lineNo = -1;
	  }

	  _createClass(_LinePrependor, [{
	    key: "render",
	    value: function render(inherited, options) {
	      this._lineNo++;
	      return '<none>' + this._render(inherited, options) + '</none>';
	    }
	  }]);

	  return _LinePrependor;
	}();
	return _LinePrependor_1;
}

var Default$2;
var hasRequiredDefault$2;

function requireDefault$2 () {
	if (hasRequiredDefault$2) return Default$2;
	hasRequiredDefault$2 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var SpecialString, tools;
	tools = requireTools();
	SpecialString = requireSpecialString();

	Default$2 = function () {
	  var self;

	  var DefaultLinePrependor = /*#__PURE__*/function (_require) {
	    _inherits(DefaultLinePrependor, _require);

	    var _super = _createSuper(DefaultLinePrependor);

	    function DefaultLinePrependor() {
	      _classCallCheck(this, DefaultLinePrependor);

	      return _super.apply(this, arguments);
	    }

	    _createClass(DefaultLinePrependor, [{
	      key: "_render",
	      value: function _render(inherited, options) {
	        var addToLeft, addToRight, alignment, bullet, char, charLen, diff, left, output, space;

	        if (this._lineNo === 0 && (bullet = this._config.bullet)) {
	          char = bullet.char;
	          charLen = new SpecialString(char).length;
	          alignment = bullet.alignment;
	          space = this._config.amount;
	          addToLeft = '';
	          addToRight = '';

	          if (space > charLen) {
	            diff = space - charLen;

	            if (alignment === 'right') {
	              addToLeft = self.pad(diff);
	            } else if (alignment === 'left') {
	              addToRight = self.pad(diff);
	            } else if (alignment === 'center') {
	              left = Math.round(diff / 2);
	              addToLeft = self.pad(left);
	              addToRight = self.pad(diff - left);
	            } else {
	              throw Error("Unknown alignment `".concat(alignment, "`"));
	            }
	          }

	          output = addToLeft + char + addToRight;
	        } else {
	          output = self.pad(this._config.amount);
	        }

	        return inherited + output;
	      }
	    }], [{
	      key: "pad",
	      value: function pad(howMuch) {
	        return tools.repeatString(" ", howMuch);
	      }
	    }]);

	    return DefaultLinePrependor;
	  }(require_LinePrependor());
	  self = DefaultLinePrependor;
	  return DefaultLinePrependor;
	}.call(void 0);
	return Default$2;
}

var _LineAppendor_1;
var hasRequired_LineAppendor;

function require_LineAppendor () {
	if (hasRequired_LineAppendor) return _LineAppendor_1;
	hasRequired_LineAppendor = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_LineAppendor_1 = /*#__PURE__*/function () {
	  function _LineAppendor(_config) {
	    _classCallCheck(this, _LineAppendor);

	    this._config = _config;
	    this._lineNo = 0;
	  }

	  _createClass(_LineAppendor, [{
	    key: "render",
	    value: function render(inherited, options) {
	      this._lineNo++;
	      return '<none>' + this._render(inherited, options) + '</none>';
	    }
	  }]);

	  return _LineAppendor;
	}();
	return _LineAppendor_1;
}

var Default$1;
var hasRequiredDefault$1;

function requireDefault$1 () {
	if (hasRequiredDefault$1) return Default$1;
	hasRequiredDefault$1 = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	// Generated by CoffeeScript 2.5.1
	var tools;
	tools = requireTools();

	Default$1 = /*#__PURE__*/function (_require) {
	  _inherits(DefaultLineAppendor, _require);

	  var _super = _createSuper(DefaultLineAppendor);

	  function DefaultLineAppendor() {
	    _classCallCheck(this, DefaultLineAppendor);

	    return _super.apply(this, arguments);
	  }

	  _createClass(DefaultLineAppendor, [{
	    key: "_render",
	    value: function _render(inherited, options) {
	      return inherited + tools.repeatString(" ", this._config.amount);
	    }
	  }]);

	  return DefaultLineAppendor;
	}(require_LineAppendor());
	return Default$1;
}

var _LineWrapper_1;
var hasRequired_LineWrapper;

function require_LineWrapper () {
	if (hasRequired_LineWrapper) return _LineWrapper_1;
	hasRequired_LineWrapper = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	_LineWrapper_1 = /*#__PURE__*/function () {
	  function _LineWrapper() {
	    _classCallCheck(this, _LineWrapper);
	  }

	  _createClass(_LineWrapper, [{
	    key: "render",
	    value: function render(str, options) {
	      return this._render(str, options);
	    }
	  }]);

	  return _LineWrapper;
	}();
	return _LineWrapper_1;
}

var Default;
var hasRequiredDefault;

function requireDefault () {
	if (hasRequiredDefault) return Default;
	hasRequiredDefault = 1;

	function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

	Default = /*#__PURE__*/function (_require) {
	  _inherits(DefaultLineWrapper, _require);

	  var _super = _createSuper(DefaultLineWrapper);

	  function DefaultLineWrapper() {
	    _classCallCheck(this, DefaultLineWrapper);

	    return _super.apply(this, arguments);
	  }

	  _createClass(DefaultLineWrapper, [{
	    key: "_render",
	    value: function _render() {}
	  }]);

	  return DefaultLineWrapper;
	}(require_LineWrapper());
	return Default;
}

var Block_1;
var hasRequiredBlock;

function requireBlock () {
	if (hasRequiredBlock) return Block_1;
	hasRequiredBlock = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var SpecialString, cloneAndMergeDeep, terminalWidth;
	SpecialString = requireSpecialString();
	terminalWidth = requireTools().getCols();

	var _require = requireTools();

	cloneAndMergeDeep = _require.cloneAndMergeDeep;

	Block_1 = function () {
	  var self;

	  var Block = /*#__PURE__*/function () {
	    function Block(_layout, _parent) {
	      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      var _name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

	      _classCallCheck(this, Block);

	      this._layout = _layout;
	      this._parent = _parent;
	      this._name = _name;
	      this._config = cloneAndMergeDeep(self.defaultConfig, config);
	      this._closed = false;
	      this._wasOpenOnce = false;
	      this._active = false;
	      this._buffer = '';
	      this._didSeparateBlock = false;
	      this._linePrependor = new this._config.linePrependor.fn(this._config.linePrependor.options);
	      this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options);
	      this._blockPrependor = new this._config.blockPrependor.fn(this._config.blockPrependor.options);
	      this._blockAppendor = new this._config.blockAppendor.fn(this._config.blockAppendor.options);
	    }

	    _createClass(Block, [{
	      key: "_activate",
	      value: function _activate() {
	        var deactivateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	        if (this._active) {
	          throw Error("This block is already active. This is probably a bug in RenderKid itself");
	        }

	        if (this._closed) {
	          throw Error("This block is closed and cannot be activated. This is probably a bug in RenderKid itself");
	        }

	        this._active = true;
	        this._layout._activeBlock = this;

	        if (deactivateParent) {
	          if (this._parent != null) {
	            this._parent._deactivate(false);
	          }
	        }

	        return this;
	      }
	    }, {
	      key: "_deactivate",
	      value: function _deactivate() {
	        var activateParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	        this._ensureActive();

	        this._flushBuffer();

	        if (activateParent) {
	          if (this._parent != null) {
	            this._parent._activate(false);
	          }
	        }

	        this._active = false;
	        return this;
	      }
	    }, {
	      key: "_ensureActive",
	      value: function _ensureActive() {
	        if (!this._wasOpenOnce) {
	          throw Error("This block has never been open before. This is probably a bug in RenderKid itself.");
	        }

	        if (!this._active) {
	          throw Error("This block is not active. This is probably a bug in RenderKid itself.");
	        }

	        if (this._closed) {
	          throw Error("This block is already closed. This is probably a bug in RenderKid itself.");
	        }
	      }
	    }, {
	      key: "_open",
	      value: function _open() {
	        if (this._wasOpenOnce) {
	          throw Error("Block._open() has been called twice. This is probably a RenderKid bug.");
	        }

	        this._wasOpenOnce = true;

	        if (this._parent != null) {
	          this._parent.write(this._whatToPrependToBlock());
	        }

	        this._activate();

	        return this;
	      }
	    }, {
	      key: "close",
	      value: function close() {
	        this._deactivate();

	        this._closed = true;

	        if (this._parent != null) {
	          this._parent.write(this._whatToAppendToBlock());
	        }

	        return this;
	      }
	    }, {
	      key: "isOpen",
	      value: function isOpen() {
	        return this._wasOpenOnce && !this._closed;
	      }
	    }, {
	      key: "write",
	      value: function write(str) {
	        this._ensureActive();

	        if (str === '') {
	          return;
	        }

	        str = String(str);
	        this._buffer += str;
	        return this;
	      }
	    }, {
	      key: "openBlock",
	      value: function openBlock(config, name) {
	        var block;

	        this._ensureActive();

	        block = new Block(this._layout, this, config, name);

	        block._open();

	        return block;
	      }
	    }, {
	      key: "_flushBuffer",
	      value: function _flushBuffer() {
	        var str;

	        if (this._buffer === '') {
	          return;
	        }

	        str = this._buffer;
	        this._buffer = '';

	        this._writeInline(str);
	      }
	    }, {
	      key: "_toPrependToLine",
	      value: function _toPrependToLine() {
	        var fromParent;
	        fromParent = '';

	        if (this._parent != null) {
	          fromParent = this._parent._toPrependToLine();
	        }

	        return this._linePrependor.render(fromParent);
	      }
	    }, {
	      key: "_toAppendToLine",
	      value: function _toAppendToLine() {
	        var fromParent;
	        fromParent = '';

	        if (this._parent != null) {
	          fromParent = this._parent._toAppendToLine();
	        }

	        return this._lineAppendor.render(fromParent);
	      }
	    }, {
	      key: "_whatToPrependToBlock",
	      value: function _whatToPrependToBlock() {
	        return this._blockPrependor.render();
	      }
	    }, {
	      key: "_whatToAppendToBlock",
	      value: function _whatToAppendToBlock() {
	        return this._blockAppendor.render();
	      }
	    }, {
	      key: "_writeInline",
	      value: function _writeInline(str) {
	        var j, k, l, lineBreaksToAppend, m, ref, ref1, ref2, remaining; // special characters (such as <bg-white>) don't require
	        // any wrapping...

	        if (new SpecialString(str).isOnlySpecialChars()) {
	          // ... and directly get appended to the layout.
	          this._layout._append(str);

	          return;
	        } // we'll be removing from the original string till it's empty


	        remaining = str; // we might need to add a few line breaks at the end of the text.

	        lineBreaksToAppend = 0; // if text starts with line breaks...

	        if (m = remaining.match(/^\n+/)) {
	          // ... we want to write the exact same number of line breaks
	          // to the layout.
	          for (j = 1, ref = m[0].length; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? ++j : --j) {
	            this._writeLine('');
	          }

	          remaining = remaining.substr(m[0].length, remaining.length);
	        } // and if the text ends with line breaks...


	        if (m = remaining.match(/\n+$/)) {
	          // we want to write the exact same number of line breaks
	          // to the end of the layout.
	          lineBreaksToAppend = m[0].length;
	          remaining = remaining.substr(0, remaining.length - m[0].length);
	        } // now let's parse the body of the text:


	        while (remaining.length > 0) {
	          // anything other than a break line...
	          if (m = remaining.match(/^[^\n]+/)) {
	            // ... should be wrapped as a block of text.
	            this._writeLine(m[0]);

	            remaining = remaining.substr(m[0].length, remaining.length); // for any number of line breaks we find inside the text...
	          } else if (m = remaining.match(/^\n+/)) {
	            // ... we write one less break line to the layout.
	            for (k = 1, ref1 = m[0].length; 1 <= ref1 ? k < ref1 : k > ref1; 1 <= ref1 ? ++k : --k) {
	              this._writeLine('');
	            }

	            remaining = remaining.substr(m[0].length, remaining.length);
	          }
	        } // if we had line breaks to append to the layout...


	        if (lineBreaksToAppend > 0) {
	          // ... we append the exact same number of line breaks to the layout.
	          for (l = 1, ref2 = lineBreaksToAppend; 1 <= ref2 ? l <= ref2 : l >= ref2; 1 <= ref2 ? ++l : --l) {
	            this._writeLine('');
	          }
	        }
	      } // wraps a line into multiple lines if necessary, adds horizontal margins,
	      // etc, and appends it to the layout.

	    }, {
	      key: "_writeLine",
	      value: function _writeLine(str) {
	        var line, lineContent, lineContentLength, remaining, roomLeft, toAppend, toAppendLength, toPrepend, toPrependLength; // we'll be cutting from our string as we go

	        remaining = new SpecialString(str);

	        while (true) {
	          // left margin...
	          // this will continue until nothing is left of our block.
	          toPrepend = this._toPrependToLine(); // ... and its length

	          toPrependLength = new SpecialString(toPrepend).length; // right margin...

	          toAppend = this._toAppendToLine(); // ... and its length

	          toAppendLength = new SpecialString(toAppend).length; // how much room is left for content

	          roomLeft = this._layout._config.terminalWidth - (toPrependLength + toAppendLength); // how much room each line of content will have

	          lineContentLength = Math.min(this._config.width, roomLeft); // cut line content, only for the amount needed

	          lineContent = remaining.cut(0, lineContentLength, true); // line will consist of both margins and the content

	          line = toPrepend + lineContent.str + toAppend; // send it off to layout

	          this._layout._appendLine(line);

	          if (remaining.isEmpty()) {
	            break;
	          }
	        }
	      }
	    }]);

	    return Block;
	  }();
	  self = Block;
	  Block.defaultConfig = {
	    blockPrependor: {
	      fn: requireDefault$4(),
	      options: {
	        amount: 0
	      }
	    },
	    blockAppendor: {
	      fn: requireDefault$3(),
	      options: {
	        amount: 0
	      }
	    },
	    linePrependor: {
	      fn: requireDefault$2(),
	      options: {
	        amount: 0
	      }
	    },
	    lineAppendor: {
	      fn: requireDefault$1(),
	      options: {
	        amount: 0
	      }
	    },
	    lineWrapper: {
	      fn: requireDefault(),
	      options: {
	        lineWidth: null
	      }
	    },
	    width: terminalWidth,
	    prefixRaw: '',
	    suffixRaw: ''
	  };
	  return Block;
	}.call(void 0);
	return Block_1;
}

var Layout_1;
var hasRequiredLayout;

function requireLayout () {
	if (hasRequiredLayout) return Layout_1;
	hasRequiredLayout = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var Block, Layout, SpecialString, cloneAndMergeDeep, i, len, prop, ref, terminalWidth;
	Block = requireBlock();

	var _require = requireTools();

	cloneAndMergeDeep = _require.cloneAndMergeDeep;
	SpecialString = requireSpecialString();
	terminalWidth = requireTools().getCols();

	Layout_1 = Layout = function () {
	  var self;

	  var Layout = /*#__PURE__*/function () {
	    function Layout() {
	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var rootBlockConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      _classCallCheck(this, Layout);

	      var rootConfig;
	      this._written = [];
	      this._activeBlock = null;
	      this._config = cloneAndMergeDeep(self._defaultConfig, config); // Every layout has a root block

	      rootConfig = cloneAndMergeDeep(self._rootBlockDefaultConfig, rootBlockConfig);
	      this._root = new Block(this, null, rootConfig, '__root');

	      this._root._open();
	    }

	    _createClass(Layout, [{
	      key: "getRootBlock",
	      value: function getRootBlock() {
	        return this._root;
	      }
	    }, {
	      key: "_append",
	      value: function _append(text) {
	        return this._written.push(text);
	      }
	    }, {
	      key: "_appendLine",
	      value: function _appendLine(text) {
	        var s;

	        this._append(text);

	        s = new SpecialString(text);

	        if (s.length < this._config.terminalWidth) {
	          this._append('<none>\n</none>');
	        }

	        return this;
	      }
	    }, {
	      key: "get",
	      value: function get() {
	        this._ensureClosed();

	        if (this._written[this._written.length - 1] === '<none>\n</none>') {
	          this._written.pop();
	        }

	        return this._written.join("");
	      }
	    }, {
	      key: "_ensureClosed",
	      value: function _ensureClosed() {
	        if (this._activeBlock !== this._root) {
	          throw Error("Not all the blocks have been closed. Please call block.close() on all open blocks.");
	        }

	        if (this._root.isOpen()) {
	          this._root.close();
	        }
	      }
	    }]);

	    return Layout;
	  }();
	  self = Layout;
	  Layout._rootBlockDefaultConfig = {
	    linePrependor: {
	      options: {
	        amount: 0
	      }
	    },
	    lineAppendor: {
	      options: {
	        amount: 0
	      }
	    },
	    blockPrependor: {
	      options: {
	        amount: 0
	      }
	    },
	    blockAppendor: {
	      options: {
	        amount: 0
	      }
	    }
	  };
	  Layout._defaultConfig = {
	    terminalWidth: terminalWidth
	  };
	  return Layout;
	}.call(void 0);

	ref = ['openBlock', 'write'];

	for (i = 0, len = ref.length; i < len; i++) {
	  prop = ref[i];

	  (function () {
	    var method;
	    method = prop;
	    return Layout.prototype[method] = function () {
	      return this._root[method].apply(this._root, arguments);
	    };
	  })();
	}
	return Layout_1;
}

function ansiRegex({onlyFirst = false} = {}) {
	const pattern = [
	    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex = ansiRegex();

function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex, '');
}

var stripAnsi$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: stripAnsi
});

var require$$7 = /*@__PURE__*/getAugmentedNamespace(stripAnsi$1);

var RenderKid_1;
var hasRequiredRenderKid;

function requireRenderKid () {
	if (hasRequiredRenderKid) return RenderKid_1;
	hasRequiredRenderKid = 1;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Generated by CoffeeScript 2.5.1
	var AnsiPainter, Layout, Styles, blockStyleApplier, cloneAndMergeDeep, inlineStyleApplier, isPlainObject, stripAnsi, terminalWidth, tools;
	inlineStyleApplier = requireInline$1();
	blockStyleApplier = requireBlock$1();
	isPlainObject = requireIsPlainObject();

	var _require = requireTools();

	cloneAndMergeDeep = _require.cloneAndMergeDeep;
	AnsiPainter = requireAnsiPainter();
	Styles = requireStyles();
	Layout = requireLayout();
	tools = requireTools();
	stripAnsi = require$$7;
	terminalWidth = requireTools().getCols();

	RenderKid_1 = function () {
	  var self;

	  var RenderKid = /*#__PURE__*/function () {
	    function RenderKid() {
	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      _classCallCheck(this, RenderKid);

	      this.tools = self.tools;
	      this._config = cloneAndMergeDeep(self._defaultConfig, config);

	      this._initStyles();
	    }

	    _createClass(RenderKid, [{
	      key: "_initStyles",
	      value: function _initStyles() {
	        return this._styles = new Styles();
	      }
	    }, {
	      key: "style",
	      value: function style() {
	        return this._styles.setRule.apply(this._styles, arguments);
	      }
	    }, {
	      key: "_getStyleFor",
	      value: function _getStyleFor(el) {
	        return this._styles.getStyleFor(el);
	      }
	    }, {
	      key: "render",
	      value: function render(input) {
	        var withColors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	        return this._paint(this._renderDom(this._toDom(input)), withColors);
	      }
	    }, {
	      key: "_toDom",
	      value: function _toDom(input) {
	        if (typeof input === 'string') {
	          return this._parse(input);
	        } else if (isPlainObject(input) || Array.isArray(input)) {
	          return this._objToDom(input);
	        } else {
	          throw Error("Invalid input type. Only strings, arrays and objects are accepted");
	        }
	      }
	    }, {
	      key: "_objToDom",
	      value: function _objToDom(o) {
	        var injectFakeRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	        if (injectFakeRoot) {
	          o = {
	            body: o
	          };
	        }

	        return tools.objectToDom(o);
	      }
	    }, {
	      key: "_paint",
	      value: function _paint(text, withColors) {
	        var painted;
	        painted = AnsiPainter.paint(text);

	        if (withColors) {
	          return painted;
	        } else {
	          return stripAnsi(painted);
	        }
	      }
	    }, {
	      key: "_parse",
	      value: function _parse(string) {
	        var injectFakeRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	        if (injectFakeRoot) {
	          string = '<body>' + string + '</body>';
	        }

	        return tools.stringToDom(string);
	      }
	    }, {
	      key: "_renderDom",
	      value: function _renderDom(dom) {
	        var bodyTag, layout, rootBlock;
	        bodyTag = dom[0];
	        layout = new Layout(this._config.layout);
	        rootBlock = layout.getRootBlock();

	        this._renderBlockNode(bodyTag, null, rootBlock);

	        return layout.get();
	      }
	    }, {
	      key: "_renderChildrenOf",
	      value: function _renderChildrenOf(parentNode, parentBlock) {
	        var i, len, node, nodes;
	        nodes = parentNode.children;

	        for (i = 0, len = nodes.length; i < len; i++) {
	          node = nodes[i];

	          this._renderNode(node, parentNode, parentBlock);
	        }
	      }
	    }, {
	      key: "_renderNode",
	      value: function _renderNode(node, parentNode, parentBlock) {
	        if (node.type === 'text') {
	          this._renderText(node, parentNode, parentBlock);
	        } else if (node.name === 'br') {
	          this._renderBr(node, parentNode, parentBlock);
	        } else if (this._isBlock(node)) {
	          this._renderBlockNode(node, parentNode, parentBlock);
	        } else if (this._isNone(node)) {
	          return;
	        } else {
	          this._renderInlineNode(node, parentNode, parentBlock);
	        }
	      }
	    }, {
	      key: "_renderText",
	      value: function _renderText(node, parentNode, parentBlock) {
	        var ref, text;
	        text = node.data;
	        text = text.replace(/\s+/g, ' '); // let's only trim if the parent is an inline element

	        if ((parentNode != null ? (ref = parentNode.styles) != null ? ref.display : void 0 : void 0) !== 'inline') {
	          text = text.trim();
	        }

	        if (text.length === 0) {
	          return;
	        }

	        text = text.replace(/&nl;/g, "\n");
	        return parentBlock.write(text);
	      }
	    }, {
	      key: "_renderBlockNode",
	      value: function _renderBlockNode(node, parentNode, parentBlock) {
	        var after, before, block, blockConfig;

	        var _blockStyleApplier$ap = blockStyleApplier.applyTo(node, this._getStyleFor(node));

	        before = _blockStyleApplier$ap.before;
	        after = _blockStyleApplier$ap.after;
	        blockConfig = _blockStyleApplier$ap.blockConfig;
	        block = parentBlock.openBlock(blockConfig);

	        if (before !== '') {
	          block.write(before);
	        }

	        this._renderChildrenOf(node, block);

	        if (after !== '') {
	          block.write(after);
	        }

	        return block.close();
	      }
	    }, {
	      key: "_renderInlineNode",
	      value: function _renderInlineNode(node, parentNode, parentBlock) {
	        var after, before;

	        var _inlineStyleApplier$a = inlineStyleApplier.applyTo(node, this._getStyleFor(node));

	        before = _inlineStyleApplier$a.before;
	        after = _inlineStyleApplier$a.after;

	        if (before !== '') {
	          parentBlock.write(before);
	        }

	        this._renderChildrenOf(node, parentBlock);

	        if (after !== '') {
	          return parentBlock.write(after);
	        }
	      }
	    }, {
	      key: "_renderBr",
	      value: function _renderBr(node, parentNode, parentBlock) {
	        return parentBlock.write("\n");
	      }
	    }, {
	      key: "_isBlock",
	      value: function _isBlock(node) {
	        return !(node.type === 'text' || node.name === 'br' || this._getStyleFor(node).display !== 'block');
	      }
	    }, {
	      key: "_isNone",
	      value: function _isNone(node) {
	        return !(node.type === 'text' || node.name === 'br' || this._getStyleFor(node).display !== 'none');
	      }
	    }]);

	    return RenderKid;
	  }();
	  self = RenderKid;
	  RenderKid.AnsiPainter = AnsiPainter;
	  RenderKid.Layout = Layout;
	  RenderKid.quote = tools.quote;
	  RenderKid.tools = tools;
	  RenderKid._defaultConfig = {
	    layout: {
	      terminalWidth: terminalWidth
	    }
	  };
	  return RenderKid;
	}.call(void 0);
	return RenderKid_1;
}

var PrettyError_1;
var hasRequiredPrettyError;

function requirePrettyError () {
	if (hasRequiredPrettyError) return PrettyError_1;
	hasRequiredPrettyError = 1;
	// Generated by CoffeeScript 1.8.0
	var ParsedError, PrettyError, RenderKid, arrayUtils, defaultStyle, instance, isPlainObject, merge, nodePaths, prop, _fn, _i, _len, _ref,
	  __slice = [].slice,
	  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	isPlainObject = requireIsPlainObject();

	defaultStyle = requireDefaultStyle();

	ParsedError = requireParsedError();

	nodePaths = requireNodePaths();

	RenderKid = requireRenderKid();

	merge = requireMerge();

	arrayUtils = {
	  pluckByCallback: function(a, cb) {
	    var index, removed, value, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    removed = 0;
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      value = a[index];
	      if (cb(value, index)) {
	        removed++;
	        continue;
	      }
	      if (removed !== 0) {
	        a[index - removed] = a[index];
	      }
	    }
	    if (removed > 0) {
	      a.length = a.length - removed;
	    }
	    return a;
	  },
	  pluckOneItem: function(a, item) {
	    var index, reached, value, _i, _len;
	    if (a.length < 1) {
	      return a;
	    }
	    reached = false;
	    for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
	      value = a[index];
	      if (!reached) {
	        if (value === item) {
	          reached = true;
	          continue;
	        }
	      } else {
	        a[index - 1] = a[index];
	      }
	    }
	    if (reached) {
	      a.length = a.length - 1;
	    }
	    return a;
	  }
	};

	instance = null;

	PrettyError_1 = PrettyError = (function() {
	  var self;

	  self = PrettyError;

	  PrettyError._filters = {
	    'module.exports': function(item) {
	      if (item.what == null) {
	        return;
	      }
	      item.what = item.what.replace(/\.module\.exports\./g, ' - ');
	    }
	  };

	  PrettyError._getDefaultStyle = function() {
	    return defaultStyle();
	  };

	  PrettyError.start = function() {
	    if (instance == null) {
	      instance = new self;
	      instance.start();
	    }
	    return instance;
	  };

	  PrettyError.stop = function() {
	    return instance != null ? instance.stop() : void 0;
	  };

	  function PrettyError() {
	    this._useColors = true;
	    this._maxItems = 50;
	    this._packagesToSkip = [];
	    this._pathsToSkip = [];
	    this._skipCallbacks = [];
	    this._filterCallbacks = [];
	    this._parsedErrorFilters = [];
	    this._aliases = [];
	    this._renderer = new RenderKid;
	    this._style = self._getDefaultStyle();
	    this._renderer.style(this._style);
	  }

	  PrettyError.prototype.start = function() {
	    var prepeare;
	    this._oldPrepareStackTrace = Error.prepareStackTrace;
	    prepeare = this._oldPrepareStackTrace || function(exc, frames) {
	      var result;
	      result = exc.toString();
	      frames = frames.map(function(frame) {
	        return "  at " + (frame.toString());
	      });
	      return result + "\n" + frames.join("\n");
	    };
	    Error.prepareStackTrace = (function(_this) {
	      return function(exc, trace) {
	        var stack;
	        stack = prepeare.apply(null, arguments);
	        return _this.render({
	          stack: stack,
	          message: exc.toString().replace(/^.*: /, '')
	        }, false);
	      };
	    })(this);
	    return this;
	  };

	  PrettyError.prototype.stop = function() {
	    Error.prepareStackTrace = this._oldPrepareStackTrace;
	    return this._oldPrepareStackTrace = null;
	  };

	  PrettyError.prototype.config = function(c) {
	    var alias, path, _ref;
	    if (c.skipPackages != null) {
	      if (c.skipPackages === false) {
	        this.unskipAllPackages();
	      } else {
	        this.skipPackage.apply(this, c.skipPackages);
	      }
	    }
	    if (c.skipPaths != null) {
	      if (c.skipPaths === false) {
	        this.unskipAllPaths();
	      } else {
	        this.skipPath.apply(this, c.skipPaths);
	      }
	    }
	    if (c.skip != null) {
	      if (c.skip === false) {
	        this.unskipAll();
	      } else {
	        this.skip.apply(this, c.skip);
	      }
	    }
	    if (c.maxItems != null) {
	      this.setMaxItems(c.maxItems);
	    }
	    if (c.skipNodeFiles === true) {
	      this.skipNodeFiles();
	    } else if (c.skipNodeFiles === false) {
	      this.unskipNodeFiles();
	    }
	    if (c.filters != null) {
	      if (c.filters === false) {
	        this.removeAllFilters();
	      } else {
	        this.filter.apply(this, c.filters);
	      }
	    }
	    if (c.parsedErrorFilters != null) {
	      if (c.parsedErrorFilters === false) {
	        this.removeAllParsedErrorFilters();
	      } else {
	        this.filterParsedError.apply(this, c.parsedErrorFilters);
	      }
	    }
	    if (c.aliases != null) {
	      if (isPlainObject(c.aliases)) {
	        _ref = c.aliases;
	        for (path in _ref) {
	          alias = _ref[path];
	          this.alias(path, alias);
	        }
	      } else if (c.aliases === false) {
	        this.removeAllAliases();
	      }
	    }
	    return this;
	  };

	  PrettyError.prototype.withoutColors = function() {
	    this._useColors = false;
	    return this;
	  };

	  PrettyError.prototype.withColors = function() {
	    this._useColors = true;
	    return this;
	  };

	  PrettyError.prototype.skipPackage = function() {
	    var packages, pkg, _i, _len;
	    packages = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = packages.length; _i < _len; _i++) {
	      pkg = packages[_i];
	      this._packagesToSkip.push(String(pkg));
	    }
	    return this;
	  };

	  PrettyError.prototype.unskipPackage = function() {
	    var packages, pkg, _i, _len;
	    packages = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = packages.length; _i < _len; _i++) {
	      pkg = packages[_i];
	      arrayUtils.pluckOneItem(this._packagesToSkip, pkg);
	    }
	    return this;
	  };

	  PrettyError.prototype.unskipAllPackages = function() {
	    this._packagesToSkip.length = 0;
	    return this;
	  };

	  PrettyError.prototype.skipPath = function() {
	    var path, paths, _i, _len;
	    paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = paths.length; _i < _len; _i++) {
	      path = paths[_i];
	      this._pathsToSkip.push(path);
	    }
	    return this;
	  };

	  PrettyError.prototype.unskipPath = function() {
	    var path, paths, _i, _len;
	    paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = paths.length; _i < _len; _i++) {
	      path = paths[_i];
	      arrayUtils.pluckOneItem(this._pathsToSkip, path);
	    }
	    return this;
	  };

	  PrettyError.prototype.unskipAllPaths = function() {
	    this._pathsToSkip.length = 0;
	    return this;
	  };

	  PrettyError.prototype.skip = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      this._skipCallbacks.push(cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.unskip = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      arrayUtils.pluckOneItem(this._skipCallbacks, cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.unskipAll = function() {
	    this._skipCallbacks.length = 0;
	    return this;
	  };

	  PrettyError.prototype.skipNodeFiles = function() {
	    return this.skipPath.apply(this, nodePaths);
	  };

	  PrettyError.prototype.unskipNodeFiles = function() {
	    return this.unskipPath.apply(this, nodePaths);
	  };

	  PrettyError.prototype.filter = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      this._filterCallbacks.push(cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.removeFilter = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      arrayUtils.pluckOneItem(this._filterCallbacks, cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.removeAllFilters = function() {
	    this._filterCallbacks.length = 0;
	    return this;
	  };

	  PrettyError.prototype.filterParsedError = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      this._parsedErrorFilters.push(cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.removeParsedErrorFilter = function() {
	    var callbacks, cb, _i, _len;
	    callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	      cb = callbacks[_i];
	      arrayUtils.pluckOneItem(this._parsedErrorFilters, cb);
	    }
	    return this;
	  };

	  PrettyError.prototype.removeAllParsedErrorFilters = function() {
	    this._parsedErrorFilters.length = 0;
	    return this;
	  };

	  PrettyError.prototype.setMaxItems = function(maxItems) {
	    if (maxItems == null) {
	      maxItems = 50;
	    }
	    if (maxItems === 0) {
	      maxItems = 50;
	    }
	    this._maxItems = maxItems | 0;
	    return this;
	  };

	  PrettyError.prototype.alias = function(stringOrRx, alias) {
	    this._aliases.push({
	      stringOrRx: stringOrRx,
	      alias: alias
	    });
	    return this;
	  };

	  PrettyError.prototype.removeAlias = function(stringOrRx) {
	    arrayUtils.pluckByCallback(this._aliases, function(pair) {
	      return pair.stringOrRx === stringOrRx;
	    });
	    return this;
	  };

	  PrettyError.prototype.removeAllAliases = function() {
	    this._aliases.length = 0;
	    return this;
	  };

	  PrettyError.prototype._getStyle = function() {
	    return this._style;
	  };

	  PrettyError.prototype.appendStyle = function(toAppend) {
	    merge(this._style, toAppend);
	    this._renderer.style(toAppend);
	    return this;
	  };

	  PrettyError.prototype._getRenderer = function() {
	    return this._renderer;
	  };

	  PrettyError.prototype.render = function(e, logIt, useColors) {
	    var obj, rendered;
	    if (logIt == null) {
	      logIt = false;
	    }
	    if (useColors == null) {
	      useColors = this._useColors;
	    }
	    obj = this.getObject(e);
	    rendered = this._renderer.render(obj, useColors);
	    if (logIt === true) {
	      console.error(rendered);
	    }
	    return rendered;
	  };

	  PrettyError.prototype.getObject = function(e) {
	    var count, header, i, item, obj, traceItems, _i, _len, _ref;
	    if (!(e instanceof ParsedError)) {
	      e = new ParsedError(e);
	    }
	    this._applyParsedErrorFiltersOn(e);
	    header = {
	      title: (function() {
	        var ret;
	        ret = {};
	        if (e.wrapper !== '') {
	          ret.wrapper = "" + e.wrapper;
	        }
	        ret.kind = e.kind;
	        return ret;
	      })(),
	      colon: ':',
	      message: String(e.message).trim()
	    };
	    traceItems = [];
	    count = -1;
	    _ref = e.trace;
	    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
	      item = _ref[i];
	      if (item == null) {
	        continue;
	      }
	      if (this._skipOrFilter(item, i) === true) {
	        continue;
	      }
	      count++;
	      if (count > this._maxItems) {
	        break;
	      }
	      if (typeof item === 'string') {
	        traceItems.push({
	          item: {
	            custom: item
	          }
	        });
	        continue;
	      }
	      traceItems.push((function() {
	        var markupItem;
	        markupItem = {
	          item: {
	            header: {
	              pointer: (function() {
	                if (item.file == null) {
	                  return '';
	                }
	                return {
	                  file: item.file,
	                  colon: ':',
	                  line: item.line
	                };
	              })()
	            },
	            footer: (function() {
	              var foooter;
	              foooter = {
	                addr: item.shortenedAddr
	              };
	              if (item.extra != null) {
	                foooter.extra = item.extra;
	              }
	              return foooter;
	            })()
	          }
	        };
	        if (typeof item.what === 'string' && item.what.trim().length > 0) {
	          markupItem.item.header.what = item.what;
	        }
	        return markupItem;
	      })());
	    }
	    obj = {
	      'pretty-error': {
	        header: header
	      }
	    };
	    if (traceItems.length > 0) {
	      obj['pretty-error'].trace = traceItems;
	    }
	    return obj;
	  };

	  PrettyError.prototype._skipOrFilter = function(item, itemNumber) {
	    var cb, modName, pair, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
	    if (typeof item === 'object') {
	      if (_ref = item.modName, __indexOf.call(this._packagesToSkip, _ref) >= 0) {
	        return true;
	      }
	      if (_ref1 = item.path, __indexOf.call(this._pathsToSkip, _ref1) >= 0) {
	        return true;
	      }
	      _ref2 = item.packages;
	      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
	        modName = _ref2[_i];
	        if (__indexOf.call(this._packagesToSkip, modName) >= 0) {
	          return true;
	        }
	      }
	      if (typeof item.shortenedAddr === 'string') {
	        _ref3 = this._aliases;
	        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
	          pair = _ref3[_j];
	          item.shortenedAddr = item.shortenedAddr.replace(pair.stringOrRx, pair.alias);
	        }
	      }
	    }
	    _ref4 = this._skipCallbacks;
	    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
	      cb = _ref4[_k];
	      if (cb(item, itemNumber) === true) {
	        return true;
	      }
	    }
	    _ref5 = this._filterCallbacks;
	    for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
	      cb = _ref5[_l];
	      cb(item, itemNumber);
	    }
	    return false;
	  };

	  PrettyError.prototype._applyParsedErrorFiltersOn = function(error) {
	    var cb, _i, _len, _ref;
	    _ref = this._parsedErrorFilters;
	    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	      cb = _ref[_i];
	      cb(error);
	    }
	  };

	  return PrettyError;

	})();

	_ref = ['renderer', 'style'];
	_fn = function() {
	  var methodName;
	  methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length);
	  return PrettyError.prototype.__defineGetter__(prop, function() {
	    return this[methodName]();
	  });
	};
	for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	  prop = _ref[_i];
	  _fn();
	}
	return PrettyError_1;
}

let prettyError$1;

function getPrettyError () {
  if (!prettyError$1) {
    // lazily require to improve startup time since pretty-error is rather heavy package
    const PrettyError = requirePrettyError();
    prettyError$1 = new PrettyError();
    prettyError$1.withoutColors();
    prettyError$1.skipPackage('html-plugin-evaluation');
    prettyError$1.skipNodeFiles();
    prettyError$1.skip(function (traceLine) {
      return traceLine.path === 'html-plugin-evaluation';
    });
  }
  return prettyError$1;
}

var errors = function (err, context) {
  return {
    toHtml: function () {
      return 'Html Webpack Plugin:\n<pre>\n' + this.toString() + '</pre>';
    },
    toJsonHtml: function () {
      return JSON.stringify(this.toHtml());
    },
    toString: function () {
      try {
        return getPrettyError().render(err).replace(/webpack:\/\/\/\./g, context);
      } catch (e) {
        // This can sometimes fail. We don't know why, but returning the
        // original error is better than returning the error thrown by
        // pretty-error.
        return err;
      }
    }
  };
};

var chunksorter = {exports: {}};

(function (module) {

	/**
	 * @type {{[sortmode: string] : (entryPointNames: Array<string>, compilation, htmlWebpackPluginOptions) => Array<string> }}
	 * This file contains different sort methods for the entry chunks names
	 */
	module.exports = {};

	/**
	 * Performs identity mapping (no-sort).
	 * @param  {Array} chunks the chunks to sort
	 * @return {Array} The sorted chunks
	 */
	module.exports.none = chunks => chunks;

	/**
	 * Sort manually by the chunks
	 * @param  {string[]} entryPointNames the chunks to sort
	 * @param  {WebpackCompilation} compilation the webpack compilation
	 * @param  htmlWebpackPluginOptions the plugin options
	 * @return {string[]} The sorted chunks
	 */
	module.exports.manual = (entryPointNames, compilation, htmlWebpackPluginOptions) => {
	  const chunks = htmlWebpackPluginOptions.chunks;
	  if (!Array.isArray(chunks)) {
	    return entryPointNames;
	  }
	  // Remove none existing entries from
	  // htmlWebpackPluginOptions.chunks
	  return chunks.filter((entryPointName) => {
	    return compilation.entrypoints.has(entryPointName);
	  });
	};

	/**
	 * Defines the default sorter.
	 */
	module.exports.auto = module.exports.none; 
} (chunksorter));

var chunksorterExports = chunksorter.exports;

var lib$1 = {};

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const util$2 = require$$0$5;

const deprecateContext = util$2.deprecate(() => {},
"Hook.context is deprecated and will be removed");

const CALL_DELEGATE = function(...args) {
	this.call = this._createCall("sync");
	return this.call(...args);
};
const CALL_ASYNC_DELEGATE = function(...args) {
	this.callAsync = this._createCall("async");
	return this.callAsync(...args);
};
const PROMISE_DELEGATE = function(...args) {
	this.promise = this._createCall("promise");
	return this.promise(...args);
};

let Hook$a = class Hook {
	constructor(args = [], name = undefined) {
		this._args = args;
		this.name = name;
		this.taps = [];
		this.interceptors = [];
		this._call = CALL_DELEGATE;
		this.call = CALL_DELEGATE;
		this._callAsync = CALL_ASYNC_DELEGATE;
		this.callAsync = CALL_ASYNC_DELEGATE;
		this._promise = PROMISE_DELEGATE;
		this.promise = PROMISE_DELEGATE;
		this._x = undefined;

		this.compile = this.compile;
		this.tap = this.tap;
		this.tapAsync = this.tapAsync;
		this.tapPromise = this.tapPromise;
	}

	compile(options) {
		throw new Error("Abstract: should be overridden");
	}

	_createCall(type) {
		return this.compile({
			taps: this.taps,
			interceptors: this.interceptors,
			args: this._args,
			type: type
		});
	}

	_tap(type, options, fn) {
		if (typeof options === "string") {
			options = {
				name: options.trim()
			};
		} else if (typeof options !== "object" || options === null) {
			throw new Error("Invalid tap options");
		}
		if (typeof options.name !== "string" || options.name === "") {
			throw new Error("Missing name for tap");
		}
		if (typeof options.context !== "undefined") {
			deprecateContext();
		}
		options = Object.assign({ type, fn }, options);
		options = this._runRegisterInterceptors(options);
		this._insert(options);
	}

	tap(options, fn) {
		this._tap("sync", options, fn);
	}

	tapAsync(options, fn) {
		this._tap("async", options, fn);
	}

	tapPromise(options, fn) {
		this._tap("promise", options, fn);
	}

	_runRegisterInterceptors(options) {
		for (const interceptor of this.interceptors) {
			if (interceptor.register) {
				const newOptions = interceptor.register(options);
				if (newOptions !== undefined) {
					options = newOptions;
				}
			}
		}
		return options;
	}

	withOptions(options) {
		const mergeOptions = opt =>
			Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);

		return {
			name: this.name,
			tap: (opt, fn) => this.tap(mergeOptions(opt), fn),
			tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),
			tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),
			intercept: interceptor => this.intercept(interceptor),
			isUsed: () => this.isUsed(),
			withOptions: opt => this.withOptions(mergeOptions(opt))
		};
	}

	isUsed() {
		return this.taps.length > 0 || this.interceptors.length > 0;
	}

	intercept(interceptor) {
		this._resetCompilation();
		this.interceptors.push(Object.assign({}, interceptor));
		if (interceptor.register) {
			for (let i = 0; i < this.taps.length; i++) {
				this.taps[i] = interceptor.register(this.taps[i]);
			}
		}
	}

	_resetCompilation() {
		this.call = this._call;
		this.callAsync = this._callAsync;
		this.promise = this._promise;
	}

	_insert(item) {
		this._resetCompilation();
		let before;
		if (typeof item.before === "string") {
			before = new Set([item.before]);
		} else if (Array.isArray(item.before)) {
			before = new Set(item.before);
		}
		let stage = 0;
		if (typeof item.stage === "number") {
			stage = item.stage;
		}
		let i = this.taps.length;
		while (i > 0) {
			i--;
			const x = this.taps[i];
			this.taps[i + 1] = x;
			const xStage = x.stage || 0;
			if (before) {
				if (before.has(x.name)) {
					before.delete(x.name);
					continue;
				}
				if (before.size > 0) {
					continue;
				}
			}
			if (xStage > stage) {
				continue;
			}
			i++;
			break;
		}
		this.taps[i] = item;
	}
};

Object.setPrototypeOf(Hook$a.prototype, null);

var Hook_1 = Hook$a;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

let HookCodeFactory$a = class HookCodeFactory {
	constructor(config) {
		this.config = config;
		this.options = undefined;
		this._args = undefined;
	}

	create(options) {
		this.init(options);
		let fn;
		switch (this.options.type) {
			case "sync":
				fn = new Function(
					this.args(),
					'"use strict";\n' +
						this.header() +
						this.contentWithInterceptors({
							onError: err => `throw ${err};\n`,
							onResult: result => `return ${result};\n`,
							resultReturns: true,
							onDone: () => "",
							rethrowIfPossible: true
						})
				);
				break;
			case "async":
				fn = new Function(
					this.args({
						after: "_callback"
					}),
					'"use strict";\n' +
						this.header() +
						this.contentWithInterceptors({
							onError: err => `_callback(${err});\n`,
							onResult: result => `_callback(null, ${result});\n`,
							onDone: () => "_callback();\n"
						})
				);
				break;
			case "promise":
				let errorHelperUsed = false;
				const content = this.contentWithInterceptors({
					onError: err => {
						errorHelperUsed = true;
						return `_error(${err});\n`;
					},
					onResult: result => `_resolve(${result});\n`,
					onDone: () => "_resolve();\n"
				});
				let code = "";
				code += '"use strict";\n';
				code += this.header();
				code += "return new Promise((function(_resolve, _reject) {\n";
				if (errorHelperUsed) {
					code += "var _sync = true;\n";
					code += "function _error(_err) {\n";
					code += "if(_sync)\n";
					code +=
						"_resolve(Promise.resolve().then((function() { throw _err; })));\n";
					code += "else\n";
					code += "_reject(_err);\n";
					code += "};\n";
				}
				code += content;
				if (errorHelperUsed) {
					code += "_sync = false;\n";
				}
				code += "}));\n";
				fn = new Function(this.args(), code);
				break;
		}
		this.deinit();
		return fn;
	}

	setup(instance, options) {
		instance._x = options.taps.map(t => t.fn);
	}

	/**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */
	init(options) {
		this.options = options;
		this._args = options.args.slice();
	}

	deinit() {
		this.options = undefined;
		this._args = undefined;
	}

	contentWithInterceptors(options) {
		if (this.options.interceptors.length > 0) {
			const onError = options.onError;
			const onResult = options.onResult;
			const onDone = options.onDone;
			let code = "";
			for (let i = 0; i < this.options.interceptors.length; i++) {
				const interceptor = this.options.interceptors[i];
				if (interceptor.call) {
					code += `${this.getInterceptor(i)}.call(${this.args({
						before: interceptor.context ? "_context" : undefined
					})});\n`;
				}
			}
			code += this.content(
				Object.assign(options, {
					onError:
						onError &&
						(err => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.error) {
									code += `${this.getInterceptor(i)}.error(${err});\n`;
								}
							}
							code += onError(err);
							return code;
						}),
					onResult:
						onResult &&
						(result => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.result) {
									code += `${this.getInterceptor(i)}.result(${result});\n`;
								}
							}
							code += onResult(result);
							return code;
						}),
					onDone:
						onDone &&
						(() => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.done) {
									code += `${this.getInterceptor(i)}.done();\n`;
								}
							}
							code += onDone();
							return code;
						})
				})
			);
			return code;
		} else {
			return this.content(options);
		}
	}

	header() {
		let code = "";
		if (this.needContext()) {
			code += "var _context = {};\n";
		} else {
			code += "var _context;\n";
		}
		code += "var _x = this._x;\n";
		if (this.options.interceptors.length > 0) {
			code += "var _taps = this.taps;\n";
			code += "var _interceptors = this.interceptors;\n";
		}
		return code;
	}

	needContext() {
		for (const tap of this.options.taps) if (tap.context) return true;
		return false;
	}

	callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
		let code = "";
		let hasTapCached = false;
		for (let i = 0; i < this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.tap) {
				if (!hasTapCached) {
					code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
					hasTapCached = true;
				}
				code += `${this.getInterceptor(i)}.tap(${
					interceptor.context ? "_context, " : ""
				}_tap${tapIndex});\n`;
			}
		}
		code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
		const tap = this.options.taps[tapIndex];
		switch (tap.type) {
			case "sync":
				if (!rethrowIfPossible) {
					code += `var _hasError${tapIndex} = false;\n`;
					code += "try {\n";
				}
				if (onResult) {
					code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
						before: tap.context ? "_context" : undefined
					})});\n`;
				} else {
					code += `_fn${tapIndex}(${this.args({
						before: tap.context ? "_context" : undefined
					})});\n`;
				}
				if (!rethrowIfPossible) {
					code += "} catch(_err) {\n";
					code += `_hasError${tapIndex} = true;\n`;
					code += onError("_err");
					code += "}\n";
					code += `if(!_hasError${tapIndex}) {\n`;
				}
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				if (!rethrowIfPossible) {
					code += "}\n";
				}
				break;
			case "async":
				let cbCode = "";
				if (onResult)
					cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\n`;
				else cbCode += `(function(_err${tapIndex}) {\n`;
				cbCode += `if(_err${tapIndex}) {\n`;
				cbCode += onError(`_err${tapIndex}`);
				cbCode += "} else {\n";
				if (onResult) {
					cbCode += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					cbCode += onDone();
				}
				cbCode += "}\n";
				cbCode += "})";
				code += `_fn${tapIndex}(${this.args({
					before: tap.context ? "_context" : undefined,
					after: cbCode
				})});\n`;
				break;
			case "promise":
				code += `var _hasResult${tapIndex} = false;\n`;
				code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
					before: tap.context ? "_context" : undefined
				})});\n`;
				code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
				code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
				code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
				code += `_hasResult${tapIndex} = true;\n`;
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				code += `}), function(_err${tapIndex}) {\n`;
				code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
				code += onError(`_err${tapIndex}`);
				code += "});\n";
				break;
		}
		return code;
	}

	callTapsSeries({
		onError,
		onResult,
		resultReturns,
		onDone,
		doneReturns,
		rethrowIfPossible
	}) {
		if (this.options.taps.length === 0) return onDone();
		const firstAsync = this.options.taps.findIndex(t => t.type !== "sync");
		const somethingReturns = resultReturns || doneReturns;
		let code = "";
		let current = onDone;
		let unrollCounter = 0;
		for (let j = this.options.taps.length - 1; j >= 0; j--) {
			const i = j;
			const unroll =
				current !== onDone &&
				(this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
			if (unroll) {
				unrollCounter = 0;
				code += `function _next${i}() {\n`;
				code += current();
				code += `}\n`;
				current = () => `${somethingReturns ? "return " : ""}_next${i}();\n`;
			}
			const done = current;
			const doneBreak = skipDone => {
				if (skipDone) return "";
				return onDone();
			};
			const content = this.callTap(i, {
				onError: error => onError(i, error, done, doneBreak),
				onResult:
					onResult &&
					(result => {
						return onResult(i, result, done, doneBreak);
					}),
				onDone: !onResult && done,
				rethrowIfPossible:
					rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
			});
			current = () => content;
		}
		code += current();
		return code;
	}

	callTapsLooping({ onError, onDone, rethrowIfPossible }) {
		if (this.options.taps.length === 0) return onDone();
		const syncOnly = this.options.taps.every(t => t.type === "sync");
		let code = "";
		if (!syncOnly) {
			code += "var _looper = (function() {\n";
			code += "var _loopAsync = false;\n";
		}
		code += "var _loop;\n";
		code += "do {\n";
		code += "_loop = false;\n";
		for (let i = 0; i < this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.loop) {
				code += `${this.getInterceptor(i)}.loop(${this.args({
					before: interceptor.context ? "_context" : undefined
				})});\n`;
			}
		}
		code += this.callTapsSeries({
			onError,
			onResult: (i, result, next, doneBreak) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += "_loop = true;\n";
				if (!syncOnly) code += "if(_loopAsync) _looper();\n";
				code += doneBreak(true);
				code += `} else {\n`;
				code += next();
				code += `}\n`;
				return code;
			},
			onDone:
				onDone &&
				(() => {
					let code = "";
					code += "if(!_loop) {\n";
					code += onDone();
					code += "}\n";
					return code;
				}),
			rethrowIfPossible: rethrowIfPossible && syncOnly
		});
		code += "} while(_loop);\n";
		if (!syncOnly) {
			code += "_loopAsync = true;\n";
			code += "});\n";
			code += "_looper();\n";
		}
		return code;
	}

	callTapsParallel({
		onError,
		onResult,
		onDone,
		rethrowIfPossible,
		onTap = (i, run) => run()
	}) {
		if (this.options.taps.length <= 1) {
			return this.callTapsSeries({
				onError,
				onResult,
				onDone,
				rethrowIfPossible
			});
		}
		let code = "";
		code += "do {\n";
		code += `var _counter = ${this.options.taps.length};\n`;
		if (onDone) {
			code += "var _done = (function() {\n";
			code += onDone();
			code += "});\n";
		}
		for (let i = 0; i < this.options.taps.length; i++) {
			const done = () => {
				if (onDone) return "if(--_counter === 0) _done();\n";
				else return "--_counter;";
			};
			const doneBreak = skipDone => {
				if (skipDone || !onDone) return "_counter = 0;\n";
				else return "_counter = 0;\n_done();\n";
			};
			code += "if(_counter <= 0) break;\n";
			code += onTap(
				i,
				() =>
					this.callTap(i, {
						onError: error => {
							let code = "";
							code += "if(_counter > 0) {\n";
							code += onError(i, error, done, doneBreak);
							code += "}\n";
							return code;
						},
						onResult:
							onResult &&
							(result => {
								let code = "";
								code += "if(_counter > 0) {\n";
								code += onResult(i, result, done, doneBreak);
								code += "}\n";
								return code;
							}),
						onDone:
							!onResult &&
							(() => {
								return done();
							}),
						rethrowIfPossible
					}),
				done,
				doneBreak
			);
		}
		code += "} while(false);\n";
		return code;
	}

	args({ before, after } = {}) {
		let allArgs = this._args;
		if (before) allArgs = [before].concat(allArgs);
		if (after) allArgs = allArgs.concat(after);
		if (allArgs.length === 0) {
			return "";
		} else {
			return allArgs.join(", ");
		}
	}

	getTapFn(idx) {
		return `_x[${idx}]`;
	}

	getTap(idx) {
		return `_taps[${idx}]`;
	}

	getInterceptor(idx) {
		return `_interceptors[${idx}]`;
	}
};

var HookCodeFactory_1 = HookCodeFactory$a;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$9 = Hook_1;
const HookCodeFactory$9 = HookCodeFactory_1;

class SyncHookCodeFactory extends HookCodeFactory$9 {
	content({ onError, onDone, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onDone,
			rethrowIfPossible
		});
	}
}

const factory$9 = new SyncHookCodeFactory();

const TAP_ASYNC$3 = () => {
	throw new Error("tapAsync is not supported on a SyncHook");
};

const TAP_PROMISE$3 = () => {
	throw new Error("tapPromise is not supported on a SyncHook");
};

const COMPILE$9 = function(options) {
	factory$9.setup(this, options);
	return factory$9.create(options);
};

function SyncHook(args = [], name = undefined) {
	const hook = new Hook$9(args, name);
	hook.constructor = SyncHook;
	hook.tapAsync = TAP_ASYNC$3;
	hook.tapPromise = TAP_PROMISE$3;
	hook.compile = COMPILE$9;
	return hook;
}

SyncHook.prototype = null;

var SyncHook_1 = SyncHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$8 = Hook_1;
const HookCodeFactory$8 = HookCodeFactory_1;

class SyncBailHookCodeFactory extends HookCodeFactory$8 {
	content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onResult: (i, result, next) =>
				`if(${result} !== undefined) {\n${onResult(
					result
				)};\n} else {\n${next()}}\n`,
			resultReturns,
			onDone,
			rethrowIfPossible
		});
	}
}

const factory$8 = new SyncBailHookCodeFactory();

const TAP_ASYNC$2 = () => {
	throw new Error("tapAsync is not supported on a SyncBailHook");
};

const TAP_PROMISE$2 = () => {
	throw new Error("tapPromise is not supported on a SyncBailHook");
};

const COMPILE$8 = function(options) {
	factory$8.setup(this, options);
	return factory$8.create(options);
};

function SyncBailHook(args = [], name = undefined) {
	const hook = new Hook$8(args, name);
	hook.constructor = SyncBailHook;
	hook.tapAsync = TAP_ASYNC$2;
	hook.tapPromise = TAP_PROMISE$2;
	hook.compile = COMPILE$8;
	return hook;
}

SyncBailHook.prototype = null;

var SyncBailHook_1 = SyncBailHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$7 = Hook_1;
const HookCodeFactory$7 = HookCodeFactory_1;

class SyncWaterfallHookCodeFactory extends HookCodeFactory$7 {
	content({ onError, onResult, resultReturns, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onResult: (i, result, next) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += `${this._args[0]} = ${result};\n`;
				code += `}\n`;
				code += next();
				return code;
			},
			onDone: () => onResult(this._args[0]),
			doneReturns: resultReturns,
			rethrowIfPossible
		});
	}
}

const factory$7 = new SyncWaterfallHookCodeFactory();

const TAP_ASYNC$1 = () => {
	throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};

const TAP_PROMISE$1 = () => {
	throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};

const COMPILE$7 = function(options) {
	factory$7.setup(this, options);
	return factory$7.create(options);
};

function SyncWaterfallHook(args = [], name = undefined) {
	if (args.length < 1)
		throw new Error("Waterfall hooks must have at least one argument");
	const hook = new Hook$7(args, name);
	hook.constructor = SyncWaterfallHook;
	hook.tapAsync = TAP_ASYNC$1;
	hook.tapPromise = TAP_PROMISE$1;
	hook.compile = COMPILE$7;
	return hook;
}

SyncWaterfallHook.prototype = null;

var SyncWaterfallHook_1 = SyncWaterfallHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$6 = Hook_1;
const HookCodeFactory$6 = HookCodeFactory_1;

class SyncLoopHookCodeFactory extends HookCodeFactory$6 {
	content({ onError, onDone, rethrowIfPossible }) {
		return this.callTapsLooping({
			onError: (i, err) => onError(err),
			onDone,
			rethrowIfPossible
		});
	}
}

const factory$6 = new SyncLoopHookCodeFactory();

const TAP_ASYNC = () => {
	throw new Error("tapAsync is not supported on a SyncLoopHook");
};

const TAP_PROMISE = () => {
	throw new Error("tapPromise is not supported on a SyncLoopHook");
};

const COMPILE$6 = function(options) {
	factory$6.setup(this, options);
	return factory$6.create(options);
};

function SyncLoopHook(args = [], name = undefined) {
	const hook = new Hook$6(args, name);
	hook.constructor = SyncLoopHook;
	hook.tapAsync = TAP_ASYNC;
	hook.tapPromise = TAP_PROMISE;
	hook.compile = COMPILE$6;
	return hook;
}

SyncLoopHook.prototype = null;

var SyncLoopHook_1 = SyncLoopHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$5 = Hook_1;
const HookCodeFactory$5 = HookCodeFactory_1;

class AsyncParallelHookCodeFactory extends HookCodeFactory$5 {
	content({ onError, onDone }) {
		return this.callTapsParallel({
			onError: (i, err, done, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory$5 = new AsyncParallelHookCodeFactory();

const COMPILE$5 = function(options) {
	factory$5.setup(this, options);
	return factory$5.create(options);
};

function AsyncParallelHook(args = [], name = undefined) {
	const hook = new Hook$5(args, name);
	hook.constructor = AsyncParallelHook;
	hook.compile = COMPILE$5;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncParallelHook.prototype = null;

var AsyncParallelHook_1 = AsyncParallelHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$4 = Hook_1;
const HookCodeFactory$4 = HookCodeFactory_1;

class AsyncParallelBailHookCodeFactory extends HookCodeFactory$4 {
	content({ onError, onResult, onDone }) {
		let code = "";
		code += `var _results = new Array(${this.options.taps.length});\n`;
		code += "var _checkDone = function() {\n";
		code += "for(var i = 0; i < _results.length; i++) {\n";
		code += "var item = _results[i];\n";
		code += "if(item === undefined) return false;\n";
		code += "if(item.result !== undefined) {\n";
		code += onResult("item.result");
		code += "return true;\n";
		code += "}\n";
		code += "if(item.error) {\n";
		code += onError("item.error");
		code += "return true;\n";
		code += "}\n";
		code += "}\n";
		code += "return false;\n";
		code += "}\n";
		code += this.callTapsParallel({
			onError: (i, err, done, doneBreak) => {
				let code = "";
				code += `if(${i} < _results.length && ((_results.length = ${i +
					1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
				code += doneBreak(true);
				code += "} else {\n";
				code += done();
				code += "}\n";
				return code;
			},
			onResult: (i, result, done, doneBreak) => {
				let code = "";
				code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i +
					1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
				code += doneBreak(true);
				code += "} else {\n";
				code += done();
				code += "}\n";
				return code;
			},
			onTap: (i, run, done, doneBreak) => {
				let code = "";
				if (i > 0) {
					code += `if(${i} >= _results.length) {\n`;
					code += done();
					code += "} else {\n";
				}
				code += run();
				if (i > 0) code += "}\n";
				return code;
			},
			onDone
		});
		return code;
	}
}

const factory$4 = new AsyncParallelBailHookCodeFactory();

const COMPILE$4 = function(options) {
	factory$4.setup(this, options);
	return factory$4.create(options);
};

function AsyncParallelBailHook(args = [], name = undefined) {
	const hook = new Hook$4(args, name);
	hook.constructor = AsyncParallelBailHook;
	hook.compile = COMPILE$4;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncParallelBailHook.prototype = null;

var AsyncParallelBailHook_1 = AsyncParallelBailHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$3 = Hook_1;
const HookCodeFactory$3 = HookCodeFactory_1;

class AsyncSeriesHookCodeFactory extends HookCodeFactory$3 {
	content({ onError, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory$3 = new AsyncSeriesHookCodeFactory();

const COMPILE$3 = function(options) {
	factory$3.setup(this, options);
	return factory$3.create(options);
};

function AsyncSeriesHook(args = [], name = undefined) {
	const hook = new Hook$3(args, name);
	hook.constructor = AsyncSeriesHook;
	hook.compile = COMPILE$3;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesHook.prototype = null;

var AsyncSeriesHook_1 = AsyncSeriesHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$2 = Hook_1;
const HookCodeFactory$2 = HookCodeFactory_1;

class AsyncSeriesBailHookCodeFactory extends HookCodeFactory$2 {
	content({ onError, onResult, resultReturns, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onResult: (i, result, next) =>
				`if(${result} !== undefined) {\n${onResult(
					result
				)}\n} else {\n${next()}}\n`,
			resultReturns,
			onDone
		});
	}
}

const factory$2 = new AsyncSeriesBailHookCodeFactory();

const COMPILE$2 = function(options) {
	factory$2.setup(this, options);
	return factory$2.create(options);
};

function AsyncSeriesBailHook(args = [], name = undefined) {
	const hook = new Hook$2(args, name);
	hook.constructor = AsyncSeriesBailHook;
	hook.compile = COMPILE$2;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesBailHook.prototype = null;

var AsyncSeriesBailHook_1 = AsyncSeriesBailHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook$1 = Hook_1;
const HookCodeFactory$1 = HookCodeFactory_1;

class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory$1 {
	content({ onError, onDone }) {
		return this.callTapsLooping({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory$1 = new AsyncSeriesLoopHookCodeFactory();

const COMPILE$1 = function(options) {
	factory$1.setup(this, options);
	return factory$1.create(options);
};

function AsyncSeriesLoopHook(args = [], name = undefined) {
	const hook = new Hook$1(args, name);
	hook.constructor = AsyncSeriesLoopHook;
	hook.compile = COMPILE$1;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesLoopHook.prototype = null;

var AsyncSeriesLoopHook_1 = AsyncSeriesLoopHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const Hook = Hook_1;
const HookCodeFactory = HookCodeFactory_1;

class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onResult: (i, result, next) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += `${this._args[0]} = ${result};\n`;
				code += `}\n`;
				code += next();
				return code;
			},
			onDone: () => onResult(this._args[0])
		});
	}
}

const factory = new AsyncSeriesWaterfallHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncSeriesWaterfallHook$1(args = [], name = undefined) {
	if (args.length < 1)
		throw new Error("Waterfall hooks must have at least one argument");
	const hook = new Hook(args, name);
	hook.constructor = AsyncSeriesWaterfallHook$1;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesWaterfallHook$1.prototype = null;

var AsyncSeriesWaterfallHook_1 = AsyncSeriesWaterfallHook$1;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

const util$1 = require$$0$5;

const defaultFactory = (key, hook) => hook;

class HookMap {
	constructor(factory, name = undefined) {
		this._map = new Map();
		this.name = name;
		this._factory = factory;
		this._interceptors = [];
	}

	get(key) {
		return this._map.get(key);
	}

	for(key) {
		const hook = this.get(key);
		if (hook !== undefined) {
			return hook;
		}
		let newHook = this._factory(key);
		const interceptors = this._interceptors;
		for (let i = 0; i < interceptors.length; i++) {
			newHook = interceptors[i].factory(key, newHook);
		}
		this._map.set(key, newHook);
		return newHook;
	}

	intercept(interceptor) {
		this._interceptors.push(
			Object.assign(
				{
					factory: defaultFactory
				},
				interceptor
			)
		);
	}
}

HookMap.prototype.tap = util$1.deprecate(function(key, options, fn) {
	return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");

HookMap.prototype.tapAsync = util$1.deprecate(function(key, options, fn) {
	return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");

HookMap.prototype.tapPromise = util$1.deprecate(function(key, options, fn) {
	return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");

var HookMap_1 = HookMap;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

class MultiHook {
	constructor(hooks, name = undefined) {
		this.hooks = hooks;
		this.name = name;
	}

	tap(options, fn) {
		for (const hook of this.hooks) {
			hook.tap(options, fn);
		}
	}

	tapAsync(options, fn) {
		for (const hook of this.hooks) {
			hook.tapAsync(options, fn);
		}
	}

	tapPromise(options, fn) {
		for (const hook of this.hooks) {
			hook.tapPromise(options, fn);
		}
	}

	isUsed() {
		for (const hook of this.hooks) {
			if (hook.isUsed()) return true;
		}
		return false;
	}

	intercept(interceptor) {
		for (const hook of this.hooks) {
			hook.intercept(interceptor);
		}
	}

	withOptions(options) {
		return new MultiHook(
			this.hooks.map(h => h.withOptions(options)),
			this.name
		);
	}
}

var MultiHook_1 = MultiHook;

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

lib$1.__esModule = true;
lib$1.SyncHook = SyncHook_1;
lib$1.SyncBailHook = SyncBailHook_1;
lib$1.SyncWaterfallHook = SyncWaterfallHook_1;
lib$1.SyncLoopHook = SyncLoopHook_1;
lib$1.AsyncParallelHook = AsyncParallelHook_1;
lib$1.AsyncParallelBailHook = AsyncParallelBailHook_1;
lib$1.AsyncSeriesHook = AsyncSeriesHook_1;
lib$1.AsyncSeriesBailHook = AsyncSeriesBailHook_1;
lib$1.AsyncSeriesLoopHook = AsyncSeriesLoopHook_1;
lib$1.AsyncSeriesWaterfallHook = AsyncSeriesWaterfallHook_1;
lib$1.HookMap = HookMap_1;
lib$1.MultiHook = MultiHook_1;

/**
 * This file provides access to all public htmlWebpackPlugin hooks
 */

/** @typedef {import("webpack/lib/Compilation.js")} WebpackCompilation */
/** @typedef {import("../index.js")} HtmlWebpackPlugin */

const AsyncSeriesWaterfallHook = lib$1.AsyncSeriesWaterfallHook;

// The following is the API definition for all available hooks
// For the TypeScript definition, see the Hooks type in typings.d.ts
/**
  beforeAssetTagGeneration:
    AsyncSeriesWaterfallHook<{
      assets: {
        publicPath: string,
        js: Array<string>,
        css: Array<string>,
        favicon?: string | undefined,
        manifest?: string | undefined
      },
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
  alterAssetTags:
    AsyncSeriesWaterfallHook<{
      assetTags: {
        scripts: Array<HtmlTagObject>,
        styles: Array<HtmlTagObject>,
        meta: Array<HtmlTagObject>,
      },
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
  alterAssetTagGroups:
    AsyncSeriesWaterfallHook<{
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      publicPath: string,
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>,
  afterTemplateExecution:
    AsyncSeriesWaterfallHook<{
      html: string,
      headTags: Array<HtmlTagObject | HtmlTagObject>,
      bodyTags: Array<HtmlTagObject | HtmlTagObject>,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
  beforeEmit:
    AsyncSeriesWaterfallHook<{
      html: string,
      outputName: string,
      plugin: HtmlWebpackPlugin,
    }>,
  afterEmit:
    AsyncSeriesWaterfallHook<{
      outputName: string,
      plugin: HtmlWebpackPlugin
    }>
*/

/**
 * @type {WeakMap<WebpackCompilation, HtmlWebpackPluginHooks>}}
 */
const htmlWebpackPluginHooksMap = new WeakMap();

/**
 * Returns all public hooks of the html webpack plugin for the given compilation
 *
 * @param {WebpackCompilation} compilation
 * @returns {HtmlWebpackPluginHooks}
 */
function getHtmlWebpackPluginHooks$1 (compilation) {
  let hooks = htmlWebpackPluginHooksMap.get(compilation);
  // Setup the hooks only once
  if (hooks === undefined) {
    hooks = createHtmlWebpackPluginHooks();
    htmlWebpackPluginHooksMap.set(compilation, hooks);
  }
  return hooks;
}

/**
 * Add hooks to the webpack compilation object to allow foreign plugins to
 * extend the HtmlWebpackPlugin
 *
 * @returns {HtmlWebpackPluginHooks}
 */
function createHtmlWebpackPluginHooks () {
  return {
    beforeAssetTagGeneration: new AsyncSeriesWaterfallHook(['pluginArgs']),
    alterAssetTags: new AsyncSeriesWaterfallHook(['pluginArgs']),
    alterAssetTagGroups: new AsyncSeriesWaterfallHook(['pluginArgs']),
    afterTemplateExecution: new AsyncSeriesWaterfallHook(['pluginArgs']),
    beforeEmit: new AsyncSeriesWaterfallHook(['pluginArgs']),
    afterEmit: new AsyncSeriesWaterfallHook(['pluginArgs'])
  };
}

var hooks = {
  getHtmlWebpackPluginHooks: getHtmlWebpackPluginHooks$1
};

var htmlminifier = {};

var clean = {exports: {}};

var optimize$3;
var hasRequiredOptimize$3;

function requireOptimize$3 () {
	if (hasRequiredOptimize$3) return optimize$3;
	hasRequiredOptimize$3 = 1;
	function level0Optimize(tokens) {
	  // noop as level 0 means no optimizations!
	  return tokens;
	}

	optimize$3 = level0Optimize;
	return optimize$3;
}

var naturalCompare_1;
var hasRequiredNaturalCompare;

function requireNaturalCompare () {
	if (hasRequiredNaturalCompare) return naturalCompare_1;
	hasRequiredNaturalCompare = 1;
	// adapted from http://nedbatchelder.com/blog/200712.html#e20071211T054956

	var NUMBER_PATTERN = /([0-9]+)/;

	function naturalCompare(value1, value2) {
	  var keys1 = ('' + value1).split(NUMBER_PATTERN).map(tryParseInt);
	  var keys2 = ('' + value2).split(NUMBER_PATTERN).map(tryParseInt);
	  var key1;
	  var key2;
	  var compareFirst = Math.min(keys1.length, keys2.length);
	  var i, l;

	  for (i = 0, l = compareFirst; i < l; i++) {
	    key1 = keys1[i];
	    key2 = keys2[i];

	    if (key1 != key2) {
	      return key1 > key2 ? 1 : -1;
	    }
	  }

	  return keys1.length > keys2.length ? 1 : (keys1.length == keys2.length ? 0 : -1);
	}

	function tryParseInt(value) {
	  return ('' + parseInt(value)) == value
	    ? parseInt(value)
	    : value;
	}

	naturalCompare_1 = naturalCompare;
	return naturalCompare_1;
}

var sortSelectors_1;
var hasRequiredSortSelectors;

function requireSortSelectors () {
	if (hasRequiredSortSelectors) return sortSelectors_1;
	hasRequiredSortSelectors = 1;
	var naturalCompare = requireNaturalCompare();

	function naturalSorter(scope1, scope2) {
	  return naturalCompare(scope1[1], scope2[1]);
	}

	function standardSorter(scope1, scope2) {
	  return scope1[1] > scope2[1] ? 1 : -1;
	}

	function sortSelectors(selectors, method) {
	  switch (method) {
	  case 'natural':
	    return selectors.sort(naturalSorter);
	  case 'standard':
	    return selectors.sort(standardSorter);
	  case 'none':
	  case false:
	    return selectors;
	  }
	}

	sortSelectors_1 = sortSelectors;
	return sortSelectors_1;
}

var override_1;
var hasRequiredOverride;

function requireOverride () {
	if (hasRequiredOverride) return override_1;
	hasRequiredOverride = 1;
	function override(source1, source2) {
	  var target = {};
	  var key1;
	  var key2;
	  var item;

	  for (key1 in source1) {
	    item = source1[key1];

	    if (Array.isArray(item)) {
	      target[key1] = item.slice(0);
	    } else if (typeof item == 'object' && item !== null) {
	      target[key1] = override(item, {});
	    } else {
	      target[key1] = item;
	    }
	  }

	  for (key2 in source2) {
	    item = source2[key2];

	    if (key2 in target && Array.isArray(item)) {
	      target[key2] = item.slice(0);
	    } else if (key2 in target && typeof item == 'object' && item !== null) {
	      target[key2] = override(target[key2], item);
	    } else {
	      target[key2] = item;
	    }
	  }

	  return target;
	}

	override_1 = override;
	return override_1;
}

var format$1;
var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format$1;
	hasRequiredFormat$1 = 1;
	var systemLineBreak = require$$0$6.EOL;

	var override = requireOverride();

	var Breaks = {
	  AfterAtRule: 'afterAtRule',
	  AfterBlockBegins: 'afterBlockBegins',
	  AfterBlockEnds: 'afterBlockEnds',
	  AfterComment: 'afterComment',
	  AfterProperty: 'afterProperty',
	  AfterRuleBegins: 'afterRuleBegins',
	  AfterRuleEnds: 'afterRuleEnds',
	  BeforeBlockEnds: 'beforeBlockEnds',
	  BetweenSelectors: 'betweenSelectors'
	};

	var BreakWith = {
	  CarriageReturnLineFeed: '\r\n',
	  LineFeed: '\n',
	  System: systemLineBreak
	};

	var IndentWith = {
	  Space: ' ',
	  Tab: '\t'
	};

	var Spaces = {
	  AroundSelectorRelation: 'aroundSelectorRelation',
	  BeforeBlockBegins: 'beforeBlockBegins',
	  BeforeValue: 'beforeValue'
	};

	var DEFAULTS = {
	  breaks: breaks(false),
	  breakWith: BreakWith.System,
	  indentBy: 0,
	  indentWith: IndentWith.Space,
	  spaces: spaces(false),
	  wrapAt: false,
	  semicolonAfterLastProperty: false
	};

	var BEAUTIFY_ALIAS = 'beautify';
	var KEEP_BREAKS_ALIAS = 'keep-breaks';

	var OPTION_SEPARATOR = ';';
	var OPTION_NAME_VALUE_SEPARATOR = ':';
	var HASH_VALUES_OPTION_SEPARATOR = ',';
	var HASH_VALUES_NAME_VALUE_SEPARATOR = '=';

	var FALSE_KEYWORD_1 = 'false';
	var FALSE_KEYWORD_2 = 'off';
	var TRUE_KEYWORD_1 = 'true';
	var TRUE_KEYWORD_2 = 'on';

	function breaks(value) {
	  var breakOptions = {};

	  breakOptions[Breaks.AfterAtRule] = value;
	  breakOptions[Breaks.AfterBlockBegins] = value;
	  breakOptions[Breaks.AfterBlockEnds] = value;
	  breakOptions[Breaks.AfterComment] = value;
	  breakOptions[Breaks.AfterProperty] = value;
	  breakOptions[Breaks.AfterRuleBegins] = value;
	  breakOptions[Breaks.AfterRuleEnds] = value;
	  breakOptions[Breaks.BeforeBlockEnds] = value;
	  breakOptions[Breaks.BetweenSelectors] = value;

	  return breakOptions;
	}

	function spaces(value) {
	  var spaceOptions = {};

	  spaceOptions[Spaces.AroundSelectorRelation] = value;
	  spaceOptions[Spaces.BeforeBlockBegins] = value;
	  spaceOptions[Spaces.BeforeValue] = value;

	  return spaceOptions;
	}

	function formatFrom(source) {
	  if (source === undefined || source === false) {
	    return false;
	  }

	  if (typeof source == 'object' && 'breakWith' in source) {
	    source = override(source, { breakWith: mapBreakWith(source.breakWith) });
	  }

	  if (typeof source == 'object' && 'indentBy' in source) {
	    source = override(source, { indentBy: parseInt(source.indentBy) });
	  }

	  if (typeof source == 'object' && 'indentWith' in source) {
	    source = override(source, { indentWith: mapIndentWith(source.indentWith) });
	  }

	  if (typeof source == 'object') {
	    return remapBreaks(override(DEFAULTS, source));
	  }

	  if (typeof source == 'string' && source == BEAUTIFY_ALIAS) {
	    return remapBreaks(
	      override(DEFAULTS, {
	        breaks: breaks(true),
	        indentBy: 2,
	        spaces: spaces(true)
	      })
	    );
	  }

	  if (typeof source == 'string' && source == KEEP_BREAKS_ALIAS) {
	    return remapBreaks(
	      override(DEFAULTS, {
	        breaks: {
	          afterAtRule: true,
	          afterBlockBegins: true,
	          afterBlockEnds: true,
	          afterComment: true,
	          afterRuleEnds: true,
	          beforeBlockEnds: true
	        }
	      })
	    );
	  }

	  if (typeof source == 'string') {
	    return remapBreaks(override(DEFAULTS, toHash(source)));
	  }

	  return DEFAULTS;
	}

	function toHash(string) {
	  return string
	    .split(OPTION_SEPARATOR)
	    .reduce(function(accumulator, directive) {
	      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];

	      if (name == 'breaks' || name == 'spaces') {
	        accumulator[name] = hashValuesToHash(value);
	      } else if (name == 'indentBy' || name == 'wrapAt') {
	        accumulator[name] = parseInt(value);
	      } else if (name == 'indentWith') {
	        accumulator[name] = mapIndentWith(value);
	      } else if (name == 'breakWith') {
	        accumulator[name] = mapBreakWith(value);
	      }

	      return accumulator;
	    }, {});
	}

	function hashValuesToHash(string) {
	  return string
	    .split(HASH_VALUES_OPTION_SEPARATOR)
	    .reduce(function(accumulator, directive) {
	      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];

	      accumulator[name] = normalizeValue(value);

	      return accumulator;
	    }, {});
	}

	function normalizeValue(value) {
	  switch (value) {
	  case FALSE_KEYWORD_1:
	  case FALSE_KEYWORD_2:
	    return false;
	  case TRUE_KEYWORD_1:
	  case TRUE_KEYWORD_2:
	    return true;
	  default:
	    return value;
	  }
	}

	function mapBreakWith(value) {
	  switch (value) {
	  case 'windows':
	  case 'crlf':
	  case BreakWith.CarriageReturnLineFeed:
	    return BreakWith.CarriageReturnLineFeed;
	  case 'unix':
	  case 'lf':
	  case BreakWith.LineFeed:
	    return BreakWith.LineFeed;
	  default:
	    return systemLineBreak;
	  }
	}

	function mapIndentWith(value) {
	  switch (value) {
	  case 'space':
	    return IndentWith.Space;
	  case 'tab':
	    return IndentWith.Tab;
	  default:
	    return value;
	  }
	}

	function remapBreaks(source) {
	  for (var key in Breaks) {
	    var breakName = Breaks[key];
	    var breakValue = source.breaks[breakName];

	    if (breakValue === true) {
	      source.breaks[breakName] = source.breakWith;
	    } else if (breakValue === false) {
	      source.breaks[breakName] = '';
	    } else {
	      source.breaks[breakName] = source.breakWith.repeat(parseInt(breakValue));
	    }
	  }

	  return source;
	}

	format$1 = {
	  Breaks: Breaks,
	  Spaces: Spaces,
	  formatFrom: formatFrom
	};
	return format$1;
}

var marker;
var hasRequiredMarker;

function requireMarker () {
	if (hasRequiredMarker) return marker;
	hasRequiredMarker = 1;
	var Marker = {
	  ASTERISK: '*',
	  AT: '@',
	  BACK_SLASH: '\\',
	  CARRIAGE_RETURN: '\r',
	  CLOSE_CURLY_BRACKET: '}',
	  CLOSE_ROUND_BRACKET: ')',
	  CLOSE_SQUARE_BRACKET: ']',
	  COLON: ':',
	  COMMA: ',',
	  DOUBLE_QUOTE: '"',
	  EXCLAMATION: '!',
	  FORWARD_SLASH: '/',
	  INTERNAL: '-clean-css-',
	  NEW_LINE_NIX: '\n',
	  OPEN_CURLY_BRACKET: '{',
	  OPEN_ROUND_BRACKET: '(',
	  OPEN_SQUARE_BRACKET: '[',
	  SEMICOLON: ';',
	  SINGLE_QUOTE: '\'',
	  SPACE: ' ',
	  TAB: '\t',
	  UNDERSCORE: '_'
	};

	marker = Marker;
	return marker;
}

var formatPosition_1;
var hasRequiredFormatPosition;

function requireFormatPosition () {
	if (hasRequiredFormatPosition) return formatPosition_1;
	hasRequiredFormatPosition = 1;
	function formatPosition(metadata) {
	  var line = metadata[0];
	  var column = metadata[1];
	  var source = metadata[2];

	  return source
	    ? source + ':' + line + ':' + column
	    : line + ':' + column;
	}

	formatPosition_1 = formatPosition;
	return formatPosition_1;
}

var tidyRules_1;
var hasRequiredTidyRules;

function requireTidyRules () {
	if (hasRequiredTidyRules) return tidyRules_1;
	hasRequiredTidyRules = 1;
	var Spaces = requireFormat$1().Spaces;
	var Marker = requireMarker();
	var formatPosition = requireFormatPosition();

	var CASE_ATTRIBUTE_PATTERN = /[\s"'][iI]\s*\]/;
	var CASE_RESTORE_PATTERN = /([\d\w])([iI])\]/g;
	var DOUBLE_QUOTE_CASE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g;
	var DOUBLE_QUOTE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g;
	var HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\s*)+/;
	var SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g;
	var SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g;
	var RELATION_PATTERN = /[>+~]/;
	var WHITESPACE_PATTERN = /\s/;

	var ASTERISK_PLUS_HTML_HACK = '*+html ';
	var ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = '*:first-child+html ';
	var LESS_THAN = '<';

	var PSEUDO_CLASSES_WITH_SELECTORS = [
	  ':current',
	  ':future',
	  ':has',
	  ':host',
	  ':host-context',
	  ':is',
	  ':not',
	  ':past',
	  ':where'
	];

	function hasInvalidCharacters(value) {
	  var isEscaped;
	  var isInvalid = false;
	  var character;
	  var isQuote = false;
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {
	      isQuote = !isQuote;
	    } else if (!isQuote
	      && (character == Marker.CLOSE_CURLY_BRACKET
	        || character == Marker.EXCLAMATION
	        || character == LESS_THAN
	        || character == Marker.SEMICOLON)
	    ) {
	      isInvalid = true;
	      break;
	    } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {
	      isInvalid = true;
	      break;
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	  }

	  return isInvalid;
	}

	function removeWhitespace(value, format) {
	  var stripped = [];
	  var character;
	  var isNewLineNix;
	  var isNewLineWin;
	  var isEscaped;
	  var wasEscaped;
	  var isQuoted;
	  var isSingleQuoted;
	  var isDoubleQuoted;
	  var isAttribute;
	  var isRelation;
	  var isWhitespace;
	  var isSpaceAwarePseudoClass;
	  var roundBracketLevel = 0;
	  var wasComma = false;
	  var wasRelation = false;
	  var wasWhitespace = false;
	  var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);
	  var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    isNewLineNix = character == Marker.NEW_LINE_NIX;
	    isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;
	    isQuoted = isSingleQuoted || isDoubleQuoted;
	    isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);
	    isWhitespace = WHITESPACE_PATTERN.test(character);
	    isSpaceAwarePseudoClass = roundBracketLevel == 1 && character == Marker.CLOSE_ROUND_BRACKET
	      ? false
	      : isSpaceAwarePseudoClass
	        || (roundBracketLevel === 0 && character == Marker.COLON && isPseudoClassWithSelectors(value, i));

	    if (wasEscaped && isQuoted && isNewLineWin) {
	      // swallow escaped new windows lines in comments
	      stripped.pop();
	      stripped.pop();
	    } else if (isEscaped && isQuoted && isNewLineNix) {
	      // swallow escaped new *nix lines in comments
	      stripped.pop();
	    } else if (isEscaped) {
	      stripped.push(character);
	    } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {
	      stripped.push(character);
	      isAttribute = true;
	    } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {
	      stripped.push(character);
	      isAttribute = false;
	    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {
	      stripped.push(character);
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {
	      stripped.push(character);
	      roundBracketLevel--;
	    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
	      stripped.push(character);
	      isSingleQuoted = true;
	    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
	      stripped.push(character);
	      isDoubleQuoted = true;
	    } else if (character == Marker.SINGLE_QUOTE && isQuoted) {
	      stripped.push(character);
	      isSingleQuoted = false;
	    } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {
	      stripped.push(character);
	      isDoubleQuoted = false;
	    } else if (isWhitespace && wasRelation && !spaceAroundRelation) {
	      continue;
	    } else if (!isWhitespace && wasRelation && spaceAroundRelation) {
	      stripped.push(Marker.SPACE);
	      stripped.push(character);
	    } else if (isWhitespace && !wasWhitespace && wasComma && roundBracketLevel > 0 && isSpaceAwarePseudoClass) ; else if (isWhitespace && !wasWhitespace && roundBracketLevel > 0 && isSpaceAwarePseudoClass) {
	      stripped.push(character);
	    } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) ; else if (isWhitespace && wasWhitespace && !isQuoted) ; else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) ; else if (isRelation && wasWhitespace && !spaceAroundRelation) {
	      stripped.pop();
	      stripped.push(character);
	    } else if (isRelation && !wasWhitespace && spaceAroundRelation) {
	      stripped.push(Marker.SPACE);
	      stripped.push(character);
	    } else if (isWhitespace) {
	      stripped.push(Marker.SPACE);
	    } else {
	      stripped.push(character);
	    }

	    wasEscaped = isEscaped;
	    isEscaped = character == Marker.BACK_SLASH;
	    wasRelation = isRelation;
	    wasWhitespace = isWhitespace;
	    wasComma = character == Marker.COMMA;
	  }

	  return withCaseAttribute
	    ? stripped.join('').replace(CASE_RESTORE_PATTERN, '$1 $2]')
	    : stripped.join('');
	}

	function isPseudoClassWithSelectors(value, colonPosition) {
	  var pseudoClass = value.substring(colonPosition, value.indexOf(Marker.OPEN_ROUND_BRACKET, colonPosition));

	  return PSEUDO_CLASSES_WITH_SELECTORS.indexOf(pseudoClass) > -1;
	}

	function removeQuotes(value) {
	  if (value.indexOf('\'') == -1 && value.indexOf('"') == -1) {
	    return value;
	  }

	  return value
	    .replace(SINGLE_QUOTE_CASE_PATTERN, '=$1 $2')
	    .replace(SINGLE_QUOTE_PATTERN, '=$1$2')
	    .replace(DOUBLE_QUOTE_CASE_PATTERN, '=$1 $2')
	    .replace(DOUBLE_QUOTE_PATTERN, '=$1$2');
	}

	function replacePseudoClasses(value) {
	  return value
	    .replace('nth-child(1)', 'first-child')
	    .replace('nth-of-type(1)', 'first-of-type')
	    .replace('nth-of-type(even)', 'nth-of-type(2n)')
	    .replace('nth-child(even)', 'nth-child(2n)')
	    .replace('nth-of-type(2n+1)', 'nth-of-type(odd)')
	    .replace('nth-child(2n+1)', 'nth-child(odd)')
	    .replace('nth-last-child(1)', 'last-child')
	    .replace('nth-last-of-type(1)', 'last-of-type')
	    .replace('nth-last-of-type(even)', 'nth-last-of-type(2n)')
	    .replace('nth-last-child(even)', 'nth-last-child(2n)')
	    .replace('nth-last-of-type(2n+1)', 'nth-last-of-type(odd)')
	    .replace('nth-last-child(2n+1)', 'nth-last-child(odd)');
	}

	function tidyRules(rules, removeUnsupported, adjacentSpace, format, warnings) {
	  var list = [];
	  var repeated = [];

	  function removeHTMLComment(rule, match) {
	    warnings.push('HTML comment \'' + match + '\' at ' + formatPosition(rule[2][0]) + '. Removing.');
	    return '';
	  }

	  for (var i = 0, l = rules.length; i < l; i++) {
	    var rule = rules[i];
	    var reduced = rule[1];

	    reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));

	    if (hasInvalidCharacters(reduced)) {
	      warnings.push('Invalid selector \'' + rule[1] + '\' at ' + formatPosition(rule[2][0]) + '. Ignoring.');
	      continue;
	    }

	    reduced = removeWhitespace(reduced, format);
	    reduced = removeQuotes(reduced);

	    if (adjacentSpace && reduced.indexOf('nav') > 0) {
	      reduced = reduced.replace(/\+nav(\S|$)/, '+ nav$1');
	    }

	    if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {
	      continue;
	    }

	    if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {
	      continue;
	    }

	    if (reduced.indexOf('*') > -1) {
	      reduced = reduced
	        .replace(/\*([:#.[])/g, '$1')
	        .replace(/^(:first-child)?\+html/, '*$1+html');
	    }

	    if (repeated.indexOf(reduced) > -1) {
	      continue;
	    }

	    reduced = replacePseudoClasses(reduced);

	    rule[1] = reduced;
	    repeated.push(reduced);
	    list.push(rule);
	  }

	  if (list.length == 1 && list[0][1].length === 0) {
	    warnings.push('Empty selector \'' + list[0][1] + '\' at ' + formatPosition(list[0][2][0]) + '. Ignoring.');
	    list = [];
	  }

	  return list;
	}

	tidyRules_1 = tidyRules;
	return tidyRules_1;
}

var tidyBlock_1;
var hasRequiredTidyBlock;

function requireTidyBlock () {
	if (hasRequiredTidyBlock) return tidyBlock_1;
	hasRequiredTidyBlock = 1;
	var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\W/;
	var SUPPORTED_QUOTE_REMOVAL_MATCHER = /^@(?:keyframes|-moz-keyframes|-o-keyframes|-webkit-keyframes)\W/;

	function tidyBlock(values, spaceAfterClosingBrace) {
	  var withoutSpaceAfterClosingBrace;
	  var withoutQuotes;
	  var i;

	  for (i = values.length - 1; i >= 0; i--) {
	    withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);
	    withoutQuotes = SUPPORTED_QUOTE_REMOVAL_MATCHER.test(values[i][1]);

	    values[i][1] = values[i][1]
	      .replace(/\n|\r\n/g, ' ')
	      .replace(/\s+/g, ' ')
	      .replace(/(,|:|\() /g, '$1')
	      .replace(/ \)/g, ')');

	    if (withoutQuotes) {
	      values[i][1] = values[i][1]
	        .replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, '$1')
	        .replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, '$1');
	    }

	    if (withoutSpaceAfterClosingBrace) {
	      values[i][1] = values[i][1]
	        .replace(/\) /g, ')');
	    }
	  }

	  return values;
	}

	tidyBlock_1 = tidyBlock;
	return tidyBlock_1;
}

var tidyAtRule_1;
var hasRequiredTidyAtRule;

function requireTidyAtRule () {
	if (hasRequiredTidyAtRule) return tidyAtRule_1;
	hasRequiredTidyAtRule = 1;
	function tidyAtRule(value) {
	  return value
	    .replace(/\s+/g, ' ')
	    .replace(/url\(\s+/g, 'url(')
	    .replace(/\s+\)/g, ')')
	    .trim();
	}

	tidyAtRule_1 = tidyAtRule;
	return tidyAtRule_1;
}

var hack;
var hasRequiredHack;

function requireHack () {
	if (hasRequiredHack) return hack;
	hasRequiredHack = 1;
	var Hack = {
	  ASTERISK: 'asterisk',
	  BANG: 'bang',
	  BACKSLASH: 'backslash',
	  UNDERSCORE: 'underscore'
	};

	hack = Hack;
	return hack;
}

var removeUnused_1;
var hasRequiredRemoveUnused;

function requireRemoveUnused () {
	if (hasRequiredRemoveUnused) return removeUnused_1;
	hasRequiredRemoveUnused = 1;
	function removeUnused(properties) {
	  for (var i = properties.length - 1; i >= 0; i--) {
	    var property = properties[i];

	    if (property.unused) {
	      property.all.splice(property.position, 1);
	    }
	  }
	}

	removeUnused_1 = removeUnused;
	return removeUnused_1;
}

var restoreFromOptimizing_1;
var hasRequiredRestoreFromOptimizing;

function requireRestoreFromOptimizing () {
	if (hasRequiredRestoreFromOptimizing) return restoreFromOptimizing_1;
	hasRequiredRestoreFromOptimizing = 1;
	var Hack = requireHack();

	var Marker = requireMarker();

	var ASTERISK_HACK = '*';
	var BACKSLASH_HACK = '\\';
	var IMPORTANT_TOKEN = '!important';
	var UNDERSCORE_HACK = '_';
	var BANG_HACK = '!ie';

	function restoreFromOptimizing(properties, restoreCallback) {
	  var property;
	  var restored;
	  var current;
	  var i;

	  for (i = properties.length - 1; i >= 0; i--) {
	    property = properties[i];

	    if (property.dynamic && property.important) {
	      restoreImportant(property);
	      continue;
	    }

	    if (property.dynamic) {
	      continue;
	    }

	    if (property.unused) {
	      continue;
	    }

	    if (!property.dirty && !property.important && !property.hack) {
	      continue;
	    }

	    if (property.optimizable && restoreCallback) {
	      restored = restoreCallback(property);
	      property.value = restored;
	    } else {
	      restored = property.value;
	    }

	    if (property.important) {
	      restoreImportant(property);
	    }

	    if (property.hack) {
	      restoreHack(property);
	    }

	    if ('all' in property) {
	      current = property.all[property.position];
	      current[1][1] = property.name;

	      current.splice(2, current.length - 1);
	      Array.prototype.push.apply(current, restored);
	    }
	  }
	}

	function restoreImportant(property) {
	  property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;
	}

	function restoreHack(property) {
	  if (property.hack[0] == Hack.UNDERSCORE) {
	    property.name = UNDERSCORE_HACK + property.name;
	  } else if (property.hack[0] == Hack.ASTERISK) {
	    property.name = ASTERISK_HACK + property.name;
	  } else if (property.hack[0] == Hack.BACKSLASH) {
	    property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];
	  } else if (property.hack[0] == Hack.BANG) {
	    property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;
	  }
	}

	restoreFromOptimizing_1 = restoreFromOptimizing;
	return restoreFromOptimizing_1;
}

var token;
var hasRequiredToken;

function requireToken () {
	if (hasRequiredToken) return token;
	hasRequiredToken = 1;
	var Token = {
	  AT_RULE: 'at-rule', // e.g. `@import`, `@charset`
	  AT_RULE_BLOCK: 'at-rule-block', // e.g. `@font-face{...}`
	  AT_RULE_BLOCK_SCOPE: 'at-rule-block-scope', // e.g. `@font-face`
	  COMMENT: 'comment', // e.g. `/* comment */`
	  NESTED_BLOCK: 'nested-block', // e.g. `@media screen{...}`, `@keyframes animation {...}`
	  NESTED_BLOCK_SCOPE: 'nested-block-scope', // e.g. `@media`, `@keyframes`
	  PROPERTY: 'property', // e.g. `color:red`
	  PROPERTY_BLOCK: 'property-block', // e.g. `--var:{color:red}`
	  PROPERTY_NAME: 'property-name', // e.g. `color`
	  PROPERTY_VALUE: 'property-value', // e.g. `red`
	  RAW: 'raw', // e.g. anything between /* clean-css ignore:start */ and /* clean-css ignore:end */ comments
	  RULE: 'rule', // e.g `div > a{...}`
	  RULE_SCOPE: 'rule-scope' // e.g `div > a`
	};

	token = Token;
	return token;
}

var wrapForOptimizing;
var hasRequiredWrapForOptimizing;

function requireWrapForOptimizing () {
	if (hasRequiredWrapForOptimizing) return wrapForOptimizing;
	hasRequiredWrapForOptimizing = 1;
	var Hack = requireHack();

	var Marker = requireMarker();
	var Token = requireToken();

	var Match = {
	  ASTERISK: '*',
	  BACKSLASH: '\\',
	  BANG: '!',
	  BANG_SUFFIX_PATTERN: /!\w+$/,
	  IMPORTANT_TOKEN: '!important',
	  IMPORTANT_TOKEN_PATTERN: new RegExp('!important$', 'i'),
	  IMPORTANT_WORD: 'important',
	  IMPORTANT_WORD_PATTERN: new RegExp('important$', 'i'),
	  SUFFIX_BANG_PATTERN: /!$/,
	  UNDERSCORE: '_',
	  VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
	};

	function wrapAll(properties, skipProperties) {
	  var wrapped = [];
	  var single;
	  var property;
	  var i;

	  for (i = properties.length - 1; i >= 0; i--) {
	    property = properties[i];

	    if (property[0] != Token.PROPERTY) {
	      continue;
	    }

	    if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {
	      continue;
	    }

	    single = wrapSingle(property);
	    single.all = properties;
	    single.position = i;
	    wrapped.unshift(single);
	  }

	  return wrapped;
	}

	function someVariableReferences(property) {
	  var i, l;
	  var value;

	  // skipping `property` and property name tokens
	  for (i = 2, l = property.length; i < l; i++) {
	    value = property[i];

	    if (value[0] != Token.PROPERTY_VALUE) {
	      continue;
	    }

	    if (isVariableReference(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function isVariableReference(value) {
	  return Match.VARIABLE_REFERENCE_PATTERN.test(value);
	}

	function isMultiplex(property) {
	  var value;
	  var i, l;

	  for (i = 3, l = property.length; i < l; i++) {
	    value = property[i];

	    if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {
	      return true;
	    }
	  }

	  return false;
	}

	function hackFrom(property) {
	  var match = false;
	  var name = property[1][1];
	  var lastValue = property[property.length - 1];

	  if (name[0] == Match.UNDERSCORE) {
	    match = [Hack.UNDERSCORE];
	  } else if (name[0] == Match.ASTERISK) {
	    match = [Hack.ASTERISK];
	  } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {
	    match = [Hack.BANG];
	  } else if (lastValue[1].indexOf(Match.BANG) > 0
	    && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)
	    && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {
	    match = [Hack.BANG];
	  } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0
	    && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {
	    match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];
	  } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {
	    match = [Hack.BACKSLASH, lastValue[1].substring(1)];
	  }

	  return match;
	}

	function isImportant(property) {
	  if (property.length < 3) { return false; }

	  var lastValue = property[property.length - 1];
	  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
	    return true;
	  } if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1])
	    && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {
	    return true;
	  }

	  return false;
	}

	function stripImportant(property) {
	  var lastValue = property[property.length - 1];
	  var oneButLastValue = property[property.length - 2];

	  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
	    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, '');
	  } else {
	    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, '');
	    oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, '');
	  }

	  if (lastValue[1].length === 0) {
	    property.pop();
	  }

	  if (oneButLastValue[1].length === 0) {
	    property.pop();
	  }
	}

	function stripPrefixHack(property) {
	  property[1][1] = property[1][1].substring(1);
	}

	function stripSuffixHack(property, hackFrom) {
	  var lastValue = property[property.length - 1];
	  lastValue[1] = lastValue[1]
	    .substring(0, lastValue[1].indexOf(hackFrom[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG))
	    .trim();

	  if (lastValue[1].length === 0) {
	    property.pop();
	  }
	}

	function wrapSingle(property) {
	  var importantProperty = isImportant(property);
	  if (importantProperty) {
	    stripImportant(property);
	  }

	  var whichHack = hackFrom(property);
	  if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {
	    stripPrefixHack(property);
	  } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {
	    stripSuffixHack(property, whichHack);
	  }

	  return {
	    block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,
	    components: [],
	    dirty: false,
	    dynamic: someVariableReferences(property),
	    hack: whichHack,
	    important: importantProperty,
	    name: property[1][1],
	    multiplex: property.length > 3 ? isMultiplex(property) : false,
	    optimizable: true,
	    position: 0,
	    shorthand: false,
	    unused: false,
	    value: property.slice(2)
	  };
	}

	wrapForOptimizing = {
	  all: wrapAll,
	  single: wrapSingle
	};
	return wrapForOptimizing;
}

var invalidPropertyError;
var hasRequiredInvalidPropertyError;

function requireInvalidPropertyError () {
	if (hasRequiredInvalidPropertyError) return invalidPropertyError;
	hasRequiredInvalidPropertyError = 1;
	function InvalidPropertyError(message) {
	  this.name = 'InvalidPropertyError';
	  this.message = message;
	  this.stack = (new Error()).stack;
	}

	InvalidPropertyError.prototype = Object.create(Error.prototype);
	InvalidPropertyError.prototype.constructor = InvalidPropertyError;

	invalidPropertyError = InvalidPropertyError;
	return invalidPropertyError;
}

var breakUp;
var hasRequiredBreakUp;

function requireBreakUp () {
	if (hasRequiredBreakUp) return breakUp;
	hasRequiredBreakUp = 1;
	var InvalidPropertyError = requireInvalidPropertyError();

	var wrapSingle = requireWrapForOptimizing().single;

	var Token = requireToken();
	var Marker = requireMarker();

	var formatPosition = requireFormatPosition();

	function _anyIsInherit(values) {
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    if (values[i][1] == 'inherit') {
	      return true;
	    }
	  }

	  return false;
	}

	function _colorFilter(validator) {
	  return function(value) {
	    return value[1] == 'invert' || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
	  };
	}

	function _styleFilter(validator) {
	  return function(value) {
	    return value[1] != 'inherit' && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
	  };
	}

	function _wrapDefault(name, property, configuration) {
	  var descriptor = configuration[name];
	  if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {
	    return wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, name],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]
	    ]);
	  } if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
	    return wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, name],
	      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]
	    ]);
	  }
	  return wrapSingle([
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, name],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ]);
	}

	function _widthFilter(validator) {
	  return function(value) {
	    return value[1] != 'inherit'
	      && (validator.isWidth(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1]))
	      && !validator.isStyleKeyword(value[1])
	      && !validator.isColorFunction(value[1]);
	  };
	}

	function animation(property, configuration, validator) {
	  var duration = _wrapDefault(property.name + '-duration', property, configuration);
	  var timing = _wrapDefault(property.name + '-timing-function', property, configuration);
	  var delay = _wrapDefault(property.name + '-delay', property, configuration);
	  var iteration = _wrapDefault(property.name + '-iteration-count', property, configuration);
	  var direction = _wrapDefault(property.name + '-direction', property, configuration);
	  var fill = _wrapDefault(property.name + '-fill-mode', property, configuration);
	  var play = _wrapDefault(property.name + '-play-state', property, configuration);
	  var name = _wrapDefault(property.name + '-name', property, configuration);
	  var components = [duration, timing, delay, iteration, direction, fill, play, name];
	  var values = property.value;
	  var value;
	  var durationSet = false;
	  var timingSet = false;
	  var delaySet = false;
	  var iterationSet = false;
	  var directionSet = false;
	  var fillSet = false;
	  var playSet = false;
	  var nameSet = false;
	  var i;
	  var l;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    // eslint-disable-next-line max-len
	    duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
	    return components;
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isTime(value[1]) && !durationSet) {
	      duration.value = [value];
	      durationSet = true;
	    } else if (validator.isTime(value[1]) && !delaySet) {
	      delay.value = [value];
	      delaySet = true;
	    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
	      timing.value = [value];
	      timingSet = true;
	    } else if ((validator.isAnimationIterationCountKeyword(value[1])
	      || validator.isPositiveNumber(value[1]))
	      && !iterationSet) {
	      iteration.value = [value];
	      iterationSet = true;
	    } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {
	      direction.value = [value];
	      directionSet = true;
	    } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {
	      fill.value = [value];
	      fillSet = true;
	    } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {
	      play.value = [value];
	      playSet = true;
	    } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {
	      name.value = [value];
	      nameSet = true;
	    } else {
	      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
	    }
	  }

	  return components;
	}

	function background(property, configuration, validator) {
	  var image = _wrapDefault('background-image', property, configuration);
	  var position = _wrapDefault('background-position', property, configuration);
	  var size = _wrapDefault('background-size', property, configuration);
	  var repeat = _wrapDefault('background-repeat', property, configuration);
	  var attachment = _wrapDefault('background-attachment', property, configuration);
	  var origin = _wrapDefault('background-origin', property, configuration);
	  var clip = _wrapDefault('background-clip', property, configuration);
	  var color = _wrapDefault('background-color', property, configuration);
	  var components = [image, position, size, repeat, attachment, origin, clip, color];
	  var values = property.value;

	  var positionSet = false;
	  var clipSet = false;
	  var originSet = false;
	  var repeatSet = false;

	  var anyValueSet = false;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    // NOTE: 'inherit' is not a valid value for background-attachment
	    color.value = image.value = repeat.value = position.value = size.value = origin.value = clip.value = property.value;
	    return components;
	  }

	  if (property.value.length == 1 && property.value[0][1] == '0 0') {
	    return components;
	  }

	  for (var i = values.length - 1; i >= 0; i--) {
	    var value = values[i];

	    if (validator.isBackgroundAttachmentKeyword(value[1])) {
	      attachment.value = [value];
	      anyValueSet = true;
	    } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
	      if (clipSet) {
	        origin.value = [value];
	        originSet = true;
	      } else {
	        clip.value = [value];
	        clipSet = true;
	      }
	      anyValueSet = true;
	    } else if (validator.isBackgroundRepeatKeyword(value[1])) {
	      if (repeatSet) {
	        repeat.value.unshift(value);
	      } else {
	        repeat.value = [value];
	        repeatSet = true;
	      }
	      anyValueSet = true;
	    } else if (validator.isBackgroundPositionKeyword(value[1])
	    || validator.isBackgroundSizeKeyword(value[1])
	    || validator.isUnit(value[1])
	    || validator.isDynamicUnit(value[1])) {
	      if (i > 0) {
	        var previousValue = values[i - 1];

	        if (previousValue[1] == Marker.FORWARD_SLASH) {
	          size.value = [value];
	        } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {
	          size.value = [previousValue, value];
	          i -= 2;
	        } else {
	          if (!positionSet) { position.value = []; }

	          position.value.unshift(value);
	          positionSet = true;
	        }
	      } else {
	        if (!positionSet) { position.value = []; }

	        position.value.unshift(value);
	        positionSet = true;
	      }
	      anyValueSet = true;
	    } else if ((color.value[0][1] == configuration[color.name].defaultValue || color.value[0][1] == 'none') && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
	      color.value = [value];
	      anyValueSet = true;
	    } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
	      image.value = [value];
	      anyValueSet = true;
	    }
	  }

	  if (clipSet && !originSet) { origin.value = clip.value.slice(0); }

	  if (!anyValueSet) {
	    throw new InvalidPropertyError('Invalid background value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  return components;
	}

	function borderRadius(property, configuration) {
	  var values = property.value;
	  var splitAt = -1;

	  for (var i = 0, l = values.length; i < l; i++) {
	    if (values[i][1] == Marker.FORWARD_SLASH) {
	      splitAt = i;
	      break;
	    }
	  }

	  if (splitAt === 0 || splitAt === values.length - 1) {
	    throw new InvalidPropertyError('Invalid border-radius value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  var target = _wrapDefault(property.name, property, configuration);
	  target.value = splitAt > -1
	    ? values.slice(0, splitAt)
	    : values.slice(0);
	  target.components = fourValues(target, configuration);

	  var remainder = _wrapDefault(property.name, property, configuration);
	  remainder.value = splitAt > -1
	    ? values.slice(splitAt + 1)
	    : values.slice(0);
	  remainder.components = fourValues(remainder, configuration);

	  for (var j = 0; j < 4; j++) {
	    target.components[j].multiplex = true;
	    target.components[j].value = target.components[j].value.concat(remainder.components[j].value);
	  }

	  return target.components;
	}

	function font(property, configuration, validator) {
	  var style = _wrapDefault('font-style', property, configuration);
	  var variant = _wrapDefault('font-variant', property, configuration);
	  var weight = _wrapDefault('font-weight', property, configuration);
	  var stretch = _wrapDefault('font-stretch', property, configuration);
	  var size = _wrapDefault('font-size', property, configuration);
	  var height = _wrapDefault('line-height', property, configuration);
	  var family = _wrapDefault('font-family', property, configuration);
	  var components = [style, variant, weight, stretch, size, height, family];
	  var values = property.value;
	  var fuzzyMatched = 4; // style, variant, weight, and stretch
	  var index = 0;
	  var isStretchSet = false;
	  var isStretchValid;
	  var isStyleSet = false;
	  var isStyleValid;
	  var isVariantSet = false;
	  var isVariantValid;
	  var isWeightSet = false;
	  var isWeightValid;
	  var appendableFamilyName = false;

	  if (!values[index]) {
	    throw new InvalidPropertyError('Missing font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
	  }

	  if (values.length == 1 && values[0][1] == 'inherit') {
	    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
	    return components;
	  }

	  if (values.length == 1
	    && (validator.isFontKeyword(values[0][1])
	    || validator.isGlobal(values[0][1])
	    || validator.isPrefixed(values[0][1]))
	  ) {
	    values[0][1] = Marker.INTERNAL + values[0][1];
	    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
	    return components;
	  }

	  if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
	    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  // fuzzy match style, variant, weight, and stretch on first elements
	  while (index < fuzzyMatched) {
	    isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
	    isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);

	    if (isStyleValid && !isStyleSet) {
	      style.value = [values[index]];
	      isStyleSet = true;
	    } else if (isVariantValid && !isVariantSet) {
	      variant.value = [values[index]];
	      isVariantSet = true;
	    } else if (isWeightValid && !isWeightSet) {
	      weight.value = [values[index]];
	      isWeightSet = true;
	    } else if (isStretchValid && !isStretchSet) {
	      stretch.value = [values[index]];
	      isStretchSet = true;
	    } else if (isStyleValid
	      && isStyleSet
	      || isVariantValid
	      && isVariantSet
	      || isWeightValid
	      && isWeightSet
	      || isStretchValid
	      && isStretchSet) {
	      throw new InvalidPropertyError('Invalid font style / variant / weight / stretch value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	    } else {
	      break;
	    }

	    index++;
	  }

	  // now comes font-size ...
	  if (validator.isFontSizeKeyword(values[index][1])
	    || validator.isUnit(values[index][1])
	    && !validator.isDynamicUnit(values[index][1])) {
	    size.value = [values[index]];
	    index++;
	  } else {
	    throw new InvalidPropertyError('Missing font size at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  if (!values[index]) {
	    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  // ... and perhaps line-height
	  if (values[index]
	    && values[index][1] == Marker.FORWARD_SLASH
	    && values[index + 1]
	    && (validator.isLineHeightKeyword(values[index + 1][1])
	    || validator.isUnit(values[index + 1][1])
	    || validator.isNumber(values[index + 1][1]))) {
	    height.value = [values[index + 1]];
	    index++;
	    index++;
	  }

	  // ... and whatever comes next is font-family
	  family.value = [];

	  while (values[index]) {
	    if (values[index][1] == Marker.COMMA) {
	      appendableFamilyName = false;
	    } else {
	      if (appendableFamilyName) {
	        family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
	      } else {
	        family.value.push(values[index]);
	      }

	      appendableFamilyName = true;
	    }

	    index++;
	  }

	  if (family.value.length === 0) {
	    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  return components;
	}

	function _anyIsFontSize(values, validator) {
	  var value;
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isFontSizeKeyword(value[1])
	      || validator.isUnit(value[1])
	      && !validator.isDynamicUnit(value[1])
	      || validator.isFunction(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function _anyIsFontFamily(values, validator) {
	  var value;
	  var i, l;

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isIdentifier(value[1]) || validator.isQuotedText(value[1])) {
	      return true;
	    }
	  }

	  return false;
	}

	function fourValues(property, configuration) {
	  var componentNames = configuration[property.name].components;
	  var components = [];
	  var value = property.value;

	  if (value.length < 1) { return []; }

	  if (value.length < 2) { value[1] = value[0].slice(0); }
	  if (value.length < 3) { value[2] = value[0].slice(0); }
	  if (value.length < 4) { value[3] = value[1].slice(0); }

	  for (var i = componentNames.length - 1; i >= 0; i--) {
	    var component = wrapSingle([
	      Token.PROPERTY,
	      [Token.PROPERTY_NAME, componentNames[i]]
	    ]);
	    component.value = [value[i]];
	    components.unshift(component);
	  }

	  return components;
	}

	function multiplex(splitWith) {
	  return function(property, configuration, validator) {
	    var splitsAt = [];
	    var values = property.value;
	    var i, j, l, m;

	    // find split commas
	    for (i = 0, l = values.length; i < l; i++) {
	      if (values[i][1] == ',') { splitsAt.push(i); }
	    }

	    if (splitsAt.length === 0) { return splitWith(property, configuration, validator); }

	    var splitComponents = [];

	    // split over commas, and into components
	    for (i = 0, l = splitsAt.length; i <= l; i++) {
	      var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
	      var to = i < l ? splitsAt[i] : values.length;

	      var _property = _wrapDefault(property.name, property, configuration);
	      _property.value = values.slice(from, to);

	      if (_property.value.length > 0) {
	        splitComponents.push(splitWith(_property, configuration, validator));
	      }
	    }

	    var components = splitComponents[0];

	    // group component values from each split
	    for (i = 0, l = components.length; i < l; i++) {
	      components[i].multiplex = true;

	      for (j = 1, m = splitComponents.length; j < m; j++) {
	        components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
	        Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);
	      }
	    }

	    return components;
	  };
	}

	function listStyle(property, configuration, validator) {
	  var type = _wrapDefault('list-style-type', property, configuration);
	  var position = _wrapDefault('list-style-position', property, configuration);
	  var image = _wrapDefault('list-style-image', property, configuration);
	  var components = [type, position, image];

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    type.value = position.value = image.value = [property.value[0]];
	    return components;
	  }

	  var values = property.value.slice(0);
	  var total = values.length;
	  var index = 0;

	  // `image` first...
	  for (index = 0, total = values.length; index < total; index++) {
	    if (validator.isUrl(values[index][1]) || values[index][1] == '0') {
	      image.value = [values[index]];
	      values.splice(index, 1);
	      break;
	    }
	  }

	  // ... then `position`
	  for (index = 0, total = values.length; index < total; index++) {
	    if (validator.isListStylePositionKeyword(values[index][1])) {
	      position.value = [values[index]];
	      values.splice(index, 1);
	      break;
	    }
	  }

	  // ... and what's left is a `type`
	  if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
	    type.value = [values[0]];
	  }

	  return components;
	}

	function transition(property, configuration, validator) {
	  var prop = _wrapDefault(property.name + '-property', property, configuration);
	  var duration = _wrapDefault(property.name + '-duration', property, configuration);
	  var timing = _wrapDefault(property.name + '-timing-function', property, configuration);
	  var delay = _wrapDefault(property.name + '-delay', property, configuration);
	  var components = [prop, duration, timing, delay];
	  var values = property.value;
	  var value;
	  var durationSet = false;
	  var delaySet = false;
	  var propSet = false;
	  var timingSet = false;
	  var i;
	  var l;

	  if (property.value.length == 1 && property.value[0][1] == 'inherit') {
	    prop.value = duration.value = timing.value = delay.value = property.value;
	    return components;
	  }

	  if (values.length > 1 && _anyIsInherit(values)) {
	    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
	  }

	  for (i = 0, l = values.length; i < l; i++) {
	    value = values[i];

	    if (validator.isTime(value[1]) && !durationSet) {
	      duration.value = [value];
	      durationSet = true;
	    } else if (validator.isTime(value[1]) && !delaySet) {
	      delay.value = [value];
	      delaySet = true;
	    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
	      timing.value = [value];
	      timingSet = true;
	    } else if (validator.isIdentifier(value[1]) && !propSet) {
	      prop.value = [value];
	      propSet = true;
	    } else {
	      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
	    }
	  }

	  return components;
	}

	function widthStyleColor(property, configuration, validator) {
	  var descriptor = configuration[property.name];
	  var components = [
	    _wrapDefault(descriptor.components[0], property, configuration),
	    _wrapDefault(descriptor.components[1], property, configuration),
	    _wrapDefault(descriptor.components[2], property, configuration)
	  ];
	  var color, style, width;

	  for (var i = 0; i < 3; i++) {
	    var component = components[i];

	    if (component.name.indexOf('color') > 0) { color = component; } else if (component.name.indexOf('style') > 0) { style = component; } else { width = component; }
	  }

	  if ((property.value.length == 1 && property.value[0][1] == 'inherit')
	      || (property.value.length == 3 && property.value[0][1] == 'inherit' && property.value[1][1] == 'inherit' && property.value[2][1] == 'inherit')) {
	    color.value = style.value = width.value = [property.value[0]];
	    return components;
	  }

	  var values = property.value.slice(0);
	  var match, matches;

	  // NOTE: usually users don't follow the required order of parts in this shorthand,
	  // so we'll try to parse it caring as little about order as possible

	  if (values.length > 0) {
	    matches = values.filter(_widthFilter(validator));
	    match = matches.length > 1 && (matches[0][1] == 'none' || matches[0][1] == 'auto') ? matches[1] : matches[0];
	    if (match) {
	      width.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  if (values.length > 0) {
	    match = values.filter(_styleFilter(validator))[0];
	    if (match) {
	      style.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  if (values.length > 0) {
	    match = values.filter(_colorFilter(validator))[0];
	    if (match) {
	      color.value = [match];
	      values.splice(values.indexOf(match), 1);
	    }
	  }

	  return components;
	}

	breakUp = {
	  animation: animation,
	  background: background,
	  border: widthStyleColor,
	  borderRadius: borderRadius,
	  font: font,
	  fourValues: fourValues,
	  listStyle: listStyle,
	  multiplex: multiplex,
	  outline: widthStyleColor,
	  transition: transition
	};
	return breakUp;
}

var vendorPrefixes;
var hasRequiredVendorPrefixes;

function requireVendorPrefixes () {
	if (hasRequiredVendorPrefixes) return vendorPrefixes;
	hasRequiredVendorPrefixes = 1;
	var VENDOR_PREFIX_PATTERN = /(?:^|\W)(-\w+-)/g;

	function unique(value) {
	  var prefixes = [];
	  var match;

	  // eslint-disable-next-line no-cond-assign
	  while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {
	    if (prefixes.indexOf(match[0]) == -1) {
	      prefixes.push(match[0]);
	    }
	  }

	  return prefixes;
	}

	function same(value1, value2) {
	  return unique(value1).sort().join(',') == unique(value2).sort().join(',');
	}

	vendorPrefixes = {
	  unique: unique,
	  same: same
	};
	return vendorPrefixes;
}

var understandable_1;
var hasRequiredUnderstandable;

function requireUnderstandable () {
	if (hasRequiredUnderstandable) return understandable_1;
	hasRequiredUnderstandable = 1;
	var sameVendorPrefixes = requireVendorPrefixes().same;

	function understandable(validator, value1, value2, _position, isPaired) {
	  if (!sameVendorPrefixes(value1, value2)) {
	    return false;
	  }

	  if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {
	    return false;
	  }

	  return true;
	}

	understandable_1 = understandable;
	return understandable_1;
}

var canOverride;
var hasRequiredCanOverride;

function requireCanOverride () {
	if (hasRequiredCanOverride) return canOverride;
	hasRequiredCanOverride = 1;
	var understandable = requireUnderstandable();

	function animationIterationCount(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);
	}

	function animationName(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);
	}

	function areSameFunction(validator, value1, value2) {
	  if (!validator.isFunction(value1) || !validator.isFunction(value2)) {
	    return false;
	  }

	  var function1Name = value1.substring(0, value1.indexOf('('));
	  var function2Name = value2.substring(0, value2.indexOf('('));

	  var function1Value = value1.substring(function1Name.length + 1, value1.length - 1);
	  var function2Value = value2.substring(function2Name.length + 1, value2.length - 1);

	  if (validator.isFunction(function1Value) || validator.isFunction(function2Value)) {
	    return function1Name === function2Name && areSameFunction(validator, function1Value, function2Value);
	  }
	  return function1Name === function2Name;
	}

	function backgroundPosition(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {
	    return true;
	  }

	  return unit(validator, value1, value2);
	}

	function backgroundSize(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {
	    return true;
	  }

	  return unit(validator, value1, value2);
	}

	function color(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {
	    return false;
	  } if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {
	    return false;
	  } if (!validator.colorHexAlpha && (validator.isHexAlphaColor(value1) || validator.isHexAlphaColor(value2))) {
	    return false;
	  } if (validator.isColor(value1) && validator.isColor(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function components(overrideCheckers) {
	  return function(validator, value1, value2, position) {
	    return overrideCheckers[position](validator, value1, value2);
	  };
	}

	function fontFamily(validator, value1, value2) {
	  return understandable(validator, value1, value2, 0, true);
	}

	function image(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (validator.isImage(value2)) {
	    return true;
	  } if (validator.isImage(value1)) {
	    return false;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function keyword(propertyName) {
	  return function(validator, value1, value2) {
	    if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName)(value2)) {
	      return false;
	    } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	      return true;
	    }

	    return validator.isKeyword(propertyName)(value2);
	  };
	}

	function keywordWithGlobal(propertyName) {
	  return function(validator, value1, value2) {
	    if (!understandable(validator, value1, value2, 0, true)
	      && !(validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2))) {
	      return false;
	    } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	      return true;
	    }

	    return validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2);
	  };
	}

	function propertyName(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isIdentifier(value2);
	}

	function sameFunctionOrValue(validator, value1, value2) {
	  return areSameFunction(validator, value1, value2)
	    ? true
	    : value1 === value2;
	}

	function textShadow(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isUnit(value2)
	    || validator.isColor(value2)
	    || validator.isGlobal(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);
	}

	function time(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (validator.isTime(value1) && !validator.isTime(value2)) {
	    return false;
	  } if (validator.isTime(value2)) {
	    return true;
	  } if (validator.isTime(value1)) {
	    return false;
	  } if (validator.isFunction(value1)
	    && !validator.isPrefixed(value1)
	    && validator.isFunction(value2)
	    && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function timingFunction(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isTimingFunction(value2) || validator.isGlobal(value2);
	}

	function unit(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if (validator.isUnit(value1) && !validator.isUnit(value2)) {
	    return false;
	  } if (validator.isUnit(value2)) {
	    return true;
	  } if (validator.isUnit(value1)) {
	    return false;
	  } if (validator.isFunction(value1)
	    && !validator.isPrefixed(value1)
	    && validator.isFunction(value2)
	    && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function unitOrKeywordWithGlobal(propertyName) {
	  var byKeyword = keywordWithGlobal(propertyName);

	  return function(validator, value1, value2) {
	    return unit(validator, value1, value2) || byKeyword(validator, value1, value2);
	  };
	}

	function unitOrNumber(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true)
	    && !(validator.isUnit(value2)
	    || validator.isNumber(value2))) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  } if ((validator.isUnit(value1)
	    || validator.isNumber(value1))
	    && !(validator.isUnit(value2)
	    || validator.isNumber(value2))) {
	    return false;
	  } if (validator.isUnit(value2) || validator.isNumber(value2)) {
	    return true;
	  } if (validator.isUnit(value1) || validator.isNumber(value1)) {
	    return false;
	  } if (validator.isFunction(value1)
	    && !validator.isPrefixed(value1)
	    && validator.isFunction(value2)
	    && !validator.isPrefixed(value2)) {
	    return true;
	  }

	  return sameFunctionOrValue(validator, value1, value2);
	}

	function zIndex(validator, value1, value2) {
	  if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {
	    return false;
	  } if (validator.isVariable(value1) && validator.isVariable(value2)) {
	    return true;
	  }

	  return validator.isZIndex(value2);
	}

	canOverride = {
	  generic: {
	    color: color,
	    components: components,
	    image: image,
	    propertyName: propertyName,
	    time: time,
	    timingFunction: timingFunction,
	    unit: unit,
	    unitOrNumber: unitOrNumber
	  },
	  property: {
	    animationDirection: keywordWithGlobal('animation-direction'),
	    animationFillMode: keyword('animation-fill-mode'),
	    animationIterationCount: animationIterationCount,
	    animationName: animationName,
	    animationPlayState: keywordWithGlobal('animation-play-state'),
	    backgroundAttachment: keyword('background-attachment'),
	    backgroundClip: keywordWithGlobal('background-clip'),
	    backgroundOrigin: keyword('background-origin'),
	    backgroundPosition: backgroundPosition,
	    backgroundRepeat: keyword('background-repeat'),
	    backgroundSize: backgroundSize,
	    bottom: unitOrKeywordWithGlobal('bottom'),
	    borderCollapse: keyword('border-collapse'),
	    borderStyle: keywordWithGlobal('*-style'),
	    clear: keywordWithGlobal('clear'),
	    cursor: keywordWithGlobal('cursor'),
	    display: keywordWithGlobal('display'),
	    float: keywordWithGlobal('float'),
	    left: unitOrKeywordWithGlobal('left'),
	    fontFamily: fontFamily,
	    fontStretch: keywordWithGlobal('font-stretch'),
	    fontStyle: keywordWithGlobal('font-style'),
	    fontVariant: keywordWithGlobal('font-variant'),
	    fontWeight: keywordWithGlobal('font-weight'),
	    listStyleType: keywordWithGlobal('list-style-type'),
	    listStylePosition: keywordWithGlobal('list-style-position'),
	    outlineStyle: keywordWithGlobal('*-style'),
	    overflow: keywordWithGlobal('overflow'),
	    position: keywordWithGlobal('position'),
	    right: unitOrKeywordWithGlobal('right'),
	    textAlign: keywordWithGlobal('text-align'),
	    textDecoration: keywordWithGlobal('text-decoration'),
	    textOverflow: keywordWithGlobal('text-overflow'),
	    textShadow: textShadow,
	    top: unitOrKeywordWithGlobal('top'),
	    transform: sameFunctionOrValue,
	    verticalAlign: unitOrKeywordWithGlobal('vertical-align'),
	    visibility: keywordWithGlobal('visibility'),
	    whiteSpace: keywordWithGlobal('white-space'),
	    zIndex: zIndex
	  }
	};
	return canOverride;
}

var clone;
var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone;
	hasRequiredClone = 1;
	var wrapSingle = requireWrapForOptimizing().single;

	var Token = requireToken();

	function deep(property) {
	  var cloned = shallow(property);
	  for (var i = property.components.length - 1; i >= 0; i--) {
	    var component = shallow(property.components[i]);
	    component.value = property.components[i].value.slice(0);
	    cloned.components.unshift(component);
	  }

	  cloned.dirty = true;
	  cloned.value = property.value.slice(0);

	  return cloned;
	}

	function shallow(property) {
	  var cloned = wrapSingle([
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, property.name]
	  ]);
	  cloned.important = property.important;
	  cloned.hack = property.hack;
	  cloned.unused = false;
	  return cloned;
	}

	clone = {
	  deep: deep,
	  shallow: shallow
	};
	return clone;
}

var restore;
var hasRequiredRestore;

function requireRestore () {
	if (hasRequiredRestore) return restore;
	hasRequiredRestore = 1;
	var shallowClone = requireClone().shallow;

	var Token = requireToken();
	var Marker = requireMarker();

	function isInheritOnly(values) {
	  for (var i = 0, l = values.length; i < l; i++) {
	    var value = values[i][1];

	    if (value != 'inherit' && value != Marker.COMMA && value != Marker.FORWARD_SLASH) { return false; }
	  }

	  return true;
	}

	function background(property, configuration, lastInMultiplex) {
	  var components = property.components;
	  var restored = [];
	  var needsOne, needsBoth;

	  function restoreValue(component) {
	    Array.prototype.unshift.apply(restored, component.value);
	  }

	  function isDefaultValue(component) {
	    var descriptor = configuration[component.name];

	    if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
	      return component.value[0][1] == descriptor.defaultValue[0]
	        && (component.value[1]
	          ? component.value[1][1] == descriptor.defaultValue[0]
	          : true);
	    } if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {
	      return component.value[0][1] == descriptor.defaultValue[0]
	      && ((component.value[1] ? component.value[1][1] : component.value[0][1])
	        == descriptor.defaultValue[1]);
	    }
	    return component.value[0][1] == descriptor.defaultValue;
	  }

	  for (var i = components.length - 1; i >= 0; i--) {
	    var component = components[i];
	    var isDefault = isDefaultValue(component);

	    if (component.name == 'background-clip') {
	      var originComponent = components[i - 1];
	      var isOriginDefault = isDefaultValue(originComponent);

	      needsOne = component.value[0][1] == originComponent.value[0][1];

	      needsBoth = !needsOne && (
	        (isOriginDefault && !isDefault)
	        || (!isOriginDefault && !isDefault)
	        || (!isOriginDefault && isDefault && component.value[0][1] != originComponent.value[0][1]));

	      if (needsOne) {
	        restoreValue(originComponent);
	      } else if (needsBoth) {
	        restoreValue(component);
	        restoreValue(originComponent);
	      }

	      i--;
	    } else if (component.name == 'background-size') {
	      var positionComponent = components[i - 1];
	      var isPositionDefault = isDefaultValue(positionComponent);

	      needsOne = !isPositionDefault && isDefault;

	      needsBoth = !needsOne
	        && (isPositionDefault && !isDefault || !isPositionDefault && !isDefault);

	      if (needsOne) {
	        restoreValue(positionComponent);
	      } else if (needsBoth) {
	        restoreValue(component);
	        restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);
	        restoreValue(positionComponent);
	      } else if (positionComponent.value.length == 1) {
	        restoreValue(positionComponent);
	      }

	      i--;
	    } else {
	      if (isDefault || configuration[component.name].multiplexLastOnly && !lastInMultiplex) { continue; }

	      restoreValue(component);
	    }
	  }

	  if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == '0') { restored.push(property.value[0]); }

	  if (restored.length === 0) { restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]); }

	  if (isInheritOnly(restored)) { return [restored[0]]; }

	  return restored;
	}

	function borderRadius(property) {
	  if (property.multiplex) {
	    var horizontal = shallowClone(property);
	    var vertical = shallowClone(property);

	    for (var i = 0; i < 4; i++) {
	      var component = property.components[i];

	      var horizontalComponent = shallowClone(property);
	      horizontalComponent.value = [component.value[0]];
	      horizontal.components.push(horizontalComponent);

	      var verticalComponent = shallowClone(property);
	      // FIXME: only shorthand compactor (see breakup#borderRadius) knows that border radius
	      // longhands have two values, whereas tokenizer does not care about populating 2nd value
	      // if it's missing, hence this fallback
	      verticalComponent.value = [component.value[1] || component.value[0]];
	      vertical.components.push(verticalComponent);
	    }

	    var horizontalValues = fourValues(horizontal);
	    var verticalValues = fourValues(vertical);

	    if (horizontalValues.length == verticalValues.length
	        && horizontalValues[0][1] == verticalValues[0][1]
	        && (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true)
	        && (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true)
	        && (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {
	      return horizontalValues;
	    }
	    return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);
	  }
	  return fourValues(property);
	}

	function font(property, configuration) {
	  var components = property.components;
	  var restored = [];
	  var component;
	  var componentIndex = 0;
	  var fontFamilyIndex = 0;

	  if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {
	    property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);
	    return property.value;
	  }

	  // first four components are optional
	  while (componentIndex < 4) {
	    component = components[componentIndex];

	    if (component.value[0][1] != configuration[component.name].defaultValue) {
	      Array.prototype.push.apply(restored, component.value);
	    }

	    componentIndex++;
	  }

	  // then comes font-size
	  Array.prototype.push.apply(restored, components[componentIndex].value);
	  componentIndex++;

	  // then may come line-height
	  if (components[componentIndex].value[0][1] != configuration[components[componentIndex].name].defaultValue) {
	    Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);
	    Array.prototype.push.apply(restored, components[componentIndex].value);
	  }

	  componentIndex++;

	  // then comes font-family
	  while (components[componentIndex].value[fontFamilyIndex]) {
	    restored.push(components[componentIndex].value[fontFamilyIndex]);

	    if (components[componentIndex].value[fontFamilyIndex + 1]) {
	      restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
	    }

	    fontFamilyIndex++;
	  }

	  if (isInheritOnly(restored)) {
	    return [restored[0]];
	  }

	  return restored;
	}

	function fourValues(property) {
	  var components = property.components;
	  var value1 = components[0].value[0];
	  var value2 = components[1].value[0];
	  var value3 = components[2].value[0];
	  var value4 = components[3].value[0];

	  if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {
	    return [value1];
	  } if (value1[1] == value3[1] && value2[1] == value4[1]) {
	    return [value1, value2];
	  } if (value2[1] == value4[1]) {
	    return [value1, value2, value3];
	  }
	  return [value1, value2, value3, value4];
	}

	function multiplex(restoreWith) {
	  return function(property, configuration) {
	    if (!property.multiplex) { return restoreWith(property, configuration, true); }

	    var multiplexSize = 0;
	    var restored = [];
	    var componentMultiplexSoFar = {};
	    var i, l;

	    // At this point we don't know what's the multiplex size, e.g. how many background layers are there
	    for (i = 0, l = property.components[0].value.length; i < l; i++) {
	      if (property.components[0].value[i][1] == Marker.COMMA) { multiplexSize++; }
	    }

	    for (i = 0; i <= multiplexSize; i++) {
	      var _property = shallowClone(property);

	      // We split multiplex into parts and restore them one by one
	      for (var j = 0, m = property.components.length; j < m; j++) {
	        var componentToClone = property.components[j];
	        var _component = shallowClone(componentToClone);
	        _property.components.push(_component);

	        // The trick is some properties has more than one value, so we iterate over values looking for
	        // a multiplex separator - a comma
	        for (var k = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length; k < n; k++) {
	          if (componentToClone.value[k][1] == Marker.COMMA) {
	            componentMultiplexSoFar[_component.name] = k + 1;
	            break;
	          }

	          _component.value.push(componentToClone.value[k]);
	        }
	      }

	      // No we can restore shorthand value
	      var lastInMultiplex = i == multiplexSize;
	      var _restored = restoreWith(_property, configuration, lastInMultiplex);
	      Array.prototype.push.apply(restored, _restored);

	      if (i < multiplexSize) { restored.push([Token.PROPERTY_VALUE, Marker.COMMA]); }
	    }

	    return restored;
	  };
	}

	function withoutDefaults(property, configuration) {
	  var components = property.components;
	  var restored = [];

	  for (var i = components.length - 1; i >= 0; i--) {
	    var component = components[i];
	    var descriptor = configuration[component.name];

	    if (component.value[0][1] != descriptor.defaultValue || ('keepUnlessDefault' in descriptor) && !isDefault(components, configuration, descriptor.keepUnlessDefault)) {
	      restored.unshift(component.value[0]);
	    }
	  }

	  if (restored.length === 0) { restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]); }

	  if (isInheritOnly(restored)) { return [restored[0]]; }

	  return restored;
	}

	function isDefault(components, configuration, propertyName) {
	  var component;
	  var i, l;

	  for (i = 0, l = components.length; i < l; i++) {
	    component = components[i];

	    if (component.name == propertyName && component.value[0][1] == configuration[propertyName].defaultValue) {
	      return true;
	    }
	  }

	  return false;
	}

	restore = {
	  background: background,
	  borderRadius: borderRadius,
	  font: font,
	  fourValues: fourValues,
	  multiplex: multiplex,
	  withoutDefaults: withoutDefaults
	};
	return restore;
}

var roundingPrecision;
var hasRequiredRoundingPrecision;

function requireRoundingPrecision () {
	if (hasRequiredRoundingPrecision) return roundingPrecision;
	hasRequiredRoundingPrecision = 1;
	var override = requireOverride();

	var INTEGER_PATTERN = /^\d+$/;

	var ALL_UNITS = ['*', 'all'];
	var DEFAULT_PRECISION = 'off'; // all precision changes are disabled
	var DIRECTIVES_SEPARATOR = ','; // e.g. *=5,px=3
	var DIRECTIVE_VALUE_SEPARATOR = '='; // e.g. *=5

	function roundingPrecisionFrom(source) {
	  return override(defaults(DEFAULT_PRECISION), buildPrecisionFrom(source));
	}

	function defaults(value) {
	  return {
	    ch: value,
	    cm: value,
	    em: value,
	    ex: value,
	    in: value,
	    mm: value,
	    pc: value,
	    pt: value,
	    px: value,
	    q: value,
	    rem: value,
	    vh: value,
	    vmax: value,
	    vmin: value,
	    vw: value,
	    '%': value
	  };
	}

	function buildPrecisionFrom(source) {
	  if (source === null || source === undefined) {
	    return {};
	  }

	  if (typeof source == 'boolean') {
	    return {};
	  }

	  if (typeof source == 'number' && source == -1) {
	    return defaults(DEFAULT_PRECISION);
	  }

	  if (typeof source == 'number') {
	    return defaults(source);
	  }

	  if (typeof source == 'string' && INTEGER_PATTERN.test(source)) {
	    return defaults(parseInt(source));
	  }

	  if (typeof source == 'string' && source == DEFAULT_PRECISION) {
	    return defaults(DEFAULT_PRECISION);
	  }

	  if (typeof source == 'object') {
	    return source;
	  }

	  return source
	    .split(DIRECTIVES_SEPARATOR)
	    .reduce(function(accumulator, directive) {
	      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);
	      var name = directiveParts[0];
	      var value = parseInt(directiveParts[1]);

	      if (Number.isNaN(value) || value == -1) {
	        value = DEFAULT_PRECISION;
	      }

	      if (ALL_UNITS.indexOf(name) > -1) {
	        accumulator = override(accumulator, defaults(value));
	      } else {
	        accumulator[name] = value;
	      }

	      return accumulator;
	    }, {});
	}

	roundingPrecision = {
	  DEFAULT: DEFAULT_PRECISION,
	  roundingPrecisionFrom: roundingPrecisionFrom
	};
	return roundingPrecision;
}

var optimizationLevel;
var hasRequiredOptimizationLevel;

function requireOptimizationLevel () {
	if (hasRequiredOptimizationLevel) return optimizationLevel;
	hasRequiredOptimizationLevel = 1;
	var roundingPrecisionFrom = requireRoundingPrecision().roundingPrecisionFrom;

	var override = requireOverride();

	var OptimizationLevel = {
	  Zero: '0',
	  One: '1',
	  Two: '2'
	};

	var DEFAULTS = {};

	DEFAULTS[OptimizationLevel.Zero] = {};
	DEFAULTS[OptimizationLevel.One] = {
	  cleanupCharsets: true,
	  normalizeUrls: true,
	  optimizeBackground: true,
	  optimizeBorderRadius: true,
	  optimizeFilter: true,
	  optimizeFontWeight: true,
	  optimizeOutline: true,
	  removeEmpty: true,
	  removeNegativePaddings: true,
	  removeQuotes: true,
	  removeWhitespace: true,
	  replaceMultipleZeros: true,
	  replaceTimeUnits: true,
	  replaceZeroUnits: true,
	  roundingPrecision: roundingPrecisionFrom(undefined),
	  selectorsSortingMethod: 'standard',
	  specialComments: 'all',
	  tidyAtRules: true,
	  tidyBlockScopes: true,
	  tidySelectors: true,
	  variableValueOptimizers: []
	};
	DEFAULTS[OptimizationLevel.Two] = {
	  mergeAdjacentRules: true,
	  mergeIntoShorthands: true,
	  mergeMedia: true,
	  mergeNonAdjacentRules: true,
	  mergeSemantically: false,
	  overrideProperties: true,
	  removeEmpty: true,
	  reduceNonAdjacentRules: true,
	  removeDuplicateFontRules: true,
	  removeDuplicateMediaBlocks: true,
	  removeDuplicateRules: true,
	  removeUnusedAtRules: false,
	  restructureRules: false,
	  skipProperties: []
	};

	var ALL_KEYWORD_1 = '*';
	var ALL_KEYWORD_2 = 'all';
	var FALSE_KEYWORD_1 = 'false';
	var FALSE_KEYWORD_2 = 'off';
	var TRUE_KEYWORD_1 = 'true';
	var TRUE_KEYWORD_2 = 'on';

	var LIST_VALUE_SEPARATOR = ',';
	var OPTION_SEPARATOR = ';';
	var OPTION_VALUE_SEPARATOR = ':';

	function optimizationLevelFrom(source) {
	  var level = override(DEFAULTS, {});
	  var Zero = OptimizationLevel.Zero;
	  var One = OptimizationLevel.One;
	  var Two = OptimizationLevel.Two;

	  if (undefined === source) {
	    delete level[Two];
	    return level;
	  }

	  if (typeof source == 'string') {
	    source = parseInt(source);
	  }

	  if (typeof source == 'number' && source === parseInt(Two)) {
	    return level;
	  }

	  if (typeof source == 'number' && source === parseInt(One)) {
	    delete level[Two];
	    return level;
	  }

	  if (typeof source == 'number' && source === parseInt(Zero)) {
	    delete level[Two];
	    delete level[One];
	    return level;
	  }

	  if (typeof source == 'object') {
	    source = covertValuesToHashes(source);
	  }

	  if (One in source && 'roundingPrecision' in source[One]) {
	    source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);
	  }

	  if (Two in source && 'skipProperties' in source[Two] && typeof (source[Two].skipProperties) == 'string') {
	    source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);
	  }

	  if (Zero in source || One in source || Two in source) {
	    level[Zero] = override(level[Zero], source[Zero]);
	  }

	  if (One in source && ALL_KEYWORD_1 in source[One]) {
	    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_1])));
	    delete source[One][ALL_KEYWORD_1];
	  }

	  if (One in source && ALL_KEYWORD_2 in source[One]) {
	    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_2])));
	    delete source[One][ALL_KEYWORD_2];
	  }

	  if (One in source || Two in source) {
	    level[One] = override(level[One], source[One]);
	  } else {
	    delete level[One];
	  }

	  if (Two in source && ALL_KEYWORD_1 in source[Two]) {
	    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));
	    delete source[Two][ALL_KEYWORD_1];
	  }

	  if (Two in source && ALL_KEYWORD_2 in source[Two]) {
	    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));
	    delete source[Two][ALL_KEYWORD_2];
	  }

	  if (Two in source) {
	    level[Two] = override(level[Two], source[Two]);
	  } else {
	    delete level[Two];
	  }

	  return level;
	}

	function defaults(level, value) {
	  var options = override(DEFAULTS[level], {});
	  var key;

	  for (key in options) {
	    if (typeof options[key] == 'boolean') {
	      options[key] = value;
	    }
	  }

	  return options;
	}

	function normalizeValue(value) {
	  switch (value) {
	  case FALSE_KEYWORD_1:
	  case FALSE_KEYWORD_2:
	    return false;
	  case TRUE_KEYWORD_1:
	  case TRUE_KEYWORD_2:
	    return true;
	  default:
	    return value;
	  }
	}

	function covertValuesToHashes(source) {
	  var clonedSource = override(source, {});
	  var level;
	  var i;

	  for (i = 0; i <= 2; i++) {
	    level = '' + i;

	    if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {
	      delete clonedSource[level];
	    }

	    if (level in clonedSource && clonedSource[level] === true) {
	      clonedSource[level] = {};
	    }

	    if (level in clonedSource && typeof clonedSource[level] == 'string') {
	      clonedSource[level] = covertToHash(clonedSource[level], level);
	    }
	  }

	  return clonedSource;
	}

	function covertToHash(asString, level) {
	  return asString
	    .split(OPTION_SEPARATOR)
	    .reduce(function(accumulator, directive) {
	      var parts = directive.split(OPTION_VALUE_SEPARATOR);
	      var name = parts[0];
	      var value = parts[1];
	      var normalizedValue = normalizeValue(value);

	      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {
	        accumulator = override(accumulator, defaults(level, normalizedValue));
	      } else {
	        accumulator[name] = normalizedValue;
	      }

	      return accumulator;
	    }, {});
	}

	optimizationLevel = {
	  OptimizationLevel: OptimizationLevel,
	  optimizationLevelFrom: optimizationLevelFrom
	};
	return optimizationLevel;
}

var background;
var hasRequiredBackground;

function requireBackground () {
	if (hasRequiredBackground) return background;
	hasRequiredBackground = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var plugin = {
	  level1: {
	    property: function background(_rule, property, options) {
	      var values = property.value;

	      if (!options.level[OptimizationLevel.One].optimizeBackground) {
	        return;
	      }

	      if (values.length == 1 && values[0][1] == 'none') {
	        values[0][1] = '0 0';
	      }

	      if (values.length == 1 && values[0][1] == 'transparent') {
	        values[0][1] = '0 0';
	      }
	    }
	  }
	};

	background = plugin;
	return background;
}

var boxShadow;
var hasRequiredBoxShadow;

function requireBoxShadow () {
	if (hasRequiredBoxShadow) return boxShadow;
	hasRequiredBoxShadow = 1;
	var plugin = {
	  level1: {
	    property: function boxShadow(_rule, property) {
	      var values = property.value;

	      // remove multiple zeros
	      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {
	        property.value.splice(2);
	        property.dirty = true;
	      }
	    }
	  }
	};

	boxShadow = plugin;
	return boxShadow;
}

var borderRadius;
var hasRequiredBorderRadius;

function requireBorderRadius () {
	if (hasRequiredBorderRadius) return borderRadius;
	hasRequiredBorderRadius = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var plugin = {
	  level1: {
	    property: function borderRadius(_rule, property, options) {
	      var values = property.value;

	      if (!options.level[OptimizationLevel.One].optimizeBorderRadius) {
	        return;
	      }

	      if (values.length == 3 && values[1][1] == '/' && values[0][1] == values[2][1]) {
	        property.value.splice(1);
	        property.dirty = true;
	      } else if (values.length == 5 && values[2][1] == '/' && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {
	        property.value.splice(2);
	        property.dirty = true;
	      } else if (values.length == 7 && values[3][1] == '/' && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {
	        property.value.splice(3);
	        property.dirty = true;
	      } else if (values.length == 9 && values[4][1] == '/' && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {
	        property.value.splice(4);
	        property.dirty = true;
	      }
	    }
	  }
	};

	borderRadius = plugin;
	return borderRadius;
}

var filter;
var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var ALPHA_OR_CHROMA_FILTER_PATTERN = /progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/;
	var NO_SPACE_AFTER_COMMA_PATTERN = /,(\S)/g;
	var WHITESPACE_AROUND_EQUALS_PATTERN = / ?= ?/g;

	var plugin = {
	  level1: {
	    property: function filter(_rule, property, options) {
	      if (!options.compatibility.properties.ieFilters) {
	        return;
	      }

	      if (!options.level[OptimizationLevel.One].optimizeFilter) {
	        return;
	      }

	      if (property.value.length == 1) {
	        property.value[0][1] = property.value[0][1].replace(
	          ALPHA_OR_CHROMA_FILTER_PATTERN,
	          function(match, filter, suffix) {
	            return filter.toLowerCase() + suffix;
	          }
	        );
	      }

	      property.value[0][1] = property.value[0][1]
	        .replace(NO_SPACE_AFTER_COMMA_PATTERN, ', $1')
	        .replace(WHITESPACE_AROUND_EQUALS_PATTERN, '=');
	    }
	  }
	};

	filter = plugin;
	return filter;
}

var fontWeight;
var hasRequiredFontWeight;

function requireFontWeight () {
	if (hasRequiredFontWeight) return fontWeight;
	hasRequiredFontWeight = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var plugin = {
	  level1: {
	    property: function fontWeight(_rule, property, options) {
	      var value = property.value[0][1];

	      if (!options.level[OptimizationLevel.One].optimizeFontWeight) {
	        return;
	      }

	      if (value == 'normal') {
	        value = '400';
	      } else if (value == 'bold') {
	        value = '700';
	      }

	      property.value[0][1] = value;
	    }
	  }
	};

	fontWeight = plugin;
	return fontWeight;
}

var margin;
var hasRequiredMargin;

function requireMargin () {
	if (hasRequiredMargin) return margin;
	hasRequiredMargin = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var plugin = {
	  level1: {
	    property: function margin(_rule, property, options) {
	      var values = property.value;

	      if (!options.level[OptimizationLevel.One].replaceMultipleZeros) {
	        return;
	      }

	      // remove multiple zeros
	      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {
	        property.value.splice(1);
	        property.dirty = true;
	      }
	    }
	  }
	};

	margin = plugin;
	return margin;
}

var outline;
var hasRequiredOutline;

function requireOutline () {
	if (hasRequiredOutline) return outline;
	hasRequiredOutline = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var plugin = {
	  level1: {
	    property: function outline(_rule, property, options) {
	      var values = property.value;

	      if (!options.level[OptimizationLevel.One].optimizeOutline) {
	        return;
	      }

	      if (values.length == 1 && values[0][1] == 'none') {
	        values[0][1] = '0';
	      }
	    }
	  }
	};

	outline = plugin;
	return outline;
}

var padding;
var hasRequiredPadding;

function requirePadding () {
	if (hasRequiredPadding) return padding;
	hasRequiredPadding = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	function isNegative(value) {
	  return value && value[1][0] == '-' && parseFloat(value[1]) < 0;
	}

	var plugin = {
	  level1: {
	    property: function padding(_rule, property, options) {
	      var values = property.value;

	      // remove multiple zeros
	      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {
	        property.value.splice(1);
	        property.dirty = true;
	      }

	      // remove negative paddings
	      if (options.level[OptimizationLevel.One].removeNegativePaddings
	        && (
	          isNegative(property.value[0])
	          || isNegative(property.value[1])
	          || isNegative(property.value[2])
	          || isNegative(property.value[3])
	        )) {
	        property.unused = true;
	      }
	    }
	  }
	};

	padding = plugin;
	return padding;
}

var propertyOptimizers;
var hasRequiredPropertyOptimizers;

function requirePropertyOptimizers () {
	if (hasRequiredPropertyOptimizers) return propertyOptimizers;
	hasRequiredPropertyOptimizers = 1;
	propertyOptimizers = {
	  background: requireBackground().level1.property,
	  boxShadow: requireBoxShadow().level1.property,
	  borderRadius: requireBorderRadius().level1.property,
	  filter: requireFilter().level1.property,
	  fontWeight: requireFontWeight().level1.property,
	  margin: requireMargin().level1.property,
	  outline: requireOutline().level1.property,
	  padding: requirePadding().level1.property
	};
	return propertyOptimizers;
}

var shortenHex_1;
var hasRequiredShortenHex;

function requireShortenHex () {
	if (hasRequiredShortenHex) return shortenHex_1;
	hasRequiredShortenHex = 1;
	var COLORS = {
	  aliceblue: '#f0f8ff',
	  antiquewhite: '#faebd7',
	  aqua: '#0ff',
	  aquamarine: '#7fffd4',
	  azure: '#f0ffff',
	  beige: '#f5f5dc',
	  bisque: '#ffe4c4',
	  black: '#000',
	  blanchedalmond: '#ffebcd',
	  blue: '#00f',
	  blueviolet: '#8a2be2',
	  brown: '#a52a2a',
	  burlywood: '#deb887',
	  cadetblue: '#5f9ea0',
	  chartreuse: '#7fff00',
	  chocolate: '#d2691e',
	  coral: '#ff7f50',
	  cornflowerblue: '#6495ed',
	  cornsilk: '#fff8dc',
	  crimson: '#dc143c',
	  cyan: '#0ff',
	  darkblue: '#00008b',
	  darkcyan: '#008b8b',
	  darkgoldenrod: '#b8860b',
	  darkgray: '#a9a9a9',
	  darkgreen: '#006400',
	  darkgrey: '#a9a9a9',
	  darkkhaki: '#bdb76b',
	  darkmagenta: '#8b008b',
	  darkolivegreen: '#556b2f',
	  darkorange: '#ff8c00',
	  darkorchid: '#9932cc',
	  darkred: '#8b0000',
	  darksalmon: '#e9967a',
	  darkseagreen: '#8fbc8f',
	  darkslateblue: '#483d8b',
	  darkslategray: '#2f4f4f',
	  darkslategrey: '#2f4f4f',
	  darkturquoise: '#00ced1',
	  darkviolet: '#9400d3',
	  deeppink: '#ff1493',
	  deepskyblue: '#00bfff',
	  dimgray: '#696969',
	  dimgrey: '#696969',
	  dodgerblue: '#1e90ff',
	  firebrick: '#b22222',
	  floralwhite: '#fffaf0',
	  forestgreen: '#228b22',
	  fuchsia: '#f0f',
	  gainsboro: '#dcdcdc',
	  ghostwhite: '#f8f8ff',
	  gold: '#ffd700',
	  goldenrod: '#daa520',
	  gray: '#808080',
	  green: '#008000',
	  greenyellow: '#adff2f',
	  grey: '#808080',
	  honeydew: '#f0fff0',
	  hotpink: '#ff69b4',
	  indianred: '#cd5c5c',
	  indigo: '#4b0082',
	  ivory: '#fffff0',
	  khaki: '#f0e68c',
	  lavender: '#e6e6fa',
	  lavenderblush: '#fff0f5',
	  lawngreen: '#7cfc00',
	  lemonchiffon: '#fffacd',
	  lightblue: '#add8e6',
	  lightcoral: '#f08080',
	  lightcyan: '#e0ffff',
	  lightgoldenrodyellow: '#fafad2',
	  lightgray: '#d3d3d3',
	  lightgreen: '#90ee90',
	  lightgrey: '#d3d3d3',
	  lightpink: '#ffb6c1',
	  lightsalmon: '#ffa07a',
	  lightseagreen: '#20b2aa',
	  lightskyblue: '#87cefa',
	  lightslategray: '#778899',
	  lightslategrey: '#778899',
	  lightsteelblue: '#b0c4de',
	  lightyellow: '#ffffe0',
	  lime: '#0f0',
	  limegreen: '#32cd32',
	  linen: '#faf0e6',
	  magenta: '#ff00ff',
	  maroon: '#800000',
	  mediumaquamarine: '#66cdaa',
	  mediumblue: '#0000cd',
	  mediumorchid: '#ba55d3',
	  mediumpurple: '#9370db',
	  mediumseagreen: '#3cb371',
	  mediumslateblue: '#7b68ee',
	  mediumspringgreen: '#00fa9a',
	  mediumturquoise: '#48d1cc',
	  mediumvioletred: '#c71585',
	  midnightblue: '#191970',
	  mintcream: '#f5fffa',
	  mistyrose: '#ffe4e1',
	  moccasin: '#ffe4b5',
	  navajowhite: '#ffdead',
	  navy: '#000080',
	  oldlace: '#fdf5e6',
	  olive: '#808000',
	  olivedrab: '#6b8e23',
	  orange: '#ffa500',
	  orangered: '#ff4500',
	  orchid: '#da70d6',
	  palegoldenrod: '#eee8aa',
	  palegreen: '#98fb98',
	  paleturquoise: '#afeeee',
	  palevioletred: '#db7093',
	  papayawhip: '#ffefd5',
	  peachpuff: '#ffdab9',
	  peru: '#cd853f',
	  pink: '#ffc0cb',
	  plum: '#dda0dd',
	  powderblue: '#b0e0e6',
	  purple: '#800080',
	  rebeccapurple: '#663399',
	  red: '#f00',
	  rosybrown: '#bc8f8f',
	  royalblue: '#4169e1',
	  saddlebrown: '#8b4513',
	  salmon: '#fa8072',
	  sandybrown: '#f4a460',
	  seagreen: '#2e8b57',
	  seashell: '#fff5ee',
	  sienna: '#a0522d',
	  silver: '#c0c0c0',
	  skyblue: '#87ceeb',
	  slateblue: '#6a5acd',
	  slategray: '#708090',
	  slategrey: '#708090',
	  snow: '#fffafa',
	  springgreen: '#00ff7f',
	  steelblue: '#4682b4',
	  tan: '#d2b48c',
	  teal: '#008080',
	  thistle: '#d8bfd8',
	  tomato: '#ff6347',
	  turquoise: '#40e0d0',
	  violet: '#ee82ee',
	  wheat: '#f5deb3',
	  white: '#fff',
	  whitesmoke: '#f5f5f5',
	  yellow: '#ff0',
	  yellowgreen: '#9acd32'
	};

	var toHex = {};
	var toName = {};

	for (var name in COLORS) {
	  var hex = COLORS[name];

	  if (name.length < hex.length) {
	    toName[hex] = name;
	  } else {
	    toHex[name] = hex;
	  }
	}

	var toHexPattern = new RegExp('(^| |,|\\))(' + Object.keys(toHex).join('|') + ')( |,|\\)|$)', 'ig');
	var toNamePattern = new RegExp('(' + Object.keys(toName).join('|') + ')([^a-f0-9]|$)', 'ig');

	function hexConverter(match, prefix, colorValue, suffix) {
	  return prefix + toHex[colorValue.toLowerCase()] + suffix;
	}

	function nameConverter(match, colorValue, suffix) {
	  return toName[colorValue.toLowerCase()] + suffix;
	}

	function shortenHex(value) {
	  var hasHex = value.indexOf('#') > -1;
	  var shortened = value.replace(toHexPattern, hexConverter);

	  if (shortened != value) {
	    shortened = shortened.replace(toHexPattern, hexConverter);
	  }

	  return hasHex
	    ? shortened.replace(toNamePattern, nameConverter)
	    : shortened;
	}

	shortenHex_1 = shortenHex;
	return shortenHex_1;
}

var shortenHsl_1;
var hasRequiredShortenHsl;

function requireShortenHsl () {
	if (hasRequiredShortenHsl) return shortenHsl_1;
	hasRequiredShortenHsl = 1;
	// HSL to RGB converter. Both methods adapted from:
	// http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript

	function hslToRgb(h, s, l) {
	  var r, g, b;

	  // normalize hue orientation b/w 0 and 360 degrees
	  h %= 360;
	  if (h < 0) { h += 360; }
	  h = ~~h / 360;

	  if (s < 0) { s = 0; } else if (s > 100) { s = 100; }
	  s = ~~s / 100;

	  if (l < 0) { l = 0; } else if (l > 100) { l = 100; }
	  l = ~~l / 100;

	  if (s === 0) {
	    r = g = b = l; // achromatic
	  } else {
	    var q = l < 0.5
	      ? l * (1 + s)
	      : l + s - l * s;
	    var p = 2 * l - q;
	    r = hueToRgb(p, q, h + 1 / 3);
	    g = hueToRgb(p, q, h);
	    b = hueToRgb(p, q, h - 1 / 3);
	  }

	  return [~~(r * 255), ~~(g * 255), ~~(b * 255)];
	}

	function hueToRgb(p, q, t) {
	  if (t < 0) { t += 1; }
	  if (t > 1) { t -= 1; }
	  if (t < 1 / 6) { return p + (q - p) * 6 * t; }
	  if (t < 1 / 2) { return q; }
	  if (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6; }
	  return p;
	}

	function shortenHsl(hue, saturation, lightness) {
	  var asRgb = hslToRgb(hue, saturation, lightness);
	  var redAsHex = asRgb[0].toString(16);
	  var greenAsHex = asRgb[1].toString(16);
	  var blueAsHex = asRgb[2].toString(16);

	  return '#'
	    + ((redAsHex.length == 1 ? '0' : '') + redAsHex)
	    + ((greenAsHex.length == 1 ? '0' : '') + greenAsHex)
	    + ((blueAsHex.length == 1 ? '0' : '') + blueAsHex);
	}

	shortenHsl_1 = shortenHsl;
	return shortenHsl_1;
}

var shortenRgb_1;
var hasRequiredShortenRgb;

function requireShortenRgb () {
	if (hasRequiredShortenRgb) return shortenRgb_1;
	hasRequiredShortenRgb = 1;
	function shortenRgb(red, green, blue) {
	  var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));
	  var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));
	  var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));

	  // Credit: Asen  http://jsbin.com/UPUmaGOc/2/edit?js,console
	  return '#' + ('00000' + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);
	}

	shortenRgb_1 = shortenRgb;
	return shortenRgb_1;
}

var split_1;
var hasRequiredSplit;

function requireSplit () {
	if (hasRequiredSplit) return split_1;
	hasRequiredSplit = 1;
	var Marker = requireMarker();

	function is(value, separator, isSeparatorRegex) {
	  return isSeparatorRegex
	    ? separator.test(value)
	    : value === separator;
	}

	function split(value, separator) {
	  var openLevel = Marker.OPEN_ROUND_BRACKET;
	  var closeLevel = Marker.CLOSE_ROUND_BRACKET;
	  var level = 0;
	  var cursor = 0;
	  var lastStart = 0;
	  var lastValue;
	  var lastCharacter;
	  var len = value.length;
	  var parts = [];
	  var isSeparatorRegex = typeof (separator) == 'object' && 'exec' in separator;

	  if (!isSeparatorRegex && value.indexOf(separator) == -1) {
	    return [value];
	  }

	  if (value.indexOf(openLevel) == -1) {
	    return value.split(separator);
	  }

	  while (cursor < len) {
	    if (value[cursor] == openLevel) {
	      level++;
	    } else if (value[cursor] == closeLevel) {
	      level--;
	    }

	    if (level === 0 && cursor > 0 && cursor + 1 < len && is(value[cursor], separator, isSeparatorRegex)) {
	      parts.push(value.substring(lastStart, cursor));

	      if (isSeparatorRegex && separator.exec(value[cursor]).length > 1) {
	        parts.push(value[cursor]);
	      }

	      lastStart = cursor + 1;
	    }

	    cursor++;
	  }

	  if (lastStart < cursor + 1) {
	    lastValue = value.substring(lastStart);
	    lastCharacter = lastValue[lastValue.length - 1];
	    if (is(lastCharacter, separator, isSeparatorRegex)) {
	      lastValue = lastValue.substring(0, lastValue.length - 1);
	    }

	    parts.push(lastValue);
	  }

	  return parts;
	}

	split_1 = split;
	return split_1;
}

var color;
var hasRequiredColor;

function requireColor () {
	if (hasRequiredColor) return color;
	hasRequiredColor = 1;
	var shortenHex = requireShortenHex();
	var shortenHsl = requireShortenHsl();
	var shortenRgb = requireShortenRgb();

	var split = requireSplit();

	var ANY_COLOR_FUNCTION_PATTERN = /(rgb|rgba|hsl|hsla)\(([^()]+)\)/gi;
	var COLOR_PREFIX_PATTERN = /#|rgb|hsl/gi;
	var HEX_LONG_PATTERN = /(^|[^='"])#([0-9a-f]{6})/gi;
	var HEX_SHORT_PATTERN = /(^|[^='"])#([0-9a-f]{3})/gi;
	var HEX_VALUE_PATTERN = /[0-9a-f]/i;
	var HSL_PATTERN = /hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi;
	var RGBA_HSLA_PATTERN = /(rgb|hsl)a?\((-?\d+),(-?\d+%?),(-?\d+%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi;
	var RGB_PATTERN = /rgb\((-?\d+),(-?\d+),(-?\d+)\)/gi;
	var TRANSPARENT_FUNCTION_PATTERN = /(?:rgba|hsla)\(0,0%?,0%?,0\)/g;

	var plugin = {
	  level1: {
	    value: function color(name, value, options) {
	      if (!options.compatibility.properties.colors) {
	        return value;
	      }

	      if (!value.match(COLOR_PREFIX_PATTERN)) {
	        return shortenHex(value);
	      }

	      value = value
	        .replace(RGBA_HSLA_PATTERN, function(match, colorFn, p1, p2, p3, alpha) {
	          return (parseInt(alpha) >= 1 ? colorFn + '(' + [p1, p2, p3].join(',') + ')' : match);
	        })
	        .replace(RGB_PATTERN, function(match, red, green, blue) {
	          return shortenRgb(red, green, blue);
	        })
	        .replace(HSL_PATTERN, function(match, hue, saturation, lightness) {
	          return shortenHsl(hue, saturation, lightness);
	        })
	        .replace(HEX_LONG_PATTERN, function(match, prefix, color, at, inputValue) {
	          var suffix = inputValue[at + match.length];

	          if (suffix && HEX_VALUE_PATTERN.test(suffix)) {
	            return match;
	          } if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {
	            return (prefix + '#' + color[0] + color[2] + color[4]).toLowerCase();
	          }
	          return (prefix + '#' + color).toLowerCase();
	        })
	        .replace(HEX_SHORT_PATTERN, function(match, prefix, color) {
	          return prefix + '#' + color.toLowerCase();
	        })
	        .replace(ANY_COLOR_FUNCTION_PATTERN, function(match, colorFunction, colorDef) {
	          var tokens = colorDef.split(',');
	          var colorFnLowercase = colorFunction && colorFunction.toLowerCase();
	          var applies = (colorFnLowercase == 'hsl' && tokens.length == 3)
	            || (colorFnLowercase == 'hsla' && tokens.length == 4)
	            || (colorFnLowercase == 'rgb' && tokens.length === 3 && colorDef.indexOf('%') > 0)
	            || (colorFnLowercase == 'rgba' && tokens.length == 4 && tokens[0].indexOf('%') > 0);

	          if (!applies) {
	            return match;
	          }

	          if (tokens[1].indexOf('%') == -1) {
	            tokens[1] += '%';
	          }

	          if (tokens[2].indexOf('%') == -1) {
	            tokens[2] += '%';
	          }

	          return colorFunction + '(' + tokens.join(',') + ')';
	        });

	      if (options.compatibility.colors.opacity && name.indexOf('background') == -1) {
	        value = value.replace(TRANSPARENT_FUNCTION_PATTERN, function(match) {
	          if (split(value, ',').pop().indexOf('gradient(') > -1) {
	            return match;
	          }

	          return 'transparent';
	        });
	      }

	      return shortenHex(value);
	    }
	  }
	};

	color = plugin;
	return color;
}

var degrees;
var hasRequiredDegrees;

function requireDegrees () {
	if (hasRequiredDegrees) return degrees;
	hasRequiredDegrees = 1;
	var ZERO_DEG_PATTERN = /\(0deg\)/g;

	var plugin = {
	  level1: {
	    value: function degrees(_name, value, options) {
	      if (!options.compatibility.properties.zeroUnits) {
	        return value;
	      }

	      if (value.indexOf('0deg') == -1) {
	        return value;
	      }

	      return value.replace(ZERO_DEG_PATTERN, '(0)');
	    }
	  }
	};

	degrees = plugin;
	return degrees;
}

var startsAsUrl_1;
var hasRequiredStartsAsUrl;

function requireStartsAsUrl () {
	if (hasRequiredStartsAsUrl) return startsAsUrl_1;
	hasRequiredStartsAsUrl = 1;
	var URL_PREFIX_PATTERN = /^url\(/i;

	function startsAsUrl(value) {
	  return URL_PREFIX_PATTERN.test(value);
	}

	startsAsUrl_1 = startsAsUrl;
	return startsAsUrl_1;
}

var fraction;
var hasRequiredFraction;

function requireFraction () {
	if (hasRequiredFraction) return fraction;
	hasRequiredFraction = 1;
	var split = requireSplit();
	var startsAsUrl = requireStartsAsUrl();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var EXPRESSION_PATTERN = /^expression\(.*\)$/;
	var ANY_FUNCTION_PATTERN = /^(-(?:moz|ms|o|webkit)-[a-z-]+|[a-z-]+)\((.+)\)$/;
	var TOKEN_SEPARATOR_PATTERN = /([\s,/])/;

	var DOT_ZERO_PATTERN = /(^|\D)\.0+(\D|$)/g;
	var FRACTION_PATTERN = /\.([1-9]*)0+(\D|$)/g;
	var LEADING_ZERO_FRACTION_PATTERN = /(^|\D)0\.(\d)/g;
	var MINUS_ZERO_FRACTION_PATTERN = /([^\w\d-]|^)-0([^.]|$)/g;
	var ZERO_PREFIXED_UNIT_PATTERN = /(^|\s)0+([1-9])/g;

	function optimizeRecursively(value) {
	  var functionTokens;
	  var tokens;

	  if (startsAsUrl(value)) {
	    return value;
	  }

	  if (EXPRESSION_PATTERN.test(value)) {
	    return value;
	  }

	  functionTokens = ANY_FUNCTION_PATTERN.exec(value);

	  if (!functionTokens) {
	    return optimizeFractions(value);
	  }

	  tokens = split(functionTokens[2], TOKEN_SEPARATOR_PATTERN)
	    .map(function(token) { return optimizeRecursively(token); });

	  return functionTokens[1] + '(' + tokens.join('') + ')';
	}

	function optimizeFractions(value) {
	  if (value.indexOf('0') == -1) {
	    return value;
	  }

	  if (value.indexOf('-') > -1) {
	    value = value
	      .replace(MINUS_ZERO_FRACTION_PATTERN, '$10$2')
	      .replace(MINUS_ZERO_FRACTION_PATTERN, '$10$2');
	  }

	  return value
	    .replace(ZERO_PREFIXED_UNIT_PATTERN, '$1$2')
	    .replace(DOT_ZERO_PATTERN, '$10$2')
	    .replace(FRACTION_PATTERN, function(match, nonZeroPart, suffix) {
	      return (nonZeroPart.length > 0 ? '.' : '') + nonZeroPart + suffix;
	    })
	    .replace(LEADING_ZERO_FRACTION_PATTERN, '$1.$2');
	}

	var plugin = {
	  level1: {
	    value: function fraction(name, value, options) {
	      if (!options.level[OptimizationLevel.One].replaceZeroUnits) {
	        return value;
	      }

	      return optimizeRecursively(value);
	    }
	  }
	};

	fraction = plugin;
	return fraction;
}

var precision;
var hasRequiredPrecision;

function requirePrecision () {
	if (hasRequiredPrecision) return precision;
	hasRequiredPrecision = 1;
	var plugin = {
	  level1: {
	    value: function precision(_name, value, options) {
	      if (!options.precision.enabled || value.indexOf('.') === -1) {
	        return value;
	      }

	      return value
	        .replace(options.precision.decimalPointMatcher, '$1$2$3')
	        .replace(options.precision.zeroMatcher, function(match, integerPart, fractionPart, unit) {
	          var multiplier = options.precision.units[unit].multiplier;
	          var parsedInteger = parseInt(integerPart);
	          var integer = Number.isNaN(parsedInteger) ? 0 : parsedInteger;
	          var fraction = parseFloat(fractionPart);

	          return Math.round((integer + fraction) * multiplier) / multiplier + unit;
	        });
	    }
	  }
	};

	precision = plugin;
	return precision;
}

var textQuotes;
var hasRequiredTextQuotes;

function requireTextQuotes () {
	if (hasRequiredTextQuotes) return textQuotes;
	hasRequiredTextQuotes = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var LOCAL_PREFIX_PATTERN = /^local\(/i;
	var QUOTED_PATTERN = /^('.*'|".*")$/;
	var QUOTED_BUT_SAFE_PATTERN = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/;
	// eslint-disable-next-line max-len
	var GENERIC_FONT_FAMILY_PATTERN = /^['"](?:cursive|default|emoji|fangsong|fantasy|inherit|initial|math|monospace|revert|revert-layer|sans-serif|serif|system-ui|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|unset)['"]$/;

	var plugin = {
	  level1: {
	    value: function textQuotes(name, value, options) {
	      if ((name == 'font-family' || name == 'font') && GENERIC_FONT_FAMILY_PATTERN.test(value)) {
	        return value;
	      }

	      if (!options.level[OptimizationLevel.One].removeQuotes) {
	        return value;
	      }

	      if (!QUOTED_PATTERN.test(value) && !LOCAL_PREFIX_PATTERN.test(value)) {
	        return value;
	      }

	      return QUOTED_BUT_SAFE_PATTERN.test(value)
	        ? value.substring(1, value.length - 1)
	        : value;
	    }
	  }
	};

	textQuotes = plugin;
	return textQuotes;
}

var time;
var hasRequiredTime;

function requireTime () {
	if (hasRequiredTime) return time;
	hasRequiredTime = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var TIME_VALUE = /^(-?[\d.]+)(m?s)$/;

	var plugin = {
	  level1: {
	    value: function time(name, value, options) {
	      if (!options.level[OptimizationLevel.One].replaceTimeUnits) {
	        return value;
	      }

	      if (!TIME_VALUE.test(value)) {
	        return value;
	      }

	      return value.replace(TIME_VALUE, function(match, val, unit) {
	        var newValue;

	        if (unit == 'ms') {
	          newValue = parseInt(val) / 1000 + 's';
	        } else if (unit == 's') {
	          newValue = parseFloat(val) * 1000 + 'ms';
	        }

	        return newValue.length < match.length ? newValue : match;
	      });
	    }
	  }
	};

	time = plugin;
	return time;
}

var unit;
var hasRequiredUnit;

function requireUnit () {
	if (hasRequiredUnit) return unit;
	hasRequiredUnit = 1;
	var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;

	var plugin = {
	  level1: {
	    value: function unit(_name, value, options) {
	      if (!WHOLE_PIXEL_VALUE.test(value)) {
	        return value;
	      }

	      return value.replace(WHOLE_PIXEL_VALUE, function(match, val) {
	        var newValue;
	        var intVal = parseInt(val);

	        if (intVal === 0) {
	          return match;
	        }

	        if (options.compatibility.properties.shorterLengthUnits
	          && options.compatibility.units.pt
	          && intVal * 3 % 4 === 0) {
	          newValue = intVal * 3 / 4 + 'pt';
	        }

	        if (options.compatibility.properties.shorterLengthUnits
	          && options.compatibility.units.pc
	          && intVal % 16 === 0) {
	          newValue = intVal / 16 + 'pc';
	        }

	        if (options.compatibility.properties.shorterLengthUnits
	          && options.compatibility.units.in
	          && intVal % 96 === 0) {
	          newValue = intVal / 96 + 'in';
	        }

	        if (newValue) {
	          newValue = match.substring(0, match.indexOf(val)) + newValue;
	        }

	        return newValue && newValue.length < match.length ? newValue : match;
	      });
	    }
	  }
	};

	unit = plugin;
	return unit;
}

var urlPrefix;
var hasRequiredUrlPrefix;

function requireUrlPrefix () {
	if (hasRequiredUrlPrefix) return urlPrefix;
	hasRequiredUrlPrefix = 1;
	var startsAsUrl = requireStartsAsUrl();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var URL_PREFIX_PATTERN = /^url\(/i;

	var plugin = {
	  level1: {
	    value: function urlPrefix(_name, value, options) {
	      if (!options.level[OptimizationLevel.One].normalizeUrls) {
	        return value;
	      }

	      if (!startsAsUrl(value)) {
	        return value;
	      }

	      return value.replace(URL_PREFIX_PATTERN, 'url(');
	    }
	  }
	};

	urlPrefix = plugin;
	return urlPrefix;
}

var urlQuotes;
var hasRequiredUrlQuotes;

function requireUrlQuotes () {
	if (hasRequiredUrlQuotes) return urlQuotes;
	hasRequiredUrlQuotes = 1;
	var QUOTED_URL_PATTERN = /^url\(['"].+['"]\)$/;
	var QUOTED_URL_WITH_WHITESPACE_PATTERN = /^url\(['"].*[*\s()'"].*['"]\)$/;
	var QUOTES_PATTERN = /["']/g;
	var URL_DATA_PATTERN = /^url\(['"]data:[^;]+;charset/;

	var plugin = {
	  level1: {
	    value: function urlQuotes(_name, value, options) {
	      if (options.compatibility.properties.urlQuotes) {
	        return value;
	      }

	      return QUOTED_URL_PATTERN.test(value)
	        && !QUOTED_URL_WITH_WHITESPACE_PATTERN.test(value)
	        && !URL_DATA_PATTERN.test(value)
	        ? value.replace(QUOTES_PATTERN, '')
	        : value;
	    }
	  }
	};

	urlQuotes = plugin;
	return urlQuotes;
}

var urlWhitespace;
var hasRequiredUrlWhitespace;

function requireUrlWhitespace () {
	if (hasRequiredUrlWhitespace) return urlWhitespace;
	hasRequiredUrlWhitespace = 1;
	var startsAsUrl = requireStartsAsUrl();

	var WHITESPACE_PATTERN = /\\?\n|\\?\r\n/g;
	var WHITESPACE_PREFIX_PATTERN = /(\()\s+/g;
	var WHITESPACE_SUFFIX_PATTERN = /\s+(\))/g;

	var plugin = {
	  level1: {
	    value: function urlWhitespace(_name, value) {
	      if (!startsAsUrl(value)) {
	        return value;
	      }

	      return value
	        .replace(WHITESPACE_PATTERN, '')
	        .replace(WHITESPACE_PREFIX_PATTERN, '$1')
	        .replace(WHITESPACE_SUFFIX_PATTERN, '$1');
	    }
	  }
	};

	urlWhitespace = plugin;
	return urlWhitespace;
}

var whitespace;
var hasRequiredWhitespace;

function requireWhitespace () {
	if (hasRequiredWhitespace) return whitespace;
	hasRequiredWhitespace = 1;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var Marker = requireMarker();

	var CALC_DIVISION_WHITESPACE_PATTERN = /\) ?\/ ?/g;
	var COMMA_AND_SPACE_PATTERN = /, /g;
	var LINE_BREAK_PATTERN = /\r?\n/g;
	var MULTI_WHITESPACE_PATTERN = /\s+/g;
	var FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN = /\s+(;?\))/g;
	var FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN = /(\(;?)\s+/g;
	var VARIABLE_NAME_PATTERN = /^--\S+$/;
	var VARIABLE_VALUE_PATTERN = /^var\(\s*--\S+\s*\)$/;

	var plugin = {
	  level1: {
	    value: function whitespace(name, value, options) {
	      if (!options.level[OptimizationLevel.One].removeWhitespace) {
	        return value;
	      }

	      if (VARIABLE_NAME_PATTERN.test(name) && !VARIABLE_VALUE_PATTERN.test(value)) {
	        return value;
	      }

	      if ((value.indexOf(' ') == -1 && value.indexOf('\n') == -1) || value.indexOf('expression') === 0) {
	        return value;
	      }

	      if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {
	        return value;
	      }

	      value = value.replace(LINE_BREAK_PATTERN, '');
	      value = value.replace(MULTI_WHITESPACE_PATTERN, ' ');

	      if (value.indexOf('calc') > -1) {
	        value = value.replace(CALC_DIVISION_WHITESPACE_PATTERN, ')/ ');
	      }

	      return value
	        .replace(FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN, '$1')
	        .replace(FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN, '$1')
	        .replace(COMMA_AND_SPACE_PATTERN, ',');
	    }
	  }
	};

	whitespace = plugin;
	return whitespace;
}

var zero;
var hasRequiredZero;

function requireZero () {
	if (hasRequiredZero) return zero;
	hasRequiredZero = 1;
	var split = requireSplit();

	var ANY_FUNCTION_PATTERN = /^(-(?:moz|ms|o|webkit)-[a-z-]+|[a-z-]+)\((.+)\)$/;
	var SKIP_FUNCTION_PATTERN = /^(?:-moz-calc|-webkit-calc|calc|rgb|hsl|rgba|hsla|min|max|clamp|expression)\(/;
	var TOKEN_SEPARATOR_PATTERN = /([\s,/])/;

	function removeRecursively(value, options) {
	  var functionTokens;
	  var tokens;

	  if (SKIP_FUNCTION_PATTERN.test(value)) {
	    return value;
	  }

	  functionTokens = ANY_FUNCTION_PATTERN.exec(value);

	  if (!functionTokens) {
	    return removeZeros(value, options);
	  }

	  tokens = split(functionTokens[2], TOKEN_SEPARATOR_PATTERN)
	    .map(function(token) { return removeRecursively(token, options); });

	  return functionTokens[1] + '(' + tokens.join('') + ')';
	}

	function removeZeros(value, options) {
	  return value
	    .replace(options.unitsRegexp, '$10$2')
	    .replace(options.unitsRegexp, '$10$2');
	}

	var plugin = {
	  level1: {
	    value: function zero(name, value, options) {
	      if (!options.compatibility.properties.zeroUnits) {
	        return value;
	      }

	      if (value.indexOf('%') > 0 && (name == 'height' || name == 'max-height' || name == 'width' || name == 'max-width')) {
	        return value;
	      }

	      return removeRecursively(value, options);
	    }
	  }
	};

	zero = plugin;
	return zero;
}

var valueOptimizers;
var hasRequiredValueOptimizers;

function requireValueOptimizers () {
	if (hasRequiredValueOptimizers) return valueOptimizers;
	hasRequiredValueOptimizers = 1;
	valueOptimizers = {
	  color: requireColor().level1.value,
	  degrees: requireDegrees().level1.value,
	  fraction: requireFraction().level1.value,
	  precision: requirePrecision().level1.value,
	  textQuotes: requireTextQuotes().level1.value,
	  time: requireTime().level1.value,
	  unit: requireUnit().level1.value,
	  urlPrefix: requireUrlPrefix().level1.value,
	  urlQuotes: requireUrlQuotes().level1.value,
	  urlWhiteSpace: requireUrlWhitespace().level1.value,
	  whiteSpace: requireWhitespace().level1.value,
	  zero: requireZero().level1.value
	};
	return valueOptimizers;
}

var configuration_1;
var hasRequiredConfiguration;

function requireConfiguration () {
	if (hasRequiredConfiguration) return configuration_1;
	hasRequiredConfiguration = 1;
	// Contains the interpretation of CSS properties, as used by the property optimizer

	var breakUp = requireBreakUp();
	var canOverride = requireCanOverride();
	var restore = requireRestore();

	var propertyOptimizers = requirePropertyOptimizers();
	var valueOptimizers = requireValueOptimizers();

	var override = requireOverride();

	// Properties to process
	// Extend this object in order to add support for more properties in the optimizer.
	//
	// Each key in this object represents a CSS property and should be an object.
	// Such an object contains properties that describe how the represented CSS property should be handled.
	// Possible options:
	//
	// * components: array (Only specify for shorthand properties.)
	//   Contains the names of the granular properties this shorthand compacts.
	//
	// * canOverride: function
	//   Returns whether two tokens of this property can be merged with each other.
	//   This property has no meaning for shorthands.
	//
	// * defaultValue: string
	//   Specifies the default value of the property according to the CSS standard.
	//   For shorthand, this is used when every component is set to its default value, therefore it should be the shortest possible default value of all the components.
	//
	// * shortestValue: string
	//   Specifies the shortest possible value the property can possibly have.
	//   (Falls back to defaultValue if unspecified.)
	//
	// * breakUp: function (Only specify for shorthand properties.)
	//   Breaks the shorthand up to its components.
	//
	// * restore: function (Only specify for shorthand properties.)
	//   Puts the shorthand together from its components.
	//
	var configuration = {
	  animation: {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.time,
	      canOverride.generic.timingFunction,
	      canOverride.generic.time,
	      canOverride.property.animationIterationCount,
	      canOverride.property.animationDirection,
	      canOverride.property.animationFillMode,
	      canOverride.property.animationPlayState,
	      canOverride.property.animationName
	    ]),
	    components: [
	      'animation-duration',
	      'animation-timing-function',
	      'animation-delay',
	      'animation-iteration-count',
	      'animation-direction',
	      'animation-fill-mode',
	      'animation-play-state',
	      'animation-name'
	    ],
	    breakUp: breakUp.multiplex(breakUp.animation),
	    defaultValue: 'none',
	    restore: restore.multiplex(restore.withoutDefaults),
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.textQuotes,
	      valueOptimizers.time,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-delay': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    valueOptimizers: [
	      valueOptimizers.time,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-direction': {
	    canOverride: canOverride.property.animationDirection,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'normal',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-duration': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    keepUnlessDefault: 'animation-delay',
	    valueOptimizers: [
	      valueOptimizers.time,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-fill-mode': {
	    canOverride: canOverride.property.animationFillMode,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-iteration-count': {
	    canOverride: canOverride.property.animationIterationCount,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: '1',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-name': {
	    canOverride: canOverride.property.animationName,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'real',
	    valueOptimizers: [
	      valueOptimizers.textQuotes
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-play-state': {
	    canOverride: canOverride.property.animationPlayState,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'running',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'animation-timing-function': {
	    canOverride: canOverride.generic.timingFunction,
	    componentOf: [
	      'animation'
	    ],
	    defaultValue: 'ease',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  background: {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.image,
	      canOverride.property.backgroundPosition,
	      canOverride.property.backgroundSize,
	      canOverride.property.backgroundRepeat,
	      canOverride.property.backgroundAttachment,
	      canOverride.property.backgroundOrigin,
	      canOverride.property.backgroundClip,
	      canOverride.generic.color
	    ]),
	    components: [
	      'background-image',
	      'background-position',
	      'background-size',
	      'background-repeat',
	      'background-attachment',
	      'background-origin',
	      'background-clip',
	      'background-color'
	    ],
	    breakUp: breakUp.multiplex(breakUp.background),
	    defaultValue: '0 0',
	    propertyOptimizer: propertyOptimizers.background,
	    restore: restore.multiplex(restore.background),
	    shortestValue: '0',
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.urlWhiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.zero,
	      valueOptimizers.color,
	      valueOptimizers.urlPrefix,
	      valueOptimizers.urlQuotes
	    ]
	  },
	  'background-attachment': {
	    canOverride: canOverride.property.backgroundAttachment,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'scroll',
	    intoMultiplexMode: 'real'
	  },
	  'background-clip': {
	    canOverride: canOverride.property.backgroundClip,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'border-box',
	    intoMultiplexMode: 'real',
	    shortestValue: 'border-box'
	  },
	  'background-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'transparent',
	    intoMultiplexMode: 'real', // otherwise real color will turn into default since color appears in last multiplex only
	    multiplexLastOnly: true,
	    nonMergeableValue: 'none',
	    shortestValue: 'red',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'background-image': {
	    canOverride: canOverride.generic.image,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'none',
	    intoMultiplexMode: 'default',
	    valueOptimizers: [
	      valueOptimizers.urlWhiteSpace,
	      valueOptimizers.urlPrefix,
	      valueOptimizers.urlQuotes,
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ]
	  },
	  'background-origin': {
	    canOverride: canOverride.property.backgroundOrigin,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: 'padding-box',
	    intoMultiplexMode: 'real',
	    shortestValue: 'border-box'
	  },
	  'background-position': {
	    canOverride: canOverride.property.backgroundPosition,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['0', '0'],
	    doubleValues: true,
	    intoMultiplexMode: 'real',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'background-repeat': {
	    canOverride: canOverride.property.backgroundRepeat,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['repeat'],
	    doubleValues: true,
	    intoMultiplexMode: 'real'
	  },
	  'background-size': {
	    canOverride: canOverride.property.backgroundSize,
	    componentOf: [
	      'background'
	    ],
	    defaultValue: ['auto'],
	    doubleValues: true,
	    intoMultiplexMode: 'real',
	    shortestValue: '0 0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  bottom: {
	    canOverride: canOverride.property.bottom,
	    defaultValue: 'auto',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  border: {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-width',
	      'border-style',
	      'border-color'
	    ],
	    defaultValue: 'none',
	    overridesShorthands: [
	      'border-bottom',
	      'border-left',
	      'border-right',
	      'border-top'
	    ],
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    shorthandComponents: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ]
	  },
	  'border-bottom': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-bottom-width',
	      'border-bottom-style',
	      'border-bottom-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ]
	  },
	  'border-bottom-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-bottom',
	      'border-color'
	    ],
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-bottom-left-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.borderRadius,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-bottom-right-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.borderRadius,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-bottom-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-bottom',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-bottom-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-bottom',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-top-width',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'border-collapse': {
	    canOverride: canOverride.property.borderCollapse,
	    defaultValue: 'separate'
	  },
	  'border-color': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.color,
	      canOverride.generic.color,
	      canOverride.generic.color,
	      canOverride.generic.color
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-color',
	      'border-right-color',
	      'border-bottom-color',
	      'border-left-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.fourValues,
	    shortestValue: 'red',
	    shorthand: true,
	    singleTypeComponents: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-left': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-left-width',
	      'border-left-style',
	      'border-left-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ]
	  },
	  'border-left-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-left'
	    ],
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-left-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-left',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-left-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-left',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-right-width',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'border-radius': {
	    breakUp: breakUp.borderRadius,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'border-top-left-radius',
	      'border-top-right-radius',
	      'border-bottom-right-radius',
	      'border-bottom-left-radius'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.borderRadius,
	    restore: restore.borderRadius,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-right': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-right-width',
	      'border-right-style',
	      'border-right-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-right-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-right'
	    ],
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-right-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-right',
	      'border-style'
	    ],
	    defaultValue: 'none'
	  },
	  'border-right-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-right',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-left-width',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'border-style': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle,
	      canOverride.property.borderStyle
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-style',
	      'border-right-style',
	      'border-bottom-style',
	      'border-left-style'
	    ],
	    defaultValue: 'none',
	    restore: restore.fourValues,
	    shorthand: true,
	    singleTypeComponents: true
	  },
	  'border-top': {
	    breakUp: breakUp.border,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.property.borderStyle,
	      canOverride.generic.color
	    ]),
	    components: [
	      'border-top-width',
	      'border-top-style',
	      'border-top-color'
	    ],
	    defaultValue: 'none',
	    restore: restore.withoutDefaults,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.zero,
	      valueOptimizers.color,
	      valueOptimizers.unit
	    ]
	  },
	  'border-top-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'border-color',
	      'border-top'
	    ],
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'border-top-left-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.borderRadius,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-top-right-radius': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-radius'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.borderRadius,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-o-'
	    ]
	  },
	  'border-top-style': {
	    canOverride: canOverride.property.borderStyle,
	    componentOf: [
	      'border-style',
	      'border-top'
	    ],
	    defaultValue: 'none'
	  },
	  'border-top-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'border-top',
	      'border-width'
	    ],
	    defaultValue: 'medium',
	    oppositeTo: 'border-bottom-width',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'border-width': {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    componentOf: [
	      'border'
	    ],
	    components: [
	      'border-top-width',
	      'border-right-width',
	      'border-bottom-width',
	      'border-left-width'
	    ],
	    defaultValue: 'medium',
	    restore: restore.fourValues,
	    shortestValue: '0',
	    shorthand: true,
	    singleTypeComponents: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'box-shadow': {
	    propertyOptimizer: propertyOptimizers.boxShadow,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  clear: {
	    canOverride: canOverride.property.clear,
	    defaultValue: 'none'
	  },
	  clip: {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  color: {
	    canOverride: canOverride.generic.color,
	    defaultValue: 'transparent',
	    shortestValue: 'red',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'column-gap': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  cursor: {
	    canOverride: canOverride.property.cursor,
	    defaultValue: 'auto'
	  },
	  display: { canOverride: canOverride.property.display },
	  filter: {
	    propertyOptimizer: propertyOptimizers.filter,
	    valueOptimizers: [
	      valueOptimizers.fraction
	    ]
	  },
	  float: {
	    canOverride: canOverride.property.float,
	    defaultValue: 'none'
	  },
	  font: {
	    breakUp: breakUp.font,
	    canOverride: canOverride.generic.components([
	      canOverride.property.fontStyle,
	      canOverride.property.fontVariant,
	      canOverride.property.fontWeight,
	      canOverride.property.fontStretch,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.property.fontFamily
	    ]),
	    components: [
	      'font-style',
	      'font-variant',
	      'font-weight',
	      'font-stretch',
	      'font-size',
	      'line-height',
	      'font-family'
	    ],
	    restore: restore.font,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.textQuotes
	    ]
	  },
	  'font-family': {
	    canOverride: canOverride.property.fontFamily,
	    defaultValue: 'user|agent|specific',
	    valueOptimizers: [
	      valueOptimizers.textQuotes
	    ]
	  },
	  'font-size': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'medium',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.fraction
	    ]
	  },
	  'font-stretch': {
	    canOverride: canOverride.property.fontStretch,
	    defaultValue: 'normal'
	  },
	  'font-style': {
	    canOverride: canOverride.property.fontStyle,
	    defaultValue: 'normal'
	  },
	  'font-variant': {
	    canOverride: canOverride.property.fontVariant,
	    defaultValue: 'normal'
	  },
	  'font-weight': {
	    canOverride: canOverride.property.fontWeight,
	    defaultValue: 'normal',
	    propertyOptimizer: propertyOptimizers.fontWeight,
	    shortestValue: '400'
	  },
	  gap: {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  height: {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'auto',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  left: {
	    canOverride: canOverride.property.left,
	    defaultValue: 'auto',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'letter-spacing': {
	    valueOptimizers: [
	      valueOptimizers.fraction,
	      valueOptimizers.zero
	    ]
	  },
	  'line-height': {
	    canOverride: canOverride.generic.unitOrNumber,
	    defaultValue: 'normal',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.fraction,
	      valueOptimizers.zero
	    ]
	  },
	  'list-style': {
	    canOverride: canOverride.generic.components([
	      canOverride.property.listStyleType,
	      canOverride.property.listStylePosition,
	      canOverride.property.listStyleImage
	    ]),
	    components: [
	      'list-style-type',
	      'list-style-position',
	      'list-style-image'
	    ],
	    breakUp: breakUp.listStyle,
	    restore: restore.withoutDefaults,
	    defaultValue: 'outside', // can't use 'disc' because that'd override default 'decimal' for <ol>
	    shortestValue: 'none',
	    shorthand: true
	  },
	  'list-style-image': {
	    canOverride: canOverride.generic.image,
	    componentOf: [
	      'list-style'
	    ],
	    defaultValue: 'none'
	  },
	  'list-style-position': {
	    canOverride: canOverride.property.listStylePosition,
	    componentOf: [
	      'list-style'
	    ],
	    defaultValue: 'outside',
	    shortestValue: 'inside'
	  },
	  'list-style-type': {
	    canOverride: canOverride.property.listStyleType,
	    componentOf: [
	      'list-style'
	    ],
	    // NOTE: we can't tell the real default value here, it's 'disc' for <ul> and 'decimal' for <ol>
	    // this is a hack, but it doesn't matter because this value will be either overridden or
	    // it will disappear at the final step anyway
	    defaultValue: 'decimal|disc',
	    shortestValue: 'none'
	  },
	  margin: {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'margin-top',
	      'margin-right',
	      'margin-bottom',
	      'margin-left'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.margin,
	    restore: restore.fourValues,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-bottom': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-top',
	    propertyOptimizer: propertyOptimizers.margin,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-inline-end': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-inline-start': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-left': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-right',
	    propertyOptimizer: propertyOptimizers.margin,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-right': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-left',
	    propertyOptimizer: propertyOptimizers.margin,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'margin-top': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'margin'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'margin-bottom',
	    propertyOptimizer: propertyOptimizers.margin,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'max-height': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'none',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'max-width': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'none',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'min-height': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: '0',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'min-width': {
	    canOverride: canOverride.generic.unit,
	    defaultValue: '0',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  opacity: {
	    valueOptimizers: [
	      valueOptimizers.fraction,
	      valueOptimizers.precision
	    ]
	  },
	  outline: {
	    canOverride: canOverride.generic.components([
	      canOverride.generic.color,
	      canOverride.property.outlineStyle,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'outline-color',
	      'outline-style',
	      'outline-width'
	    ],
	    breakUp: breakUp.outline,
	    restore: restore.withoutDefaults,
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.outline,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'outline-color': {
	    canOverride: canOverride.generic.color,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'invert',
	    shortestValue: 'red',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.color
	    ]
	  },
	  'outline-style': {
	    canOverride: canOverride.property.outlineStyle,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'none'
	  },
	  'outline-width': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'outline'
	    ],
	    defaultValue: 'medium',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  overflow: {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  'overflow-x': {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  'overflow-y': {
	    canOverride: canOverride.property.overflow,
	    defaultValue: 'visible'
	  },
	  padding: {
	    breakUp: breakUp.fourValues,
	    canOverride: canOverride.generic.components([
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit,
	      canOverride.generic.unit
	    ]),
	    components: [
	      'padding-top',
	      'padding-right',
	      'padding-bottom',
	      'padding-left'
	    ],
	    defaultValue: '0',
	    propertyOptimizer: propertyOptimizers.padding,
	    restore: restore.fourValues,
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'padding-bottom': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-top',
	    propertyOptimizer: propertyOptimizers.padding,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'padding-left': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-right',
	    propertyOptimizer: propertyOptimizers.padding,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'padding-right': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-left',
	    propertyOptimizer: propertyOptimizers.padding,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'padding-top': {
	    canOverride: canOverride.generic.unit,
	    componentOf: [
	      'padding'
	    ],
	    defaultValue: '0',
	    oppositeTo: 'padding-bottom',
	    propertyOptimizer: propertyOptimizers.padding,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  position: {
	    canOverride: canOverride.property.position,
	    defaultValue: 'static'
	  },
	  right: {
	    canOverride: canOverride.property.right,
	    defaultValue: 'auto',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'row-gap': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  src: {
	    valueOptimizers: [
	      valueOptimizers.urlWhiteSpace,
	      valueOptimizers.urlPrefix,
	      valueOptimizers.urlQuotes
	    ]
	  },
	  'stroke-width': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'text-align': {
	    canOverride: canOverride.property.textAlign,
	    // NOTE: we can't tell the real default value here, as it depends on default text direction
	    // this is a hack, but it doesn't matter because this value will be either overridden or
	    // it will disappear anyway
	    defaultValue: 'left|right'
	  },
	  'text-decoration': {
	    canOverride: canOverride.property.textDecoration,
	    defaultValue: 'none'
	  },
	  'text-indent': {
	    canOverride: canOverride.property.textOverflow,
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.fraction,
	      valueOptimizers.zero
	    ]
	  },
	  'text-overflow': {
	    canOverride: canOverride.property.textOverflow,
	    defaultValue: 'none'
	  },
	  'text-shadow': {
	    canOverride: canOverride.property.textShadow,
	    defaultValue: 'none',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.zero,
	      valueOptimizers.color
	    ]
	  },
	  top: {
	    canOverride: canOverride.property.top,
	    defaultValue: 'auto',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  transform: {
	    canOverride: canOverride.property.transform,
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.degrees,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  transition: {
	    breakUp: breakUp.multiplex(breakUp.transition),
	    canOverride: canOverride.generic.components([
	      canOverride.property.transitionProperty,
	      canOverride.generic.time,
	      canOverride.generic.timingFunction,
	      canOverride.generic.time
	    ]),
	    components: [
	      'transition-property',
	      'transition-duration',
	      'transition-timing-function',
	      'transition-delay'
	    ],
	    defaultValue: 'none',
	    restore: restore.multiplex(restore.withoutDefaults),
	    shorthand: true,
	    valueOptimizers: [
	      valueOptimizers.time,
	      valueOptimizers.fraction
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-delay': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    valueOptimizers: [
	      valueOptimizers.time
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-duration': {
	    canOverride: canOverride.generic.time,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: '0s',
	    intoMultiplexMode: 'real',
	    keepUnlessDefault: 'transition-delay',
	    valueOptimizers: [
	      valueOptimizers.time,
	      valueOptimizers.fraction
	    ],
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-property': {
	    canOverride: canOverride.generic.propertyName,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: 'all',
	    intoMultiplexMode: 'placeholder',
	    placeholderValue: '_', // it's a short value that won't match any property and still be a valid `transition-property`
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'transition-timing-function': {
	    canOverride: canOverride.generic.timingFunction,
	    componentOf: [
	      'transition'
	    ],
	    defaultValue: 'ease',
	    intoMultiplexMode: 'real',
	    vendorPrefixes: [
	      '-moz-',
	      '-ms-',
	      '-o-',
	      '-webkit-'
	    ]
	  },
	  'vertical-align': {
	    canOverride: canOverride.property.verticalAlign,
	    defaultValue: 'baseline',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  visibility: {
	    canOverride: canOverride.property.visibility,
	    defaultValue: 'visible'
	  },
	  '-webkit-tap-highlight-color': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.color
	    ]
	  },
	  '-webkit-margin-end': {
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'white-space': {
	    canOverride: canOverride.property.whiteSpace,
	    defaultValue: 'normal'
	  },
	  width: {
	    canOverride: canOverride.generic.unit,
	    defaultValue: 'auto',
	    shortestValue: '0',
	    valueOptimizers: [
	      valueOptimizers.whiteSpace,
	      valueOptimizers.fraction,
	      valueOptimizers.precision,
	      valueOptimizers.unit,
	      valueOptimizers.zero
	    ]
	  },
	  'z-index': {
	    canOverride: canOverride.property.zIndex,
	    defaultValue: 'auto'
	  }
	};

	// generate vendor-prefixed configuration
	var vendorPrefixedConfiguration = {};

	function cloneDescriptor(propertyName, prefix) {
	  var clonedDescriptor = override(configuration[propertyName], {});

	  if ('componentOf' in clonedDescriptor) {
	    clonedDescriptor.componentOf = clonedDescriptor.componentOf.map(function(shorthandName) {
	      return prefix + shorthandName;
	    });
	  }

	  if ('components' in clonedDescriptor) {
	    clonedDescriptor.components = clonedDescriptor.components.map(function(longhandName) {
	      return prefix + longhandName;
	    });
	  }

	  if ('keepUnlessDefault' in clonedDescriptor) {
	    clonedDescriptor.keepUnlessDefault = prefix + clonedDescriptor.keepUnlessDefault;
	  }

	  return clonedDescriptor;
	}

	for (var propertyName in configuration) {
	  var descriptor = configuration[propertyName];

	  if (!('vendorPrefixes' in descriptor)) {
	    continue;
	  }

	  for (var i = 0; i < descriptor.vendorPrefixes.length; i++) {
	    var prefix = descriptor.vendorPrefixes[i];
	    var clonedDescriptor = cloneDescriptor(propertyName, prefix);
	    delete clonedDescriptor.vendorPrefixes;

	    vendorPrefixedConfiguration[prefix + propertyName] = clonedDescriptor;
	  }

	  delete descriptor.vendorPrefixes;
	}

	configuration_1 = override(configuration, vendorPrefixedConfiguration);
	return configuration_1;
}

var helpers;
var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	var emptyCharacter = '';

	var Breaks = requireFormat$1().Breaks;
	var Spaces = requireFormat$1().Spaces;

	var Marker = requireMarker();
	var Token = requireToken();

	function supportsAfterClosingBrace(token) {
	  return token[1][1] == 'background' || token[1][1] == 'transform' || token[1][1] == 'src';
	}

	function afterClosingBrace(token, valueIndex) {
	  return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;
	}

	function afterComma(token, valueIndex) {
	  return token[valueIndex][1] == Marker.COMMA;
	}

	function afterSlash(token, valueIndex) {
	  return token[valueIndex][1] == Marker.FORWARD_SLASH;
	}

	function beforeComma(token, valueIndex) {
	  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;
	}

	function beforeSlash(token, valueIndex) {
	  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;
	}

	function inFilter(token) {
	  return token[1][1] == 'filter' || token[1][1] == '-ms-filter';
	}

	function disallowsSpace(context, token, valueIndex) {
	  return !context.spaceAfterClosingBrace
	    && supportsAfterClosingBrace(token)
	    && afterClosingBrace(token, valueIndex)
	    || beforeSlash(token, valueIndex)
	    || afterSlash(token, valueIndex)
	    || beforeComma(token, valueIndex)
	    || afterComma(token, valueIndex);
	}

	function rules(context, tokens) {
	  var store = context.store;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    store(context, tokens[i]);

	    if (i < l - 1) {
	      store(context, comma(context));
	    }
	  }
	}

	function body(context, tokens) {
	  var lastPropertyAt = lastPropertyIndex(tokens);

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    property(context, tokens, i, lastPropertyAt);
	  }
	}

	function lastPropertyIndex(tokens) {
	  var index = tokens.length - 1;

	  for (; index >= 0; index--) {
	    if (tokens[index][0] != Token.COMMENT) {
	      break;
	    }
	  }

	  return index;
	}

	function property(context, tokens, position, lastPropertyAt) {
	  var store = context.store;
	  var token = tokens[position];

	  var propertyValue = token[2];
	  var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;

	  var needsSemicolon;
	  if (context.format) {
	    if (context.format.semicolonAfterLastProperty || isPropertyBlock) {
	      needsSemicolon = true;
	    } else if (position < lastPropertyAt) {
	      needsSemicolon = true;
	    } else {
	      needsSemicolon = false;
	    }
	  } else {
	    needsSemicolon = position < lastPropertyAt || isPropertyBlock;
	  }

	  var isLast = position === lastPropertyAt;

	  switch (token[0]) {
	  case Token.AT_RULE:
	    store(context, token);
	    store(context, semicolon(context, Breaks.AfterProperty, false));
	    break;
	  case Token.AT_RULE_BLOCK:
	    rules(context, token[1]);
	    store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	    body(context, token[2]);
	    store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	    break;
	  case Token.COMMENT:
	    store(context, token);
	    store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);
	    break;
	  case Token.PROPERTY:
	    store(context, token[1]);
	    store(context, colon(context));
	    if (propertyValue) {
	      value(context, token);
	    }
	    store(
	      context,
	      needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter
	    );
	    break;
	  case Token.RAW:
	    store(context, token);
	  }
	}

	function value(context, token) {
	  var store = context.store;
	  var j, m;

	  if (token[2][0] == Token.PROPERTY_BLOCK) {
	    store(context, openBrace(context, Breaks.AfterBlockBegins, false));
	    body(context, token[2][1]);
	    store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));
	  } else {
	    for (j = 2, m = token.length; j < m; j++) {
	      store(context, token[j]);

	      if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {
	        store(context, Marker.SPACE);
	      }
	    }
	  }
	}

	function breakFor(context, where) {
	  return context.format ? context.format.breaks[where] : emptyCharacter;
	}

	function allowsSpace(context, where) {
	  return context.format && context.format.spaces[where];
	}

	function openBrace(context, where, needsPrefixSpace) {
	  if (context.format) {
	    context.indentBy += context.format.indentBy;
	    context.indentWith = context.format.indentWith.repeat(context.indentBy);
	    return (
	      needsPrefixSpace
	      && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter
	    ) + Marker.OPEN_CURLY_BRACKET
	      + breakFor(context, where)
	      + context.indentWith;
	  }
	  return Marker.OPEN_CURLY_BRACKET;
	}

	function closeBrace(context, where, beforeBlockEnd, isLast) {
	  if (context.format) {
	    context.indentBy -= context.format.indentBy;
	    context.indentWith = context.format.indentWith.repeat(context.indentBy);
	    return (
	      beforeBlockEnd
	        ? breakFor(context, Breaks.BeforeBlockEnds)
	        : breakFor(context, Breaks.AfterProperty)
	    ) + context.indentWith
	      + Marker.CLOSE_CURLY_BRACKET
	      + (isLast ? emptyCharacter : breakFor(context, where) + context.indentWith);
	  }
	  return Marker.CLOSE_CURLY_BRACKET;
	}

	function colon(context) {
	  return context.format
	    ? Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter)
	    : Marker.COLON;
	}

	function semicolon(context, where, isLast) {
	  return context.format
	    ? Marker.SEMICOLON + (isLast ? emptyCharacter : (breakFor(context, where) + context.indentWith))
	    : Marker.SEMICOLON;
	}

	function comma(context) {
	  return context.format
	    ? Marker.COMMA + breakFor(context, Breaks.BetweenSelectors) + context.indentWith
	    : Marker.COMMA;
	}

	function all(context, tokens) {
	  var store = context.store;
	  var token;
	  var isLast;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    isLast = i == l - 1;

	    switch (token[0]) {
	    case Token.AT_RULE:
	      store(context, token);
	      store(context, semicolon(context, Breaks.AfterAtRule, isLast));
	      break;
	    case Token.AT_RULE_BLOCK:
	      rules(context, token[1]);
	      store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	      body(context, token[2]);
	      store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	      break;
	    case Token.NESTED_BLOCK:
	      rules(context, token[1]);
	      store(context, openBrace(context, Breaks.AfterBlockBegins, true));
	      all(context, token[2]);
	      store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));
	      break;
	    case Token.COMMENT:
	      store(context, token);
	      store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);
	      break;
	    case Token.RAW:
	      store(context, token);
	      break;
	    case Token.RULE:
	      rules(context, token[1]);
	      store(context, openBrace(context, Breaks.AfterRuleBegins, true));
	      body(context, token[2]);
	      store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
	      break;
	    }
	  }
	}

	helpers = {
	  all: all,
	  body: body,
	  property: property,
	  rules: rules,
	  value: value
	};
	return helpers;
}

var oneTime;
var hasRequiredOneTime;

function requireOneTime () {
	if (hasRequiredOneTime) return oneTime;
	hasRequiredOneTime = 1;
	var helpers = requireHelpers();

	function store(serializeContext, token) {
	  serializeContext.output.push(typeof token == 'string' ? token : token[1]);
	}

	function context() {
	  var newContext = {
	    output: [],
	    store: store
	  };

	  return newContext;
	}

	function all(tokens) {
	  var oneTimeContext = context();
	  helpers.all(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function body(tokens) {
	  var oneTimeContext = context();
	  helpers.body(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function property(tokens, position) {
	  var oneTimeContext = context();
	  helpers.property(oneTimeContext, tokens, position, true);
	  return oneTimeContext.output.join('');
	}

	function rules(tokens) {
	  var oneTimeContext = context();
	  helpers.rules(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	function value(tokens) {
	  var oneTimeContext = context();
	  helpers.value(oneTimeContext, tokens);
	  return oneTimeContext.output.join('');
	}

	oneTime = {
	  all: all,
	  body: body,
	  property: property,
	  rules: rules,
	  value: value
	};
	return oneTime;
}

var optimize$2;
var hasRequiredOptimize$2;

function requireOptimize$2 () {
	if (hasRequiredOptimize$2) return optimize$2;
	hasRequiredOptimize$2 = 1;
	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();
	var tidyBlock = requireTidyBlock();
	var tidyAtRule = requireTidyAtRule();

	var Hack = requireHack();
	var removeUnused = requireRemoveUnused();
	var restoreFromOptimizing = requireRestoreFromOptimizing();
	var wrapForOptimizing = requireWrapForOptimizing().all;

	var configuration = requireConfiguration();
	var optimizers = requireValueOptimizers();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var Token = requireToken();
	var Marker = requireMarker();

	var formatPosition = requireFormatPosition();

	var serializeRules = requireOneTime().rules;

	var CHARSET_TOKEN = '@charset';
	var CHARSET_REGEXP = new RegExp('^' + CHARSET_TOKEN, 'i');

	var DEFAULT_ROUNDING_PRECISION = requireRoundingPrecision().DEFAULT;

	var VARIABLE_PROPERTY_NAME_PATTERN = /^--\S+$/;
	var PROPERTY_NAME_PATTERN = /^(?:-chrome-|-[\w-]+\w|\w[\w-]+\w|\w{1,})$/;
	var IMPORT_PREFIX_PATTERN = /^@import/i;
	var URL_PREFIX_PATTERN = /^url\(/i;

	function startsAsUrl(value) {
	  return URL_PREFIX_PATTERN.test(value);
	}

	function isImport(token) {
	  return IMPORT_PREFIX_PATTERN.test(token[1]);
	}

	function isLegacyFilter(property) {
	  var value;

	  if (property.name == 'filter' || property.name == '-ms-filter') {
	    value = property.value[0][1];

	    return value.indexOf('progid') > -1
	      || value.indexOf('alpha') === 0
	      || value.indexOf('chroma') === 0;
	  }
	  return false;
	}

	function noop() {}

	function noopValueOptimizer(_name, value, _options) { return value; }

	function optimizeBody(rule, properties, context) {
	  var options = context.options;
	  var valueOptimizers;
	  var property, name, type, value;
	  var propertyToken;
	  var propertyOptimizer;
	  var serializedRule = serializeRules(rule);
	  var _properties = wrapForOptimizing(properties);
	  var pluginValueOptimizers = context.options.plugins.level1Value;
	  var pluginPropertyOptimizers = context.options.plugins.level1Property;
	  var isVariable;
	  var i, l;

	  for (i = 0, l = _properties.length; i < l; i++) {
	    var j, k, m, n;

	    property = _properties[i];
	    name = property.name;
	    propertyOptimizer = configuration[name] && configuration[name].propertyOptimizer || noop;
	    valueOptimizers = configuration[name] && configuration[name].valueOptimizers || [optimizers.whiteSpace];
	    isVariable = VARIABLE_PROPERTY_NAME_PATTERN.test(name);

	    if (isVariable) {
	      valueOptimizers = options.variableOptimizers.length > 0
	        ? options.variableOptimizers
	        : [optimizers.whiteSpace];
	    }

	    if (!isVariable && !PROPERTY_NAME_PATTERN.test(name)) {
	      propertyToken = property.all[property.position];
	      context.warnings.push('Invalid property name \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
	      property.unused = true;
	      continue;
	    }

	    if (property.value.length === 0) {
	      propertyToken = property.all[property.position];
	      context.warnings.push('Empty property \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
	      property.unused = true;
	      continue;
	    }

	    if (property.hack && (
	      (property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE)
	        && !options.compatibility.properties.iePrefixHack
	        || property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack
	        || property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {
	      property.unused = true;
	      continue;
	    }

	    if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {
	      property.unused = true;
	      continue;
	    }

	    if (property.block) {
	      optimizeBody(rule, property.value[0][1], context);
	      continue;
	    }

	    for (j = 0, m = property.value.length; j < m; j++) {
	      type = property.value[j][0];
	      value = property.value[j][1];

	      if (type == Token.PROPERTY_BLOCK) {
	        property.unused = true;
	        context.warnings.push('Invalid value token at ' + formatPosition(value[0][1][2][0]) + '. Ignoring.');
	        break;
	      }

	      if (startsAsUrl(value) && !context.validator.isUrl(value)) {
	        property.unused = true;
	        context.warnings.push('Broken URL \'' + value + '\' at ' + formatPosition(property.value[j][2][0]) + '. Ignoring.');
	        break;
	      }

	      for (k = 0, n = valueOptimizers.length; k < n; k++) {
	        value = valueOptimizers[k](name, value, options);
	      }

	      for (k = 0, n = pluginValueOptimizers.length; k < n; k++) {
	        value = pluginValueOptimizers[k](name, value, options);
	      }

	      property.value[j][1] = value;
	    }

	    propertyOptimizer(serializedRule, property, options);

	    for (j = 0, m = pluginPropertyOptimizers.length; j < m; j++) {
	      pluginPropertyOptimizers[j](serializedRule, property, options);
	    }
	  }

	  restoreFromOptimizing(_properties);
	  removeUnused(_properties);
	  removeComments(properties, options);
	}

	function removeComments(tokens, options) {
	  var token;
	  var i;

	  for (i = 0; i < tokens.length; i++) {
	    token = tokens[i];

	    if (token[0] != Token.COMMENT) {
	      continue;
	    }

	    optimizeComment(token, options);

	    if (token[1].length === 0) {
	      tokens.splice(i, 1);
	      i--;
	    }
	  }
	}

	function optimizeComment(token, options) {
	  if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == 'all' || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {
	    options.commentsKept++;
	    return;
	  }

	  token[1] = [];
	}

	function cleanupCharsets(tokens) {
	  var hasCharset = false;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] != Token.AT_RULE) { continue; }

	    if (!CHARSET_REGEXP.test(token[1])) { continue; }

	    if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    } else {
	      hasCharset = true;
	      tokens.splice(i, 1);
	      tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
	    }
	  }
	}

	function buildUnitRegexp(options) {
	  var units = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%'];
	  var otherUnits = ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];

	  otherUnits.forEach(function(unit) {
	    if (options.compatibility.units[unit]) {
	      units.push(unit);
	    }
	  });

	  return new RegExp('(^|\\s|\\(|,)0(?:' + units.join('|') + ')(\\W|$)', 'g');
	}

	function buildPrecisionOptions(roundingPrecision) {
	  var precisionOptions = {
	    matcher: null,
	    units: {}
	  };
	  var optimizable = [];
	  var unit;
	  var value;

	  for (unit in roundingPrecision) {
	    value = roundingPrecision[unit];

	    if (value != DEFAULT_ROUNDING_PRECISION) {
	      precisionOptions.units[unit] = {};
	      precisionOptions.units[unit].value = value;
	      precisionOptions.units[unit].multiplier = 10 ** value;

	      optimizable.push(unit);
	    }
	  }

	  if (optimizable.length > 0) {
	    precisionOptions.enabled = true;
	    precisionOptions.decimalPointMatcher = new RegExp('(\\d)\\.($|' + optimizable.join('|') + ')($|\\W)', 'g');
	    precisionOptions.zeroMatcher = new RegExp('(\\d*)(\\.\\d+)(' + optimizable.join('|') + ')', 'g');
	  }

	  return precisionOptions;
	}

	function buildVariableOptimizers(options) {
	  return options.level[OptimizationLevel.One].variableValueOptimizers.map(function(optimizer) {
	    if (typeof (optimizer) == 'string') {
	      return optimizers[optimizer] || noopValueOptimizer;
	    }

	    return optimizer;
	  });
	}

	function level1Optimize(tokens, context) {
	  var options = context.options;
	  var levelOptions = options.level[OptimizationLevel.One];
	  var ie7Hack = options.compatibility.selectors.ie7Hack;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
	  var format = options.format;
	  var mayHaveCharset = false;
	  var afterRules = false;

	  options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
	  options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
	  options.commentsKept = options.commentsKept || 0;
	  options.variableOptimizers = options.variableOptimizers || buildVariableOptimizers(options);

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    switch (token[0]) {
	    case Token.AT_RULE:
	      token[1] = isImport(token) && afterRules ? '' : token[1];
	      token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
	      mayHaveCharset = true;
	      break;
	    case Token.AT_RULE_BLOCK:
	      optimizeBody(token[1], token[2], context);
	      afterRules = true;
	      break;
	    case Token.NESTED_BLOCK:
	      token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
	      level1Optimize(token[2], context);
	      afterRules = true;
	      break;
	    case Token.COMMENT:
	      optimizeComment(token, options);
	      break;
	    case Token.RULE:
	      token[1] = levelOptions.tidySelectors
	        ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings)
	        : token[1];
	      token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
	      optimizeBody(token[1], token[2], context);
	      afterRules = true;
	      break;
	    }

	    if (token[0] == Token.COMMENT
	      && token[1].length === 0
	      || levelOptions.removeEmpty
	      && (token[1].length === 0 || (token[2] && token[2].length === 0))) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    }
	  }

	  if (levelOptions.cleanupCharsets && mayHaveCharset) {
	    cleanupCharsets(tokens);
	  }

	  return tokens;
	}

	optimize$2 = level1Optimize;
	return optimize$2;
}

var isMergeable_1;
var hasRequiredIsMergeable;

function requireIsMergeable () {
	if (hasRequiredIsMergeable) return isMergeable_1;
	hasRequiredIsMergeable = 1;
	var Marker = requireMarker();
	var split = requireSplit();

	var DEEP_SELECTOR_PATTERN = /\/deep\//;
	var DOUBLE_COLON_PATTERN = /^::/;
	var VENDOR_PREFIXED_PATTERN = /:(-moz-|-ms-|-o-|-webkit-)/;

	var NOT_PSEUDO = ':not';
	var PSEUDO_CLASSES_WITH_ARGUMENTS = [
	  ':dir',
	  ':lang',
	  ':not',
	  ':nth-child',
	  ':nth-last-child',
	  ':nth-last-of-type',
	  ':nth-of-type'
	];
	var RELATION_PATTERN = /[>+~]/;
	var UNMIXABLE_PSEUDO_CLASSES = [
	  ':after',
	  ':before',
	  ':first-letter',
	  ':first-line',
	  ':lang'
	];
	var UNMIXABLE_PSEUDO_ELEMENTS = [
	  '::after',
	  '::before',
	  '::first-letter',
	  '::first-line'
	];

	var Level = {
	  DOUBLE_QUOTE: 'double-quote',
	  SINGLE_QUOTE: 'single-quote',
	  ROOT: 'root'
	};

	function isMergeable(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
	  var singleSelectors = split(selector, Marker.COMMA);
	  var singleSelector;
	  var i, l;

	  for (i = 0, l = singleSelectors.length; i < l; i++) {
	    singleSelector = singleSelectors[i];

	    if (singleSelector.length === 0
	        || isDeepSelector(singleSelector)
	        || isVendorPrefixed(singleSelector)
	        || (singleSelector.indexOf(Marker.COLON) > -1
	          && !areMergeable(
	            singleSelector,
	            extractPseudoFrom(singleSelector),
	            mergeablePseudoClasses,
	            mergeablePseudoElements,
	            multiplePseudoMerging
	          ))) {
	      return false;
	    }
	  }

	  return true;
	}

	function isDeepSelector(selector) {
	  return DEEP_SELECTOR_PATTERN.test(selector);
	}

	function isVendorPrefixed(selector) {
	  return VENDOR_PREFIXED_PATTERN.test(selector);
	}

	function extractPseudoFrom(selector) {
	  var list = [];
	  var character;
	  var buffer = [];
	  var level = Level.ROOT;
	  var roundBracketLevel = 0;
	  var isQuoted;
	  var isEscaped;
	  var isPseudo = false;
	  var isRelation;
	  var wasColon = false;
	  var index;
	  var len;

	  for (index = 0, len = selector.length; index < len; index++) {
	    character = selector[index];

	    isRelation = !isEscaped && RELATION_PATTERN.test(character);
	    isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;

	    if (isEscaped) {
	      buffer.push(character);
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {
	      buffer.push(character);
	      level = Level.DOUBLE_QUOTE;
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
	      buffer.push(character);
	      level = Level.ROOT;
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {
	      buffer.push(character);
	      level = Level.SINGLE_QUOTE;
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
	      buffer.push(character);
	      level = Level.ROOT;
	    } else if (isQuoted) {
	      buffer.push(character);
	    } else if (character == Marker.OPEN_ROUND_BRACKET) {
	      buffer.push(character);
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {
	      buffer.push(character);
	      list.push(buffer.join(''));
	      roundBracketLevel--;
	      buffer = [];
	      isPseudo = false;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET) {
	      buffer.push(character);
	      roundBracketLevel--;
	    } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {
	      list.push(buffer.join(''));
	      buffer = [];
	      buffer.push(character);
	    } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {
	      buffer = [];
	      buffer.push(character);
	      isPseudo = true;
	    } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {
	      list.push(buffer.join(''));
	      buffer = [];
	      isPseudo = false;
	    } else if (isRelation && roundBracketLevel === 0 && isPseudo) {
	      list.push(buffer.join(''));
	      buffer = [];
	      isPseudo = false;
	    } else {
	      buffer.push(character);
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	    wasColon = character == Marker.COLON;
	  }

	  if (buffer.length > 0 && isPseudo) {
	    list.push(buffer.join(''));
	  }

	  return list;
	}

	function areMergeable(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
	  return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements)
	    && needArguments(matches)
	    && (matches.length < 2 || !someIncorrectlyChained(selector, matches))
	    && (matches.length < 2 || multiplePseudoMerging && allMixable(matches));
	}

	function areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) {
	  var match;
	  var name;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];
	    name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1
	      ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET))
	      : match;

	    if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {
	      return false;
	    }
	  }

	  return true;
	}

	function needArguments(matches) {
	  var match;
	  var name;
	  var bracketOpensAt;
	  var hasArguments;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];

	    bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);
	    hasArguments = bracketOpensAt > -1;
	    name = hasArguments
	      ? match.substring(0, bracketOpensAt)
	      : match;

	    if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {
	      return false;
	    }

	    if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {
	      return false;
	    }
	  }

	  return true;
	}

	function someIncorrectlyChained(selector, matches) {
	  var positionInSelector = 0;
	  var match;
	  var matchAt;
	  var nextMatch;
	  var nextMatchAt;
	  var name;
	  var nextName;
	  var areChained;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];
	    nextMatch = matches[i + 1];

	    if (!nextMatch) {
	      break;
	    }

	    matchAt = selector.indexOf(match, positionInSelector);
	    nextMatchAt = selector.indexOf(match, matchAt + 1);
	    positionInSelector = nextMatchAt;
	    areChained = matchAt + match.length == nextMatchAt;

	    if (areChained) {
	      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1
	        ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET))
	        : match;
	      nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1
	        ? nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET))
	        : nextMatch;

	      if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function allMixable(matches) {
	  var unmixableMatches = 0;
	  var match;
	  var i, l;

	  for (i = 0, l = matches.length; i < l; i++) {
	    match = matches[i];

	    if (isPseudoElement(match)) {
	      unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;
	    } else {
	      unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;
	    }

	    if (unmixableMatches > 1) {
	      return false;
	    }
	  }

	  return true;
	}

	function isPseudoElement(pseudo) {
	  return DOUBLE_COLON_PATTERN.test(pseudo);
	}

	isMergeable_1 = isMergeable;
	return isMergeable_1;
}

var everyValuesPair_1;
var hasRequiredEveryValuesPair;

function requireEveryValuesPair () {
	if (hasRequiredEveryValuesPair) return everyValuesPair_1;
	hasRequiredEveryValuesPair = 1;
	var Marker = requireMarker();

	function everyValuesPair(fn, left, right) {
	  var leftSize = left.value.length;
	  var rightSize = right.value.length;
	  var total = Math.max(leftSize, rightSize);
	  var lowerBound = Math.min(leftSize, rightSize) - 1;
	  var leftValue;
	  var rightValue;
	  var position;

	  for (position = 0; position < total; position++) {
	    leftValue = left.value[position] && left.value[position][1] || leftValue;
	    rightValue = right.value[position] && right.value[position][1] || rightValue;

	    if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {
	      continue;
	    }

	    if (!fn(leftValue, rightValue, position, position <= lowerBound)) {
	      return false;
	    }
	  }

	  return true;
	}

	everyValuesPair_1 = everyValuesPair;
	return everyValuesPair_1;
}

var hasInherit_1;
var hasRequiredHasInherit;

function requireHasInherit () {
	if (hasRequiredHasInherit) return hasInherit_1;
	hasRequiredHasInherit = 1;
	function hasInherit(property) {
	  for (var i = property.value.length - 1; i >= 0; i--) {
	    if (property.value[i][1] == 'inherit') { return true; }
	  }

	  return false;
	}

	hasInherit_1 = hasInherit;
	return hasInherit_1;
}

var hasSameValues_1;
var hasRequiredHasSameValues;

function requireHasSameValues () {
	if (hasRequiredHasSameValues) return hasSameValues_1;
	hasRequiredHasSameValues = 1;
	function hasSameValues(property) {
	  var firstValue = property.value[0][1];
	  var i, l;

	  for (i = 1, l = property.value.length; i < l; i++) {
	    if (property.value[i][1] != firstValue) {
	      return false;
	    }
	  }

	  return true;
	}

	hasSameValues_1 = hasSameValues;
	return hasSameValues_1;
}

var populateComponents_1;
var hasRequiredPopulateComponents;

function requirePopulateComponents () {
	if (hasRequiredPopulateComponents) return populateComponents_1;
	hasRequiredPopulateComponents = 1;
	var configuration = requireConfiguration();
	var InvalidPropertyError = requireInvalidPropertyError();

	function populateComponents(properties, validator, warnings) {
	  var component;
	  var j, m;

	  for (var i = properties.length - 1; i >= 0; i--) {
	    var property = properties[i];
	    var descriptor = configuration[property.name];

	    if (!property.dynamic && descriptor && descriptor.shorthand) {
	      if (onlyValueIsVariable(property, validator) || moreThanOneValueIsVariable(property, validator)) {
	        property.optimizable = false;
	        continue;
	      }

	      property.shorthand = true;
	      property.dirty = true;

	      try {
	        property.components = descriptor.breakUp(property, configuration, validator);

	        if (descriptor.shorthandComponents) {
	          for (j = 0, m = property.components.length; j < m; j++) {
	            component = property.components[j];
	            component.components = configuration[component.name].breakUp(component, configuration, validator);
	          }
	        }
	      } catch (e) {
	        if (e instanceof InvalidPropertyError) {
	          property.components = []; // this will set property.unused to true below
	          warnings.push(e.message);
	        } else {
	          throw e;
	        }
	      }

	      if (property.components.length > 0) {
	        property.multiplex = property.components[0].multiplex;
	      } else {
	        property.unused = true;
	      }
	    }
	  }
	}

	function onlyValueIsVariable(property, validator) {
	  return property.value.length == 1 && validator.isVariable(property.value[0][1]);
	}

	function moreThanOneValueIsVariable(property, validator) {
	  return property.value.length > 1
	    && property.value.filter(
	      function(value) {
	        return validator.isVariable(value[1]);
	      }
	    ).length > 1;
	}

	populateComponents_1 = populateComponents;
	return populateComponents_1;
}

var restoreWithComponents_1;
var hasRequiredRestoreWithComponents;

function requireRestoreWithComponents () {
	if (hasRequiredRestoreWithComponents) return restoreWithComponents_1;
	hasRequiredRestoreWithComponents = 1;
	var configuration = requireConfiguration();

	function restoreWithComponents(property) {
	  var descriptor = configuration[property.name];

	  if (descriptor && descriptor.shorthand) {
	    return descriptor.restore(property, configuration);
	  }
	  return property.value;
	}

	restoreWithComponents_1 = restoreWithComponents;
	return restoreWithComponents_1;
}

var mergeIntoShorthands_1;
var hasRequiredMergeIntoShorthands;

function requireMergeIntoShorthands () {
	if (hasRequiredMergeIntoShorthands) return mergeIntoShorthands_1;
	hasRequiredMergeIntoShorthands = 1;
	var everyValuesPair = requireEveryValuesPair();
	var hasInherit = requireHasInherit();
	var hasSameValues = requireHasSameValues();
	var populateComponents = requirePopulateComponents();

	var configuration = requireConfiguration();
	var deepClone = requireClone().deep;
	var restoreWithComponents = requireRestoreWithComponents();

	var restoreFromOptimizing = requireRestoreFromOptimizing();
	var wrapSingle = requireWrapForOptimizing().single;

	var serializeBody = requireOneTime().body;
	var Token = requireToken();

	function mergeIntoShorthands(properties, validator) {
	  var candidates = {};
	  var descriptor;
	  var componentOf;
	  var property;
	  var i, l;
	  var j, m;

	  // there is no shorthand property made up of less than 3 longhands
	  if (properties.length < 3) {
	    return;
	  }

	  for (i = 0, l = properties.length; i < l; i++) {
	    property = properties[i];
	    descriptor = configuration[property.name];

	    if (property.dynamic) {
	      continue;
	    }

	    if (property.unused) {
	      continue;
	    }

	    if (property.hack) {
	      continue;
	    }

	    if (property.block) {
	      continue;
	    }

	    if (descriptor && descriptor.singleTypeComponents && !hasSameValues(property)) {
	      continue;
	    }

	    invalidateOrCompact(properties, i, candidates, validator);

	    if (descriptor && descriptor.componentOf) {
	      for (j = 0, m = descriptor.componentOf.length; j < m; j++) {
	        componentOf = descriptor.componentOf[j];

	        candidates[componentOf] = candidates[componentOf] || {};
	        candidates[componentOf][property.name] = property;
	      }
	    }
	  }

	  invalidateOrCompact(properties, i, candidates, validator);
	}

	function invalidateOrCompact(properties, position, candidates, validator) {
	  var invalidatedBy = properties[position];
	  var shorthandName;
	  var shorthandDescriptor;
	  var candidateComponents;
	  var replacedCandidates = [];
	  var i;

	  for (shorthandName in candidates) {
	    if (undefined !== invalidatedBy && shorthandName == invalidatedBy.name) {
	      continue;
	    }

	    shorthandDescriptor = configuration[shorthandName];
	    candidateComponents = candidates[shorthandName];
	    if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {
	      delete candidates[shorthandName];
	      continue;
	    }

	    if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {
	      continue;
	    }

	    if (mixedImportance(candidateComponents)) {
	      continue;
	    }

	    if (!overridable(candidateComponents, shorthandName, validator)) {
	      continue;
	    }

	    if (!mergeable(candidateComponents)) {
	      continue;
	    }

	    if (mixedInherit(candidateComponents)) {
	      replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);
	    } else {
	      replaceWithShorthand(properties, candidateComponents, shorthandName, validator);
	    }

	    replacedCandidates.push(shorthandName);
	  }

	  for (i = replacedCandidates.length - 1; i >= 0; i--) {
	    delete candidates[replacedCandidates[i]];
	  }
	}

	function invalidates(candidates, shorthandName, invalidatedBy) {
	  var shorthandDescriptor = configuration[shorthandName];
	  var invalidatedByDescriptor = configuration[invalidatedBy.name];
	  var componentName;

	  if ('overridesShorthands' in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {
	    return true;
	  }

	  if (invalidatedByDescriptor && 'componentOf' in invalidatedByDescriptor) {
	    for (componentName in candidates[shorthandName]) {
	      if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function mixedImportance(components) {
	  var important;
	  var componentName;

	  for (componentName in components) {
	    if (undefined !== important && components[componentName].important != important) {
	      return true;
	    }

	    important = components[componentName].important;
	  }

	  return false;
	}

	function overridable(components, shorthandName, validator) {
	  var descriptor = configuration[shorthandName];
	  var newValuePlaceholder = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var newProperty = wrapSingle(newValuePlaceholder);
	  var component;
	  var mayOverride;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];
	    mayOverride = configuration[component.name].canOverride || sameValue;

	    if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {
	      return false;
	    }
	  }

	  return true;
	}

	function sameValue(_validator, value1, value2) {
	  return value1 === value2;
	}

	function mergeable(components) {
	  var lastCount = null;
	  var currentCount;
	  var componentName;
	  var component;
	  var descriptor;
	  var values;

	  for (componentName in components) {
	    component = components[componentName];
	    descriptor = configuration[componentName];

	    if (!('restore' in descriptor)) {
	      continue;
	    }

	    restoreFromOptimizing([component.all[component.position]], restoreWithComponents);
	    values = descriptor.restore(component, configuration);

	    currentCount = values.length;

	    if (lastCount !== null && currentCount !== lastCount) {
	      return false;
	    }

	    lastCount = currentCount;
	  }

	  return true;
	}

	function mixedInherit(components) {
	  var componentName;
	  var lastValue = null;
	  var currentValue;

	  for (componentName in components) {
	    currentValue = hasInherit(components[componentName]);

	    if (lastValue !== null && lastValue !== currentValue) {
	      return true;
	    }

	    lastValue = currentValue;
	  }

	  return false;
	}

	function replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator) {
	  var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);
	  var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);
	  var longhandTokensSequence = viaLonghands[0];
	  var shorthandTokensSequence = viaShorthand[0];
	  var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;
	  var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;
	  var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];
	  var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];
	  var lastComponent = candidateComponents[Object.keys(candidateComponents).pop()];
	  var all = lastComponent.all;
	  var insertAt = lastComponent.position;
	  var componentName;
	  var oldComponent;
	  var newComponent;
	  var newToken;

	  newProperty.position = insertAt;
	  newProperty.shorthand = true;
	  newProperty.important = lastComponent.important;
	  newProperty.multiplex = false;
	  newProperty.dirty = true;
	  newProperty.all = all;
	  newProperty.all[insertAt] = newTokensSequence[0];

	  properties.splice(insertAt, 1, newProperty);

	  for (componentName in candidateComponents) {
	    oldComponent = candidateComponents[componentName];
	    oldComponent.unused = true;

	    newProperty.multiplex = newProperty.multiplex || oldComponent.multiplex;

	    if (oldComponent.name in newComponents) {
	      newComponent = newComponents[oldComponent.name];
	      newToken = findTokenIn(newTokensSequence, componentName);

	      newComponent.position = all.length;
	      newComponent.all = all;
	      newComponent.all.push(newToken);

	      properties.push(newComponent);
	    }
	  }
	}

	function buildSequenceWithInheritLonghands(components, shorthandName, validator) {
	  var tokensSequence = [];
	  var inheritComponents = {};
	  var nonInheritComponents = {};
	  var descriptor = configuration[shorthandName];
	  var shorthandToken = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var newProperty = wrapSingle(shorthandToken);
	  var component;
	  var longhandToken;
	  var newComponent;
	  var nameMetadata;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];

	    if (hasInherit(component)) {
	      longhandToken = component.all[component.position].slice(0, 2);
	      Array.prototype.push.apply(longhandToken, component.value);
	      tokensSequence.push(longhandToken);

	      newComponent = deepClone(component);
	      newComponent.value = inferComponentValue(components, newComponent.name);

	      newProperty.components[i] = newComponent;
	      inheritComponents[component.name] = deepClone(component);
	    } else {
	      newComponent = deepClone(component);
	      newComponent.all = component.all;
	      newProperty.components[i] = newComponent;

	      nonInheritComponents[component.name] = component;
	    }
	  }

	  newProperty.important = components[Object.keys(components).pop()].important;

	  nameMetadata = joinMetadata(nonInheritComponents, 1);
	  shorthandToken[1].push(nameMetadata);

	  restoreFromOptimizing([newProperty], restoreWithComponents);

	  shorthandToken = shorthandToken.slice(0, 2);
	  Array.prototype.push.apply(shorthandToken, newProperty.value);

	  tokensSequence.unshift(shorthandToken);

	  return [tokensSequence, newProperty, inheritComponents];
	}

	function inferComponentValue(components, propertyName) {
	  var descriptor = configuration[propertyName];

	  if ('oppositeTo' in descriptor) {
	    return components[descriptor.oppositeTo].value;
	  }
	  return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
	}

	function joinMetadata(components, at) {
	  var metadata = [];
	  var component;
	  var originalValue;
	  var componentMetadata;
	  var componentName;

	  for (componentName in components) {
	    component = components[componentName];
	    originalValue = component.all[component.position];
	    componentMetadata = originalValue[at][originalValue[at].length - 1];

	    Array.prototype.push.apply(metadata, componentMetadata);
	  }

	  return metadata.sort(metadataSorter);
	}

	function metadataSorter(metadata1, metadata2) {
	  var line1 = metadata1[0];
	  var line2 = metadata2[0];
	  var column1 = metadata1[1];
	  var column2 = metadata2[1];

	  if (line1 < line2) {
	    return -1;
	  } if (line1 === line2) {
	    return column1 < column2 ? -1 : 1;
	  }
	  return 1;
	}

	function buildSequenceWithInheritShorthand(components, shorthandName, validator) {
	  var tokensSequence = [];
	  var inheritComponents = {};
	  var nonInheritComponents = {};
	  var descriptor = configuration[shorthandName];
	  var shorthandToken = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, 'inherit']
	  ];
	  var newProperty = wrapSingle(shorthandToken);
	  var component;
	  var longhandToken;
	  var nameMetadata;
	  var valueMetadata;
	  var i, l;

	  populateComponents([newProperty], validator, []);

	  for (i = 0, l = descriptor.components.length; i < l; i++) {
	    component = components[descriptor.components[i]];

	    if (hasInherit(component)) {
	      inheritComponents[component.name] = component;
	    } else {
	      longhandToken = component.all[component.position].slice(0, 2);
	      Array.prototype.push.apply(longhandToken, component.value);
	      tokensSequence.push(longhandToken);

	      nonInheritComponents[component.name] = deepClone(component);
	    }
	  }

	  nameMetadata = joinMetadata(inheritComponents, 1);
	  shorthandToken[1].push(nameMetadata);

	  valueMetadata = joinMetadata(inheritComponents, 2);
	  shorthandToken[2].push(valueMetadata);

	  tokensSequence.unshift(shorthandToken);

	  return [tokensSequence, newProperty, nonInheritComponents];
	}

	function findTokenIn(tokens, componentName) {
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    if (tokens[i][1][1] == componentName) {
	      return tokens[i];
	    }
	  }
	}

	function replaceWithShorthand(properties, candidateComponents, shorthandName, validator) {
	  var descriptor = configuration[shorthandName];
	  var nameMetadata;
	  var valueMetadata;
	  var newValuePlaceholder = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, shorthandName],
	    [Token.PROPERTY_VALUE, descriptor.defaultValue]
	  ];
	  var all;
	  var insertAt = inferInsertAtFrom(properties, candidateComponents, shorthandName);

	  var newProperty = wrapSingle(newValuePlaceholder);
	  newProperty.shorthand = true;
	  newProperty.dirty = true;
	  newProperty.multiplex = false;

	  populateComponents([newProperty], validator, []);

	  for (var i = 0, l = descriptor.components.length; i < l; i++) {
	    var component = candidateComponents[descriptor.components[i]];

	    newProperty.components[i] = deepClone(component);
	    newProperty.important = component.important;
	    newProperty.multiplex = newProperty.multiplex || component.multiplex;

	    all = component.all;
	  }

	  for (var componentName in candidateComponents) {
	    candidateComponents[componentName].unused = true;
	  }

	  nameMetadata = joinMetadata(candidateComponents, 1);
	  newValuePlaceholder[1].push(nameMetadata);

	  valueMetadata = joinMetadata(candidateComponents, 2);
	  newValuePlaceholder[2].push(valueMetadata);

	  newProperty.position = insertAt;
	  newProperty.all = all;
	  newProperty.all[insertAt] = newValuePlaceholder;

	  properties.splice(insertAt, 1, newProperty);
	}

	function inferInsertAtFrom(properties, candidateComponents, shorthandName) {
	  var candidateComponentNames = Object.keys(candidateComponents);
	  var firstCandidatePosition = candidateComponents[candidateComponentNames[0]].position;
	  var lastCandidatePosition = candidateComponents[candidateComponentNames[candidateComponentNames.length - 1]].position;

	  if (shorthandName == 'border' && traversesVia(properties.slice(firstCandidatePosition, lastCandidatePosition), 'border-image')) {
	    return firstCandidatePosition;
	  }
	  return lastCandidatePosition;
	}

	function traversesVia(properties, propertyName) {
	  for (var i = properties.length - 1; i >= 0; i--) {
	    if (properties[i].name == propertyName) {
	      return true;
	    }
	  }

	  return false;
	}

	mergeIntoShorthands_1 = mergeIntoShorthands;
	return mergeIntoShorthands_1;
}

var hasUnset_1;
var hasRequiredHasUnset;

function requireHasUnset () {
	if (hasRequiredHasUnset) return hasUnset_1;
	hasRequiredHasUnset = 1;
	function hasUnset(property) {
	  for (var i = property.value.length - 1; i >= 0; i--) {
	    if (property.value[i][1] == 'unset') { return true; }
	  }

	  return false;
	}

	hasUnset_1 = hasUnset;
	return hasUnset_1;
}

var findComponentIn_1;
var hasRequiredFindComponentIn;

function requireFindComponentIn () {
	if (hasRequiredFindComponentIn) return findComponentIn_1;
	hasRequiredFindComponentIn = 1;
	var configuration = requireConfiguration();

	function findComponentIn(shorthand, longhand) {
	  var comparator = nameComparator(longhand);

	  return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);
	}

	function nameComparator(to) {
	  return function(property) {
	    return to.name === property.name;
	  };
	}

	function findInDirectComponents(shorthand, comparator) {
	  return shorthand.components.filter(comparator)[0];
	}

	function findInSubComponents(shorthand, comparator) {
	  var shorthandComponent;
	  var longhandMatch;
	  var i, l;

	  if (!configuration[shorthand.name].shorthandComponents) {
	    return;
	  }

	  for (i = 0, l = shorthand.components.length; i < l; i++) {
	    shorthandComponent = shorthand.components[i];
	    longhandMatch = findInDirectComponents(shorthandComponent, comparator);

	    if (longhandMatch) {
	      return longhandMatch;
	    }
	  }
	}

	findComponentIn_1 = findComponentIn;
	return findComponentIn_1;
}

var isComponentOf_1;
var hasRequiredIsComponentOf;

function requireIsComponentOf () {
	if (hasRequiredIsComponentOf) return isComponentOf_1;
	hasRequiredIsComponentOf = 1;
	var configuration = requireConfiguration();

	function isComponentOf(property1, property2, shallow) {
	  return isDirectComponentOf(property1, property2)
	    || !shallow && !!configuration[property1.name].shorthandComponents && isSubComponentOf(property1, property2);
	}

	function isDirectComponentOf(property1, property2) {
	  var descriptor = configuration[property1.name];

	  return 'components' in descriptor && descriptor.components.indexOf(property2.name) > -1;
	}

	function isSubComponentOf(property1, property2) {
	  return property1
	    .components
	    .some(function(component) {
	      return isDirectComponentOf(component, property2);
	    });
	}

	isComponentOf_1 = isComponentOf;
	return isComponentOf_1;
}

var isMergeableShorthand_1;
var hasRequiredIsMergeableShorthand;

function requireIsMergeableShorthand () {
	if (hasRequiredIsMergeableShorthand) return isMergeableShorthand_1;
	hasRequiredIsMergeableShorthand = 1;
	var Marker = requireMarker();

	function isMergeableShorthand(shorthand) {
	  if (shorthand.name != 'font') {
	    return true;
	  }

	  return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;
	}

	isMergeableShorthand_1 = isMergeableShorthand;
	return isMergeableShorthand_1;
}

var overridesNonComponentShorthand_1;
var hasRequiredOverridesNonComponentShorthand;

function requireOverridesNonComponentShorthand () {
	if (hasRequiredOverridesNonComponentShorthand) return overridesNonComponentShorthand_1;
	hasRequiredOverridesNonComponentShorthand = 1;
	var configuration = requireConfiguration();

	function overridesNonComponentShorthand(property1, property2) {
	  return property1.name in configuration
	    && 'overridesShorthands' in configuration[property1.name]
	    && configuration[property1.name].overridesShorthands.indexOf(property2.name) > -1;
	}

	overridesNonComponentShorthand_1 = overridesNonComponentShorthand;
	return overridesNonComponentShorthand_1;
}

var overrideProperties_1;
var hasRequiredOverrideProperties;

function requireOverrideProperties () {
	if (hasRequiredOverrideProperties) return overrideProperties_1;
	hasRequiredOverrideProperties = 1;
	var hasInherit = requireHasInherit();
	var hasUnset = requireHasUnset();
	var everyValuesPair = requireEveryValuesPair();
	var findComponentIn = requireFindComponentIn();
	var isComponentOf = requireIsComponentOf();
	var isMergeableShorthand = requireIsMergeableShorthand();
	var overridesNonComponentShorthand = requireOverridesNonComponentShorthand();
	var sameVendorPrefixesIn = requireVendorPrefixes().same;

	var configuration = requireConfiguration();
	var deepClone = requireClone().deep;
	var restoreWithComponents = requireRestoreWithComponents();
	var shallowClone = requireClone().shallow;

	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var Token = requireToken();
	var Marker = requireMarker();

	var serializeProperty = requireOneTime().property;

	function sameValue(_validator, value1, value2) {
	  return value1 === value2;
	}

	function wouldBreakCompatibility(property, validator) {
	  for (var i = 0; i < property.components.length; i++) {
	    var component = property.components[i];
	    var descriptor = configuration[component.name];
	    var canOverride = descriptor && descriptor.canOverride || sameValue;

	    var _component = shallowClone(component);
	    _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];

	    if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {
	      return true;
	    }
	  }

	  return false;
	}

	function overrideIntoMultiplex(property, by) {
	  by.unused = true;

	  turnIntoMultiplex(by, multiplexSize(property));
	  property.value = by.value;
	}

	function overrideByMultiplex(property, by) {
	  by.unused = true;
	  property.multiplex = true;
	  property.value = by.value;
	}

	function overrideSimple(property, by) {
	  by.unused = true;
	  property.value = by.value;
	}

	function override(property, by) {
	  if (by.multiplex) {
	    overrideByMultiplex(property, by);
	  } else if (property.multiplex) {
	    overrideIntoMultiplex(property, by);
	  } else {
	    overrideSimple(property, by);
	  }
	}

	function overrideShorthand(property, by) {
	  by.unused = true;

	  for (var i = 0, l = property.components.length; i < l; i++) {
	    override(property.components[i], by.components[i]);
	  }
	}

	function turnIntoMultiplex(property, size) {
	  property.multiplex = true;

	  if (configuration[property.name].shorthand) {
	    turnShorthandValueIntoMultiplex(property, size);
	  } else {
	    turnLonghandValueIntoMultiplex(property, size);
	  }
	}

	function turnShorthandValueIntoMultiplex(property, size) {
	  var component;
	  var i, l;

	  for (i = 0, l = property.components.length; i < l; i++) {
	    component = property.components[i];

	    if (!component.multiplex) {
	      turnLonghandValueIntoMultiplex(component, size);
	    }
	  }
	}

	function turnLonghandValueIntoMultiplex(property, size) {
	  var descriptor = configuration[property.name];
	  var withRealValue = descriptor.intoMultiplexMode == 'real';
	  var withValue = descriptor.intoMultiplexMode == 'real'
	    ? property.value.slice(0)
	    : (descriptor.intoMultiplexMode == 'placeholder' ? descriptor.placeholderValue : descriptor.defaultValue);
	  var i = multiplexSize(property);
	  var j;
	  var m = withValue.length;

	  for (; i < size; i++) {
	    property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);

	    if (Array.isArray(withValue)) {
	      for (j = 0; j < m; j++) {
	        property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);
	      }
	    } else {
	      property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);
	    }
	  }
	}

	function multiplexSize(component) {
	  var size = 0;

	  for (var i = 0, l = component.value.length; i < l; i++) {
	    if (component.value[i][1] == Marker.COMMA) { size++; }
	  }

	  return size + 1;
	}

	function lengthOf(property) {
	  var fakeAsArray = [
	    Token.PROPERTY,
	    [Token.PROPERTY_NAME, property.name]
	  ].concat(property.value);
	  return serializeProperty([fakeAsArray], 0).length;
	}

	function moreSameShorthands(properties, startAt, name) {
	  // Since we run the main loop in `compactOverrides` backwards, at this point some
	  // properties may not be marked as unused.
	  // We should consider reverting the order if possible
	  var count = 0;

	  for (var i = startAt; i >= 0; i--) {
	    if (properties[i].name == name && !properties[i].unused) { count++; }
	    if (count > 1) { break; }
	  }

	  return count > 1;
	}

	function overridingFunction(shorthand, validator) {
	  for (var i = 0, l = shorthand.components.length; i < l; i++) {
	    if (!anyValue(validator.isUrl, shorthand.components[i])
	      && anyValue(validator.isFunction, shorthand.components[i])) { return true; }
	  }

	  return false;
	}

	function anyValue(fn, property) {
	  for (var i = 0, l = property.value.length; i < l; i++) {
	    if (property.value[i][1] == Marker.COMMA) { continue; }

	    if (fn(property.value[i][1])) { return true; }
	  }

	  return false;
	}

	function wouldResultInLongerValue(left, right) {
	  if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex) { return false; }

	  var multiplex = left.multiplex ? left : right;
	  var simple = left.multiplex ? right : left;
	  var component;

	  var multiplexClone = deepClone(multiplex);
	  restoreFromOptimizing([multiplexClone], restoreWithComponents);

	  var simpleClone = deepClone(simple);
	  restoreFromOptimizing([simpleClone], restoreWithComponents);

	  var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);

	  if (left.multiplex) {
	    component = findComponentIn(multiplexClone, simpleClone);
	    overrideIntoMultiplex(component, simpleClone);
	  } else {
	    component = findComponentIn(simpleClone, multiplexClone);
	    turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));
	    overrideByMultiplex(component, multiplexClone);
	  }

	  restoreFromOptimizing([simpleClone], restoreWithComponents);

	  var lengthAfter = lengthOf(simpleClone);

	  return lengthBefore <= lengthAfter;
	}

	function isCompactable(property) {
	  return property.name in configuration;
	}

	function noneOverrideHack(left, right) {
	  return !left.multiplex
	    && (left.name == 'background' || left.name == 'background-image')
	    && right.multiplex
	    && (right.name == 'background' || right.name == 'background-image')
	    && anyLayerIsNone(right.value);
	}

	function anyLayerIsNone(values) {
	  var layers = intoLayers(values);

	  for (var i = 0, l = layers.length; i < l; i++) {
	    if (layers[i].length == 1 && layers[i][0][1] == 'none') { return true; }
	  }

	  return false;
	}

	function intoLayers(values) {
	  var layers = [];

	  for (var i = 0, layer = [], l = values.length; i < l; i++) {
	    var value = values[i];
	    if (value[1] == Marker.COMMA) {
	      layers.push(layer);
	      layer = [];
	    } else {
	      layer.push(value);
	    }
	  }

	  layers.push(layer);
	  return layers;
	}

	function overrideProperties(properties, withMerging, compatibility, validator) {
	  var mayOverride, right, left, component;
	  var overriddenComponents;
	  var overriddenComponent;
	  var overridingComponent;
	  var overridable;
	  var i, j, k;

	  propertyLoop:
	  for (i = properties.length - 1; i >= 0; i--) {
	    right = properties[i];

	    if (!isCompactable(right)) { continue; }

	    if (right.block) { continue; }

	    mayOverride = configuration[right.name].canOverride || sameValue;

	    traverseLoop:
	    for (j = i - 1; j >= 0; j--) {
	      left = properties[j];

	      if (!isCompactable(left)) { continue; }

	      if (left.block) { continue; }

	      if (left.dynamic || right.dynamic) { continue; }

	      if (left.unused || right.unused) { continue; }

	      if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack) { continue; }

	      if (left.important == right.important && left.hack[0] != right.hack[0]) { continue; }

	      if (left.important == right.important
	        && (left.hack[0] != right.hack[0] || (left.hack[1] && left.hack[1] != right.hack[1]))) { continue; }

	      if (hasInherit(right)) { continue; }

	      if (noneOverrideHack(left, right)) { continue; }

	      if (right.shorthand && isComponentOf(right, left)) {
	        // maybe `left` can be overridden by `right` which is a shorthand?
	        if (!right.important && left.important) { continue; }

	        if (!sameVendorPrefixesIn([left], right.components)) { continue; }

	        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) { continue; }

	        if (!isMergeableShorthand(right)) {
	          left.unused = true;
	          continue;
	        }

	        component = findComponentIn(right, left);
	        mayOverride = configuration[left.name].canOverride || sameValue;
	        if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {
	          left.unused = true;
	        }
	      } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {
	        // `right` is a shorthand while `left` can be overriden by it, think `border` and `border-top`
	        if (!right.important && left.important) {
	          continue;
	        }

	        if (!sameVendorPrefixesIn([left], right.components)) {
	          continue;
	        }

	        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {
	          continue;
	        }

	        overriddenComponents = left.shorthand
	          ? left.components
	          : [left];

	        for (k = overriddenComponents.length - 1; k >= 0; k--) {
	          overriddenComponent = overriddenComponents[k];
	          overridingComponent = findComponentIn(right, overriddenComponent);
	          mayOverride = configuration[overriddenComponent.name].canOverride || sameValue;

	          if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {
	            continue traverseLoop;
	          }
	        }

	        left.unused = true;
	      } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {
	        // maybe `right` can be pulled into `left` which is a shorthand?
	        if (right.important && !left.important) { continue; }

	        if (!right.important && left.important) {
	          right.unused = true;
	          continue;
	        }

	        // Pending more clever algorithm in #527
	        if (moreSameShorthands(properties, i - 1, left.name)) { continue; }

	        if (overridingFunction(left, validator)) { continue; }

	        if (!isMergeableShorthand(left)) { continue; }

	        if (hasUnset(left) || hasUnset(right)) { continue; }

	        component = findComponentIn(left, right);
	        if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {
	          var disabledBackgroundMerging = !compatibility.properties.backgroundClipMerging && component.name.indexOf('background-clip') > -1
	            || !compatibility.properties.backgroundOriginMerging && component.name.indexOf('background-origin') > -1
	            || !compatibility.properties.backgroundSizeMerging && component.name.indexOf('background-size') > -1;
	          var nonMergeableValue = configuration[right.name].nonMergeableValue === right.value[0][1];

	          if (disabledBackgroundMerging || nonMergeableValue) { continue; }

	          if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator)) { continue; }

	          if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right))) { continue; }

	          if (wouldResultInLongerValue(left, right)) { continue; }

	          if (!left.multiplex && right.multiplex) { turnIntoMultiplex(left, multiplexSize(right)); }

	          override(component, right);
	          left.dirty = true;
	        }
	      } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {
	        // merge if all components can be merged

	        if (!left.multiplex && right.multiplex) { continue; }

	        if (!right.important && left.important) {
	          right.unused = true;
	          continue propertyLoop;
	        }

	        if (right.important && !left.important) {
	          left.unused = true;
	          continue;
	        }

	        if (!isMergeableShorthand(right)) {
	          left.unused = true;
	          continue;
	        }

	        for (k = left.components.length - 1; k >= 0; k--) {
	          var leftComponent = left.components[k];
	          var rightComponent = right.components[k];

	          mayOverride = configuration[leftComponent.name].canOverride || sameValue;
	          if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent)) {
	            continue propertyLoop;
	          }
	        }

	        overrideShorthand(left, right);
	        left.dirty = true;
	      } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {
	        // border is a shorthand but any of its components is a shorthand too

	        if (!left.important && right.important) { continue; }

	        component = findComponentIn(left, right);
	        mayOverride = configuration[right.name].canOverride || sameValue;
	        if (!everyValuesPair(mayOverride.bind(null, validator), component, right)) { continue; }

	        if (left.important && !right.important) {
	          right.unused = true;
	          continue;
	        }

	        var rightRestored = configuration[right.name].restore(right, configuration);
	        if (rightRestored.length > 1) { continue; }

	        component = findComponentIn(left, right);
	        override(component, right);
	        right.dirty = true;
	      } else if (left.name == right.name) {
	        // two non-shorthands should be merged based on understandability
	        overridable = true;

	        if (right.shorthand) {
	          for (k = right.components.length - 1; k >= 0 && overridable; k--) {
	            overriddenComponent = left.components[k];
	            overridingComponent = right.components[k];
	            mayOverride = configuration[overridingComponent.name].canOverride || sameValue;

	            overridable = everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);
	          }
	        } else {
	          mayOverride = configuration[right.name].canOverride || sameValue;
	          overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);
	        }

	        if (left.important && !right.important && overridable) {
	          right.unused = true;
	          continue;
	        }

	        if (!left.important && right.important && overridable) {
	          left.unused = true;
	          continue;
	        }

	        if (!overridable) {
	          continue;
	        }

	        left.unused = true;
	      }
	    }
	  }
	}

	overrideProperties_1 = overrideProperties;
	return overrideProperties_1;
}

var optimize$1;
var hasRequiredOptimize$1;

function requireOptimize$1 () {
	if (hasRequiredOptimize$1) return optimize$1;
	hasRequiredOptimize$1 = 1;
	var mergeIntoShorthands = requireMergeIntoShorthands();
	var overrideProperties = requireOverrideProperties();
	var populateComponents = requirePopulateComponents();

	var restoreWithComponents = requireRestoreWithComponents();

	var wrapForOptimizing = requireWrapForOptimizing().all;
	var removeUnused = requireRemoveUnused();
	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	function optimizeProperties(properties, withOverriding, withMerging, context) {
	  var levelOptions = context.options.level[OptimizationLevel.Two];
	  var _properties = wrapForOptimizing(properties, levelOptions.skipProperties);
	  var _property;
	  var i, l;

	  populateComponents(_properties, context.validator, context.warnings);

	  for (i = 0, l = _properties.length; i < l; i++) {
	    _property = _properties[i];
	    if (_property.block) {
	      optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);
	    }
	  }

	  if (withMerging && levelOptions.mergeIntoShorthands) {
	    mergeIntoShorthands(_properties, context.validator);
	  }

	  if (withOverriding && levelOptions.overrideProperties) {
	    overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);
	  }

	  restoreFromOptimizing(_properties, restoreWithComponents);
	  removeUnused(_properties);
	}

	optimize$1 = optimizeProperties;
	return optimize$1;
}

var mergeAdjacent_1;
var hasRequiredMergeAdjacent;

function requireMergeAdjacent () {
	if (hasRequiredMergeAdjacent) return mergeAdjacent_1;
	hasRequiredMergeAdjacent = 1;
	var isMergeable = requireIsMergeable();

	var optimizeProperties = requireOptimize$1();

	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function mergeAdjacent(tokens, context) {
	  var lastToken = [null, [], []];
	  var options = context.options;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var mergeLimit = options.compatibility.selectors.mergeLimit;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] != Token.RULE) {
	      lastToken = [null, [], []];
	      continue;
	    }

	    if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {
	      Array.prototype.push.apply(lastToken[2], token[2]);
	      optimizeProperties(lastToken[2], true, true, context);
	      token[2] = [];
	    } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2])
	        && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)
	        && isMergeable(
	          serializeRules(lastToken[1]),
	          mergeablePseudoClasses,
	          mergeablePseudoElements,
	          multiplePseudoMerging
	        )
	        && lastToken[1].length < mergeLimit) {
	      lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
	      lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];
	      token[2] = [];
	    } else {
	      lastToken = token;
	    }
	  }
	}

	mergeAdjacent_1 = mergeAdjacent;
	return mergeAdjacent_1;
}

var rulesOverlap_1;
var hasRequiredRulesOverlap;

function requireRulesOverlap () {
	if (hasRequiredRulesOverlap) return rulesOverlap_1;
	hasRequiredRulesOverlap = 1;
	var MODIFIER_PATTERN = /--.+$/;

	function rulesOverlap(rule1, rule2, bemMode) {
	  var scope1;
	  var scope2;
	  var i, l;
	  var j, m;

	  for (i = 0, l = rule1.length; i < l; i++) {
	    scope1 = rule1[i][1];

	    for (j = 0, m = rule2.length; j < m; j++) {
	      scope2 = rule2[j][1];

	      if (scope1 == scope2) {
	        return true;
	      }

	      if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function withoutModifiers(scope) {
	  return scope.replace(MODIFIER_PATTERN, '');
	}

	rulesOverlap_1 = rulesOverlap;
	return rulesOverlap_1;
}

var specificity_1;
var hasRequiredSpecificity;

function requireSpecificity () {
	if (hasRequiredSpecificity) return specificity_1;
	hasRequiredSpecificity = 1;
	var Marker = requireMarker();

	var Selector = {
	  ADJACENT_SIBLING: '+',
	  DESCENDANT: '>',
	  DOT: '.',
	  HASH: '#',
	  NON_ADJACENT_SIBLING: '~',
	  PSEUDO: ':'
	};

	var LETTER_PATTERN = /[a-zA-Z]/;
	var NOT_PREFIX = ':not(';
	var SEPARATOR_PATTERN = /[\s,(>~+]/;

	function specificity(selector) {
	  var result = [0, 0, 0];
	  var character;
	  var isEscaped;
	  var isSingleQuoted;
	  var isDoubleQuoted;
	  var roundBracketLevel = 0;
	  var couldIntroduceNewTypeSelector;
	  var withinNotPseudoClass = false;
	  var wasPseudoClass = false;
	  var i, l;

	  for (i = 0, l = selector.length; i < l; i++) {
	    character = selector[i];

	    if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
	      isSingleQuoted = true;
	    } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {
	      isSingleQuoted = false;
	    } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
	      isDoubleQuoted = true;
	    } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {
	      isDoubleQuoted = false;
	    } else if (isSingleQuoted || isDoubleQuoted) {
	      continue;
	    } else if (roundBracketLevel > 0 && !withinNotPseudoClass) ; else if (character == Marker.OPEN_ROUND_BRACKET) {
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {
	      roundBracketLevel--;
	      withinNotPseudoClass = false;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET) {
	      roundBracketLevel--;
	    } else if (character == Selector.HASH) {
	      result[0]++;
	    } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {
	      result[1]++;
	    } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {
	      result[1]++;
	      withinNotPseudoClass = false;
	    } else if (character == Selector.PSEUDO) {
	      withinNotPseudoClass = true;
	    } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {
	      result[2]++;
	    }

	    isEscaped = character == Marker.BACK_SLASH;
	    wasPseudoClass = character == Selector.PSEUDO;
	    couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);
	  }

	  return result;
	}

	function isNotPseudoClass(selector, index) {
	  return selector.indexOf(NOT_PREFIX, index) === index;
	}

	specificity_1 = specificity;
	return specificity_1;
}

var specificitiesOverlap_1;
var hasRequiredSpecificitiesOverlap;

function requireSpecificitiesOverlap () {
	if (hasRequiredSpecificitiesOverlap) return specificitiesOverlap_1;
	hasRequiredSpecificitiesOverlap = 1;
	var specificity = requireSpecificity();

	function specificitiesOverlap(selector1, selector2, cache) {
	  var specificity1;
	  var specificity2;
	  var i, l;
	  var j, m;

	  for (i = 0, l = selector1.length; i < l; i++) {
	    specificity1 = findSpecificity(selector1[i][1], cache);

	    for (j = 0, m = selector2.length; j < m; j++) {
	      specificity2 = findSpecificity(selector2[j][1], cache);

	      if (specificity1[0] === specificity2[0]
	        && specificity1[1] === specificity2[1]
	        && specificity1[2] === specificity2[2]) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	function findSpecificity(selector, cache) {
	  var value;

	  if (!(selector in cache)) {
	    cache[selector] = value = specificity(selector);
	  }

	  return value || cache[selector];
	}

	specificitiesOverlap_1 = specificitiesOverlap;
	return specificitiesOverlap_1;
}

var reorderable;
var hasRequiredReorderable;

function requireReorderable () {
	if (hasRequiredReorderable) return reorderable;
	hasRequiredReorderable = 1;
	// TODO: it'd be great to merge it with the other canReorder functionality

	var rulesOverlap = requireRulesOverlap();
	var specificitiesOverlap = requireSpecificitiesOverlap();

	var FLEX_PROPERTIES = /align-items|box-align|box-pack|flex|justify/;
	var BORDER_PROPERTIES = /^border-(top|right|bottom|left|color|style|width|radius)/;

	function canReorder(left, right, cache) {
	  for (var i = right.length - 1; i >= 0; i--) {
	    for (var j = left.length - 1; j >= 0; j--) {
	      if (!canReorderSingle(left[j], right[i], cache)) { return false; }
	    }
	  }

	  return true;
	}

	function canReorderSingle(left, right, cache) {
	  var leftName = left[0];
	  var leftValue = left[1];
	  var leftNameRoot = left[2];
	  var leftSelector = left[5];
	  var leftInSpecificSelector = left[6];
	  var rightName = right[0];
	  var rightValue = right[1];
	  var rightNameRoot = right[2];
	  var rightSelector = right[5];
	  var rightInSpecificSelector = right[6];

	  if (leftName == 'font' && rightName == 'line-height' || rightName == 'font' && leftName == 'line-height') { return false; }
	  if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName)) { return false; }
	  if (leftNameRoot == rightNameRoot
	    && unprefixed(leftName) == unprefixed(rightName)
	    && (vendorPrefixed(leftName) ^ vendorPrefixed(rightName))) { return false; }
	  if (leftNameRoot == 'border' && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == 'border' || leftName == rightNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName)))) { return false; }
	  if (rightNameRoot == 'border' && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == 'border' || rightName == leftNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName)))) { return false; }
	  if (leftNameRoot == 'border' && rightNameRoot == 'border' && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName))) { return false; }
	  if (leftNameRoot != rightNameRoot) { return true; }
	  if (leftName == rightName
	    && leftNameRoot == rightNameRoot
	    && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue))) { return true; }
	  if (leftName != rightName
	    && leftNameRoot == rightNameRoot
	    && leftName != leftNameRoot
	    && rightName != rightNameRoot) { return true; }
	  if (leftName != rightName
	    && leftNameRoot == rightNameRoot
	    && leftValue == rightValue) { return true; }
	  if (rightInSpecificSelector
	    && leftInSpecificSelector
	    && !inheritable(leftNameRoot)
	    && !inheritable(rightNameRoot)
	    && !rulesOverlap(rightSelector, leftSelector, false)) { return true; }
	  if (!specificitiesOverlap(leftSelector, rightSelector, cache)) { return true; }

	  return false;
	}

	function vendorPrefixed(name) {
	  return /^-(?:moz|webkit|ms|o)-/.test(name);
	}

	function unprefixed(name) {
	  return name.replace(/^-(?:moz|webkit|ms|o)-/, '');
	}

	function sameBorderComponent(name1, name2) {
	  return name1.split('-').pop() == name2.split('-').pop();
	}

	function isSideBorder(name) {
	  return name == 'border-top' || name == 'border-right' || name == 'border-bottom' || name == 'border-left';
	}

	function isStyleBorder(name) {
	  return name == 'border-color' || name == 'border-style' || name == 'border-width';
	}

	function withDifferentVendorPrefix(value1, value2) {
	  return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split('-')[1] != value2.split('-')[2];
	}

	function inheritable(name) {
	  // According to http://www.w3.org/TR/CSS21/propidx.html
	  // Others will be catched by other, preceeding rules
	  return name == 'font' || name == 'line-height' || name == 'list-style';
	}

	reorderable = {
	  canReorder: canReorder,
	  canReorderSingle: canReorderSingle
	};
	return reorderable;
}

var extractProperties_1;
var hasRequiredExtractProperties;

function requireExtractProperties () {
	if (hasRequiredExtractProperties) return extractProperties_1;
	hasRequiredExtractProperties = 1;
	// This extractor is used in level 2 optimizations
	// IMPORTANT: Mind Token class and this code is not related!
	// Properties will be tokenized in one step, see #429

	var Token = requireToken();
	var serializeRules = requireOneTime().rules;
	var serializeValue = requireOneTime().value;

	function extractProperties(token) {
	  var properties = [];
	  var inSpecificSelector;
	  var property;
	  var name;
	  var value;
	  var i, l;

	  if (token[0] == Token.RULE) {
	    inSpecificSelector = !/[.+>~]/.test(serializeRules(token[1]));

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[0] != Token.PROPERTY) { continue; }

	      name = property[1][1];
	      if (name.length === 0) { continue; }

	      value = serializeValue(property, i);

	      properties.push([
	        name,
	        value,
	        findNameRoot(name),
	        token[2][i],
	        name + ':' + value,
	        token[1],
	        inSpecificSelector
	      ]);
	    }
	  } else if (token[0] == Token.NESTED_BLOCK) {
	    for (i = 0, l = token[2].length; i < l; i++) {
	      properties = properties.concat(extractProperties(token[2][i]));
	    }
	  }

	  return properties;
	}

	function findNameRoot(name) {
	  if (name == 'list-style') { return name; }
	  if (name.indexOf('-radius') > 0) { return 'border-radius'; }
	  if (name == 'border-collapse' || name == 'border-spacing' || name == 'border-image') { return name; }
	  if (name.indexOf('border-') === 0 && /^border-\w+-\w+$/.test(name)) { return name.match(/border-\w+/)[0]; }
	  if (name.indexOf('border-') === 0 && /^border-\w+$/.test(name)) { return 'border'; }
	  if (name.indexOf('text-') === 0) { return name; }
	  if (name == '-chrome-') { return name; }

	  return name.replace(/^-\w+-/, '').match(/([a-zA-Z]+)/)[0].toLowerCase();
	}

	extractProperties_1 = extractProperties;
	return extractProperties_1;
}

var mergeMediaQueries_1;
var hasRequiredMergeMediaQueries;

function requireMergeMediaQueries () {
	if (hasRequiredMergeMediaQueries) return mergeMediaQueries_1;
	hasRequiredMergeMediaQueries = 1;
	var canReorder = requireReorderable().canReorder;
	var canReorderSingle = requireReorderable().canReorderSingle;
	var extractProperties = requireExtractProperties();
	var rulesOverlap = requireRulesOverlap();

	var serializeRules = requireOneTime().rules;
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
	var Token = requireToken();

	function mergeMediaQueries(tokens, context) {
	  var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;
	  var specificityCache = context.cache.specificity;
	  var candidates = {};
	  var reduced = [];

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    if (token[0] != Token.NESTED_BLOCK) {
	      continue;
	    }

	    var key = serializeRules(token[1]);
	    var candidate = candidates[key];
	    if (!candidate) {
	      candidate = [];
	      candidates[key] = candidate;
	    }

	    candidate.push(i);
	  }

	  for (var name in candidates) {
	    var positions = candidates[name];

	    positionLoop:
	    for (var j = positions.length - 1; j > 0; j--) {
	      var positionOne = positions[j];
	      var tokenOne = tokens[positionOne];
	      var positionTwo = positions[j - 1];
	      var tokenTwo = tokens[positionTwo];

	      directionLoop:
	      for (var direction = 1; direction >= -1; direction -= 2) {
	        var topToBottom = direction == 1;
	        var from = topToBottom ? positionOne + 1 : positionTwo - 1;
	        var to = topToBottom ? positionTwo : positionOne;
	        var delta = topToBottom ? 1 : -1;
	        var source = topToBottom ? tokenOne : tokenTwo;
	        var target = topToBottom ? tokenTwo : tokenOne;
	        var movedProperties = extractProperties(source);

	        while (from != to) {
	          var traversedProperties = extractProperties(tokens[from]);
	          from += delta;

	          if (mergeSemantically
	            && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)
	          ) {
	            continue;
	          }

	          if (!canReorder(movedProperties, traversedProperties, specificityCache)) { continue directionLoop; }
	        }

	        target[2] = topToBottom
	          ? source[2].concat(target[2])
	          : target[2].concat(source[2]);
	        source[2] = [];

	        reduced.push(target);
	        continue positionLoop;
	      }
	    }
	  }

	  return reduced;
	}

	function allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache) {
	  var movedProperty;
	  var movedRule;
	  var traversedProperty;
	  var traversedRule;
	  var i, l;
	  var j, m;

	  for (i = 0, l = movedProperties.length; i < l; i++) {
	    movedProperty = movedProperties[i];
	    movedRule = movedProperty[5];

	    for (j = 0, m = traversedProperties.length; j < m; j++) {
	      traversedProperty = traversedProperties[j];
	      traversedRule = traversedProperty[5];

	      if (rulesOverlap(movedRule, traversedRule, true)
	        && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {
	        return false;
	      }
	    }
	  }

	  return true;
	}

	mergeMediaQueries_1 = mergeMediaQueries;
	return mergeMediaQueries_1;
}

var mergeNonAdjacentByBody_1;
var hasRequiredMergeNonAdjacentByBody;

function requireMergeNonAdjacentByBody () {
	if (hasRequiredMergeNonAdjacentByBody) return mergeNonAdjacentByBody_1;
	hasRequiredMergeNonAdjacentByBody = 1;
	var isMergeable = requireIsMergeable();

	var sortSelectors = requireSortSelectors();
	var tidyRules = requireTidyRules();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function unsafeSelector(value) {
	  return /\.|\*| :/.test(value);
	}

	function isBemElement(token) {
	  var asString = serializeRules(token[1]);
	  return asString.indexOf('__') > -1 || asString.indexOf('--') > -1;
	}

	function withoutModifier(selector) {
	  return selector.replace(/--[^ ,>+~:]+/g, '');
	}

	function removeAnyUnsafeElements(left, candidates) {
	  var leftSelector = withoutModifier(serializeRules(left[1]));

	  for (var body in candidates) {
	    var right = candidates[body];
	    var rightSelector = withoutModifier(serializeRules(right[1]));

	    if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1) {
	      delete candidates[body];
	    }
	  }
	}

	function mergeNonAdjacentByBody(tokens, context) {
	  var options = context.options;
	  var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;
	  var adjacentSpace = options.compatibility.selectors.adjacentSpace;
	  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var candidates = {};

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    if (token[0] != Token.RULE) { continue; }

	    if (token[2].length > 0 && (!mergeSemantically && unsafeSelector(serializeRules(token[1])))) { candidates = {}; }

	    if (token[2].length > 0 && mergeSemantically && isBemElement(token)) { removeAnyUnsafeElements(token, candidates); }

	    var candidateBody = serializeBody(token[2]);
	    var oldToken = candidates[candidateBody];
	    if (oldToken
	        && isMergeable(
	          serializeRules(token[1]),
	          mergeablePseudoClasses,
	          mergeablePseudoElements,
	          multiplePseudoMerging
	        )
	        && isMergeable(
	          serializeRules(oldToken[1]),
	          mergeablePseudoClasses,
	          mergeablePseudoElements,
	          multiplePseudoMerging
	        )
	    ) {
	      if (token[2].length > 0) {
	        token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
	        token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];
	      } else {
	        token[1] = oldToken[1].concat(token[1]);
	      }

	      oldToken[2] = [];
	      candidates[candidateBody] = null;
	    }

	    candidates[serializeBody(token[2])] = token;
	  }
	}

	mergeNonAdjacentByBody_1 = mergeNonAdjacentByBody;
	return mergeNonAdjacentByBody_1;
}

var mergeNonAdjacentBySelector_1;
var hasRequiredMergeNonAdjacentBySelector;

function requireMergeNonAdjacentBySelector () {
	if (hasRequiredMergeNonAdjacentBySelector) return mergeNonAdjacentBySelector_1;
	hasRequiredMergeNonAdjacentBySelector = 1;
	var canReorder = requireReorderable().canReorder;
	var extractProperties = requireExtractProperties();

	var optimizeProperties = requireOptimize$1();

	var serializeRules = requireOneTime().rules;

	var Token = requireToken();

	function mergeNonAdjacentBySelector(tokens, context) {
	  var specificityCache = context.cache.specificity;
	  var allSelectors = {};
	  var repeatedSelectors = [];
	  var i;

	  for (i = tokens.length - 1; i >= 0; i--) {
	    if (tokens[i][0] != Token.RULE) { continue; }
	    if (tokens[i][2].length === 0) { continue; }

	    var selector = serializeRules(tokens[i][1]);
	    allSelectors[selector] = [i].concat(allSelectors[selector] || []);

	    if (allSelectors[selector].length == 2) { repeatedSelectors.push(selector); }
	  }

	  for (i = repeatedSelectors.length - 1; i >= 0; i--) {
	    var positions = allSelectors[repeatedSelectors[i]];

	    selectorIterator:
	    for (var j = positions.length - 1; j > 0; j--) {
	      var positionOne = positions[j - 1];
	      var tokenOne = tokens[positionOne];
	      var positionTwo = positions[j];
	      var tokenTwo = tokens[positionTwo];

	      directionIterator:
	      for (var direction = 1; direction >= -1; direction -= 2) {
	        var topToBottom = direction == 1;
	        var from = topToBottom ? positionOne + 1 : positionTwo - 1;
	        var to = topToBottom ? positionTwo : positionOne;
	        var delta = topToBottom ? 1 : -1;
	        var moved = topToBottom ? tokenOne : tokenTwo;
	        var target = topToBottom ? tokenTwo : tokenOne;
	        var movedProperties = extractProperties(moved);

	        while (from != to) {
	          var traversedProperties = extractProperties(tokens[from]);
	          from += delta;

	          // traversed then moved as we move selectors towards the start
	          var reorderable = topToBottom
	            ? canReorder(movedProperties, traversedProperties, specificityCache)
	            : canReorder(traversedProperties, movedProperties, specificityCache);

	          if (!reorderable && !topToBottom) { continue selectorIterator; }
	          if (!reorderable && topToBottom) { continue directionIterator; }
	        }

	        if (topToBottom) {
	          Array.prototype.push.apply(moved[2], target[2]);
	          target[2] = moved[2];
	        } else {
	          Array.prototype.push.apply(target[2], moved[2]);
	        }

	        optimizeProperties(target[2], true, true, context);
	        moved[2] = [];
	      }
	    }
	  }
	}

	mergeNonAdjacentBySelector_1 = mergeNonAdjacentBySelector;
	return mergeNonAdjacentBySelector_1;
}

var cloneArray_1;
var hasRequiredCloneArray;

function requireCloneArray () {
	if (hasRequiredCloneArray) return cloneArray_1;
	hasRequiredCloneArray = 1;
	function cloneArray(array) {
	  var cloned = array.slice(0);

	  for (var i = 0, l = cloned.length; i < l; i++) {
	    if (Array.isArray(cloned[i])) { cloned[i] = cloneArray(cloned[i]); }
	  }

	  return cloned;
	}

	cloneArray_1 = cloneArray;
	return cloneArray_1;
}

var reduceNonAdjacent_1;
var hasRequiredReduceNonAdjacent;

function requireReduceNonAdjacent () {
	if (hasRequiredReduceNonAdjacent) return reduceNonAdjacent_1;
	hasRequiredReduceNonAdjacent = 1;
	var isMergeable = requireIsMergeable();

	var optimizeProperties = requireOptimize$1();

	var cloneArray = requireCloneArray();

	var Token = requireToken();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function reduceNonAdjacent(tokens, context) {
	  var options = context.options;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var candidates = {};
	  var repeated = [];

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];

	    if (token[0] != Token.RULE) {
	      continue;
	    } else if (token[2].length === 0) {
	      continue;
	    }

	    var selectorAsString = serializeRules(token[1]);
	    var isComplexAndNotSpecial = token[1].length > 1
	      && isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);
	    var wrappedSelectors = wrappedSelectorsFrom(token[1]);
	    var selectors = isComplexAndNotSpecial
	      ? [selectorAsString].concat(wrappedSelectors)
	      : [selectorAsString];

	    for (var j = 0, m = selectors.length; j < m; j++) {
	      var selector = selectors[j];

	      if (!candidates[selector]) { candidates[selector] = []; } else { repeated.push(selector); }

	      candidates[selector].push({
	        where: i,
	        list: wrappedSelectors,
	        isPartial: isComplexAndNotSpecial && j > 0,
	        isComplex: isComplexAndNotSpecial && j === 0
	      });
	    }
	  }

	  reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);
	  reduceComplexNonAdjacentCases(tokens, candidates, options, context);
	}

	function wrappedSelectorsFrom(list) {
	  var wrapped = [];

	  for (var i = 0; i < list.length; i++) {
	    wrapped.push([list[i][1]]);
	  }

	  return wrapped;
	}

	function reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context) {
	  function filterOut(idx, bodies) {
	    return data[idx].isPartial && bodies.length === 0;
	  }

	  function reduceBody(token, newBody, processedCount, tokenIdx) {
	    if (!data[processedCount - tokenIdx - 1].isPartial) { token[2] = newBody; }
	  }

	  for (var i = 0, l = repeated.length; i < l; i++) {
	    var selector = repeated[i];
	    var data = candidates[selector];

	    reduceSelector(tokens, data, {
	      filterOut: filterOut,
	      callback: reduceBody
	    }, options, context);
	  }
	}

	function reduceComplexNonAdjacentCases(tokens, candidates, options, context) {
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var localContext = {};

	  function filterOut(idx) {
	    return localContext.data[idx].where < localContext.intoPosition;
	  }

	  function collectReducedBodies(token, newBody, processedCount, tokenIdx) {
	    if (tokenIdx === 0) { localContext.reducedBodies.push(newBody); }
	  }

	  allSelectors:
	  for (var complexSelector in candidates) {
	    var into = candidates[complexSelector];
	    if (!into[0].isComplex) { continue; }

	    var intoPosition = into[into.length - 1].where;
	    var intoToken = tokens[intoPosition];
	    var reducedBodies = [];

	    var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)
	      ? into[0].list
	      : [complexSelector];

	    localContext.intoPosition = intoPosition;
	    localContext.reducedBodies = reducedBodies;

	    for (var j = 0, m = selectors.length; j < m; j++) {
	      var selector = selectors[j];
	      var data = candidates[selector];

	      if (data.length < 2) { continue allSelectors; }

	      localContext.data = data;

	      reduceSelector(tokens, data, {
	        filterOut: filterOut,
	        callback: collectReducedBodies
	      }, options, context);

	      if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0])) {
	        continue allSelectors;
	      }
	    }

	    intoToken[2] = reducedBodies[0];
	  }
	}

	function reduceSelector(tokens, data, context, options, outerContext) {
	  var bodies = [];
	  var bodiesAsList = [];
	  var processedTokens = [];

	  for (var j = data.length - 1; j >= 0; j--) {
	    if (context.filterOut(j, bodies)) { continue; }

	    var where = data[j].where;
	    var token = tokens[where];
	    var clonedBody = cloneArray(token[2]);

	    bodies = bodies.concat(clonedBody);
	    bodiesAsList.push(clonedBody);
	    processedTokens.push(where);
	  }

	  optimizeProperties(bodies, true, false, outerContext);

	  var processedCount = processedTokens.length;
	  var propertyIdx = bodies.length - 1;
	  var tokenIdx = processedCount - 1;

	  while (tokenIdx >= 0) {
	    if ((tokenIdx === 0
	      || (bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1)) && propertyIdx > -1) {
	      propertyIdx--;
	      continue;
	    }

	    var newBody = bodies.splice(propertyIdx + 1);
	    context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);

	    tokenIdx--;
	  }
	}

	reduceNonAdjacent_1 = reduceNonAdjacent;
	return reduceNonAdjacent_1;
}

var removeDuplicateFontAtRules_1;
var hasRequiredRemoveDuplicateFontAtRules;

function requireRemoveDuplicateFontAtRules () {
	if (hasRequiredRemoveDuplicateFontAtRules) return removeDuplicateFontAtRules_1;
	hasRequiredRemoveDuplicateFontAtRules = 1;
	var Token = requireToken();

	var serializeAll = requireOneTime().all;

	var FONT_FACE_SCOPE = '@font-face';

	function removeDuplicateFontAtRules(tokens) {
	  var fontAtRules = [];
	  var token;
	  var key;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {
	      continue;
	    }

	    key = serializeAll([token]);

	    if (fontAtRules.indexOf(key) > -1) {
	      token[2] = [];
	    } else {
	      fontAtRules.push(key);
	    }
	  }
	}

	removeDuplicateFontAtRules_1 = removeDuplicateFontAtRules;
	return removeDuplicateFontAtRules_1;
}

var removeDuplicateMediaQueries_1;
var hasRequiredRemoveDuplicateMediaQueries;

function requireRemoveDuplicateMediaQueries () {
	if (hasRequiredRemoveDuplicateMediaQueries) return removeDuplicateMediaQueries_1;
	hasRequiredRemoveDuplicateMediaQueries = 1;
	var Token = requireToken();

	var serializeAll = requireOneTime().all;
	var serializeRules = requireOneTime().rules;

	function removeDuplicateMediaQueries(tokens) {
	  var candidates = {};
	  var candidate;
	  var token;
	  var key;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    if (token[0] != Token.NESTED_BLOCK) {
	      continue;
	    }

	    key = serializeRules(token[1]) + '%' + serializeAll(token[2]);
	    candidate = candidates[key];

	    if (candidate) {
	      candidate[2] = [];
	    }

	    candidates[key] = token;
	  }
	}

	removeDuplicateMediaQueries_1 = removeDuplicateMediaQueries;
	return removeDuplicateMediaQueries_1;
}

var removeDuplicates_1;
var hasRequiredRemoveDuplicates;

function requireRemoveDuplicates () {
	if (hasRequiredRemoveDuplicates) return removeDuplicates_1;
	hasRequiredRemoveDuplicates = 1;
	var Token = requireToken();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function removeDuplicates(tokens) {
	  var matched = {};
	  var moreThanOnce = [];
	  var id, token;
	  var body, bodies;

	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    if (token[0] != Token.RULE) { continue; }

	    id = serializeRules(token[1]);

	    if (matched[id] && matched[id].length == 1) { moreThanOnce.push(id); } else { matched[id] = matched[id] || []; }

	    matched[id].push(i);
	  }

	  for (i = 0, l = moreThanOnce.length; i < l; i++) {
	    id = moreThanOnce[i];
	    bodies = [];

	    for (var j = matched[id].length - 1; j >= 0; j--) {
	      token = tokens[matched[id][j]];
	      body = serializeBody(token[2]);

	      if (bodies.indexOf(body) > -1) { token[2] = []; } else { bodies.push(body); }
	    }
	  }
	}

	removeDuplicates_1 = removeDuplicates;
	return removeDuplicates_1;
}

var removeUnusedAtRules_1;
var hasRequiredRemoveUnusedAtRules;

function requireRemoveUnusedAtRules () {
	if (hasRequiredRemoveUnusedAtRules) return removeUnusedAtRules_1;
	hasRequiredRemoveUnusedAtRules = 1;
	var populateComponents = requirePopulateComponents();

	var wrapForOptimizing = requireWrapForOptimizing().single;
	var restoreFromOptimizing = requireRestoreFromOptimizing();

	var Token = requireToken();

	var animationNameRegex = /^(-moz-|-o-|-webkit-)?animation-name$/;
	var animationRegex = /^(-moz-|-o-|-webkit-)?animation$/;
	var keyframeRegex = /^@(-moz-|-o-|-webkit-)?keyframes /;
	var importantRegex = /\s{0,31}!important$/;
	var optionalMatchingQuotesRegex = /^(['"]?)(.*)\1$/;

	function normalize(value) {
	  return value
	    .replace(optionalMatchingQuotesRegex, '$2')
	    .replace(importantRegex, '');
	}

	function removeUnusedAtRules(tokens, context) {
	  removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);
	  removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);
	  removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);
	  removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);
	}

	function removeUnusedAtRule(tokens, matchCallback, markCallback, context) {
	  var atRules = {};
	  var atRule;
	  var atRuleTokens;
	  var atRuleToken;
	  var zeroAt;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    matchCallback(tokens[i], atRules);
	  }

	  if (Object.keys(atRules).length === 0) {
	    return;
	  }

	  markUsedAtRules(tokens, markCallback, atRules, context);

	  for (atRule in atRules) {
	    atRuleTokens = atRules[atRule];

	    for (i = 0, l = atRuleTokens.length; i < l; i++) {
	      atRuleToken = atRuleTokens[i];
	      zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;
	      atRuleToken[zeroAt] = [];
	    }
	  }
	}

	function markUsedAtRules(tokens, markCallback, atRules, context) {
	  var boundMarkCallback = markCallback(atRules);
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    switch (tokens[i][0]) {
	    case Token.RULE:
	      boundMarkCallback(tokens[i], context);
	      break;
	    case Token.NESTED_BLOCK:
	      markUsedAtRules(tokens[i][2], markCallback, atRules, context);
	    }
	  }
	}

	function matchCounterStyle(token, atRules) {
	  var match;

	  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf('@counter-style') === 0) {
	    match = token[1][0][1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markCounterStylesAsUsed(atRules) {
	  return function(token, context) {
	    var property;
	    var wrappedProperty;
	    var i, l;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'list-style') {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);

	        if (wrappedProperty.components[0].value[0][1] in atRules) {
	          delete atRules[property[2][1]];
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (property[1][1] == 'list-style-type' && property[2][1] in atRules) {
	        delete atRules[property[2][1]];
	      }
	    }
	  };
	}

	function matchFontFace(token, atRules) {
	  var property;
	  var match;
	  var i, l;

	  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == '@font-face') {
	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'font-family') {
	        match = normalize(property[2][1].toLowerCase());
	        atRules[match] = atRules[match] || [];
	        atRules[match].push(token);
	        break;
	      }
	    }
	  }
	}

	function markFontFacesAsUsed(atRules) {
	  return function(token, context) {
	    var property;
	    var wrappedProperty;
	    var component;
	    var normalizedMatch;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (property[1][1] == 'font') {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);
	        component = wrappedProperty.components[6];

	        for (j = 0, m = component.value.length; j < m; j++) {
	          normalizedMatch = normalize(component.value[j][1].toLowerCase());

	          if (normalizedMatch in atRules) {
	            delete atRules[normalizedMatch];
	          }
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (property[1][1] == 'font-family') {
	        for (j = 2, m = property.length; j < m; j++) {
	          normalizedMatch = normalize(property[j][1].toLowerCase());

	          if (normalizedMatch in atRules) {
	            delete atRules[normalizedMatch];
	          }
	        }
	      }
	    }
	  };
	}

	function matchKeyframe(token, atRules) {
	  var match;

	  if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {
	    match = token[1][0][1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markKeyframesAsUsed(atRules) {
	  return function(token, context) {
	    var property;
	    var wrappedProperty;
	    var component;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[2].length; i < l; i++) {
	      property = token[2][i];

	      if (animationRegex.test(property[1][1])) {
	        wrappedProperty = wrapForOptimizing(property);
	        populateComponents([wrappedProperty], context.validator, context.warnings);
	        component = wrappedProperty.components[7];

	        for (j = 0, m = component.value.length; j < m; j++) {
	          if (component.value[j][1] in atRules) {
	            delete atRules[component.value[j][1]];
	          }
	        }

	        restoreFromOptimizing([wrappedProperty]);
	      }

	      if (animationNameRegex.test(property[1][1])) {
	        for (j = 2, m = property.length; j < m; j++) {
	          if (property[j][1] in atRules) {
	            delete atRules[property[j][1]];
	          }
	        }
	      }
	    }
	  };
	}

	function matchNamespace(token, atRules) {
	  var match;

	  if (token[0] == Token.AT_RULE && token[1].indexOf('@namespace') === 0) {
	    match = token[1].split(' ')[1];
	    atRules[match] = atRules[match] || [];
	    atRules[match].push(token);
	  }
	}

	function markNamespacesAsUsed(atRules) {
	  var namespaceRegex = new RegExp(Object.keys(atRules).join('\\||') + '\\|', 'g');

	  return function(token) {
	    var match;
	    var scope;
	    var normalizedMatch;
	    var i, l;
	    var j, m;

	    for (i = 0, l = token[1].length; i < l; i++) {
	      scope = token[1][i];
	      match = scope[1].match(namespaceRegex);

	      for (j = 0, m = match.length; j < m; j++) {
	        normalizedMatch = match[j].substring(0, match[j].length - 1);

	        if (normalizedMatch in atRules) {
	          delete atRules[normalizedMatch];
	        }
	      }
	    }
	  };
	}

	removeUnusedAtRules_1 = removeUnusedAtRules;
	return removeUnusedAtRules_1;
}

var tidyRuleDuplicates_1;
var hasRequiredTidyRuleDuplicates;

function requireTidyRuleDuplicates () {
	if (hasRequiredTidyRuleDuplicates) return tidyRuleDuplicates_1;
	hasRequiredTidyRuleDuplicates = 1;
	function ruleSorter(s1, s2) {
	  return s1[1] > s2[1] ? 1 : -1;
	}

	function tidyRuleDuplicates(rules) {
	  var list = [];
	  var repeated = [];

	  for (var i = 0, l = rules.length; i < l; i++) {
	    var rule = rules[i];

	    if (repeated.indexOf(rule[1]) == -1) {
	      repeated.push(rule[1]);
	      list.push(rule);
	    }
	  }

	  return list.sort(ruleSorter);
	}

	tidyRuleDuplicates_1 = tidyRuleDuplicates;
	return tidyRuleDuplicates_1;
}

var restructure_1;
var hasRequiredRestructure;

function requireRestructure () {
	if (hasRequiredRestructure) return restructure_1;
	hasRequiredRestructure = 1;
	var canReorderSingle = requireReorderable().canReorderSingle;
	var extractProperties = requireExtractProperties();
	var isMergeable = requireIsMergeable();
	var tidyRuleDuplicates = requireTidyRuleDuplicates();

	var Token = requireToken();

	var cloneArray = requireCloneArray();

	var serializeBody = requireOneTime().body;
	var serializeRules = requireOneTime().rules;

	function naturalSorter(a, b) {
	  return a > b ? 1 : -1;
	}

	function cloneAndMergeSelectors(propertyA, propertyB) {
	  var cloned = cloneArray(propertyA);
	  cloned[5] = cloned[5].concat(propertyB[5]);

	  return cloned;
	}

	function restructure(tokens, context) {
	  var options = context.options;
	  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
	  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
	  var mergeLimit = options.compatibility.selectors.mergeLimit;
	  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
	  var specificityCache = context.cache.specificity;
	  var movableTokens = {};
	  var movedProperties = [];
	  var multiPropertyMoveCache = {};
	  var movedToBeDropped = [];
	  var maxCombinationsLevel = 2;
	  var ID_JOIN_CHARACTER = '%';

	  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {
	    for (var i = allFits.length - 1; i >= 0; i--) {
	      var fit = allFits[i][0];
	      var id = addToCache(movedProperty, fit);

	      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {
	        removeAllMatchingFromCache(id);
	        break;
	      }
	    }
	  }

	  function addToCache(movedProperty, fit) {
	    var id = cacheId(fit);
	    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];
	    multiPropertyMoveCache[id].push([movedProperty, fit]);
	    return id;
	  }

	  function removeAllMatchingFromCache(matchId) {
	    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);
	    var forRemoval = [];
	    var i;

	    for (var id in multiPropertyMoveCache) {
	      var selectors = id.split(ID_JOIN_CHARACTER);
	      for (i = selectors.length - 1; i >= 0; i--) {
	        if (matchSelectors.indexOf(selectors[i]) > -1) {
	          forRemoval.push(id);
	          break;
	        }
	      }
	    }

	    for (i = forRemoval.length - 1; i >= 0; i--) {
	      delete multiPropertyMoveCache[forRemoval[i]];
	    }
	  }

	  function cacheId(cachedTokens) {
	    var id = [];
	    for (var i = 0, l = cachedTokens.length; i < l; i++) {
	      id.push(serializeRules(cachedTokens[i][1]));
	    }
	    return id.join(ID_JOIN_CHARACTER);
	  }

	  function tokensToMerge(sourceTokens) {
	    var uniqueTokensWithBody = [];
	    var mergeableTokens = [];

	    for (var i = sourceTokens.length - 1; i >= 0; i--) {
	      if (!isMergeable(
	        serializeRules(sourceTokens[i][1]),
	        mergeablePseudoClasses,
	        mergeablePseudoElements,
	        multiplePseudoMerging
	      )) {
	        continue;
	      }

	      mergeableTokens.unshift(sourceTokens[i]);
	      if (sourceTokens[i][2].length > 0
	        && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1) {
	        uniqueTokensWithBody.push(sourceTokens[i]);
	      }
	    }

	    return uniqueTokensWithBody.length > 1
	      ? mergeableTokens
	      : [];
	  }

	  function shortenIfPossible(position, movedProperty) {
	    var name = movedProperty[0];
	    var value = movedProperty[1];
	    var key = movedProperty[4];
	    var valueSize = name.length + value.length + 1;
	    var allSelectors = [];
	    var qualifiedTokens = [];

	    var mergeableTokens = tokensToMerge(movableTokens[key]);
	    if (mergeableTokens.length < 2) { return; }

	    var allFits = findAllFits(mergeableTokens, valueSize, 1);
	    var bestFit = allFits[0];
	    if (bestFit[1] > 0) { return sendToMultiPropertyMoveCache(position, movedProperty, allFits); }

	    for (var i = bestFit[0].length - 1; i >= 0; i--) {
	      allSelectors = bestFit[0][i][1].concat(allSelectors);
	      qualifiedTokens.unshift(bestFit[0][i]);
	    }

	    allSelectors = tidyRuleDuplicates(allSelectors);
	    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);
	  }

	  function fitSorter(fit1, fit2) {
	    return fit1[1] > fit2[1] ? 1 : (fit1[1] == fit2[1] ? 0 : -1);
	  }

	  function findAllFits(mergeableTokens, propertySize, propertiesCount) {
	    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);
	    return combinations.sort(fitSorter);
	  }

	  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {
	    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];
	    if (tokensVariant.length > 2 && level > 0) {
	      for (var i = tokensVariant.length - 1; i >= 0; i--) {
	        var subVariant = Array.prototype.slice.call(tokensVariant, 0);
	        subVariant.splice(i, 1);
	        differenceVariants = differenceVariants.concat(
	          allCombinations(subVariant, propertySize, propertiesCount, level - 1)
	        );
	      }
	    }

	    return differenceVariants;
	  }

	  function sizeDifference(tokensVariant, propertySize, propertiesCount) {
	    var allSelectorsSize = 0;
	    for (var i = tokensVariant.length - 1; i >= 0; i--) {
	      allSelectorsSize += tokensVariant[i][2].length > propertiesCount
	        ? serializeRules(tokensVariant[i][1]).length
	        : -1;
	    }
	    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;
	  }

	  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {
	    var i, j, k, m;
	    var allProperties = [];

	    for (i = mergeableTokens.length - 1; i >= 0; i--) {
	      var mergeableToken = mergeableTokens[i];

	      for (j = mergeableToken[2].length - 1; j >= 0; j--) {
	        var mergeableProperty = mergeableToken[2][j];

	        for (k = 0, m = properties.length; k < m; k++) {
	          var property = properties[k];

	          var mergeablePropertyName = mergeableProperty[1][1];
	          var propertyName = property[0];
	          var propertyBody = property[4];
	          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {
	            mergeableToken[2].splice(j, 1);
	            break;
	          }
	        }
	      }
	    }

	    for (i = properties.length - 1; i >= 0; i--) {
	      allProperties.unshift(properties[i][3]);
	    }

	    var newToken = [Token.RULE, allSelectors, allProperties];
	    tokens.splice(position, 0, newToken);
	  }

	  function dropPropertiesAt(position, movedProperty) {
	    var key = movedProperty[4];
	    var toMove = movableTokens[key];

	    if (toMove && toMove.length > 1) {
	      if (!shortenMultiMovesIfPossible(position, movedProperty)) { shortenIfPossible(position, movedProperty); }
	    }
	  }

	  function shortenMultiMovesIfPossible(position, movedProperty) {
	    var candidates = [];
	    var propertiesAndMergableTokens = [];
	    var key = movedProperty[4];
	    var j, k;

	    var mergeableTokens = tokensToMerge(movableTokens[key]);
	    if (mergeableTokens.length < 2) { return; }

	    movableLoop:
	    for (var value in movableTokens) {
	      var tokensList = movableTokens[value];

	      for (j = mergeableTokens.length - 1; j >= 0; j--) {
	        if (tokensList.indexOf(mergeableTokens[j]) == -1) { continue movableLoop; }
	      }

	      candidates.push(value);
	    }

	    if (candidates.length < 2) { return false; }

	    for (j = candidates.length - 1; j >= 0; j--) {
	      for (k = movedProperties.length - 1; k >= 0; k--) {
	        if (movedProperties[k][4] == candidates[j]) {
	          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);
	          break;
	        }
	      }
	    }

	    return processMultiPropertyMove(position, propertiesAndMergableTokens);
	  }

	  function processMultiPropertyMove(position, propertiesAndMergableTokens) {
	    var valueSize = 0;
	    var properties = [];
	    var property;

	    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {
	      property = propertiesAndMergableTokens[i][0];
	      var fullValue = property[4];
	      valueSize += fullValue.length + (i > 0 ? 1 : 0);

	      properties.push(property);
	    }

	    var mergeableTokens = propertiesAndMergableTokens[0][1];
	    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];
	    if (bestFit[1] > 0) { return false; }

	    var allSelectors = [];
	    var qualifiedTokens = [];
	    for (i = bestFit[0].length - 1; i >= 0; i--) {
	      allSelectors = bestFit[0][i][1].concat(allSelectors);
	      qualifiedTokens.unshift(bestFit[0][i]);
	    }

	    allSelectors = tidyRuleDuplicates(allSelectors);
	    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);

	    for (i = properties.length - 1; i >= 0; i--) {
	      property = properties[i];
	      var index = movedProperties.indexOf(property);

	      delete movableTokens[property[4]];

	      if (index > -1 && movedToBeDropped.indexOf(index) == -1) { movedToBeDropped.push(index); }
	    }

	    return true;
	  }

	  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {
	    var propertyName = property[0];
	    var movedPropertyName = movedProperty[0];
	    if (propertyName != movedPropertyName) { return false; }

	    var key = movedProperty[4];
	    var toMove = movableTokens[key];
	    return toMove && toMove.indexOf(token) > -1;
	  }

	  for (var i = tokens.length - 1; i >= 0; i--) {
	    var token = tokens[i];
	    var isRule;
	    var j, k, m;
	    var samePropertyAt;

	    if (token[0] == Token.RULE) {
	      isRule = true;
	    } else if (token[0] == Token.NESTED_BLOCK) {
	      isRule = false;
	    } else {
	      continue;
	    }

	    // We cache movedProperties.length as it may change in the loop
	    var movedCount = movedProperties.length;

	    var properties = extractProperties(token);
	    movedToBeDropped = [];

	    var unmovableInCurrentToken = [];
	    for (j = properties.length - 1; j >= 0; j--) {
	      for (k = j - 1; k >= 0; k--) {
	        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {
	          unmovableInCurrentToken.push(j);
	          break;
	        }
	      }
	    }

	    for (j = properties.length - 1; j >= 0; j--) {
	      var property = properties[j];
	      var movedSameProperty = false;

	      for (k = 0; k < movedCount; k++) {
	        var movedProperty = movedProperties[k];

	        if (movedToBeDropped.indexOf(k) == -1 && (
	          !canReorderSingle(property, movedProperty, specificityCache)
	          && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token)
	          || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)
	        ) {
	          dropPropertiesAt(i + 1, movedProperty);

	          if (movedToBeDropped.indexOf(k) == -1) {
	            movedToBeDropped.push(k);
	            delete movableTokens[movedProperty[4]];
	          }
	        }

	        if (!movedSameProperty) {
	          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];

	          if (movedSameProperty) {
	            samePropertyAt = k;
	          }
	        }
	      }

	      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1) { continue; }

	      var key = property[4];

	      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {
	        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);
	        movedProperties.splice(samePropertyAt, 1);
	        movableTokens[key] = [token];
	        movedSameProperty = false;
	      } else {
	        movableTokens[key] = movableTokens[key] || [];
	        movableTokens[key].push(token);
	      }

	      if (movedSameProperty) {
	        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);
	      } else {
	        movedProperties.push(property);
	      }
	    }

	    movedToBeDropped = movedToBeDropped.sort(naturalSorter);
	    for (j = 0, m = movedToBeDropped.length; j < m; j++) {
	      var dropAt = movedToBeDropped[j] - j;
	      movedProperties.splice(dropAt, 1);
	    }
	  }

	  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;
	  for (; position < tokens.length - 1; position++) {
	    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;
	    var isComment = tokens[position][0] === Token.COMMENT;
	    if (!(isImportRule || isComment)) { break; }
	  }

	  for (i = 0; i < movedProperties.length; i++) {
	    dropPropertiesAt(position, movedProperties[i]);
	  }
	}

	restructure_1 = restructure;
	return restructure_1;
}

var optimize;
var hasRequiredOptimize;

function requireOptimize () {
	if (hasRequiredOptimize) return optimize;
	hasRequiredOptimize = 1;
	var mergeAdjacent = requireMergeAdjacent();
	var mergeMediaQueries = requireMergeMediaQueries();
	var mergeNonAdjacentByBody = requireMergeNonAdjacentByBody();
	var mergeNonAdjacentBySelector = requireMergeNonAdjacentBySelector();
	var reduceNonAdjacent = requireReduceNonAdjacent();
	var removeDuplicateFontAtRules = requireRemoveDuplicateFontAtRules();
	var removeDuplicateMediaQueries = requireRemoveDuplicateMediaQueries();
	var removeDuplicates = requireRemoveDuplicates();
	var removeUnusedAtRules = requireRemoveUnusedAtRules();
	var restructure = requireRestructure();

	var optimizeProperties = requireOptimize$1();

	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;

	var Token = requireToken();

	function removeEmpty(tokens) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];
	    var isEmpty = false;

	    switch (token[0]) {
	    case Token.RULE:
	      isEmpty = token[1].length === 0 || token[2].length === 0;
	      break;
	    case Token.NESTED_BLOCK:
	      removeEmpty(token[2]);
	      isEmpty = token[2].length === 0;
	      break;
	    case Token.AT_RULE:
	      isEmpty = token[1].length === 0;
	      break;
	    case Token.AT_RULE_BLOCK:
	      isEmpty = token[2].length === 0;
	    }

	    if (isEmpty) {
	      tokens.splice(i, 1);
	      i--;
	      l--;
	    }
	  }
	}

	function recursivelyOptimizeBlocks(tokens, context) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    if (token[0] == Token.NESTED_BLOCK) {
	      var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);
	      level2Optimize(token[2], context, !isKeyframes);
	    }
	  }
	}

	function recursivelyOptimizeProperties(tokens, context) {
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    var token = tokens[i];

	    switch (token[0]) {
	    case Token.RULE:
	      optimizeProperties(token[2], true, true, context);
	      break;
	    case Token.NESTED_BLOCK:
	      recursivelyOptimizeProperties(token[2], context);
	    }
	  }
	}

	function level2Optimize(tokens, context, withRestructuring) {
	  var levelOptions = context.options.level[OptimizationLevel.Two];
	  var level2Plugins = context.options.plugins.level2Block;
	  var reduced;
	  var i;

	  recursivelyOptimizeBlocks(tokens, context);
	  recursivelyOptimizeProperties(tokens, context);

	  if (levelOptions.removeDuplicateRules) {
	    removeDuplicates(tokens, context);
	  }

	  if (levelOptions.mergeAdjacentRules) {
	    mergeAdjacent(tokens, context);
	  }

	  if (levelOptions.reduceNonAdjacentRules) {
	    reduceNonAdjacent(tokens, context);
	  }

	  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'body') {
	    mergeNonAdjacentBySelector(tokens, context);
	  }

	  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'selector') {
	    mergeNonAdjacentByBody(tokens, context);
	  }

	  if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {
	    restructure(tokens, context);
	    mergeAdjacent(tokens, context);
	  }

	  if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {
	    restructure(tokens, context);
	  }

	  if (levelOptions.removeDuplicateFontRules) {
	    removeDuplicateFontAtRules(tokens, context);
	  }

	  if (levelOptions.removeDuplicateMediaBlocks) {
	    removeDuplicateMediaQueries(tokens, context);
	  }

	  if (levelOptions.removeUnusedAtRules) {
	    removeUnusedAtRules(tokens, context);
	  }

	  if (levelOptions.mergeMedia) {
	    reduced = mergeMediaQueries(tokens, context);
	    for (i = reduced.length - 1; i >= 0; i--) {
	      level2Optimize(reduced[i][2], context, false);
	    }
	  }

	  for (i = 0; i < level2Plugins.length; i++) {
	    level2Plugins[i](tokens);
	  }

	  if (levelOptions.removeEmpty) {
	    removeEmpty(tokens);
	  }

	  return tokens;
	}

	optimize = level2Optimize;
	return optimize;
}

var validator_1;
var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator_1;
	hasRequiredValidator = 1;
	var functionNoVendorRegexStr = '[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)';
	var functionVendorRegexStr = '\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)';
	var variableRegexStr = 'var\\(\\-\\-[^\\)]+\\)';
	var functionAnyRegexStr = '(' + variableRegexStr + '|' + functionNoVendorRegexStr + '|' + functionVendorRegexStr + ')';

	var calcRegex = new RegExp('^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$', 'i');
	var decimalRegex = /[0-9]/;
	var functionAnyRegex = new RegExp('^' + functionAnyRegexStr + '$', 'i');
	var hexAlphaColorRegex = /^#(?:[0-9a-f]{4}|[0-9a-f]{8})$/i;
	// eslint-disable-next-line max-len
	var hslColorRegex = /^hsl\(\s{0,31}[-.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[-.]?\d+\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\d*\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/;
	// eslint-disable-next-line max-len
	var hslColorWithSpacesRegex = /^hsl\(\s{0,31}[-.]?\d+(deg)?\s{1,31}\d*\.?\d+%\s{1,31}\d*\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[-.]?\d+(deg)?\s{1,31}\d*\.?\d+%\s{1,31}\d*\.?\d+%\s{1,31}\/\s{1,31}\d*\.?\d+%?\s{0,31}\)$/;
	var identifierRegex = /^(-[a-z0-9_][a-z0-9\-_]*|[a-z_][a-z0-9\-_]*)$/i;
	var namedEntityRegex = /^[a-z]+$/i;
	var prefixRegex = /^-([a-z0-9]|-)*$/i;
	var quotedTextRegex = /^("[^"]*"|'[^']*')$/i;
	// eslint-disable-next-line max-len
	var rgbColorRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[.\d]+\s{0,31}\)$/i;
	// eslint-disable-next-line max-len
	var rgbColorWithSpacesRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}[\d]{1,3}\s{1,31}\/\s{1,31}[\d]*\.?[.\d]+%?\s{0,31}\)$/i;
	var timeUnitPattern = /\d+(s|ms)/;
	var timingFunctionRegex = /^(cubic-bezier|steps)\([^)]+\)$/;
	var validTimeUnits = ['ms', 's'];
	var urlRegex = /^url\([\s\S]+\)$/i;
	var variableRegex = new RegExp('^' + variableRegexStr + '$', 'i');

	var eightValueColorRegex = /^#[0-9a-f]{8}$/i;
	var fourValueColorRegex = /^#[0-9a-f]{4}$/i;
	var sixValueColorRegex = /^#[0-9a-f]{6}$/i;
	var threeValueColorRegex = /^#[0-9a-f]{3}$/i;

	var DECIMAL_DOT = '.';
	var MINUS_SIGN = '-';
	var PLUS_SIGN = '+';

	var Keywords = {
	  '^': [
	    'inherit',
	    'initial',
	    'unset'
	  ],
	  '*-style': [
	    'auto',
	    'dashed',
	    'dotted',
	    'double',
	    'groove',
	    'hidden',
	    'inset',
	    'none',
	    'outset',
	    'ridge',
	    'solid'
	  ],
	  '*-timing-function': [
	    'ease',
	    'ease-in',
	    'ease-in-out',
	    'ease-out',
	    'linear',
	    'step-end',
	    'step-start'
	  ],
	  'animation-direction': [
	    'alternate',
	    'alternate-reverse',
	    'normal',
	    'reverse'
	  ],
	  'animation-fill-mode': [
	    'backwards',
	    'both',
	    'forwards',
	    'none'
	  ],
	  'animation-iteration-count': [
	    'infinite'
	  ],
	  'animation-name': [
	    'none'
	  ],
	  'animation-play-state': [
	    'paused',
	    'running'
	  ],
	  'background-attachment': [
	    'fixed',
	    'inherit',
	    'local',
	    'scroll'
	  ],
	  'background-clip': [
	    'border-box',
	    'content-box',
	    'inherit',
	    'padding-box',
	    'text'
	  ],
	  'background-origin': [
	    'border-box',
	    'content-box',
	    'inherit',
	    'padding-box'
	  ],
	  'background-position': [
	    'bottom',
	    'center',
	    'left',
	    'right',
	    'top'
	  ],
	  'background-repeat': [
	    'no-repeat',
	    'inherit',
	    'repeat',
	    'repeat-x',
	    'repeat-y',
	    'round',
	    'space'
	  ],
	  'background-size': [
	    'auto',
	    'cover',
	    'contain'
	  ],
	  'border-collapse': [
	    'collapse',
	    'inherit',
	    'separate'
	  ],
	  bottom: [
	    'auto'
	  ],
	  clear: [
	    'both',
	    'left',
	    'none',
	    'right'
	  ],
	  color: [
	    'transparent'
	  ],
	  cursor: [
	    'all-scroll',
	    'auto',
	    'col-resize',
	    'crosshair',
	    'default',
	    'e-resize',
	    'help',
	    'move',
	    'n-resize',
	    'ne-resize',
	    'no-drop',
	    'not-allowed',
	    'nw-resize',
	    'pointer',
	    'progress',
	    'row-resize',
	    's-resize',
	    'se-resize',
	    'sw-resize',
	    'text',
	    'vertical-text',
	    'w-resize',
	    'wait'
	  ],
	  display: [
	    'block',
	    'inline',
	    'inline-block',
	    'inline-table',
	    'list-item',
	    'none',
	    'table',
	    'table-caption',
	    'table-cell',
	    'table-column',
	    'table-column-group',
	    'table-footer-group',
	    'table-header-group',
	    'table-row',
	    'table-row-group'
	  ],
	  float: [
	    'left',
	    'none',
	    'right'
	  ],
	  left: [
	    'auto'
	  ],
	  font: [
	    'caption',
	    'icon',
	    'menu',
	    'message-box',
	    'small-caption',
	    'status-bar',
	    'unset'
	  ],
	  'font-size': [
	    'large',
	    'larger',
	    'medium',
	    'small',
	    'smaller',
	    'x-large',
	    'x-small',
	    'xx-large',
	    'xx-small'
	  ],
	  'font-stretch': [
	    'condensed',
	    'expanded',
	    'extra-condensed',
	    'extra-expanded',
	    'normal',
	    'semi-condensed',
	    'semi-expanded',
	    'ultra-condensed',
	    'ultra-expanded'
	  ],
	  'font-style': [
	    'italic',
	    'normal',
	    'oblique'
	  ],
	  'font-variant': [
	    'normal',
	    'small-caps'
	  ],
	  'font-weight': [
	    '100',
	    '200',
	    '300',
	    '400',
	    '500',
	    '600',
	    '700',
	    '800',
	    '900',
	    'bold',
	    'bolder',
	    'lighter',
	    'normal'
	  ],
	  'line-height': [
	    'normal'
	  ],
	  'list-style-position': [
	    'inside',
	    'outside'
	  ],
	  'list-style-type': [
	    'armenian',
	    'circle',
	    'decimal',
	    'decimal-leading-zero',
	    'disc',
	    'decimal|disc', // this is the default value of list-style-type, see comment in configuration.js
	    'georgian',
	    'lower-alpha',
	    'lower-greek',
	    'lower-latin',
	    'lower-roman',
	    'none',
	    'square',
	    'upper-alpha',
	    'upper-latin',
	    'upper-roman'
	  ],
	  overflow: [
	    'auto',
	    'hidden',
	    'scroll',
	    'visible'
	  ],
	  position: [
	    'absolute',
	    'fixed',
	    'relative',
	    'static'
	  ],
	  right: [
	    'auto'
	  ],
	  'text-align': [
	    'center',
	    'justify',
	    'left',
	    'left|right', // this is the default value of list-style-type, see comment in configuration.js
	    'right'
	  ],
	  'text-decoration': [
	    'line-through',
	    'none',
	    'overline',
	    'underline'
	  ],
	  'text-overflow': [
	    'clip',
	    'ellipsis'
	  ],
	  top: [
	    'auto'
	  ],
	  'vertical-align': [
	    'baseline',
	    'bottom',
	    'middle',
	    'sub',
	    'super',
	    'text-bottom',
	    'text-top',
	    'top'
	  ],
	  visibility: [
	    'collapse',
	    'hidden',
	    'visible'
	  ],
	  'white-space': [
	    'normal',
	    'nowrap',
	    'pre'
	  ],
	  width: [
	    'inherit',
	    'initial',
	    'medium',
	    'thick',
	    'thin'
	  ]
	};

	var Units = [
	  '%',
	  'ch',
	  'cm',
	  'em',
	  'ex',
	  'in',
	  'mm',
	  'pc',
	  'pt',
	  'px',
	  'rem',
	  'vh',
	  'vm',
	  'vmax',
	  'vmin',
	  'vw'
	];

	function isColor(value) {
	  return value != 'auto'
	    && (
	      isKeyword('color')(value)
	      || isHexColor(value)
	      || isColorFunction(value)
	      || isNamedEntity(value)
	    );
	}

	function isColorFunction(value) {
	  return isRgbColor(value) || isHslColor(value);
	}

	function isDynamicUnit(value) {
	  return calcRegex.test(value);
	}

	function isFunction(value) {
	  return functionAnyRegex.test(value);
	}

	function isHexColor(value) {
	  return threeValueColorRegex.test(value)
	    || fourValueColorRegex.test(value)
	    || sixValueColorRegex.test(value)
	    || eightValueColorRegex.test(value);
	}

	function isHslColor(value) {
	  return hslColorRegex.test(value) || hslColorWithSpacesRegex.test(value);
	}

	function isHexAlphaColor(value) {
	  return hexAlphaColorRegex.test(value);
	}

	function isIdentifier(value) {
	  return identifierRegex.test(value);
	}

	function isQuotedText(value) {
	  return quotedTextRegex.test(value);
	}

	function isImage(value) {
	  return value == 'none' || value == 'inherit' || isUrl(value);
	}

	function isKeyword(propertyName) {
	  return function(value) {
	    return Keywords[propertyName].indexOf(value) > -1;
	  };
	}

	function isNamedEntity(value) {
	  return namedEntityRegex.test(value);
	}

	function isNumber(value) {
	  return scanForNumber(value) == value.length;
	}

	function isRgbColor(value) {
	  return rgbColorRegex.test(value) || rgbColorWithSpacesRegex.test(value);
	}

	function isPrefixed(value) {
	  return prefixRegex.test(value);
	}

	function isPositiveNumber(value) {
	  return isNumber(value)
	    && parseFloat(value) >= 0;
	}

	function isVariable(value) {
	  return variableRegex.test(value);
	}

	function isTime(value) {
	  var numberUpTo = scanForNumber(value);

	  return numberUpTo == value.length && parseInt(value) === 0
	    || numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1
	    || isCalculatedTime(value);
	}

	function isCalculatedTime(value) {
	  return isFunction(value) && timeUnitPattern.test(value);
	}

	function isTimingFunction() {
	  var isTimingFunctionKeyword = isKeyword('*-timing-function');

	  return function(value) {
	    return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);
	  };
	}

	function isUnit(validUnits, value) {
	  var numberUpTo = scanForNumber(value);

	  return numberUpTo == value.length && parseInt(value) === 0
	    || numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1).toLowerCase()) > -1
	    || value == 'auto'
	    || value == 'inherit';
	}

	function isUrl(value) {
	  return urlRegex.test(value);
	}

	function isZIndex(value) {
	  return value == 'auto'
	    || isNumber(value)
	    || isKeyword('^')(value);
	}

	function scanForNumber(value) {
	  var hasDot = false;
	  var hasSign = false;
	  var character;
	  var i, l;

	  for (i = 0, l = value.length; i < l; i++) {
	    character = value[i];

	    if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {
	      hasSign = true;
	    } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {
	      return i - 1;
	    } else if (character == DECIMAL_DOT && !hasDot) {
	      hasDot = true;
	    } else if (character == DECIMAL_DOT && hasDot) {
	      return i - 1;
	    } else if (decimalRegex.test(character)) {
	      continue;
	    } else {
	      return i - 1;
	    }
	  }

	  return i;
	}

	function validator(compatibility) {
	  var validUnits = Units.slice(0).filter(function(value) {
	    return !(value in compatibility.units) || compatibility.units[value] === true;
	  });

	  if (compatibility.customUnits.rpx) {
	    validUnits.push('rpx');
	  }

	  return {
	    colorOpacity: compatibility.colors.opacity,
	    colorHexAlpha: compatibility.colors.hexAlpha,
	    isAnimationDirectionKeyword: isKeyword('animation-direction'),
	    isAnimationFillModeKeyword: isKeyword('animation-fill-mode'),
	    isAnimationIterationCountKeyword: isKeyword('animation-iteration-count'),
	    isAnimationNameKeyword: isKeyword('animation-name'),
	    isAnimationPlayStateKeyword: isKeyword('animation-play-state'),
	    isTimingFunction: isTimingFunction(),
	    isBackgroundAttachmentKeyword: isKeyword('background-attachment'),
	    isBackgroundClipKeyword: isKeyword('background-clip'),
	    isBackgroundOriginKeyword: isKeyword('background-origin'),
	    isBackgroundPositionKeyword: isKeyword('background-position'),
	    isBackgroundRepeatKeyword: isKeyword('background-repeat'),
	    isBackgroundSizeKeyword: isKeyword('background-size'),
	    isColor: isColor,
	    isColorFunction: isColorFunction,
	    isDynamicUnit: isDynamicUnit,
	    isFontKeyword: isKeyword('font'),
	    isFontSizeKeyword: isKeyword('font-size'),
	    isFontStretchKeyword: isKeyword('font-stretch'),
	    isFontStyleKeyword: isKeyword('font-style'),
	    isFontVariantKeyword: isKeyword('font-variant'),
	    isFontWeightKeyword: isKeyword('font-weight'),
	    isFunction: isFunction,
	    isGlobal: isKeyword('^'),
	    isHexAlphaColor: isHexAlphaColor,
	    isHslColor: isHslColor,
	    isIdentifier: isIdentifier,
	    isImage: isImage,
	    isKeyword: isKeyword,
	    isLineHeightKeyword: isKeyword('line-height'),
	    isListStylePositionKeyword: isKeyword('list-style-position'),
	    isListStyleTypeKeyword: isKeyword('list-style-type'),
	    isNumber: isNumber,
	    isPrefixed: isPrefixed,
	    isPositiveNumber: isPositiveNumber,
	    isQuotedText: isQuotedText,
	    isRgbColor: isRgbColor,
	    isStyleKeyword: isKeyword('*-style'),
	    isTime: isTime,
	    isUnit: isUnit.bind(null, validUnits),
	    isUrl: isUrl,
	    isVariable: isVariable,
	    isWidth: isKeyword('width'),
	    isZIndex: isZIndex
	  };
	}

	validator_1 = validator;
	return validator_1;
}

var compatibility;
var hasRequiredCompatibility;

function requireCompatibility () {
	if (hasRequiredCompatibility) return compatibility;
	hasRequiredCompatibility = 1;
	var DEFAULTS = {
	  '*': {
	    colors: {
	      hexAlpha: false, // 4- and 8-character hex notation
	      opacity: true // rgba / hsla
	    },
	    customUnits: { rpx: false },
	    properties: {
	      backgroundClipMerging: true, // background-clip to shorthand
	      backgroundOriginMerging: true, // background-origin to shorthand
	      backgroundSizeMerging: true, // background-size to shorthand
	      colors: true, // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`
	      ieBangHack: false, // !ie suffix hacks on IE<8
	      ieFilters: false, // whether to preserve `filter` and `-ms-filter` properties
	      iePrefixHack: false, // underscore / asterisk prefix hacks on IE
	      ieSuffixHack: false, // \9 suffix hacks on IE6-9, \0 suffix hack on IE6-11
	      merging: true, // merging properties into one
	      shorterLengthUnits: false, // optimize pixel units into `pt`, `pc` or `in` units
	      spaceAfterClosingBrace: true, // 'url() no-repeat' to 'url()no-repeat'
	      urlQuotes: true, // whether to wrap content of `url()` into quotes or not
	      zeroUnits: true // 0[unit] -> 0
	    },
	    selectors: {
	      adjacentSpace: false, // div+ nav Android stock browser hack
	      ie7Hack: false, // *+html hack
	      mergeablePseudoClasses: [
	        ':active',
	        ':after',
	        ':before',
	        ':empty',
	        ':checked',
	        ':disabled',
	        ':empty',
	        ':enabled',
	        ':first-child',
	        ':first-letter',
	        ':first-line',
	        ':first-of-type',
	        ':focus',
	        ':hover',
	        ':lang',
	        ':last-child',
	        ':last-of-type',
	        ':link',
	        ':not',
	        ':nth-child',
	        ':nth-last-child',
	        ':nth-last-of-type',
	        ':nth-of-type',
	        ':only-child',
	        ':only-of-type',
	        ':root',
	        ':target',
	        ':visited'
	      ], // selectors with these pseudo-classes can be merged as these are universally supported
	      mergeablePseudoElements: [
	        '::after',
	        '::before',
	        '::first-letter',
	        '::first-line'
	      ], // selectors with these pseudo-elements can be merged as these are universally supported
	      mergeLimit: 8191, // number of rules that can be safely merged together
	      multiplePseudoMerging: true
	    },
	    units: {
	      ch: true,
	      in: true,
	      pc: true,
	      pt: true,
	      rem: true,
	      vh: true,
	      vm: true, // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length
	      vmax: true,
	      vmin: true,
	      vw: true
	    }
	  }
	};

	DEFAULTS.ie11 = merge(DEFAULTS['*'], { properties: { ieSuffixHack: true } });

	DEFAULTS.ie10 = merge(DEFAULTS['*'], { properties: { ieSuffixHack: true } });

	DEFAULTS.ie9 = merge(DEFAULTS['*'], {
	  properties: {
	    ieFilters: true,
	    ieSuffixHack: true
	  }
	});

	DEFAULTS.ie8 = merge(DEFAULTS.ie9, {
	  colors: { opacity: false },
	  properties: {
	    backgroundClipMerging: false,
	    backgroundOriginMerging: false,
	    backgroundSizeMerging: false,
	    iePrefixHack: true,
	    merging: false
	  },
	  selectors: {
	    mergeablePseudoClasses: [
	      ':after',
	      ':before',
	      ':first-child',
	      ':first-letter',
	      ':focus',
	      ':hover',
	      ':visited'
	    ],
	    mergeablePseudoElements: []
	  },
	  units: {
	    ch: false,
	    rem: false,
	    vh: false,
	    vm: false,
	    vmax: false,
	    vmin: false,
	    vw: false
	  }
	});

	DEFAULTS.ie7 = merge(DEFAULTS.ie8, {
	  properties: { ieBangHack: true },
	  selectors: {
	    ie7Hack: true,
	    mergeablePseudoClasses: [
	      ':first-child',
	      ':first-letter',
	      ':hover',
	      ':visited'
	    ]
	  }
	});

	function compatibilityFrom(source) {
	  return merge(DEFAULTS['*'], calculateSource(source));
	}

	function merge(source, target) {
	  for (var key in source) {
	    if (Object.prototype.hasOwnProperty.call(source, key)) {
	      var value = source[key];

	      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {
	        target[key] = merge(value, target[key] || {});
	      } else {
	        target[key] = key in target ? target[key] : value;
	      }
	    }
	  }

	  return target;
	}

	function calculateSource(source) {
	  if (typeof source == 'object') { return source; }

	  if (!/[,+-]/.test(source)) { return DEFAULTS[source] || DEFAULTS['*']; }

	  var parts = source.split(',');
	  var template = parts[0] in DEFAULTS
	    ? DEFAULTS[parts.shift()]
	    : DEFAULTS['*'];

	  source = {};

	  parts.forEach(function(part) {
	    var isAdd = part[0] == '+';
	    var key = part.substring(1).split('.');
	    var group = key[0];
	    var option = key[1];

	    source[group] = source[group] || {};
	    source[group][option] = isAdd;
	  });

	  return merge(template, source);
	}

	compatibility = compatibilityFrom;
	return compatibility;
}

var isHttpResource_1;
var hasRequiredIsHttpResource;

function requireIsHttpResource () {
	if (hasRequiredIsHttpResource) return isHttpResource_1;
	hasRequiredIsHttpResource = 1;
	var HTTP_RESOURCE_PATTERN = /^http:\/\//;

	function isHttpResource(uri) {
	  return HTTP_RESOURCE_PATTERN.test(uri);
	}

	isHttpResource_1 = isHttpResource;
	return isHttpResource_1;
}

var isHttpsResource_1;
var hasRequiredIsHttpsResource;

function requireIsHttpsResource () {
	if (hasRequiredIsHttpsResource) return isHttpsResource_1;
	hasRequiredIsHttpsResource = 1;
	var HTTPS_RESOURCE_PATTERN = /^https:\/\//;

	function isHttpsResource(uri) {
	  return HTTPS_RESOURCE_PATTERN.test(uri);
	}

	isHttpsResource_1 = isHttpsResource;
	return isHttpsResource_1;
}

var loadRemoteResource_1;
var hasRequiredLoadRemoteResource;

function requireLoadRemoteResource () {
	if (hasRequiredLoadRemoteResource) return loadRemoteResource_1;
	hasRequiredLoadRemoteResource = 1;
	var http = require$$0$7;
	var https = require$$1$2;
	var url = require$$1$3;

	var isHttpResource = requireIsHttpResource();
	var isHttpsResource = requireIsHttpsResource();
	var override = requireOverride();

	var HTTP_PROTOCOL = 'http:';

	function loadRemoteResource(uri, inlineRequest, inlineTimeout, callback) {
	  var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;
	  var errorHandled = false;
	  var requestOptions;
	  var fetch;

	  requestOptions = override(
	    url.parse(uri),
	    inlineRequest || {}
	  );

	  if (inlineRequest.hostname !== undefined) {
	    // overwrite as we always expect a http proxy currently
	    requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;
	    requestOptions.path = requestOptions.href;
	  }

	  fetch = (proxyProtocol && !isHttpsResource(proxyProtocol)) || isHttpResource(uri)
	    ? http.get
	    : https.get;

	  fetch(requestOptions, function(res) {
	    var chunks = [];
	    var movedUri;

	    if (errorHandled) {
	      return;
	    }

	    if (res.statusCode < 200 || res.statusCode > 399) {
	      return callback(res.statusCode, null);
	    } if (res.statusCode > 299) {
	      movedUri = url.resolve(uri, res.headers.location);
	      return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);
	    }

	    res.on('data', function(chunk) {
	      chunks.push(chunk.toString());
	    });
	    res.on('end', function() {
	      var body = chunks.join('');
	      callback(null, body);
	    });
	  })
	    .on('error', function(res) {
	      if (errorHandled) {
	        return;
	      }

	      errorHandled = true;
	      callback(res.message, null);
	    })
	    .on('timeout', function() {
	      if (errorHandled) {
	        return;
	      }

	      errorHandled = true;
	      callback('timeout', null);
	    })
	    .setTimeout(inlineTimeout);
	}

	loadRemoteResource_1 = loadRemoteResource;
	return loadRemoteResource_1;
}

var fetch;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch;
	hasRequiredFetch = 1;
	var loadRemoteResource = requireLoadRemoteResource();

	function fetchFrom(callback) {
	  return callback || loadRemoteResource;
	}

	fetch = fetchFrom;
	return fetch;
}

var inline;
var hasRequiredInline;

function requireInline () {
	if (hasRequiredInline) return inline;
	hasRequiredInline = 1;
	function inlineOptionsFrom(rules) {
	  if (Array.isArray(rules)) {
	    return rules;
	  }

	  if (rules === false) {
	    return ['none'];
	  }

	  return undefined === rules
	    ? ['local']
	    : rules.split(',');
	}

	inline = inlineOptionsFrom;
	return inline;
}

var inlineRequest;
var hasRequiredInlineRequest;

function requireInlineRequest () {
	if (hasRequiredInlineRequest) return inlineRequest;
	hasRequiredInlineRequest = 1;
	var url = require$$1$3;

	var override = requireOverride();

	function inlineRequestFrom(option) {
	  return override(
	    /* jshint camelcase: false */
	    proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy),
	    option || {}
	  );
	}

	function proxyOptionsFrom(httpProxy) {
	  return httpProxy
	    ? {
	      hostname: url.parse(httpProxy).hostname,
	      port: parseInt(url.parse(httpProxy).port)
	    }
	    : {};
	}

	inlineRequest = inlineRequestFrom;
	return inlineRequest;
}

var inlineTimeout;
var hasRequiredInlineTimeout;

function requireInlineTimeout () {
	if (hasRequiredInlineTimeout) return inlineTimeout;
	hasRequiredInlineTimeout = 1;
	var DEFAULT_TIMEOUT = 5000;

	function inlineTimeoutFrom(option) {
	  return option || DEFAULT_TIMEOUT;
	}

	inlineTimeout = inlineTimeoutFrom;
	return inlineTimeout;
}

var plugins;
var hasRequiredPlugins;

function requirePlugins () {
	if (hasRequiredPlugins) return plugins;
	hasRequiredPlugins = 1;
	function pluginsFrom(plugins) {
	  var flatPlugins = {
	    level1Value: [],
	    level1Property: [],
	    level2Block: []
	  };

	  plugins = plugins || [];

	  flatPlugins.level1Value = plugins
	    .map(function(plugin) { return plugin.level1 && plugin.level1.value; })
	    .filter(function(plugin) { return plugin != null; });

	  flatPlugins.level1Property = plugins
	    .map(function(plugin) { return plugin.level1 && plugin.level1.property; })
	    .filter(function(plugin) { return plugin != null; });

	  flatPlugins.level2Block = plugins
	    .map(function(plugin) { return plugin.level2 && plugin.level2.block; })
	    .filter(function(plugin) { return plugin != null; });

	  return flatPlugins;
	}

	plugins = pluginsFrom;
	return plugins;
}

var rebase;
var hasRequiredRebase$1;

function requireRebase$1 () {
	if (hasRequiredRebase$1) return rebase;
	hasRequiredRebase$1 = 1;
	function rebaseFrom(rebaseOption, rebaseToOption) {
	  if (undefined !== rebaseToOption) {
	    return true;
	  } if (undefined === rebaseOption) {
	    return false;
	  }
	  return !!rebaseOption;
	}

	rebase = rebaseFrom;
	return rebase;
}

var rebaseTo;
var hasRequiredRebaseTo;

function requireRebaseTo () {
	if (hasRequiredRebaseTo) return rebaseTo;
	hasRequiredRebaseTo = 1;
	var path = require$$0$4;

	function rebaseToFrom(option) {
	  return option ? path.resolve(option) : process.cwd();
	}

	rebaseTo = rebaseToFrom;
	return rebaseTo;
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);

		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;

		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   “sources” entry.  This value is prepended to the individual
		    //   entries in the “source” field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   “sourceRoot”, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = requireBase64Vlq();
	var util = requireUtil();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;

		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}

		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }

		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }

		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }

		  return index;
		}; 
	} (binarySearch));
	return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredQuickSort;

function requireQuickSort () {
	if (hasRequiredQuickSort) return quickSort;
	hasRequiredQuickSort = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	quickSort.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};
	return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapConsumer;

function requireSourceMapConsumer () {
	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	hasRequiredSourceMapConsumer = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var binarySearch = requireBinarySearch();
	var ArraySet = requireArraySet().ArraySet;
	var base64VLQ = requireBase64Vlq();
	var quickSort = requireQuickSort().quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceNode;

function requireSourceNode () {
	if (hasRequiredSourceNode) return sourceNode;
	hasRequiredSourceNode = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	var util = requireUtil();

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	sourceNode.SourceNode = SourceNode;
	return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
	sourceMap.SourceNode = requireSourceNode().SourceNode;
	return sourceMap;
}

var inputSourceMapTracker_1;
var hasRequiredInputSourceMapTracker;

function requireInputSourceMapTracker () {
	if (hasRequiredInputSourceMapTracker) return inputSourceMapTracker_1;
	hasRequiredInputSourceMapTracker = 1;
	var SourceMapConsumer = requireSourceMap().SourceMapConsumer;

	function inputSourceMapTracker() {
	  var maps = {};

	  return {
	    all: all.bind(null, maps),
	    isTracking: isTracking.bind(null, maps),
	    originalPositionFor: originalPositionFor.bind(null, maps),
	    track: track.bind(null, maps)
	  };
	}

	function all(maps) {
	  return maps;
	}

	function isTracking(maps, source) {
	  return source in maps;
	}

	function originalPositionFor(maps, metadata, range, selectorFallbacks) {
	  var line = metadata[0];
	  var column = metadata[1];
	  var source = metadata[2];
	  var position = {
	    line: line,
	    column: column + range
	  };
	  var originalPosition;

	  while (!originalPosition && position.column > column) {
	    position.column--;
	    originalPosition = maps[source].originalPositionFor(position);
	  }

	  if (!originalPosition || originalPosition.column < 0) {
	    return metadata;
	  }

	  if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {
	    return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);
	  }

	  return originalPosition.line !== null
	    ? toMetadata(originalPosition)
	    : metadata;
	}

	function toMetadata(asHash) {
	  return [asHash.line, asHash.column, asHash.source];
	}

	function track(maps, source, data) {
	  maps[source] = new SourceMapConsumer(data);
	}

	inputSourceMapTracker_1 = inputSourceMapTracker;
	return inputSourceMapTracker_1;
}

var isRemoteResource_1;
var hasRequiredIsRemoteResource;

function requireIsRemoteResource () {
	if (hasRequiredIsRemoteResource) return isRemoteResource_1;
	hasRequiredIsRemoteResource = 1;
	var REMOTE_RESOURCE_PATTERN = /^(\w+:\/\/|\/\/)/;
	var FILE_RESOURCE_PATTERN = /^file:\/\//;

	function isRemoteResource(uri) {
	  return REMOTE_RESOURCE_PATTERN.test(uri) && !FILE_RESOURCE_PATTERN.test(uri);
	}

	isRemoteResource_1 = isRemoteResource;
	return isRemoteResource_1;
}

var hasProtocol_1;
var hasRequiredHasProtocol;

function requireHasProtocol () {
	if (hasRequiredHasProtocol) return hasProtocol_1;
	hasRequiredHasProtocol = 1;
	var NO_PROTOCOL_RESOURCE_PATTERN = /^\/\//;

	function hasProtocol(uri) {
	  return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);
	}

	hasProtocol_1 = hasProtocol;
	return hasProtocol_1;
}

var isAllowedResource_1;
var hasRequiredIsAllowedResource;

function requireIsAllowedResource () {
	if (hasRequiredIsAllowedResource) return isAllowedResource_1;
	hasRequiredIsAllowedResource = 1;
	var path = require$$0$4;
	var url = require$$1$3;

	var isRemoteResource = requireIsRemoteResource();
	var hasProtocol = requireHasProtocol();

	var HTTP_PROTOCOL = 'http:';

	function isAllowedResource(uri, isRemote, rules) {
	  var match;
	  var absoluteUri;
	  var allowed = !isRemote;
	  var rule;
	  var isNegated;
	  var normalizedRule;
	  var i;

	  if (rules.length === 0) {
	    return false;
	  }

	  if (isRemote && !hasProtocol(uri)) {
	    uri = HTTP_PROTOCOL + uri;
	  }

	  match = isRemote
	    ? url.parse(uri).host
	    : uri;

	  absoluteUri = isRemote
	    ? uri
	    : path.resolve(uri);

	  for (i = 0; i < rules.length; i++) {
	    rule = rules[i];
	    isNegated = rule[0] == '!';
	    normalizedRule = rule.substring(1);

	    if (isNegated && isRemote && isRemoteRule(normalizedRule)) {
	      allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);
	    } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {
	      allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);
	    } else if (isNegated) {
	      allowed = allowed && true;
	    } else if (rule == 'all') {
	      allowed = true;
	    } else if (isRemote && rule == 'local') {
	      allowed = allowed || false;
	    } else if (isRemote && rule == 'remote') {
	      allowed = true;
	    } else if (!isRemote && rule == 'remote') {
	      allowed = false;
	    } else if (!isRemote && rule == 'local') {
	      allowed = true;
	    } else if (rule === match) {
	      allowed = true;
	    } else if (rule === uri) {
	      allowed = true;
	    } else if (isRemote && absoluteUri.indexOf(rule) === 0) {
	      allowed = true;
	    } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {
	      allowed = true;
	    } else if (isRemote != isRemoteRule(normalizedRule)) {
	      allowed = allowed && true;
	    } else {
	      allowed = false;
	    }
	  }

	  return allowed;
	}

	function isRemoteRule(rule) {
	  return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + '//' + rule).host == rule;
	}

	isAllowedResource_1 = isAllowedResource;
	return isAllowedResource_1;
}

var matchDataUri_1;
var hasRequiredMatchDataUri;

function requireMatchDataUri () {
	if (hasRequiredMatchDataUri) return matchDataUri_1;
	hasRequiredMatchDataUri = 1;
	var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;

	function matchDataUri(uri) {
	  return DATA_URI_PATTERN.exec(uri);
	}

	matchDataUri_1 = matchDataUri;
	return matchDataUri_1;
}

var rebaseLocalMap_1;
var hasRequiredRebaseLocalMap;

function requireRebaseLocalMap () {
	if (hasRequiredRebaseLocalMap) return rebaseLocalMap_1;
	hasRequiredRebaseLocalMap = 1;
	var path = require$$0$4;

	function rebaseLocalMap(sourceMap, sourceUri, rebaseTo) {
	  var currentPath = path.resolve('');
	  var absoluteUri = path.resolve(currentPath, sourceUri);
	  var absoluteUriDirectory = path.dirname(absoluteUri);

	  sourceMap.sources = sourceMap.sources.map(function(source) {
	    return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));
	  });

	  return sourceMap;
	}

	rebaseLocalMap_1 = rebaseLocalMap;
	return rebaseLocalMap_1;
}

var rebaseRemoteMap_1;
var hasRequiredRebaseRemoteMap;

function requireRebaseRemoteMap () {
	if (hasRequiredRebaseRemoteMap) return rebaseRemoteMap_1;
	hasRequiredRebaseRemoteMap = 1;
	var path = require$$0$4;
	var url = require$$1$3;

	function rebaseRemoteMap(sourceMap, sourceUri) {
	  var sourceDirectory = path.dirname(sourceUri);

	  sourceMap.sources = sourceMap.sources.map(function(source) {
	    return url.resolve(sourceDirectory, source);
	  });

	  return sourceMap;
	}

	rebaseRemoteMap_1 = rebaseRemoteMap;
	return rebaseRemoteMap_1;
}

var isDataUriResource_1;
var hasRequiredIsDataUriResource;

function requireIsDataUriResource () {
	if (hasRequiredIsDataUriResource) return isDataUriResource_1;
	hasRequiredIsDataUriResource = 1;
	var DATA_URI_PATTERN = /^data:(\S{0,31}?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;

	function isDataUriResource(uri) {
	  return DATA_URI_PATTERN.test(uri);
	}

	isDataUriResource_1 = isDataUriResource;
	return isDataUriResource_1;
}

var applySourceMaps_1;
var hasRequiredApplySourceMaps;

function requireApplySourceMaps () {
	if (hasRequiredApplySourceMaps) return applySourceMaps_1;
	hasRequiredApplySourceMaps = 1;
	var fs = fs$1;
	var path = require$$0$4;

	var isAllowedResource = requireIsAllowedResource();
	var matchDataUri = requireMatchDataUri();
	var rebaseLocalMap = requireRebaseLocalMap();
	var rebaseRemoteMap = requireRebaseRemoteMap();

	var Token = requireToken();
	var hasProtocol = requireHasProtocol();
	var isDataUriResource = requireIsDataUriResource();
	var isRemoteResource = requireIsRemoteResource();

	var MAP_MARKER_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;

	function applySourceMaps(tokens, context, callback) {
	  var applyContext = {
	    callback: callback,
	    fetch: context.options.fetch,
	    index: 0,
	    inline: context.options.inline,
	    inlineRequest: context.options.inlineRequest,
	    inlineTimeout: context.options.inlineTimeout,
	    inputSourceMapTracker: context.inputSourceMapTracker,
	    localOnly: context.localOnly,
	    processedTokens: [],
	    rebaseTo: context.options.rebaseTo,
	    sourceTokens: tokens,
	    warnings: context.warnings
	  };

	  return context.options.sourceMap && tokens.length > 0
	    ? doApplySourceMaps(applyContext)
	    : callback(tokens);
	}

	function doApplySourceMaps(applyContext) {
	  var singleSourceTokens = [];
	  var lastSource = findTokenSource(applyContext.sourceTokens[0]);
	  var source;
	  var token;
	  var l;

	  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {
	    token = applyContext.sourceTokens[applyContext.index];
	    source = findTokenSource(token);

	    if (source != lastSource) {
	      singleSourceTokens = [];
	      lastSource = source;
	    }

	    singleSourceTokens.push(token);
	    applyContext.processedTokens.push(token);

	    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {
	      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);
	    }
	  }

	  return applyContext.callback(applyContext.processedTokens);
	}

	function findTokenSource(token) {
	  var scope;
	  var metadata;

	  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {
	    metadata = token[2][0];
	  } else {
	    scope = token[1][0];
	    metadata = scope[2][0];
	  }

	  return metadata[2];
	}

	function fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {
	  return extractInputSourceMapFrom(sourceMapComment, applyContext, function(inputSourceMap) {
	    if (inputSourceMap) {
	      applyContext.inputSourceMapTracker.track(source, inputSourceMap);
	      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);
	    }

	    applyContext.index++;
	    return doApplySourceMaps(applyContext);
	  });
	}

	function extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {
	  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];
	  var absoluteUri;
	  var sourceMap;
	  var rebasedMap;

	  if (isDataUriResource(uri)) {
	    sourceMap = extractInputSourceMapFromDataUri(uri);
	    return whenSourceMapReady(sourceMap);
	  } if (isRemoteResource(uri)) {
	    return loadInputSourceMapFromRemoteUri(uri, applyContext, function(sourceMap) {
	      var parsedMap;

	      if (sourceMap) {
	        parsedMap = JSON.parse(sourceMap);
	        rebasedMap = rebaseRemoteMap(parsedMap, uri);
	        whenSourceMapReady(rebasedMap);
	      } else {
	        whenSourceMapReady(null);
	      }
	    });
	  }
	  // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment
	  // it is rebased to be consistent with rebasing other URIs
	  // however here we need to resolve it back to read it from disk
	  absoluteUri = path.resolve(applyContext.rebaseTo, uri);
	  sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);

	  if (sourceMap) {
	    rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);
	    return whenSourceMapReady(rebasedMap);
	  }
	  return whenSourceMapReady(null);
	}

	function extractInputSourceMapFromDataUri(uri) {
	  var dataUriMatch = matchDataUri(uri);
	  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';
	  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';
	  var data = encoding == 'utf8' ? commonjsGlobal.unescape(dataUriMatch[4]) : dataUriMatch[4];

	  var buffer = Buffer.from(data, encoding);
	  buffer.charset = charset;

	  return JSON.parse(buffer.toString());
	}

	function loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {
	  var isAllowed = isAllowedResource(uri, true, applyContext.inline);
	  var isRuntimeResource = !hasProtocol(uri);

	  if (applyContext.localOnly) {
	    applyContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
	    return whenLoaded(null);
	  } if (isRuntimeResource) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
	    return whenLoaded(null);
	  } if (!isAllowed) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return whenLoaded(null);
	  }

	  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function(error, body) {
	    if (error) {
	      applyContext.warnings.push('Missing source map at "' + uri + '" - ' + error);
	      return whenLoaded(null);
	    }

	    whenLoaded(body);
	  });
	}

	function loadInputSourceMapFromLocalUri(uri, applyContext) {
	  var isAllowed = isAllowedResource(uri, false, applyContext.inline);
	  var sourceMap;

	  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {
	    applyContext.warnings.push('Ignoring local source map at "' + uri + '" as resource is missing.');
	    return null;
	  } if (!isAllowed) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return null;
	  } if (!fs.statSync(uri).size) {
	    applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is empty.');
	    return null;
	  }

	  sourceMap = fs.readFileSync(uri, 'utf-8');
	  return JSON.parse(sourceMap);
	}

	function applySourceMapRecursively(tokens, inputSourceMapTracker) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	    case Token.AT_RULE:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.AT_RULE_BLOCK:
	      applySourceMapRecursively(token[1], inputSourceMapTracker);
	      applySourceMapRecursively(token[2], inputSourceMapTracker);
	      break;
	    case Token.AT_RULE_BLOCK_SCOPE:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.NESTED_BLOCK:
	      applySourceMapRecursively(token[1], inputSourceMapTracker);
	      applySourceMapRecursively(token[2], inputSourceMapTracker);
	      break;
	    case Token.NESTED_BLOCK_SCOPE:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.COMMENT:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.PROPERTY:
	      applySourceMapRecursively(token, inputSourceMapTracker);
	      break;
	    case Token.PROPERTY_BLOCK:
	      applySourceMapRecursively(token[1], inputSourceMapTracker);
	      break;
	    case Token.PROPERTY_NAME:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.PROPERTY_VALUE:
	      applySourceMapTo(token, inputSourceMapTracker);
	      break;
	    case Token.RULE:
	      applySourceMapRecursively(token[1], inputSourceMapTracker);
	      applySourceMapRecursively(token[2], inputSourceMapTracker);
	      break;
	    case Token.RULE_SCOPE:
	      applySourceMapTo(token, inputSourceMapTracker);
	    }
	  }

	  return tokens;
	}

	function applySourceMapTo(token, inputSourceMapTracker) {
	  var value = token[1];
	  var metadata = token[2];
	  var newMetadata = [];
	  var i, l;

	  for (i = 0, l = metadata.length; i < l; i++) {
	    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));
	  }

	  token[2] = newMetadata;
	}

	applySourceMaps_1 = applySourceMaps;
	return applySourceMaps_1;
}

var extractImportUrlAndMedia_1;
var hasRequiredExtractImportUrlAndMedia;

function requireExtractImportUrlAndMedia () {
	if (hasRequiredExtractImportUrlAndMedia) return extractImportUrlAndMedia_1;
	hasRequiredExtractImportUrlAndMedia = 1;
	var split = requireSplit();

	var BRACE_PREFIX = /^\(/;
	var BRACE_SUFFIX = /\)$/;
	var IMPORT_PREFIX_PATTERN = /^@import/i;
	var QUOTE_PREFIX_PATTERN = /['"]\s{0,31}/;
	var QUOTE_SUFFIX_PATTERN = /\s{0,31}['"]/;
	var URL_PREFIX_PATTERN = /^url\(\s{0,31}/i;
	var URL_SUFFIX_PATTERN = /\s{0,31}\)/i;

	function extractImportUrlAndMedia(atRuleValue) {
	  var uri;
	  var mediaQuery;
	  var normalized;
	  var parts;

	  normalized = atRuleValue
	    .replace(IMPORT_PREFIX_PATTERN, '')
	    .trim()
	    .replace(URL_PREFIX_PATTERN, '(')
	    .replace(URL_SUFFIX_PATTERN, ') ')
	    .replace(QUOTE_PREFIX_PATTERN, '')
	    .replace(QUOTE_SUFFIX_PATTERN, '');

	  parts = split(normalized, ' ');

	  uri = parts[0]
	    .replace(BRACE_PREFIX, '')
	    .replace(BRACE_SUFFIX, '');
	  mediaQuery = parts.slice(1).join(' ');

	  return [uri, mediaQuery];
	}

	extractImportUrlAndMedia_1 = extractImportUrlAndMedia;
	return extractImportUrlAndMedia_1;
}

var loadOriginalSources_1;
var hasRequiredLoadOriginalSources;

function requireLoadOriginalSources () {
	if (hasRequiredLoadOriginalSources) return loadOriginalSources_1;
	hasRequiredLoadOriginalSources = 1;
	var fs = fs$1;
	var path = require$$0$4;

	var isAllowedResource = requireIsAllowedResource();

	var hasProtocol = requireHasProtocol();
	var isRemoteResource = requireIsRemoteResource();

	function loadOriginalSources(context, callback) {
	  var loadContext = {
	    callback: callback,
	    fetch: context.options.fetch,
	    index: 0,
	    inline: context.options.inline,
	    inlineRequest: context.options.inlineRequest,
	    inlineTimeout: context.options.inlineTimeout,
	    localOnly: context.localOnly,
	    rebaseTo: context.options.rebaseTo,
	    sourcesContent: context.sourcesContent,
	    uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),
	    warnings: context.warnings
	  };

	  return context.options.sourceMap && context.options.sourceMapInlineSources
	    ? doLoadOriginalSources(loadContext)
	    : callback();
	}

	function uriToSourceMapping(allSourceMapConsumers) {
	  var mapping = {};
	  var consumer;
	  var uri;
	  var source;
	  var i, l;

	  for (source in allSourceMapConsumers) {
	    consumer = allSourceMapConsumers[source];

	    for (i = 0, l = consumer.sources.length; i < l; i++) {
	      uri = consumer.sources[i];
	      source = consumer.sourceContentFor(uri, true);

	      mapping[uri] = source;
	    }
	  }

	  return mapping;
	}

	function doLoadOriginalSources(loadContext) {
	  var uris = Object.keys(loadContext.uriToSource);
	  var uri;
	  var source;
	  var total;

	  for (total = uris.length; loadContext.index < total; loadContext.index++) {
	    uri = uris[loadContext.index];
	    source = loadContext.uriToSource[uri];

	    if (source) {
	      loadContext.sourcesContent[uri] = source;
	    } else {
	      return loadOriginalSource(uri, loadContext);
	    }
	  }

	  return loadContext.callback();
	}

	function loadOriginalSource(uri, loadContext) {
	  var content;

	  if (isRemoteResource(uri)) {
	    return loadOriginalSourceFromRemoteUri(uri, loadContext, function(content) {
	      loadContext.index++;
	      loadContext.sourcesContent[uri] = content;
	      return doLoadOriginalSources(loadContext);
	    });
	  }
	  content = loadOriginalSourceFromLocalUri(uri, loadContext);
	  loadContext.index++;
	  loadContext.sourcesContent[uri] = content;
	  return doLoadOriginalSources(loadContext);
	}

	function loadOriginalSourceFromRemoteUri(uri, loadContext, whenLoaded) {
	  var isAllowed = isAllowedResource(uri, true, loadContext.inline);
	  var isRuntimeResource = !hasProtocol(uri);

	  if (loadContext.localOnly) {
	    loadContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
	    return whenLoaded(null);
	  } if (isRuntimeResource) {
	    loadContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
	    return whenLoaded(null);
	  } if (!isAllowed) {
	    loadContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
	    return whenLoaded(null);
	  }

	  loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function(error, content) {
	    if (error) {
	      loadContext.warnings.push('Missing original source at "' + uri + '" - ' + error);
	    }

	    whenLoaded(content);
	  });
	}

	function loadOriginalSourceFromLocalUri(relativeUri, loadContext) {
	  var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);
	  var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);

	  if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {
	    loadContext.warnings.push('Ignoring local source map at "' + absoluteUri + '" as resource is missing.');
	    return null;
	  } if (!isAllowed) {
	    loadContext.warnings.push('Cannot fetch "' + absoluteUri + '" as resource is not allowed.');
	    return null;
	  }

	  var result = fs.readFileSync(absoluteUri, 'utf8');
	  if (result.charCodeAt(0) === 65279) {
	    result = result.substring(1);
	  }
	  return result;
	}

	loadOriginalSources_1 = loadOriginalSources;
	return loadOriginalSources_1;
}

var normalizePath_1;
var hasRequiredNormalizePath;

function requireNormalizePath () {
	if (hasRequiredNormalizePath) return normalizePath_1;
	hasRequiredNormalizePath = 1;
	var UNIX_SEPARATOR = '/';
	var WINDOWS_SEPARATOR_PATTERN = /\\/g;

	function normalizePath(path) {
	  return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);
	}

	normalizePath_1 = normalizePath;
	return normalizePath_1;
}

var restoreImport_1;
var hasRequiredRestoreImport;

function requireRestoreImport () {
	if (hasRequiredRestoreImport) return restoreImport_1;
	hasRequiredRestoreImport = 1;
	function restoreImport(uri, mediaQuery) {
	  return ('@import ' + uri + ' ' + mediaQuery).trim();
	}

	restoreImport_1 = restoreImport;
	return restoreImport_1;
}

var rewriteUrl_1;
var hasRequiredRewriteUrl;

function requireRewriteUrl () {
	if (hasRequiredRewriteUrl) return rewriteUrl_1;
	hasRequiredRewriteUrl = 1;
	var path = require$$0$4;
	var url = require$$1$3;

	var isDataUriResource = requireIsDataUriResource();

	var DOUBLE_QUOTE = '"';
	var SINGLE_QUOTE = '\'';
	var URL_PREFIX = 'url(';
	var URL_SUFFIX = ')';

	var PROTOCOL_LESS_PREFIX_PATTERN = /^[^\w\d]*\/\//;
	var QUOTE_PREFIX_PATTERN = /^["']/;
	var QUOTE_SUFFIX_PATTERN = /["']$/;
	var ROUND_BRACKETS_PATTERN = /[()]/;
	var URL_PREFIX_PATTERN = /^url\(/i;
	var URL_SUFFIX_PATTERN = /\)$/;
	var WHITESPACE_PATTERN = /\s/;

	var isWindows = process.platform == 'win32';

	function rebase(uri, rebaseConfig) {
	  if (!rebaseConfig) {
	    return uri;
	  }

	  if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {
	    return uri;
	  }

	  if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri) || isDataUriResource(uri)) {
	    return uri;
	  }

	  if (isRemote(rebaseConfig.toBase)) {
	    return url.resolve(rebaseConfig.toBase, uri);
	  }

	  return rebaseConfig.absolute
	    ? normalize(absolute(uri, rebaseConfig))
	    : normalize(relative(uri, rebaseConfig));
	}

	function isAbsolute(uri) {
	  return path.isAbsolute(uri);
	}

	function isSVGMarker(uri) {
	  return uri[0] == '#';
	}

	function isInternal(uri) {
	  return /^\w+:\w+/.test(uri);
	}

	function isRemote(uri) {
	  return /^[^:]+?:\/\//.test(uri) || PROTOCOL_LESS_PREFIX_PATTERN.test(uri);
	}

	function absolute(uri, rebaseConfig) {
	  return path
	    .resolve(path.join(rebaseConfig.fromBase || '', uri))
	    .replace(rebaseConfig.toBase, '');
	}

	function relative(uri, rebaseConfig) {
	  return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || '', uri));
	}

	function normalize(uri) {
	  return isWindows ? uri.replace(/\\/g, '/') : uri;
	}

	function quoteFor(unquotedUrl) {
	  if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {
	    return DOUBLE_QUOTE;
	  } if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {
	    return SINGLE_QUOTE;
	  } if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {
	    return SINGLE_QUOTE;
	  }
	  return '';
	}

	function hasWhitespace(url) {
	  return WHITESPACE_PATTERN.test(url);
	}

	function hasRoundBrackets(url) {
	  return ROUND_BRACKETS_PATTERN.test(url);
	}

	function rewriteUrl(originalUrl, rebaseConfig, pathOnly) {
	  var strippedUrl = originalUrl
	    .replace(URL_PREFIX_PATTERN, '')
	    .replace(URL_SUFFIX_PATTERN, '')
	    .trim();

	  var unquotedUrl = strippedUrl
	    .replace(QUOTE_PREFIX_PATTERN, '')
	    .replace(QUOTE_SUFFIX_PATTERN, '')
	    .trim();

	  var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE
	    ? strippedUrl[0]
	    : quoteFor(unquotedUrl);

	  return pathOnly
	    ? rebase(unquotedUrl, rebaseConfig)
	    : URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;
	}

	rewriteUrl_1 = rewriteUrl;
	return rewriteUrl_1;
}

var isImport_1;
var hasRequiredIsImport;

function requireIsImport () {
	if (hasRequiredIsImport) return isImport_1;
	hasRequiredIsImport = 1;
	var IMPORT_PREFIX_PATTERN = /^@import/i;

	function isImport(value) {
	  return IMPORT_PREFIX_PATTERN.test(value);
	}

	isImport_1 = isImport;
	return isImport_1;
}

var rebase_1;
var hasRequiredRebase;

function requireRebase () {
	if (hasRequiredRebase) return rebase_1;
	hasRequiredRebase = 1;
	var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
	var restoreImport = requireRestoreImport();
	var rewriteUrl = requireRewriteUrl();

	var Token = requireToken();
	var isImport = requireIsImport();

	var SOURCE_MAP_COMMENT_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;

	function rebase(tokens, rebaseAll, validator, rebaseConfig) {
	  return rebaseAll
	    ? rebaseEverything(tokens, validator, rebaseConfig)
	    : rebaseAtRules(tokens, validator, rebaseConfig);
	}

	function rebaseEverything(tokens, validator, rebaseConfig) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	    case Token.AT_RULE:
	      rebaseAtRule(token, validator, rebaseConfig);
	      break;
	    case Token.AT_RULE_BLOCK:
	      rebaseProperties(token[2], validator, rebaseConfig);
	      break;
	    case Token.COMMENT:
	      rebaseSourceMapComment(token, rebaseConfig);
	      break;
	    case Token.NESTED_BLOCK:
	      rebaseEverything(token[2], validator, rebaseConfig);
	      break;
	    case Token.RULE:
	      rebaseProperties(token[2], validator, rebaseConfig);
	      break;
	    }
	  }

	  return tokens;
	}

	function rebaseAtRules(tokens, validator, rebaseConfig) {
	  var token;
	  var i, l;

	  for (i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];

	    switch (token[0]) {
	    case Token.AT_RULE:
	      rebaseAtRule(token, validator, rebaseConfig);
	      break;
	    }
	  }

	  return tokens;
	}

	function rebaseAtRule(token, validator, rebaseConfig) {
	  if (!isImport(token[1])) {
	    return;
	  }

	  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
	  var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);
	  var mediaQuery = uriAndMediaQuery[1];

	  token[1] = restoreImport(newUrl, mediaQuery);
	}

	function rebaseSourceMapComment(token, rebaseConfig) {
	  var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);

	  if (matches && matches[1].indexOf('data:') === -1) {
	    token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));
	  }
	}

	function rebaseProperties(properties, validator, rebaseConfig) {
	  var property;
	  var value;
	  var i, l;
	  var j, m;

	  for (i = 0, l = properties.length; i < l; i++) {
	    property = properties[i];

	    for (j = 2 /* 0 is Token.PROPERTY, 1 is name */, m = property.length; j < m; j++) {
	      value = property[j][1];

	      if (validator.isUrl(value)) {
	        property[j][1] = rewriteUrl(value, rebaseConfig);
	      }
	    }
	  }
	}

	rebase_1 = rebase;
	return rebase_1;
}

var tokenize_1;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1;
	var Marker = requireMarker();
	var Token = requireToken();

	var formatPosition = requireFormatPosition();

	var Level = {
	  BLOCK: 'block',
	  COMMENT: 'comment',
	  DOUBLE_QUOTE: 'double-quote',
	  RULE: 'rule',
	  SINGLE_QUOTE: 'single-quote'
	};

	var AT_RULES = [
	  '@charset',
	  '@import'
	];

	var BLOCK_RULES = [
	  '@-moz-document',
	  '@document',
	  '@-moz-keyframes',
	  '@-ms-keyframes',
	  '@-o-keyframes',
	  '@-webkit-keyframes',
	  '@keyframes',
	  '@media',
	  '@supports',
	  '@container',
	  '@layer'
	];

	var IGNORE_END_COMMENT_PATTERN = /\/\* clean-css ignore:end \*\/$/;
	var IGNORE_START_COMMENT_PATTERN = /^\/\* clean-css ignore:start \*\//;

	var PAGE_MARGIN_BOXES = [
	  '@bottom-center',
	  '@bottom-left',
	  '@bottom-left-corner',
	  '@bottom-right',
	  '@bottom-right-corner',
	  '@left-bottom',
	  '@left-middle',
	  '@left-top',
	  '@right-bottom',
	  '@right-middle',
	  '@right-top',
	  '@top-center',
	  '@top-left',
	  '@top-left-corner',
	  '@top-right',
	  '@top-right-corner'
	];

	var EXTRA_PAGE_BOXES = [
	  '@footnote',
	  '@footnotes',
	  '@left',
	  '@page-float-bottom',
	  '@page-float-top',
	  '@right'
	];

	var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
	var TAIL_BROKEN_VALUE_PATTERN = /([^}])\}*$/;
	var RULE_WORD_SEPARATOR_PATTERN = /[\s(]/;

	function tokenize(source, externalContext) {
	  var internalContext = {
	    level: Level.BLOCK,
	    position: {
	      source: externalContext.source || undefined,
	      line: 1,
	      column: 0,
	      index: 0
	    }
	  };

	  return intoTokens(source, externalContext, internalContext, false);
	}

	function intoTokens(source, externalContext, internalContext, isNested) {
	  var allTokens = [];
	  var newTokens = allTokens;
	  var lastToken;
	  var ruleToken;
	  var ruleTokens = [];
	  var propertyToken;
	  var metadata;
	  var metadatas = [];
	  var level = internalContext.level;
	  var levels = [];
	  var buffer = [];
	  var buffers = [];
	  var isBufferEmpty = true;
	  var serializedBuffer;
	  var serializedBufferPart;
	  var roundBracketLevel = 0;
	  var isQuoted;
	  var isSpace;
	  var isNewLineNix;
	  var isNewLineWin;
	  var isCarriageReturn;
	  var isCommentStart;
	  var wasCommentStart = false;
	  var isCommentEnd;
	  var wasCommentEnd = false;
	  var isCommentEndMarker;
	  var isEscaped;
	  var wasEscaped = false;
	  var characterWithNoSpecialMeaning;
	  var isPreviousDash = false;
	  var isVariable = false;
	  var isRaw = false;
	  var seekingValue = false;
	  var seekingPropertyBlockClosing = false;
	  var position = internalContext.position;
	  var lastCommentStartAt;

	  for (; position.index < source.length; position.index++) {
	    var character = source[position.index];

	    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
	    isSpace = character == Marker.SPACE || character == Marker.TAB;
	    isNewLineNix = character == Marker.NEW_LINE_NIX;
	    isNewLineWin = character == Marker.NEW_LINE_NIX
	      && source[position.index - 1] == Marker.CARRIAGE_RETURN;
	    isCarriageReturn = character == Marker.CARRIAGE_RETURN
	      && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;
	    isCommentStart = !wasCommentEnd
	      && level != Level.COMMENT && !isQuoted
	      && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;
	    isCommentEndMarker = !wasCommentStart
	      && !isQuoted && character == Marker.FORWARD_SLASH
	      && source[position.index - 1] == Marker.ASTERISK;
	    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;
	    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');
	    isVariable = isVariable || (level != Level.COMMENT && !seekingValue && isPreviousDash && character === '-' && buffer.length === 1);
	    isPreviousDash = character === '-';
	    roundBracketLevel = Math.max(roundBracketLevel, 0);

	    metadata = isBufferEmpty
	      ? [position.line, position.column, position.source]
	      : metadata;

	    if (isEscaped) {
	      // previous character was a backslash
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (characterWithNoSpecialMeaning) {
	      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) ; else if (!isCommentEnd && level == Level.COMMENT) {
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (!isCommentStart && !isCommentEnd && isRaw) {
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (isCommentStart
	        && isVariable
	        && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
	      // comment start within a variable, e.g. var(/*<--
	      buffer.push(character);
	      isBufferEmpty = false;

	      levels.push(level);
	      level = Level.COMMENT;
	    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
	      // comment start within block preceded by some content, e.g. div/*<--
	      metadatas.push(metadata);
	      buffer.push(character);
	      buffers.push(buffer.slice(0, -2));
	      isBufferEmpty = false;

	      buffer = buffer.slice(-2);
	      metadata = [position.line, position.column - 1, position.source];

	      levels.push(level);
	      level = Level.COMMENT;
	    } else if (isCommentStart) {
	      // comment start, e.g. /*<--
	      levels.push(level);
	      level = Level.COMMENT;
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (isCommentEnd && isVariable) {
	      // comment end within a variable, e.g. var(/*!*/<--
	      buffer.push(character);
	      level = levels.pop();
	    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {
	      // ignore:start comment end, e.g. /* clean-css ignore:start */<--
	      serializedBuffer = buffer.join('').trim() + character;
	      lastToken = [
	        Token.COMMENT,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ];
	      newTokens.push(lastToken);

	      isRaw = true;
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	      isBufferEmpty = buffer.length === 0;
	    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {
	      // ignore:start comment end, e.g. /* clean-css ignore:end */<--
	      serializedBuffer = buffer.join('') + character;
	      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);

	      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
	      lastToken = [
	        Token.RAW,
	        serializedBufferPart,
	        [originalMetadata(metadata, serializedBufferPart, externalContext)]
	      ];
	      newTokens.push(lastToken);

	      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
	      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
	      lastToken = [
	        Token.COMMENT,
	        serializedBufferPart,
	        [originalMetadata(metadata, serializedBufferPart, externalContext)]
	      ];
	      newTokens.push(lastToken);

	      isRaw = false;
	      level = levels.pop();
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	      isBufferEmpty = buffer.length === 0;
	    } else if (isCommentEnd) {
	      // comment end, e.g. /* comment */<--
	      serializedBuffer = buffer.join('').trim() + character;
	      lastToken = [
	        Token.COMMENT,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ];
	      newTokens.push(lastToken);

	      level = levels.pop();
	      metadata = metadatas.pop() || null;
	      buffer = buffers.pop() || [];
	      isBufferEmpty = buffer.length === 0;
	    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {
	      externalContext.warnings.push('Unexpected \'*/\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
	      // single quotation start, e.g. a[href^='https<--
	      levels.push(level);
	      level = Level.SINGLE_QUOTE;
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
	      // single quotation end, e.g. a[href^='https'<--
	      level = levels.pop();
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
	      // double quotation start, e.g. a[href^="<--
	      levels.push(level);
	      level = Level.DOUBLE_QUOTE;
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
	      // double quotation end, e.g. a[href^="https"<--
	      level = levels.pop();
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character != Marker.CLOSE_ROUND_BRACKET
	      && character != Marker.OPEN_ROUND_BRACKET
	      && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {
	      // character inside any function, e.g. hsla(.<--
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.OPEN_ROUND_BRACKET
	      && !isQuoted && level != Level.COMMENT
	      && !seekingValue) {
	      // round open bracket, e.g. @import url(<--
	      buffer.push(character);
	      isBufferEmpty = false;

	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET
	      && !isQuoted
	      && level != Level.COMMENT
	      && !seekingValue) {
	      // round open bracket, e.g. @import url(test.css)<--
	      buffer.push(character);
	      isBufferEmpty = false;

	      roundBracketLevel--;
	    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {
	      // semicolon ending rule at block level, e.g. @import '...';<--
	      serializedBuffer = buffer.join('').trim();
	      allTokens.push([
	        Token.AT_RULE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {
	      // comma separator at block level, e.g. a,div,<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([
	        tokenScopeFrom(ruleToken[0]),
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {
	      // comma separator at block level, e.g. @import url(...) screen,<--
	      // keep iterating as end semicolon will create the token
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.COMMA && level == Level.BLOCK) {
	      // comma separator at block level, e.g. a,<--
	      ruleToken = [tokenTypeFrom(buffer), [], []];
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([
	        tokenScopeFrom(ruleToken[0]),
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext, 0)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.OPEN_CURLY_BRACKET
	      && level == Level.BLOCK
	      && ruleToken
	      && ruleToken[0] == Token.NESTED_BLOCK) {
	      // open brace opening at-rule at block level, e.g. @media{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([
	        Token.NESTED_BLOCK_SCOPE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      allTokens.push(ruleToken);

	      levels.push(level);
	      position.column++;
	      position.index++;
	      buffer = [];
	      isBufferEmpty = true;

	      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
	      ruleToken = null;
	    } else if (character == Marker.OPEN_CURLY_BRACKET
	      && level == Level.BLOCK
	      && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
	      // open brace opening at-rule at block level, e.g. @media{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
	      ruleToken[1].push([
	        Token.NESTED_BLOCK_SCOPE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      allTokens.push(ruleToken);

	      levels.push(level);
	      position.column++;
	      position.index++;
	      buffer = [];
	      isBufferEmpty = true;
	      isVariable = false;

	      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
	      ruleToken = null;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {
	      // open brace opening rule at block level, e.g. div{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
	      ruleToken[1].push([
	        tokenScopeFrom(ruleToken[0]),
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]
	      ]);
	      newTokens = ruleToken[2];
	      allTokens.push(ruleToken);

	      levels.push(level);
	      level = Level.RULE;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {
	      // open brace opening rule at rule level, e.g. div{--variable:{<--
	      ruleTokens.push(ruleToken);
	      ruleToken = [Token.PROPERTY_BLOCK, []];
	      propertyToken.push(ruleToken);
	      newTokens = ruleToken[1];

	      levels.push(level);
	      level = Level.RULE;
	      seekingValue = false;
	    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {
	      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--
	      serializedBuffer = buffer.join('').trim();
	      ruleTokens.push(ruleToken);
	      ruleToken = [Token.AT_RULE_BLOCK, [], []];
	      ruleToken[1].push([
	        Token.AT_RULE_BLOCK_SCOPE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      newTokens.push(ruleToken);
	      newTokens = ruleToken[2];

	      levels.push(level);
	      level = Level.RULE;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {
	      // colon at rule level, e.g. a{color:<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken = [
	        Token.PROPERTY,
	        [
	          Token.PROPERTY_NAME,
	          serializedBuffer,
	          [originalMetadata(metadata, serializedBuffer, externalContext)]
	        ]
	      ];
	      newTokens.push(propertyToken);

	      seekingValue = true;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.SEMICOLON
	      && level == Level.RULE
	      && propertyToken
	      && ruleTokens.length > 0
	      && !isBufferEmpty
	      && buffer[0] == Marker.AT) {
	      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--
	      serializedBuffer = buffer.join('').trim();
	      ruleToken[1].push([
	        Token.AT_RULE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {
	      // semicolon at rule level, e.g. a{color:red;<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      propertyToken = null;
	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	      isVariable = false;
	    } else if (character == Marker.SEMICOLON
	      && level == Level.RULE
	      && propertyToken
	      && isBufferEmpty
	      && isVariable
	      && !propertyToken[2]) {
	      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--
	      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);
	      isVariable = false;
	      propertyToken = null;
	      seekingValue = false;
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {
	      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--
	      propertyToken = null;
	      seekingValue = false;
	    } else if (character == Marker.SEMICOLON
	      && level == Level.RULE
	      && !isBufferEmpty
	      && buffer[0] == Marker.AT) {
	      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--
	      serializedBuffer = buffer.join('');
	      newTokens.push([
	        Token.AT_RULE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {
	      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--
	      seekingPropertyBlockClosing = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) ; else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && propertyToken
	      && seekingValue
	      && !isBufferEmpty && ruleTokens.length > 0) {
	      // close brace at rule level, e.g. a{--color:{color:red}<--
	      serializedBuffer = buffer.join('');
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && propertyToken
	      && !isBufferEmpty
	      && buffer[0] == Marker.AT
	      && ruleTokens.length > 0) {
	      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--
	      serializedBuffer = buffer.join('');
	      ruleToken[1].push([
	        Token.AT_RULE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && propertyToken
	      && ruleTokens.length > 0) {
	      // close brace at rule level after space, e.g. a{--color:{color:red }<--
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && propertyToken
	      && !isBufferEmpty) {
	      // close brace at rule level, e.g. a{color:red}<--
	      serializedBuffer = buffer.join('');
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && !isBufferEmpty
	      && buffer[0] == Marker.AT) {
	      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--
	      propertyToken = null;
	      ruleToken = null;
	      serializedBuffer = buffer.join('').trim();
	      newTokens.push([
	        Token.AT_RULE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && levels[levels.length - 1] == Level.RULE) {
	      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--
	      propertyToken = null;
	      ruleToken = ruleTokens.pop();
	      newTokens = ruleToken[2];

	      level = levels.pop();
	      seekingValue = false;
	      seekingPropertyBlockClosing = true;
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.RULE
	      && isVariable
	      && propertyToken
	      && !propertyToken[2]) {
	      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--
	      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);
	      isVariable = false;
	      propertyToken = null;
	      ruleToken = null;
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      isVariable = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {
	      // close brace after a rule, e.g. a{color:red;}<--
	      propertyToken = null;
	      ruleToken = null;
	      newTokens = allTokens;

	      level = levels.pop();
	      seekingValue = false;
	      isVariable = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET
	      && level == Level.BLOCK
	      && !isNested
	      && position.index <= source.length - 1) {
	      // stray close brace at block level, e.g. a{color:red}color:blue}<--
	      externalContext.warnings.push('Unexpected \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	      buffer.push(character);
	      isBufferEmpty = false;
	    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {
	      // close brace at block level, e.g. @media screen {...}<--
	      break;
	    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {
	      // round open bracket, e.g. a{color:hsla(<--
	      buffer.push(character);
	      isBufferEmpty = false;
	      roundBracketLevel++;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET
	      && level == Level.RULE
	      && seekingValue
	      && roundBracketLevel == 1) {
	      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--
	      buffer.push(character);
	      isBufferEmpty = false;
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      roundBracketLevel--;
	      buffer = [];
	      isBufferEmpty = true;
	      isVariable = false;
	    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {
	      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--
	      buffer.push(character);
	      isBufferEmpty = false;
	      isVariable = false;
	      roundBracketLevel--;
	    } else if (character == Marker.FORWARD_SLASH
	      && source[position.index + 1] != Marker.ASTERISK
	      && level == Level.RULE
	      && seekingValue
	      && !isBufferEmpty) {
	      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        character,
	        [[position.line, position.column, position.source]]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.FORWARD_SLASH
	      && source[position.index + 1] != Marker.ASTERISK
	      && level == Level.RULE
	      && seekingValue) {
	      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        character,
	        [[position.line, position.column, position.source]]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {
	      // comma within a property, e.g. a{background:url(image.png),<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        character,
	        [[position.line, position.column, position.source]]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {
	      // comma within a property after space, e.g. a{background:url(image.png) ,<--
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        character,
	        [[position.line, position.column, position.source]]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (character == Marker.CLOSE_SQUARE_BRACKET
	      && propertyToken
	      && propertyToken.length > 1
	      && !isBufferEmpty
	      && isRepeatToken(buffer)) {
	      buffer.push(character);
	      serializedBuffer = buffer.join('').trim();
	      propertyToken[propertyToken.length - 1][1] += serializedBuffer;

	      buffer = [];
	      isBufferEmpty = true;
	    } else if ((isSpace || (isNewLineNix && !isNewLineWin))
	      && level == Level.RULE
	      && seekingValue
	      && propertyToken
	      && !isBufferEmpty) {
	      // space or *nix newline within property, e.g. a{margin:0 <--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {
	      // win newline within property, e.g. a{margin:0\r\n<--
	      serializedBuffer = buffer.join('').trim();
	      propertyToken.push([
	        Token.PROPERTY_VALUE,
	        serializedBuffer,
	        [originalMetadata(metadata, serializedBuffer, externalContext)]
	      ]);

	      buffer = [];
	      isBufferEmpty = true;
	    } else if (isNewLineWin && level == Level.RULE && seekingValue) {
	      // win newline
	      buffer = [];
	      isBufferEmpty = true;
	    } else if (isNewLineWin && buffer.length == 1) {
	      // ignore windows newline which is composed of two characters
	      buffer.pop();
	      isBufferEmpty = buffer.length === 0;
	    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {
	      // any character
	      buffer.push(character);
	      isBufferEmpty = false;
	    }

	    wasEscaped = isEscaped;
	    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;
	    wasCommentStart = isCommentStart;
	    wasCommentEnd = isCommentEnd;

	    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;
	    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;
	  }

	  if (seekingValue) {
	    externalContext.warnings.push('Missing \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
	  }

	  if (seekingValue && buffer.length > 0) {
	    serializedBuffer = buffer.join('').trimRight().replace(TAIL_BROKEN_VALUE_PATTERN, '$1').trimRight();
	    propertyToken.push([
	      Token.PROPERTY_VALUE,
	      serializedBuffer,
	      [originalMetadata(metadata, serializedBuffer, externalContext)]
	    ]);

	    buffer = [];
	  }

	  if (buffer.length > 0) {
	    externalContext.warnings.push('Invalid character(s) \'' + buffer.join('') + '\' at ' + formatPosition(metadata) + '. Ignoring.');
	  }

	  return allTokens;
	}

	function isIgnoreStartComment(buffer) {
	  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
	}

	function isIgnoreEndComment(buffer) {
	  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
	}

	function originalMetadata(metadata, value, externalContext, selectorFallbacks) {
	  var source = metadata[2];

	  return externalContext.inputSourceMapTracker.isTracking(source)
	    ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks)
	    : metadata;
	}

	function tokenTypeFrom(buffer) {
	  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
	  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];

	  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {
	    return Token.NESTED_BLOCK;
	  } if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {
	    return Token.AT_RULE;
	  } if (isAtRule) {
	    return Token.AT_RULE_BLOCK;
	  }
	  return Token.RULE;
	}

	function tokenScopeFrom(tokenType) {
	  if (tokenType == Token.RULE) {
	    return Token.RULE_SCOPE;
	  } if (tokenType == Token.NESTED_BLOCK) {
	    return Token.NESTED_BLOCK_SCOPE;
	  } if (tokenType == Token.AT_RULE_BLOCK) {
	    return Token.AT_RULE_BLOCK_SCOPE;
	  }
	}

	function isPageMarginBox(buffer) {
	  var serializedBuffer = buffer.join('').trim();

	  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;
	}

	function isRepeatToken(buffer) {
	  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);
	}

	tokenize_1 = tokenize;
	return tokenize_1;
}

var readSources_1;
var hasRequiredReadSources;

function requireReadSources () {
	if (hasRequiredReadSources) return readSources_1;
	hasRequiredReadSources = 1;
	var fs = fs$1;
	var path = require$$0$4;

	var applySourceMaps = requireApplySourceMaps();
	var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
	var isAllowedResource = requireIsAllowedResource();
	var loadOriginalSources = requireLoadOriginalSources();
	var normalizePath = requireNormalizePath();
	var rebase = requireRebase();
	var rebaseLocalMap = requireRebaseLocalMap();
	var rebaseRemoteMap = requireRebaseRemoteMap();
	var restoreImport = requireRestoreImport();

	var tokenize = requireTokenize();
	var Token = requireToken();
	var Marker = requireMarker();
	var hasProtocol = requireHasProtocol();
	var isImport = requireIsImport();
	var isRemoteResource = requireIsRemoteResource();

	var UNKNOWN_URI = 'uri:unknown';
	var FILE_RESOURCE_PROTOCOL = 'file://';

	function readSources(input, context, callback) {
	  return doReadSources(input, context, function(tokens) {
	    return applySourceMaps(tokens, context, function() {
	      return loadOriginalSources(context, function() { return callback(tokens); });
	    });
	  });
	}

	function doReadSources(input, context, callback) {
	  if (typeof input == 'string') {
	    return fromString(input, context, callback);
	  } if (Buffer.isBuffer(input)) {
	    return fromString(input.toString(), context, callback);
	  } if (Array.isArray(input)) {
	    return fromArray(input, context, callback);
	  } if (typeof input == 'object') {
	    return fromHash(input, context, callback);
	  }
	}

	function fromString(input, context, callback) {
	  context.source = undefined;
	  context.sourcesContent[undefined] = input;
	  context.stats.originalSize += input.length;

	  return fromStyles(input, context, { inline: context.options.inline }, callback);
	}

	function fromArray(input, context, callback) {
	  var inputAsImports = input.reduce(function(accumulator, uriOrHash) {
	    if (typeof uriOrHash === 'string') {
	      return addStringSource(uriOrHash, accumulator);
	    }
	    return addHashSource(uriOrHash, context, accumulator);
	  }, []);

	  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);
	}

	function fromHash(input, context, callback) {
	  var inputAsImports = addHashSource(input, context, []);
	  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);
	}

	function addStringSource(input, imports) {
	  imports.push(restoreAsImport(normalizeUri(input)));
	  return imports;
	}

	function addHashSource(input, context, imports) {
	  var uri;
	  var normalizedUri;
	  var source;

	  for (uri in input) {
	    source = input[uri];
	    normalizedUri = normalizeUri(uri);

	    imports.push(restoreAsImport(normalizedUri));

	    context.sourcesContent[normalizedUri] = source.styles;

	    if (source.sourceMap) {
	      trackSourceMap(source.sourceMap, normalizedUri, context);
	    }
	  }

	  return imports;
	}

	function normalizeUri(uri) {
	  var currentPath = path.resolve('');
	  var absoluteUri;
	  var relativeToCurrentPath;
	  var normalizedUri;

	  if (isRemoteResource(uri)) {
	    return uri;
	  }

	  absoluteUri = path.isAbsolute(uri)
	    ? uri
	    : path.resolve(uri);
	  relativeToCurrentPath = path.relative(currentPath, absoluteUri);
	  normalizedUri = normalizePath(relativeToCurrentPath);

	  return normalizedUri;
	}

	function trackSourceMap(sourceMap, uri, context) {
	  var parsedMap = typeof sourceMap == 'string'
	    ? JSON.parse(sourceMap)
	    : sourceMap;
	  var rebasedMap = isRemoteResource(uri)
	    ? rebaseRemoteMap(parsedMap, uri)
	    : rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);

	  context.inputSourceMapTracker.track(uri, rebasedMap);
	}

	function restoreAsImport(uri) {
	  return restoreImport('url(' + uri + ')', '') + Marker.SEMICOLON;
	}

	function fromStyles(styles, context, parentInlinerContext, callback) {
	  var tokens;
	  var rebaseConfig = {};

	  if (!context.source) {
	    rebaseConfig.fromBase = path.resolve('');
	    rebaseConfig.toBase = context.options.rebaseTo;
	  } else if (isRemoteResource(context.source)) {
	    rebaseConfig.fromBase = context.source;
	    rebaseConfig.toBase = context.source;
	  } else if (path.isAbsolute(context.source)) {
	    rebaseConfig.fromBase = path.dirname(context.source);
	    rebaseConfig.toBase = context.options.rebaseTo;
	  } else {
	    rebaseConfig.fromBase = path.dirname(path.resolve(context.source));
	    rebaseConfig.toBase = context.options.rebaseTo;
	  }

	  tokens = tokenize(styles, context);
	  tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);

	  return allowsAnyImports(parentInlinerContext.inline)
	    ? inline(tokens, context, parentInlinerContext, callback)
	    : callback(tokens);
	}

	function allowsAnyImports(inline) {
	  return !(inline.length == 1 && inline[0] == 'none');
	}

	function inline(tokens, externalContext, parentInlinerContext, callback) {
	  var inlinerContext = {
	    afterContent: false,
	    callback: callback,
	    errors: externalContext.errors,
	    externalContext: externalContext,
	    fetch: externalContext.options.fetch,
	    inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,
	    inline: parentInlinerContext.inline,
	    inlineRequest: externalContext.options.inlineRequest,
	    inlineTimeout: externalContext.options.inlineTimeout,
	    isRemote: parentInlinerContext.isRemote || false,
	    localOnly: externalContext.localOnly,
	    outputTokens: [],
	    rebaseTo: externalContext.options.rebaseTo,
	    sourceTokens: tokens,
	    warnings: externalContext.warnings
	  };

	  return doInlineImports(inlinerContext);
	}

	function doInlineImports(inlinerContext) {
	  var token;
	  var i, l;

	  for (i = 0, l = inlinerContext.sourceTokens.length; i < l; i++) {
	    token = inlinerContext.sourceTokens[i];

	    if (token[0] == Token.AT_RULE && isImport(token[1])) {
	      inlinerContext.sourceTokens.splice(0, i);
	      return inlineStylesheet(token, inlinerContext);
	    } if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
	      inlinerContext.outputTokens.push(token);
	    } else {
	      inlinerContext.outputTokens.push(token);
	      inlinerContext.afterContent = true;
	    }
	  }

	  inlinerContext.sourceTokens = [];
	  return inlinerContext.callback(inlinerContext.outputTokens);
	}

	function inlineStylesheet(token, inlinerContext) {
	  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
	  var uri = uriAndMediaQuery[0];
	  var mediaQuery = uriAndMediaQuery[1];
	  var metadata = token[2];

	  return isRemoteResource(uri)
	    ? inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext)
	    : inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);
	}

	function inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) {
	  var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);
	  var originalUri = uri;
	  var isLoaded = uri in inlinerContext.externalContext.sourcesContent;
	  var isRuntimeResource = !hasProtocol(uri);

	  if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as it has already been imported.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } if (inlinerContext.localOnly && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as no callback given and after other content.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } if (isRuntimeResource) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no protocol given.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } if (inlinerContext.localOnly && !isLoaded) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no callback given.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } if (!isAllowed && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as resource is not allowed and after other content.');
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  } if (!isAllowed) {
	    inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as resource is not allowed.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	    return doInlineImports(inlinerContext);
	  }

	  inlinerContext.inlinedStylesheets.push(uri);

	  function whenLoaded(error, importedStyles) {
	    if (error) {
	      inlinerContext.errors.push('Broken @import declaration of "' + uri + '" - ' + error);

	      return process.nextTick(function() {
	        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
	        doInlineImports(inlinerContext);
	      });
	    }

	    inlinerContext.inline = inlinerContext.externalContext.options.inline;
	    inlinerContext.isRemote = true;

	    inlinerContext.externalContext.source = originalUri;
	    inlinerContext.externalContext.sourcesContent[uri] = importedStyles;
	    inlinerContext.externalContext.stats.originalSize += importedStyles.length;

	    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
	      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);

	      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
	      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	      return doInlineImports(inlinerContext);
	    });
	  }

	  return isLoaded
	    ? whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri])
	    : inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);
	}

	function inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext) {
	  var protocolLessUri = uri.replace(FILE_RESOURCE_PROTOCOL, '');
	  var currentPath = path.resolve('');
	  var absoluteUri = path.isAbsolute(protocolLessUri)
	    ? path.resolve(currentPath, protocolLessUri[0] == '/' ? protocolLessUri.substring(1) : protocolLessUri)
	    : path.resolve(inlinerContext.rebaseTo, protocolLessUri);
	  var relativeToCurrentPath = path.relative(currentPath, absoluteUri);
	  var importedStyles;
	  var isAllowed = isAllowedResource(protocolLessUri, false, inlinerContext.inline);
	  var normalizedPath = normalizePath(relativeToCurrentPath);
	  var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;

	  if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + protocolLessUri + '" as it has already been imported.');
	  } else if (isAllowed && !isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {
	    inlinerContext.errors.push('Ignoring local @import of "' + protocolLessUri + '" as resource is missing.');
	  } else if (!isAllowed && inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + protocolLessUri + '" as resource is not allowed and after other content.');
	  } else if (inlinerContext.afterContent) {
	    inlinerContext.warnings.push('Ignoring local @import of "' + protocolLessUri + '" as after other content.');
	  } else if (!isAllowed) {
	    inlinerContext.warnings.push('Skipping local @import of "' + protocolLessUri + '" as resource is not allowed.');
	    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
	  } else {
	    importedStyles = isLoaded
	      ? inlinerContext.externalContext.sourcesContent[normalizedPath]
	      : fs.readFileSync(absoluteUri, 'utf-8');

	    if (importedStyles.charCodeAt(0) === 65279) {
	      importedStyles = importedStyles.substring(1);
	    }

	    inlinerContext.inlinedStylesheets.push(absoluteUri);
	    inlinerContext.inline = inlinerContext.externalContext.options.inline;

	    inlinerContext.externalContext.source = normalizedPath;
	    inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;
	    inlinerContext.externalContext.stats.originalSize += importedStyles.length;

	    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function(importedTokens) {
	      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);

	      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
	      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	      return doInlineImports(inlinerContext);
	    });
	  }

	  inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);

	  return doInlineImports(inlinerContext);
	}

	function wrapInMedia(tokens, mediaQuery, metadata) {
	  if (mediaQuery) {
	    return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, '@media ' + mediaQuery, metadata]], tokens]];
	  }
	  return tokens;
	}

	readSources_1 = readSources;
	return readSources_1;
}

var simple;
var hasRequiredSimple;

function requireSimple () {
	if (hasRequiredSimple) return simple;
	hasRequiredSimple = 1;
	var all = requireHelpers().all;

	function store(serializeContext, token) {
	  var value = typeof token == 'string'
	    ? token
	    : token[1];
	  var wrap = serializeContext.wrap;

	  wrap(serializeContext, value);
	  track(serializeContext, value);
	  serializeContext.output.push(value);
	}

	function wrap(serializeContext, value) {
	  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
	    track(serializeContext, serializeContext.format.breakWith);
	    serializeContext.output.push(serializeContext.format.breakWith);
	  }
	}

	function track(serializeContext, value) {
	  var parts = value.split('\n');

	  serializeContext.line += parts.length - 1;
	  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);
	}

	function serializeStyles(tokens, context) {
	  var serializeContext = {
	    column: 0,
	    format: context.options.format,
	    indentBy: 0,
	    indentWith: '',
	    line: 1,
	    output: [],
	    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
	    store: store,
	    wrap: context.options.format.wrapAt
	      ? wrap
	      : function() { /* noop */ }
	  };

	  all(serializeContext, tokens);

	  return { styles: serializeContext.output.join('') };
	}

	simple = serializeStyles;
	return simple;
}

var sourceMaps;
var hasRequiredSourceMaps;

function requireSourceMaps () {
	if (hasRequiredSourceMaps) return sourceMaps;
	hasRequiredSourceMaps = 1;
	var SourceMapGenerator = requireSourceMap().SourceMapGenerator;
	var all = requireHelpers().all;

	var isRemoteResource = requireIsRemoteResource();

	var isWindows = process.platform == 'win32';

	var NIX_SEPARATOR_PATTERN = /\//g;
	var UNKNOWN_SOURCE = '$stdin';
	var WINDOWS_SEPARATOR = '\\';

	function store(serializeContext, element) {
	  var fromString = typeof element == 'string';
	  var value = fromString ? element : element[1];
	  var mappings = fromString ? null : element[2];
	  var wrap = serializeContext.wrap;

	  wrap(serializeContext, value);
	  track(serializeContext, value, mappings);
	  serializeContext.output.push(value);
	}

	function wrap(serializeContext, value) {
	  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
	    track(serializeContext, serializeContext.format.breakWith, false);
	    serializeContext.output.push(serializeContext.format.breakWith);
	  }
	}

	function track(serializeContext, value, mappings) {
	  var parts = value.split('\n');

	  if (mappings) {
	    trackAllMappings(serializeContext, mappings);
	  }

	  serializeContext.line += parts.length - 1;
	  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);
	}

	function trackAllMappings(serializeContext, mappings) {
	  for (var i = 0, l = mappings.length; i < l; i++) {
	    trackMapping(serializeContext, mappings[i]);
	  }
	}

	function trackMapping(serializeContext, mapping) {
	  var line = mapping[0];
	  var column = mapping[1];
	  var originalSource = mapping[2];
	  var source = originalSource;
	  var storedSource = source || UNKNOWN_SOURCE;

	  if (isWindows && source && !isRemoteResource(source)) {
	    storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);
	  }

	  serializeContext.outputMap.addMapping({
	    generated: {
	      line: serializeContext.line,
	      column: serializeContext.column
	    },
	    source: storedSource,
	    original: {
	      line: line,
	      column: column
	    }
	  });

	  if (serializeContext.inlineSources && (originalSource in serializeContext.sourcesContent)) {
	    serializeContext.outputMap.setSourceContent(
	      storedSource,
	      serializeContext.sourcesContent[originalSource]
	    );
	  }
	}

	function serializeStylesAndSourceMap(tokens, context) {
	  var serializeContext = {
	    column: 0,
	    format: context.options.format,
	    indentBy: 0,
	    indentWith: '',
	    inlineSources: context.options.sourceMapInlineSources,
	    line: 1,
	    output: [],
	    outputMap: new SourceMapGenerator(),
	    sourcesContent: context.sourcesContent,
	    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
	    store: store,
	    wrap: context.options.format.wrapAt
	      ? wrap
	      : function() { /* noop */ }
	  };

	  all(serializeContext, tokens);

	  return {
	    sourceMap: serializeContext.outputMap,
	    styles: serializeContext.output.join('')
	  };
	}

	sourceMaps = serializeStylesAndSourceMap;
	return sourceMaps;
}

/**
 * Clean-css - https://github.com/clean-css/clean-css
 * Released under the terms of MIT license
 */

var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean.exports;
	hasRequiredClean = 1;
	var level0Optimize = requireOptimize$3();
	var level1Optimize = requireOptimize$2();
	var level2Optimize = requireOptimize();
	var validator = requireValidator();

	var compatibilityFrom = requireCompatibility();
	var fetchFrom = requireFetch();
	var formatFrom = requireFormat$1().formatFrom;
	var inlineFrom = requireInline();
	var inlineRequestFrom = requireInlineRequest();
	var inlineTimeoutFrom = requireInlineTimeout();
	var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
	var optimizationLevelFrom = requireOptimizationLevel().optimizationLevelFrom;
	var pluginsFrom = requirePlugins();
	var rebaseFrom = requireRebase$1();
	var rebaseToFrom = requireRebaseTo();

	var inputSourceMapTracker = requireInputSourceMapTracker();
	var readSources = requireReadSources();

	var serializeStyles = requireSimple();
	var serializeStylesAndSourceMap = requireSourceMaps();

	var CleanCSS = clean.exports = function CleanCSS(options) {
	  options = options || {};

	  this.options = {
	    batch: !!options.batch,
	    compatibility: compatibilityFrom(options.compatibility),
	    explicitRebaseTo: 'rebaseTo' in options,
	    fetch: fetchFrom(options.fetch),
	    format: formatFrom(options.format),
	    inline: inlineFrom(options.inline),
	    inlineRequest: inlineRequestFrom(options.inlineRequest),
	    inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),
	    level: optimizationLevelFrom(options.level),
	    plugins: pluginsFrom(options.plugins),
	    rebase: rebaseFrom(options.rebase, options.rebaseTo),
	    rebaseTo: rebaseToFrom(options.rebaseTo),
	    returnPromise: !!options.returnPromise,
	    sourceMap: !!options.sourceMap,
	    sourceMapInlineSources: !!options.sourceMapInlineSources
	  };
	};

	// for compatibility with optimize-css-assets-webpack-plugin
	CleanCSS.process = function(input, opts) {
	  var cleanCss;
	  var optsTo = opts.to;

	  delete opts.to;
	  cleanCss = new CleanCSS(Object.assign({
	    returnPromise: true, rebaseTo: optsTo
	  }, opts));

	  return cleanCss.minify(input)
	    .then(function(output) {
	      return { css: output.styles };
	    });
	};

	CleanCSS.prototype.minify = function(input, maybeSourceMap, maybeCallback) {
	  var options = this.options;

	  if (options.returnPromise) {
	    return new Promise(function(resolve, reject) {
	      minifyAll(input, options, maybeSourceMap, function(errors, output) {
	        return errors
	          ? reject(errors)
	          : resolve(output);
	      });
	    });
	  }
	  return minifyAll(input, options, maybeSourceMap, maybeCallback);
	};

	function minifyAll(input, options, maybeSourceMap, maybeCallback) {
	  if (options.batch && Array.isArray(input)) {
	    return minifyInBatchesFromArray(input, options, maybeSourceMap, maybeCallback);
	  } if (options.batch && (typeof input == 'object')) {
	    return minifyInBatchesFromHash(input, options, maybeSourceMap, maybeCallback);
	  }
	  return minify(input, options, maybeSourceMap, maybeCallback);
	}

	function minifyInBatchesFromArray(input, options, maybeSourceMap, maybeCallback) {
	  var callback = typeof maybeCallback == 'function'
	    ? maybeCallback
	    : (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);
	  var errors = [];
	  var outputAsHash = {};
	  var inputValue;
	  var i, l;

	  function whenHashBatchDone(innerErrors, output) {
	    outputAsHash = Object.assign(outputAsHash, output);

	    if (innerErrors !== null) {
	      errors = errors.concat(innerErrors);
	    }
	  }

	  for (i = 0, l = input.length; i < l; i++) {
	    if (typeof input[i] == 'object') {
	      minifyInBatchesFromHash(input[i], options, whenHashBatchDone);
	    } else {
	      inputValue = input[i];

	      outputAsHash[inputValue] = minify([inputValue], options);
	      errors = errors.concat(outputAsHash[inputValue].errors);
	    }
	  }

	  return callback
	    ? callback(errors.length > 0 ? errors : null, outputAsHash)
	    : outputAsHash;
	}

	function minifyInBatchesFromHash(input, options, maybeSourceMap, maybeCallback) {
	  var callback = typeof maybeCallback == 'function'
	    ? maybeCallback
	    : (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);
	  var errors = [];
	  var outputAsHash = {};
	  var inputKey;
	  var inputValue;

	  for (inputKey in input) {
	    inputValue = input[inputKey];

	    outputAsHash[inputKey] = minify(inputValue.styles, options, inputValue.sourceMap);
	    errors = errors.concat(outputAsHash[inputKey].errors);
	  }

	  return callback
	    ? callback(errors.length > 0 ? errors : null, outputAsHash)
	    : outputAsHash;
	}

	function minify(input, options, maybeSourceMap, maybeCallback) {
	  var sourceMap = typeof maybeSourceMap != 'function'
	    ? maybeSourceMap
	    : null;
	  var callback = typeof maybeCallback == 'function'
	    ? maybeCallback
	    : (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);
	  var context = {
	    stats: {
	      efficiency: 0,
	      minifiedSize: 0,
	      originalSize: 0,
	      startedAt: Date.now(),
	      timeSpent: 0
	    },
	    cache: { specificity: {} },
	    errors: [],
	    inlinedStylesheets: [],
	    inputSourceMapTracker: inputSourceMapTracker(),
	    localOnly: !callback,
	    options: options,
	    source: null,
	    sourcesContent: {},
	    validator: validator(options.compatibility),
	    warnings: []
	  };
	  var implicitRebaseToWarning;

	  if (sourceMap) {
	    context.inputSourceMapTracker.track(undefined, sourceMap);
	  }

	  if (options.rebase && !options.explicitRebaseTo) {
	    implicitRebaseToWarning = 'You have set `rebase: true` without giving `rebaseTo` option, which, in this case, defaults to the current working directory. '
	      + 'You are then warned this can lead to unexpected URL rebasing (aka here be dragons)! '
	      + 'If you are OK with the clean-css output, then you can get rid of this warning by giving clean-css a `rebaseTo: process.cwd()` option.';
	    context.warnings.push(implicitRebaseToWarning);
	  }

	  return runner(context.localOnly)(function() {
	    return readSources(input, context, function(tokens) {
	      var serialize = context.options.sourceMap
	        ? serializeStylesAndSourceMap
	        : serializeStyles;

	      var optimizedTokens = optimize(tokens, context);
	      var optimizedStyles = serialize(optimizedTokens, context);
	      var output = withMetadata(optimizedStyles, context);

	      return callback
	        ? callback(context.errors.length > 0 ? context.errors : null, output)
	        : output;
	    });
	  });
	}

	function runner(localOnly) {
	  // to always execute code asynchronously when a callback is given
	  // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony
	  return localOnly
	    ? function(callback) { return callback(); }
	    : process.nextTick;
	}

	function optimize(tokens, context) {
	  var optimized = level0Optimize(tokens, context);

	  optimized = OptimizationLevel.One in context.options.level
	    ? level1Optimize(tokens, context)
	    : tokens;
	  optimized = OptimizationLevel.Two in context.options.level
	    ? level2Optimize(tokens, context, true)
	    : optimized;

	  return optimized;
	}

	function withMetadata(output, context) {
	  output.stats = calculateStatsFrom(output.styles, context);
	  output.errors = context.errors;
	  output.inlinedStylesheets = context.inlinedStylesheets;
	  output.warnings = context.warnings;

	  return output;
	}

	function calculateStatsFrom(styles, context) {
	  var finishedAt = Date.now();
	  var timeSpent = finishedAt - context.stats.startedAt;

	  delete context.stats.startedAt;
	  context.stats.timeSpent = timeSpent;
	  context.stats.efficiency = 1 - styles.length / context.stats.originalSize;
	  context.stats.minifiedSize = styles.length;

	  return context.stats;
	}
	return clean.exports;
}

var cleanCss;
var hasRequiredCleanCss;

function requireCleanCss () {
	if (hasRequiredCleanCss) return cleanCss;
	hasRequiredCleanCss = 1;
	cleanCss = requireClean();
	return cleanCss;
}

var he = {exports: {}};

/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
he.exports;

var hasRequiredHe;

function requireHe () {
	if (hasRequiredHe) return he.exports;
	hasRequiredHe = 1;
	(function (module, exports) {
(function(root) {

			// Detect free variables `exports`.
			var freeExports = exports;

			// Detect free variable `module`.
			var freeModule = module &&
				module.exports == freeExports && module;

			// Detect free variable `global`, from Node.js or Browserified code,
			// and use it as `root`.
			var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
			if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
				root = freeGlobal;
			}

			/*--------------------------------------------------------------------------*/

			// All astral symbols.
			var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
			// All ASCII symbols (not just printable ASCII) except those listed in the
			// first column of the overrides table.
			// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
			var regexAsciiWhitelist = /[\x01-\x7F]/g;
			// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
			// code points listed in the first column of the overrides table on
			// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
			var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

			var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
			var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

			var regexEscape = /["&'<>`]/g;
			var escapeMap = {
				'"': '&quot;',
				'&': '&amp;',
				'\'': '&#x27;',
				'<': '&lt;',
				// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
				// following is not strictly necessary unless it’s part of a tag or an
				// unquoted attribute value. We’re only escaping it to support those
				// situations, and for XML support.
				'>': '&gt;',
				// In Internet Explorer ≤ 8, the backtick character can be used
				// to break out of (un)quoted attribute values or HTML comments.
				// See http://html5sec.org/#102, http://html5sec.org/#108, and
				// http://html5sec.org/#133.
				'`': '&#x60;'
			};

			var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
			var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
			var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
			var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
			var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
			var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
			var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

			/*--------------------------------------------------------------------------*/

			var stringFromCharCode = String.fromCharCode;

			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			var has = function(object, propertyName) {
				return hasOwnProperty.call(object, propertyName);
			};

			var contains = function(array, value) {
				var index = -1;
				var length = array.length;
				while (++index < length) {
					if (array[index] == value) {
						return true;
					}
				}
				return false;
			};

			var merge = function(options, defaults) {
				if (!options) {
					return defaults;
				}
				var result = {};
				var key;
				for (key in defaults) {
					// A `hasOwnProperty` check is not needed here, since only recognized
					// option names are used anyway. Any others are ignored.
					result[key] = has(options, key) ? options[key] : defaults[key];
				}
				return result;
			};

			// Modified version of `ucs2encode`; see https://mths.be/punycode.
			var codePointToSymbol = function(codePoint, strict) {
				var output = '';
				if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
					// See issue #4:
					// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
					// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
					// REPLACEMENT CHARACTER.”
					if (strict) {
						parseError('character reference outside the permissible Unicode range');
					}
					return '\uFFFD';
				}
				if (has(decodeMapNumeric, codePoint)) {
					if (strict) {
						parseError('disallowed character reference');
					}
					return decodeMapNumeric[codePoint];
				}
				if (strict && contains(invalidReferenceCodePoints, codePoint)) {
					parseError('disallowed character reference');
				}
				if (codePoint > 0xFFFF) {
					codePoint -= 0x10000;
					output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
					codePoint = 0xDC00 | codePoint & 0x3FF;
				}
				output += stringFromCharCode(codePoint);
				return output;
			};

			var hexEscape = function(codePoint) {
				return '&#x' + codePoint.toString(16).toUpperCase() + ';';
			};

			var decEscape = function(codePoint) {
				return '&#' + codePoint + ';';
			};

			var parseError = function(message) {
				throw Error('Parse error: ' + message);
			};

			/*--------------------------------------------------------------------------*/

			var encode = function(string, options) {
				options = merge(options, encode.options);
				var strict = options.strict;
				if (strict && regexInvalidRawCodePoint.test(string)) {
					parseError('forbidden code point');
				}
				var encodeEverything = options.encodeEverything;
				var useNamedReferences = options.useNamedReferences;
				var allowUnsafeSymbols = options.allowUnsafeSymbols;
				var escapeCodePoint = options.decimal ? decEscape : hexEscape;

				var escapeBmpSymbol = function(symbol) {
					return escapeCodePoint(symbol.charCodeAt(0));
				};

				if (encodeEverything) {
					// Encode ASCII symbols.
					string = string.replace(regexAsciiWhitelist, function(symbol) {
						// Use named references if requested & possible.
						if (useNamedReferences && has(encodeMap, symbol)) {
							return '&' + encodeMap[symbol] + ';';
						}
						return escapeBmpSymbol(symbol);
					});
					// Shorten a few escapes that represent two symbols, of which at least one
					// is within the ASCII range.
					if (useNamedReferences) {
						string = string
							.replace(/&gt;\u20D2/g, '&nvgt;')
							.replace(/&lt;\u20D2/g, '&nvlt;')
							.replace(/&#x66;&#x6A;/g, '&fjlig;');
					}
					// Encode non-ASCII symbols.
					if (useNamedReferences) {
						// Encode non-ASCII symbols that can be replaced with a named reference.
						string = string.replace(regexEncodeNonAscii, function(string) {
							// Note: there is no need to check `has(encodeMap, string)` here.
							return '&' + encodeMap[string] + ';';
						});
					}
					// Note: any remaining non-ASCII symbols are handled outside of the `if`.
				} else if (useNamedReferences) {
					// Apply named character references.
					// Encode `<>"'&` using named character references.
					if (!allowUnsafeSymbols) {
						string = string.replace(regexEscape, function(string) {
							return '&' + encodeMap[string] + ';'; // no need to check `has()` here
						});
					}
					// Shorten escapes that represent two symbols, of which at least one is
					// `<>"'&`.
					string = string
						.replace(/&gt;\u20D2/g, '&nvgt;')
						.replace(/&lt;\u20D2/g, '&nvlt;');
					// Encode non-ASCII symbols that can be replaced with a named reference.
					string = string.replace(regexEncodeNonAscii, function(string) {
						// Note: there is no need to check `has(encodeMap, string)` here.
						return '&' + encodeMap[string] + ';';
					});
				} else if (!allowUnsafeSymbols) {
					// Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
					// using named character references.
					string = string.replace(regexEscape, escapeBmpSymbol);
				}
				return string
					// Encode astral symbols.
					.replace(regexAstralSymbols, function($0) {
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						var high = $0.charCodeAt(0);
						var low = $0.charCodeAt(1);
						var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
						return escapeCodePoint(codePoint);
					})
					// Encode any remaining BMP symbols that are not printable ASCII symbols
					// using a hexadecimal escape.
					.replace(regexBmpWhitelist, escapeBmpSymbol);
			};
			// Expose default options (so they can be overridden globally).
			encode.options = {
				'allowUnsafeSymbols': false,
				'encodeEverything': false,
				'strict': false,
				'useNamedReferences': false,
				'decimal' : false
			};

			var decode = function(html, options) {
				options = merge(options, decode.options);
				var strict = options.strict;
				if (strict && regexInvalidEntity.test(html)) {
					parseError('malformed character reference');
				}
				return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
					var codePoint;
					var semicolon;
					var decDigits;
					var hexDigits;
					var reference;
					var next;

					if ($1) {
						reference = $1;
						// Note: there is no need to check `has(decodeMap, reference)`.
						return decodeMap[reference];
					}

					if ($2) {
						// Decode named character references without trailing `;`, e.g. `&amp`.
						// This is only a parse error if it gets converted to `&`, or if it is
						// followed by `=` in an attribute context.
						reference = $2;
						next = $3;
						if (next && options.isAttributeValue) {
							if (strict && next == '=') {
								parseError('`&` did not start a character reference');
							}
							return $0;
						} else {
							if (strict) {
								parseError(
									'named character reference was not terminated by a semicolon'
								);
							}
							// Note: there is no need to check `has(decodeMapLegacy, reference)`.
							return decodeMapLegacy[reference] + (next || '');
						}
					}

					if ($4) {
						// Decode decimal escapes, e.g. `&#119558;`.
						decDigits = $4;
						semicolon = $5;
						if (strict && !semicolon) {
							parseError('character reference was not terminated by a semicolon');
						}
						codePoint = parseInt(decDigits, 10);
						return codePointToSymbol(codePoint, strict);
					}

					if ($6) {
						// Decode hexadecimal escapes, e.g. `&#x1D306;`.
						hexDigits = $6;
						semicolon = $7;
						if (strict && !semicolon) {
							parseError('character reference was not terminated by a semicolon');
						}
						codePoint = parseInt(hexDigits, 16);
						return codePointToSymbol(codePoint, strict);
					}

					// If we’re still here, `if ($7)` is implied; it’s an ambiguous
					// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					return $0;
				});
			};
			// Expose default options (so they can be overridden globally).
			decode.options = {
				'isAttributeValue': false,
				'strict': false
			};

			var escape = function(string) {
				return string.replace(regexEscape, function($0) {
					// Note: there is no need to check `has(escapeMap, $0)` here.
					return escapeMap[$0];
				});
			};

			/*--------------------------------------------------------------------------*/

			var he = {
				'version': '1.2.0',
				'encode': encode,
				'decode': decode,
				'escape': escape,
				'unescape': decode
			};

			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (freeExports && !freeExports.nodeType) {
				if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
					freeModule.exports = he;
				} else { // in Narwhal or RingoJS v0.7.0-
					for (var key in he) {
						has(he, key) && (freeExports[key] = he[key]);
					}
				}
			} else { // in Rhino or a web browser
				root.he = he;
			}

		}(commonjsGlobal)); 
	} (he, he.exports));
	return he.exports;
}

var htmlparser = {};

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	function createMap(values, ignoreCase) {
	  var map = {};
	  values.forEach(function(value) {
	    map[value] = 1;
	  });
	  return ignoreCase ? function(value) {
	    return map[value.toLowerCase()] === 1;
	  } : function(value) {
	    return map[value] === 1;
	  };
	}

	async function replaceAsync(str, regex, asyncFn) {
	  const promises = [];
	  str.replace(regex, (match, ...args) => {
	    const promise = asyncFn(match, ...args);
	    promises.push(promise);
	  });
	  const data = await Promise.all(promises);
	  return str.replace(regex, () => data.shift());
	}


	utils.createMap = createMap;
	utils.createMapFromString = function(values, ignoreCase) {
	  return createMap(values.split(/,/), ignoreCase);
	};

	utils.replaceAsync = replaceAsync;
	return utils;
}

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

var hasRequiredHtmlparser;

function requireHtmlparser () {
	if (hasRequiredHtmlparser) return htmlparser;
	hasRequiredHtmlparser = 1;

	var createMapFromString = requireUtils().createMapFromString;
	var replaceAsync = requireUtils().replaceAsync;

	function makeMap(values) {
	  return createMapFromString(values, true);
	}

	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/,
	    singleAttrAssigns = [/=/],
	    singleAttrValues = [
	    // attr value double quotes
	      /"([^"]*)"+/.source,
	      // attr value, single quotes
	      /'([^']*)'+/.source,
	      // attr value, no quotes
	      /([^ \t\n\f\r"'`=<>]+)/.source
	    ],
	    // https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	    qnameCapture = (function() {
	    // based on https://www.npmjs.com/package/ncname
	      var combiningChar = '\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A';
	      var digit = '0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29';
	      var extender = '\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309E\\u30FC-\\u30FE';
	      var letter = 'A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3';
	      var ncname = '[' + letter + '_][' + letter + digit + '\\.\\-_' + combiningChar + extender + ']*';
	      return '((?:' + ncname + '\\:)?' + ncname + ')';
	    })(),
	    startTagOpen = new RegExp('^<' + qnameCapture),
	    startTagClose = /^\s*(\/?)>/,
	    endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>'),
	    doctype = /^<!DOCTYPE\s?[^>]+>/i;

	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function(m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});

	// Empty Elements
	var empty = makeMap('area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr');

	// Inline Elements
	var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var');

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var closeSelf = makeMap('colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source');

	// Attributes that have their values filled in disabled='disabled'
	var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');

	// Special Elements (can contain anything)
	var special = makeMap('script,style');

	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var nonPhrasing = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul');

	var reCache = {};

	function attrForHandler(handler) {
	  var pattern = singleAttrIdentifier.source +
	    '(?:\\s*(' + joinSingleAttrAssigns(handler) + ')' +
	    '[ \\t\\n\\f\\r]*(?:' + singleAttrValues.join('|') + '))?';
	  if (handler.customAttrSurround) {
	    var attrClauses = [];
	    for (var i = handler.customAttrSurround.length - 1; i >= 0; i--) {
	      attrClauses[i] = '(?:' +
	        '(' + handler.customAttrSurround[i][0].source + ')\\s*' +
	        pattern +
	        '\\s*(' + handler.customAttrSurround[i][1].source + ')' +
	        ')';
	    }
	    attrClauses.push('(?:' + pattern + ')');
	    pattern = '(?:' + attrClauses.join('|') + ')';
	  }
	  return new RegExp('^\\s*' + pattern);
	}

	function joinSingleAttrAssigns(handler) {
	  return singleAttrAssigns.concat(
	    handler.customAttrAssign || []
	  ).map(function(assign) {
	    return '(?:' + assign.source + ')';
	  }).join('|');
	}

	class HTMLParser {
	  constructor(html, handler) {
	    this.html = html;
	    this.handler = handler;
	  }

	  async parse() {
	    let html = this.html;
	    const handler = this.handler;

	    var stack = [], lastTag;
	    var attribute = attrForHandler(handler);
	    var last, prevTag, nextTag;
	    while (html) {
	      last = html;
	      // Make sure we're not in a script or style element
	      if (!lastTag || !special(lastTag)) {
	        var textEnd = html.indexOf('<');
	        if (textEnd === 0) {
	          // Comment:
	          if (/^<!--/.test(html)) {
	            var commentEnd = html.indexOf('-->');

	            if (commentEnd >= 0) {
	              if (handler.comment) {
	                await handler.comment(html.substring(4, commentEnd));
	              }
	              html = html.substring(commentEnd + 3);
	              prevTag = '';
	              continue;
	            }
	          }

	          // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	          if (/^<!\[/.test(html)) {
	            var conditionalEnd = html.indexOf(']>');

	            if (conditionalEnd >= 0) {
	              if (handler.comment) {
	                await handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);
	              }
	              html = html.substring(conditionalEnd + 2);
	              prevTag = '';
	              continue;
	            }
	          }

	          // Doctype:
	          var doctypeMatch = html.match(doctype);
	          if (doctypeMatch) {
	            if (handler.doctype) {
	              handler.doctype(doctypeMatch[0]);
	            }
	            html = html.substring(doctypeMatch[0].length);
	            prevTag = '';
	            continue;
	          }

	          // End tag:
	          var endTagMatch = html.match(endTag);
	          if (endTagMatch) {
	            html = html.substring(endTagMatch[0].length);
	            await replaceAsync(endTagMatch[0], endTag, parseEndTag);
	            prevTag = '/' + endTagMatch[1].toLowerCase();
	            continue;
	          }

	          // Start tag:
	          var startTagMatch = parseStartTag(html);
	          if (startTagMatch) {
	            html = startTagMatch.rest;
	            await handleStartTag(startTagMatch);
	            prevTag = startTagMatch.tagName.toLowerCase();
	            continue;
	          }

	          // Treat `<` as text
	          if (handler.continueOnParseError) {
	            textEnd = html.indexOf('<', 1);
	          }
	        }

	        var text;
	        if (textEnd >= 0) {
	          text = html.substring(0, textEnd);
	          html = html.substring(textEnd);
	        }
	        else {
	          text = html;
	          html = '';
	        }

	        // next tag
	        var nextTagMatch = parseStartTag(html);
	        if (nextTagMatch) {
	          nextTag = nextTagMatch.tagName;
	        }
	        else {
	          nextTagMatch = html.match(endTag);
	          if (nextTagMatch) {
	            nextTag = '/' + nextTagMatch[1];
	          }
	          else {
	            nextTag = '';
	          }
	        }

	        if (handler.chars) {
	          await handler.chars(text, prevTag, nextTag);
	        }
	        prevTag = '';
	      }
	      else {
	        var stackedTag = lastTag.toLowerCase();
	        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)</' + stackedTag + '[^>]*>', 'i'));

	        html = await replaceAsync(html, reStackedTag, async(_, text) => {
	          if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
	            text = text
	              .replace(/<!--([\s\S]*?)-->/g, '$1')
	              .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	          }


	          if (handler.chars) {
	            await handler.chars(text);
	          }

	          return '';
	        });

	        await parseEndTag('</' + stackedTag + '>', stackedTag);
	      }

	      if (html === last) {
	        throw new Error('Parse Error: ' + html);
	      }
	    }

	    if (!handler.partialMarkup) {
	      // Clean up any remaining tags
	      await parseEndTag();
	    }

	    function parseStartTag(input) {
	      var start = input.match(startTagOpen);
	      if (start) {
	        var match = {
	          tagName: start[1],
	          attrs: []
	        };
	        input = input.slice(start[0].length);
	        var end, attr;
	        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {
	          input = input.slice(attr[0].length);
	          match.attrs.push(attr);
	        }
	        if (end) {
	          match.unarySlash = end[1];
	          match.rest = input.slice(end[0].length);
	          return match;
	        }
	      }
	    }

	    async function closeIfFound(tagName) {
	      if (findTag(tagName) >= 0) {
	        await parseEndTag('', tagName);
	        return true;
	      }
	    }

	    async function handleStartTag(match) {
	      var tagName = match.tagName;
	      var unarySlash = match.unarySlash;

	      if (handler.html5) {
	        if (lastTag === 'p' && nonPhrasing(tagName)) {
	          await parseEndTag('', lastTag);
	        }
	        else if (tagName === 'tbody') {
	          await closeIfFound('thead');
	        }
	        else if (tagName === 'tfoot') {
	          if (!await closeIfFound('tbody')) {
	            await closeIfFound('thead');
	          }
	        }
	        if (tagName === 'col' && findTag('colgroup') < 0) {
	          lastTag = 'colgroup';
	          stack.push({ tag: lastTag, attrs: [] });
	          if (handler.start) {
	            await handler.start(lastTag, [], false, '');
	          }
	        }
	      }

	      if (!handler.html5 && !inline(tagName)) {
	        while (lastTag && inline(lastTag)) {
	          await parseEndTag('', lastTag);
	        }
	      }

	      if (closeSelf(tagName) && lastTag === tagName) {
	        await parseEndTag('', tagName);
	      }

	      var unary = empty(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

	      var attrs = match.attrs.map(function(args) {
	        var name, value, customOpen, customClose, customAssign, quote;
	        var ncp = 7; // number of captured parts, scalar

	        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	          if (args[3] === '') { delete args[3]; }
	          if (args[4] === '') { delete args[4]; }
	          if (args[5] === '') { delete args[5]; }
	        }

	        function populate(index) {
	          customAssign = args[index];
	          value = args[index + 1];
	          if (typeof value !== 'undefined') {
	            return '"';
	          }
	          value = args[index + 2];
	          if (typeof value !== 'undefined') {
	            return '\'';
	          }
	          value = args[index + 3];
	          if (typeof value === 'undefined' && fillAttrs(name)) {
	            value = name;
	          }
	          return '';
	        }

	        var j = 1;
	        if (handler.customAttrSurround) {
	          for (var i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {
	            name = args[j + 1];
	            if (name) {
	              quote = populate(j + 2);
	              customOpen = args[j];
	              customClose = args[j + 6];
	              break;
	            }
	          }
	        }

	        if (!name && (name = args[j])) {
	          quote = populate(j + 1);
	        }

	        return {
	          name: name,
	          value: value,
	          customAssign: customAssign || '=',
	          customOpen: customOpen || '',
	          customClose: customClose || '',
	          quote: quote || ''
	        };
	      });

	      if (!unary) {
	        stack.push({ tag: tagName, attrs: attrs });
	        lastTag = tagName;
	        unarySlash = '';
	      }

	      if (handler.start) {
	        await handler.start(tagName, attrs, unary, unarySlash);
	      }
	    }

	    function findTag(tagName) {
	      var pos;
	      var needle = tagName.toLowerCase();
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].tag.toLowerCase() === needle) {
	          break;
	        }
	      }
	      return pos;
	    }

	    async function parseEndTag(tag, tagName) {
	      var pos;

	      // Find the closest opened tag of the same type
	      if (tagName) {
	        pos = findTag(tagName);
	      }
	      // If no tag name is provided, clean shop
	      else {
	        pos = 0;
	      }

	      if (pos >= 0) {
	        // Close all the open elements, up the stack
	        for (var i = stack.length - 1; i >= pos; i--) {
	          if (handler.end) {
	            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
	          }
	        }

	        // Remove the open elements from the stack
	        stack.length = pos;
	        lastTag = pos && stack[pos - 1].tag;
	      }
	      else if (tagName.toLowerCase() === 'br') {
	        if (handler.start) {
	          await handler.start(tagName, [], true, '');
	        }
	      }
	      else if (tagName.toLowerCase() === 'p') {
	        if (handler.start) {
	          await handler.start(tagName, [], false, '', true);
	        }
	        if (handler.end) {
	          handler.end(tagName, []);
	        }
	      }
	    }
	  }
	}

	htmlparser.HTMLParser = HTMLParser;
	htmlparser.HTMLtoXML = function(html) {
	  var results = '';

	  return results;
	};

	htmlparser.HTMLtoDOM = function(html, doc) {
	  // There can be only one of these elements
	  var one = {
	    html: true,
	    head: true,
	    body: true,
	    title: true
	  };

	  if (doc) {
	    doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;
	  }
	  else if (typeof DOMDocument !== 'undefined') {
	    doc = new DOMDocument();
	  }
	  else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {
	    doc = document.implementation.createDocument('', '', null);
	  }
	  else if (typeof ActiveX !== 'undefined') {
	    doc = new ActiveXObject('Msxml.DOMDocument');
	  }

	  var documentElement = doc.documentElement ||
	      doc.getDocumentElement && doc.getDocumentElement();

	  // If we're dealing with an empty document then we
	  // need to pre-populate it with the HTML document structure
	  if (!documentElement && doc.createElement) {
	    (function() {
	      var html = doc.createElement('html');
	      var head = doc.createElement('head');
	      head.appendChild(doc.createElement('title'));
	      html.appendChild(head);
	      html.appendChild(doc.createElement('body'));
	      doc.appendChild(html);
	    })();
	  }

	  // Find all the unique elements
	  if (doc.getElementsByTagName) {
	    for (var i in one) {
	      one[i] = doc.getElementsByTagName(i)[0];
	    }
	  }

	  return doc;
	};

	htmlparser.endTag = endTag;
	return htmlparser;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants =
	{
		// Output
		ABSOLUTE:      "absolute",
		PATH_RELATIVE: "pathRelative",
		ROOT_RELATIVE: "rootRelative",
		SHORTEST:      "shortest"
	};
	return constants;
}

var format;
var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format;
	hasRequiredFormat = 1;

	var constants = requireConstants();



	function formatAuth(urlObj, options)
	{
		if (urlObj.auth && !options.removeAuth && (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE))
		{
			return urlObj.auth + "@";
		}
		
		return "";
	}



	function formatHash(urlObj, options)
	{
		return urlObj.hash ? urlObj.hash : "";
	}



	function formatHost(urlObj, options)
	{
		if (urlObj.host.full && (urlObj.extra.relation.maximumAuth || options.output===constants.ABSOLUTE))
		{
			return urlObj.host.full;
		}
		
		return "";
	}



	function formatPath(urlObj, options)
	{
		var str = "";
		
		var absolutePath = urlObj.path.absolute.string;
		var relativePath = urlObj.path.relative.string;
		var resource = showResource(urlObj, options);
		
		if (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE || options.output===constants.ROOT_RELATIVE)
		{
			str = absolutePath;
		}
		else if (relativePath.length<=absolutePath.length && options.output===constants.SHORTEST || options.output===constants.PATH_RELATIVE)
		{
			str = relativePath;
			
			if (str === "")
			{
				var query = showQuery(urlObj,options) && !!getQuery(urlObj,options);
				
				if (urlObj.extra.relation.maximumPath && !resource)
				{
					str = "./";
				}
				else if (urlObj.extra.relation.overridesQuery && !resource && !query)
				{
					str = "./";
				}
			}
		}
		else
		{
			str = absolutePath;
		}
		
		if ( str==="/" && !resource && options.removeRootTrailingSlash && (!urlObj.extra.relation.minimumPort || options.output===constants.ABSOLUTE) )
		{
			str = "";
		}
		
		return str;
	}



	function formatPort(urlObj, options)
	{
		if (urlObj.port && !urlObj.extra.portIsDefault && urlObj.extra.relation.maximumHost)
		{
			return ":" + urlObj.port;
		}
		
		return "";
	}



	function formatQuery(urlObj, options)
	{
		return showQuery(urlObj,options) ? getQuery(urlObj, options) : "";
	}



	function formatResource(urlObj, options)
	{
		return showResource(urlObj,options) ? urlObj.resource : "";
	}



	function formatScheme(urlObj, options)
	{
		var str = "";
		
		if (urlObj.extra.relation.maximumHost || options.output===constants.ABSOLUTE)
		{
			if (!urlObj.extra.relation.minimumScheme || !options.schemeRelative || options.output===constants.ABSOLUTE)
			{
				str += urlObj.scheme + "://";
			}
			else
			{
				str += "//";
			}
		}
		
		return str;
	}



	function formatUrl(urlObj, options)
	{
		var url = "";
		
		url += formatScheme(urlObj, options);
		url += formatAuth(urlObj, options);
		url += formatHost(urlObj, options);
		url += formatPort(urlObj);
		url += formatPath(urlObj, options);
		url += formatResource(urlObj, options);
		url += formatQuery(urlObj, options);
		url += formatHash(urlObj);
		
		return url;
	}



	function getQuery(urlObj, options)
	{
		var stripQuery = options.removeEmptyQueries && urlObj.extra.relation.minimumPort;
		
		return urlObj.query.string[ stripQuery ? "stripped" : "full" ];
	}



	function showQuery(urlObj, options)
	{
		return !urlObj.extra.relation.minimumQuery || options.output===constants.ABSOLUTE || options.output===constants.ROOT_RELATIVE;
	}



	function showResource(urlObj, options)
	{
		var removeIndex = options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex;
		var removeMatchingResource = urlObj.extra.relation.minimumResource && options.output!==constants.ABSOLUTE && options.output!==constants.ROOT_RELATIVE;
		
		return !!urlObj.resource && !removeMatchingResource && !removeIndex;
	}



	format = formatUrl;
	return format;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;

	/*
		Deep-clone an object.
	*/
	function clone(obj)
	{
		if (obj instanceof Object)
		{
			var clonedObj = (obj instanceof Array) ? [] : {};
			
			for (var i in obj)
			{
				if ( obj.hasOwnProperty(i) )
				{
					clonedObj[i] = clone( obj[i] );
				}
			}
			
			return clonedObj;
		}
		
		return obj;
	}



	/*
		https://github.com/jonschlinkert/is-plain-object
	*/
	function isPlainObject(obj)
	{
		return !!obj && typeof obj==="object" && obj.constructor===Object;
	}



	/*
		Shallow-merge two objects.
	*/
	function shallowMerge(target, source)
	{
		if (target instanceof Object && source instanceof Object)
		{
			for (var i in source)
			{
				if ( source.hasOwnProperty(i) )
				{
					target[i] = source[i];
				}
			}
		}
		
		return target;
	}



	object =
	{
		clone: clone,
		isPlainObject: isPlainObject,
		shallowMerge: shallowMerge
	};
	return object;
}

var options;
var hasRequiredOptions;

function requireOptions () {
	if (hasRequiredOptions) return options;
	hasRequiredOptions = 1;

	var objUtils = requireObject();



	function getOptions(options, defaults)
	{
		if ( objUtils.isPlainObject(options) )
		{
			var newOptions = {};
			
			for (var i in defaults)
			{
				if ( defaults.hasOwnProperty(i) )
				{
					if (options[i] !== undefined)
					{
						newOptions[i] = mergeOption(options[i], defaults[i]);
					}
					else
					{
						newOptions[i] = defaults[i];
					}
				}
			}
			
			return newOptions;
		}
		else
		{
			return defaults;
		}
	}



	function mergeOption(newValues, defaultValues)
	{
		if (defaultValues instanceof Object && newValues instanceof Object)
		{
			if (defaultValues instanceof Array && newValues instanceof Array)
			{
				return defaultValues.concat(newValues);
			}
			else
			{
				return objUtils.shallowMerge(newValues, defaultValues);
			}
		}
		
		return newValues;
	}



	options = getOptions;
	return options;
}

var hrefInfo_1;
var hasRequiredHrefInfo;

function requireHrefInfo () {
	if (hasRequiredHrefInfo) return hrefInfo_1;
	hasRequiredHrefInfo = 1;

	function hrefInfo(urlObj)
	{
		var minimumPathOnly     = (!urlObj.scheme && !urlObj.auth && !urlObj.host.full && !urlObj.port);
		var minimumResourceOnly = (minimumPathOnly && !urlObj.path.absolute.string);
		var minimumQueryOnly    = (minimumResourceOnly && !urlObj.resource);
		var minimumHashOnly     = (minimumQueryOnly && !urlObj.query.string.full.length);
		var empty               = (minimumHashOnly && !urlObj.hash);
		
		urlObj.extra.hrefInfo.minimumPathOnly     = minimumPathOnly;
		urlObj.extra.hrefInfo.minimumResourceOnly = minimumResourceOnly;
		urlObj.extra.hrefInfo.minimumQueryOnly    = minimumQueryOnly;
		urlObj.extra.hrefInfo.minimumHashOnly     = minimumHashOnly;
		urlObj.extra.hrefInfo.empty = empty;
	}



	hrefInfo_1 = hrefInfo;
	return hrefInfo_1;
}

var host;
var hasRequiredHost;

function requireHost () {
	if (hasRequiredHost) return host;
	hasRequiredHost = 1;

	function parseHost(urlObj, options)
	{
		// TWEAK :: condition only for speed optimization
		if (options.ignore_www)
		{
			var host = urlObj.host.full;
			
			if (host)
			{
				var stripped = host;
				
				if (host.indexOf("www.") === 0)
				{
					stripped = host.substr(4);
				}
				
				urlObj.host.stripped = stripped;
			}
		}
	}



	host = parseHost;
	return host;
}

var path$2;
var hasRequiredPath$1;

function requirePath$1 () {
	if (hasRequiredPath$1) return path$2;
	hasRequiredPath$1 = 1;

	function isDirectoryIndex(resource, options)
	{
		var verdict = false;
		
		options.directoryIndexes.every( function(index)
		{
			if (index === resource)
			{
				verdict = true;
				return false;
			}
			
			return true;
		});
		
		return verdict;
	}



	function parsePath(urlObj, options)
	{
		var path = urlObj.path.absolute.string;
		
		if (path)
		{
			var lastSlash = path.lastIndexOf("/");
			
			if (lastSlash > -1)
			{
				if (++lastSlash < path.length)
				{
					var resource = path.substr(lastSlash);
					
					if (resource!=="." && resource!=="..")
					{
						urlObj.resource = resource;
						path = path.substr(0, lastSlash);
					}
					else
					{
						path += "/";
					}
				}
				
				urlObj.path.absolute.string = path;
				urlObj.path.absolute.array = splitPath(path);
			}
			else if (path==="." || path==="..")
			{
				// "..?var", "..#anchor", etc ... not "..index.html"
				path += "/";
				
				urlObj.path.absolute.string = path;
				urlObj.path.absolute.array = splitPath(path);
			}
			else
			{
				// Resource-only
				urlObj.resource = path;
				urlObj.path.absolute.string = null;
			}
			
			urlObj.extra.resourceIsIndex = isDirectoryIndex(urlObj.resource, options);
		}
		// Else: query/hash-only or empty
	}



	function splitPath(path)
	{
		// TWEAK :: condition only for speed optimization
		if (path !== "/")
		{
			var cleaned = [];
			
			path.split("/").forEach( function(dir)
			{
				// Cleanup -- splitting "/dir/" becomes ["","dir",""]
				if (dir !== "")
				{
					cleaned.push(dir);
				}
			});
			
			return cleaned;
		}
		else
		{
			// Faster to skip the above block and just create an array
			return [];
		}
	}



	path$2 = parsePath;
	return path$2;
}

var port;
var hasRequiredPort;

function requirePort () {
	if (hasRequiredPort) return port;
	hasRequiredPort = 1;

	function parsePort(urlObj, options)
	{
		var defaultPort = -1;
		
		for (var i in options.defaultPorts)
		{
			if ( i===urlObj.scheme && options.defaultPorts.hasOwnProperty(i) )
			{
				defaultPort = options.defaultPorts[i];
				break;
			}
		}
		
		if (defaultPort > -1)
		{
			// Force same type as urlObj.port
			defaultPort = defaultPort.toString();
			
			if (urlObj.port === null)
			{
				urlObj.port = defaultPort;
			}
			
			urlObj.extra.portIsDefault = (urlObj.port === defaultPort);
		}
	}



	port = parsePort;
	return port;
}

var query;
var hasRequiredQuery;

function requireQuery () {
	if (hasRequiredQuery) return query;
	hasRequiredQuery = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;



	function parseQuery(urlObj, options)
	{
		urlObj.query.string.full = stringify(urlObj.query.object, false);
		
		// TWEAK :: condition only for speed optimization
		if (options.removeEmptyQueries)
		{
			urlObj.query.string.stripped = stringify(urlObj.query.object, true);
		}
	}



	function stringify(queryObj, removeEmptyQueries)
	{
		var count = 0;
		var str = "";
		
		for (var i in queryObj)
		{
			if ( i!=="" && hasOwnProperty.call(queryObj, i)===true )
			{
				var value = queryObj[i];
				
				if (value !== "" || !removeEmptyQueries)
				{
					str += (++count===1) ? "?" : "&";
					
					i = encodeURIComponent(i);
					
					if (value !== "")
					{
						str += i +"="+ encodeURIComponent(value).replace(/%20/g,"+");
					}
					else
					{
						str += i;
					}
				}
			}
		}
		
		return str;
	}



	query = parseQuery;
	return query;
}

var urlstring;
var hasRequiredUrlstring;

function requireUrlstring () {
	if (hasRequiredUrlstring) return urlstring;
	hasRequiredUrlstring = 1;

	var _parseUrl = require$$1$3.parse;



	/*
		Customize the URL object that Node generates
		because:
		
		* necessary data for later
		* urlObj.host is useless
		* urlObj.hostname is too long
		* urlObj.path is useless
		* urlObj.pathname is too long
		* urlObj.protocol is inaccurate; should be called "scheme"
		* urlObj.search is mostly useless
	*/
	function clean(urlObj)
	{
		var scheme = urlObj.protocol;
		
		if (scheme)
		{
			// Remove ":" suffix
			if (scheme.indexOf(":") === scheme.length-1)
			{
				scheme = scheme.substr(0, scheme.length-1);
			}
		}
		
		urlObj.host =
		{
			// TODO :: unescape(encodeURIComponent(s)) ? ... http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html
			full: urlObj.hostname,
			stripped: null
		};
		
		urlObj.path =
		{
			absolute:
			{
				array: null,
				string: urlObj.pathname
			},
			relative:
			{
				array: null,
				string: null
			}
		};
		
		urlObj.query =
		{
			object: urlObj.query,
			string:
			{
				full: null,
				stripped: null
			}
		};
		
		urlObj.extra =
		{
			hrefInfo:
			{
				minimumPathOnly: null,
				minimumResourceOnly: null,
				minimumQueryOnly: null,
				minimumHashOnly: null,
				empty: null,
				
				separatorOnlyQuery: urlObj.search==="?"
			},
			portIsDefault: null,
			relation:
			{
				maximumScheme: null,
				maximumAuth: null,
				maximumHost: null,
				maximumPort: null,
				maximumPath: null,
				maximumResource: null,
				maximumQuery: null,
				maximumHash: null,
				
				minimumScheme: null,
				minimumAuth: null,
				minimumHost: null,
				minimumPort: null,
				minimumPath: null,
				minimumResource: null,
				minimumQuery: null,
				minimumHash: null,
				
				overridesQuery: null
			},
			resourceIsIndex: null,
			slashes: urlObj.slashes
		};
		
		urlObj.resource = null;
		urlObj.scheme = scheme;
		delete urlObj.hostname;
		delete urlObj.pathname;
		delete urlObj.protocol;
		delete urlObj.search;
		delete urlObj.slashes;
		
		return urlObj;
	}



	function validScheme(url, options)
	{
		var valid = true;
		
		options.rejectedSchemes.every( function(rejectedScheme)
		{
			valid = !(url.indexOf(rejectedScheme+":") === 0);
			
			// Break loop
			return valid;
		});
		
		return valid;
	}



	function parseUrlString(url, options)
	{
		if ( validScheme(url,options) )
		{
			return clean( _parseUrl(url, true, options.slashesDenoteHost) );
		}
		else
		{
			return {href:url, valid:false};
		}
	}



	urlstring = parseUrlString;
	return urlstring;
}

var path$1;
var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path$1;
	hasRequiredPath = 1;

	function joinPath(pathArray)
	{
		if (pathArray.length > 0)
		{
			return pathArray.join("/") + "/";
		}
		else
		{
			return "";
		}
	}



	function resolveDotSegments(pathArray)
	{
		var pathAbsolute = [];
		
		pathArray.forEach( function(dir)
		{
			if (dir !== "..")
			{
				if (dir !== ".")
				{
					pathAbsolute.push(dir);
				}
			}
			else
			{
				// Remove parent
				if (pathAbsolute.length > 0)
				{
					pathAbsolute.splice(pathAbsolute.length-1, 1);
				}
			}
		});
		
		return pathAbsolute;
	}



	path$1 =
	{
		join: joinPath,
		resolveDotSegments: resolveDotSegments
	};
	return path$1;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var hrefInfo   = requireHrefInfo();
	var parseHost  = requireHost();
	var parsePath  = requirePath$1();
	var parsePort  = requirePort();
	var parseQuery = requireQuery();
	var parseUrlString = requireUrlstring();
	var pathUtils      = requirePath();



	function parseFromUrl(url, options, fallback)
	{
		if (url)
		{
			var urlObj = parseUrl(url, options);
			
			// Because the following occurs in the relate stage for "to" URLs,
			// such had to be mostly duplicated here
			
			var pathArray = pathUtils.resolveDotSegments(urlObj.path.absolute.array);
			
			urlObj.path.absolute.array  = pathArray;
			urlObj.path.absolute.string = "/" + pathUtils.join(pathArray);
			
			return urlObj;
		}
		else
		{
			return fallback;
		}
	}



	function parseUrl(url, options)
	{
		var urlObj = parseUrlString(url, options);
		
		if (urlObj.valid===false) return urlObj;
		
		parseHost(urlObj, options);
		parsePort(urlObj, options);
		parsePath(urlObj, options);
		parseQuery(urlObj, options);
		hrefInfo(urlObj);
		
		return urlObj;
	}



	parse =
	{
		from: parseFromUrl,
		to:   parseUrl
	};
	return parse;
}

var findRelation;
var hasRequiredFindRelation;

function requireFindRelation () {
	if (hasRequiredFindRelation) return findRelation;
	hasRequiredFindRelation = 1;

	function findRelation_upToPath(urlObj, siteUrlObj, options)
	{
		// Path- or root-relative URL
		var pathOnly = urlObj.extra.hrefInfo.minimumPathOnly;
		
		// Matching scheme, scheme-relative or path-only
		var minimumScheme = (urlObj.scheme===siteUrlObj.scheme || !urlObj.scheme);
		
		// Matching auth, ignoring auth or path-only
		var minimumAuth = minimumScheme && (urlObj.auth===siteUrlObj.auth || options.removeAuth || pathOnly);
		
		// Matching host or path-only
		var www = options.ignore_www ? "stripped" : "full";
		var minimumHost = minimumAuth && (urlObj.host[www]===siteUrlObj.host[www] || pathOnly);
		
		// Matching port or path-only
		var minimumPort = minimumHost && (urlObj.port===siteUrlObj.port || pathOnly);
		
		urlObj.extra.relation.minimumScheme = minimumScheme;
		urlObj.extra.relation.minimumAuth   = minimumAuth;
		urlObj.extra.relation.minimumHost   = minimumHost;
		urlObj.extra.relation.minimumPort   = minimumPort;
		
		urlObj.extra.relation.maximumScheme = !minimumScheme || minimumScheme && !minimumAuth;
		urlObj.extra.relation.maximumAuth   = !minimumScheme || minimumScheme && !minimumHost;
		urlObj.extra.relation.maximumHost   = !minimumScheme || minimumScheme && !minimumPort;
	}



	function findRelation_pathOn(urlObj, siteUrlObj, options)
	{
		var queryOnly = urlObj.extra.hrefInfo.minimumQueryOnly;
		var hashOnly  = urlObj.extra.hrefInfo.minimumHashOnly;
		var empty     = urlObj.extra.hrefInfo.empty;	// not required, but self-documenting
		
		// From upToPath()
		var minimumPort   = urlObj.extra.relation.minimumPort;
		var minimumScheme = urlObj.extra.relation.minimumScheme;
		
		// Matching port and path
		var minimumPath = minimumPort && urlObj.path.absolute.string===siteUrlObj.path.absolute.string;
		
		// Matching resource or query/hash-only or empty
		var matchingResource = (urlObj.resource===siteUrlObj.resource || !urlObj.resource && siteUrlObj.extra.resourceIsIndex) || (options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex && !siteUrlObj.resource);
		var minimumResource = minimumPath && (matchingResource || queryOnly || hashOnly || empty);
		
		// Matching query or hash-only/empty
		var query = options.removeEmptyQueries ? "stripped" : "full";
		var urlQuery = urlObj.query.string[query];
		var siteUrlQuery = siteUrlObj.query.string[query];
		var minimumQuery = (minimumResource && !!urlQuery && urlQuery===siteUrlQuery) || ((hashOnly || empty) && !urlObj.extra.hrefInfo.separatorOnlyQuery);
		
		var minimumHash = minimumQuery && urlObj.hash===siteUrlObj.hash;
		
		urlObj.extra.relation.minimumPath     = minimumPath;
		urlObj.extra.relation.minimumResource = minimumResource;
		urlObj.extra.relation.minimumQuery    = minimumQuery;
		urlObj.extra.relation.minimumHash     = minimumHash;
		
		urlObj.extra.relation.maximumPort     = !minimumScheme || minimumScheme && !minimumPath;
		urlObj.extra.relation.maximumPath     = !minimumScheme || minimumScheme && !minimumResource;
		urlObj.extra.relation.maximumResource = !minimumScheme || minimumScheme && !minimumQuery;
		urlObj.extra.relation.maximumQuery    = !minimumScheme || minimumScheme && !minimumHash;
		urlObj.extra.relation.maximumHash     = !minimumScheme || minimumScheme && !minimumHash;	// there's nothing after hash, so it's the same as maximumQuery
		
		// Matching path and/or resource with existing but non-matching site query
		urlObj.extra.relation.overridesQuery  = minimumPath && urlObj.extra.relation.maximumResource && !minimumQuery && !!siteUrlQuery;
	}



	findRelation =
	{
		pathOn:   findRelation_pathOn,
		upToPath: findRelation_upToPath
	};
	return findRelation;
}

var absolutize_1;
var hasRequiredAbsolutize;

function requireAbsolutize () {
	if (hasRequiredAbsolutize) return absolutize_1;
	hasRequiredAbsolutize = 1;

	var findRelation = requireFindRelation();
	var objUtils     = requireObject();
	var pathUtils    = requirePath();



	function absolutize(urlObj, siteUrlObj, options)
	{
		findRelation.upToPath(urlObj, siteUrlObj, options);
		
		// Fill in relative URLs
		if (urlObj.extra.relation.minimumScheme) urlObj.scheme = siteUrlObj.scheme;
		if (urlObj.extra.relation.minimumAuth)   urlObj.auth   = siteUrlObj.auth;
		if (urlObj.extra.relation.minimumHost)   urlObj.host   = objUtils.clone(siteUrlObj.host);
		if (urlObj.extra.relation.minimumPort)   copyPort(urlObj, siteUrlObj);
		if (urlObj.extra.relation.minimumScheme) copyPath(urlObj, siteUrlObj);
		
		// Check remaining relativeness now that path has been copied and/or resolved
		findRelation.pathOn(urlObj, siteUrlObj, options);
		
		// Fill in relative URLs
		if (urlObj.extra.relation.minimumResource) copyResource(urlObj, siteUrlObj);
		if (urlObj.extra.relation.minimumQuery)    urlObj.query = objUtils.clone(siteUrlObj.query);
		if (urlObj.extra.relation.minimumHash)     urlObj.hash  = siteUrlObj.hash;
	}



	/*
		Get an absolute path that's relative to site url.
	*/
	function copyPath(urlObj, siteUrlObj)
	{
		if (urlObj.extra.relation.maximumHost || !urlObj.extra.hrefInfo.minimumResourceOnly)
		{
			var pathArray = urlObj.path.absolute.array;
			var pathString = "/";
			
			// If not erroneous URL
			if (pathArray)
			{
				// If is relative path
				if (urlObj.extra.hrefInfo.minimumPathOnly && urlObj.path.absolute.string.indexOf("/")!==0)
				{
					// Append path to site path
					pathArray = siteUrlObj.path.absolute.array.concat(pathArray);
				}
				
				pathArray   = pathUtils.resolveDotSegments(pathArray);
				pathString += pathUtils.join(pathArray);
			}
			else
			{
				pathArray = [];
			}
			
			urlObj.path.absolute.array  = pathArray;
			urlObj.path.absolute.string = pathString;
		}
		else
		{
			// Resource-, query- or hash-only or empty
			urlObj.path = objUtils.clone(siteUrlObj.path);
		}
	}



	function copyPort(urlObj, siteUrlObj)
	{
		urlObj.port = siteUrlObj.port;
		
		urlObj.extra.portIsDefault = siteUrlObj.extra.portIsDefault;
	}



	function copyResource(urlObj, siteUrlObj)
	{
		urlObj.resource = siteUrlObj.resource;
		
		urlObj.extra.resourceIsIndex = siteUrlObj.extra.resourceIsIndex;
	}



	absolutize_1 = absolutize;
	return absolutize_1;
}

var relativize_1;
var hasRequiredRelativize;

function requireRelativize () {
	if (hasRequiredRelativize) return relativize_1;
	hasRequiredRelativize = 1;

	var pathUtils = requirePath();



	/*
		Get a path relative to the site path.
	*/
	function relatePath(absolutePath, siteAbsolutePath)
	{
		var relativePath = [];
		
		// At this point, it's related to the host/port
		var related = true;
		var parentIndex = -1;
		
		// Find parents
		siteAbsolutePath.forEach( function(siteAbsoluteDir, i)
		{
			if (related)
			{
				if (absolutePath[i] !== siteAbsoluteDir)
				{
					related = false;
				}
				else
				{
					parentIndex = i;
				}
			}
			
			if (!related)
			{
				// Up one level
				relativePath.push("..");
			}
		});
		
		// Form path
		absolutePath.forEach( function(dir, i)
		{
			if (i > parentIndex)
			{
				relativePath.push(dir);
			}
		});
		
		return relativePath;
	}



	function relativize(urlObj, siteUrlObj, options)
	{
		if (urlObj.extra.relation.minimumScheme)
		{
			var pathArray = relatePath(urlObj.path.absolute.array, siteUrlObj.path.absolute.array);
			
			urlObj.path.relative.array  = pathArray;
			urlObj.path.relative.string = pathUtils.join(pathArray);
		}
	}



	relativize_1 = relativize;
	return relativize_1;
}

var relate;
var hasRequiredRelate;

function requireRelate () {
	if (hasRequiredRelate) return relate;
	hasRequiredRelate = 1;

	var absolutize = requireAbsolutize();
	var relativize = requireRelativize();



	function relateUrl(siteUrlObj, urlObj, options)
	{
		absolutize(urlObj, siteUrlObj, options);
		relativize(urlObj, siteUrlObj, options);
		
		return urlObj;
	}



	relate = relateUrl;
	return relate;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;

	var constants  = requireConstants();
	var formatUrl  = requireFormat();
	var getOptions = requireOptions();
	var objUtils   = requireObject();
	var parseUrl   = requireParse();
	var relateUrl  = requireRelate();



	function RelateUrl(from, options)
	{
		this.options = getOptions(options,
		{
			defaultPorts: {ftp:21, http:80, https:443},
			directoryIndexes: ["index.html"],
			ignore_www: false,
			output: RelateUrl.SHORTEST,
			rejectedSchemes: ["data","javascript","mailto"],
			removeAuth: false,
			removeDirectoryIndexes: true,
			removeEmptyQueries: false,
			removeRootTrailingSlash: true,
			schemeRelative: true,
			site: undefined,
			slashesDenoteHost: true
		});
		
		this.from = parseUrl.from(from, this.options, null);
	}



	/*
		Usage: instance=new RelateUrl(); instance.relate();
	*/
	RelateUrl.prototype.relate = function(from, to, options)
	{
		// relate(to,options)
		if ( objUtils.isPlainObject(to) )
		{
			options = to;
			to = from;
			from = null;
		}
		// relate(to)
		else if (!to)
		{
			to = from;
			from = null;
		}
		
		options = getOptions(options, this.options);
		from = from || options.site;
		from = parseUrl.from(from, options, this.from);
		
		if (!from || !from.href)
		{
			throw new Error("from value not defined.");
		}
		else if (from.extra.hrefInfo.minimumPathOnly)
		{
			throw new Error("from value supplied is not absolute: "+from.href);
		}
		
		to = parseUrl.to(to, options);
		
		if (to.valid===false) return to.href;
		
		to = relateUrl(from, to, options);
		to = formatUrl(to, options);
		
		return to;
	};



	/*
		Usage: RelateUrl.relate();
	*/
	RelateUrl.relate = function(from, to, options)
	{
		return new RelateUrl().relate(from, to, options);
	};



	// Make constants accessible from API
	objUtils.shallowMerge(RelateUrl, constants);



	lib = RelateUrl;
	return lib;
}

var tokenchain;
var hasRequiredTokenchain;

function requireTokenchain () {
	if (hasRequiredTokenchain) return tokenchain;
	hasRequiredTokenchain = 1;

	function Sorter() {
	}

	Sorter.prototype.sort = function(tokens, fromIndex) {
	  fromIndex = fromIndex || 0;
	  for (var i = 0, len = this.keys.length; i < len; i++) {
	    var key = this.keys[i];
	    var token = key.slice(1);
	    var index = tokens.indexOf(token, fromIndex);
	    if (index !== -1) {
	      do {
	        if (index !== fromIndex) {
	          tokens.splice(index, 1);
	          tokens.splice(fromIndex, 0, token);
	        }
	        fromIndex++;
	      } while ((index = tokens.indexOf(token, fromIndex)) !== -1);
	      return this[key].sort(tokens, fromIndex);
	    }
	  }
	  return tokens;
	};

	function TokenChain() {
	}

	TokenChain.prototype = {
	  add: function(tokens) {
	    var self = this;
	    tokens.forEach(function(token) {
	      var key = '$' + token;
	      if (!self[key]) {
	        self[key] = [];
	        self[key].processed = 0;
	      }
	      self[key].push(tokens);
	    });
	  },
	  createSorter: function() {
	    var self = this;
	    var sorter = new Sorter();
	    sorter.keys = Object.keys(self).sort(function(j, k) {
	      var m = self[j].length;
	      var n = self[k].length;
	      return m < n ? 1 : m > n ? -1 : j < k ? -1 : j > k ? 1 : 0;
	    }).filter(function(key) {
	      if (self[key].processed < self[key].length) {
	        var token = key.slice(1);
	        var chain = new TokenChain();
	        self[key].forEach(function(tokens) {
	          var index;
	          while ((index = tokens.indexOf(token)) !== -1) {
	            tokens.splice(index, 1);
	          }
	          tokens.forEach(function(token) {
	            self['$' + token].processed++;
	          });
	          chain.add(tokens.slice(0));
	        });
	        sorter[key] = chain.createSorter();
	        return true;
	      }
	      return false;
	    });
	    return sorter;
	  }
	};

	tokenchain = TokenChain;
	return tokenchain;
}

var bundle_min = {exports: {}};

var sourceMap_umd = {exports: {}};

var hasRequiredSourceMap_umd;

function requireSourceMap_umd () {
	if (hasRequiredSourceMap_umd) return sourceMap_umd.exports;
	hasRequiredSourceMap_umd = 1;
	(function (module, exports) {
		(function (global, factory) {
		    factory(exports) ;
		})(commonjsGlobal, (function (exports) {
		    const comma = ','.charCodeAt(0);
		    const semicolon = ';'.charCodeAt(0);
		    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		    const intToChar = new Uint8Array(64); // 64 possible chars.
		    const charToInteger = new Uint8Array(128); // z is 122 in ASCII
		    for (let i = 0; i < chars.length; i++) {
		        const c = chars.charCodeAt(i);
		        charToInteger[c] = i;
		        intToChar[i] = c;
		    }
		    // Provide a fallback for older environments.
		    const td = typeof TextDecoder !== 'undefined'
		        ? new TextDecoder()
		        : typeof Buffer !== 'undefined'
		            ? {
		                decode(buf) {
		                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
		                    return out.toString();
		                },
		            }
		            : {
		                decode(buf) {
		                    let out = '';
		                    for (let i = 0; i < buf.length; i++) {
		                        out += String.fromCharCode(buf[i]);
		                    }
		                    return out;
		                },
		            };
		    function decode(mappings) {
		        const state = new Int32Array(5);
		        const decoded = [];
		        let line = [];
		        let sorted = true;
		        let lastCol = 0;
		        for (let i = 0; i < mappings.length;) {
		            const c = mappings.charCodeAt(i);
		            if (c === comma) {
		                i++;
		            }
		            else if (c === semicolon) {
		                state[0] = lastCol = 0;
		                if (!sorted)
		                    sort(line);
		                sorted = true;
		                decoded.push(line);
		                line = [];
		                i++;
		            }
		            else {
		                i = decodeInteger(mappings, i, state, 0); // generatedCodeColumn
		                const col = state[0];
		                if (col < lastCol)
		                    sorted = false;
		                lastCol = col;
		                if (!hasMoreSegments(mappings, i)) {
		                    line.push([col]);
		                    continue;
		                }
		                i = decodeInteger(mappings, i, state, 1); // sourceFileIndex
		                i = decodeInteger(mappings, i, state, 2); // sourceCodeLine
		                i = decodeInteger(mappings, i, state, 3); // sourceCodeColumn
		                if (!hasMoreSegments(mappings, i)) {
		                    line.push([col, state[1], state[2], state[3]]);
		                    continue;
		                }
		                i = decodeInteger(mappings, i, state, 4); // nameIndex
		                line.push([col, state[1], state[2], state[3], state[4]]);
		            }
		        }
		        if (!sorted)
		            sort(line);
		        decoded.push(line);
		        return decoded;
		    }
		    function decodeInteger(mappings, pos, state, j) {
		        let value = 0;
		        let shift = 0;
		        let integer = 0;
		        do {
		            const c = mappings.charCodeAt(pos++);
		            integer = charToInteger[c];
		            value |= (integer & 31) << shift;
		            shift += 5;
		        } while (integer & 32);
		        const shouldNegate = value & 1;
		        value >>>= 1;
		        if (shouldNegate) {
		            value = -0x80000000 | -value;
		        }
		        state[j] += value;
		        return pos;
		    }
		    function hasMoreSegments(mappings, i) {
		        if (i >= mappings.length)
		            return false;
		        const c = mappings.charCodeAt(i);
		        if (c === comma || c === semicolon)
		            return false;
		        return true;
		    }
		    function sort(line) {
		        line.sort(sortComparator$1);
		    }
		    function sortComparator$1(a, b) {
		        return a[0] - b[0];
		    }
		    function encode(decoded) {
		        const state = new Int32Array(5);
		        let buf = new Uint8Array(1024);
		        let pos = 0;
		        for (let i = 0; i < decoded.length; i++) {
		            const line = decoded[i];
		            if (i > 0) {
		                buf = reserve(buf, pos, 1);
		                buf[pos++] = semicolon;
		            }
		            if (line.length === 0)
		                continue;
		            state[0] = 0;
		            for (let j = 0; j < line.length; j++) {
		                const segment = line[j];
		                // We can push up to 5 ints, each int can take at most 7 chars, and we
		                // may push a comma.
		                buf = reserve(buf, pos, 36);
		                if (j > 0)
		                    buf[pos++] = comma;
		                pos = encodeInteger(buf, pos, state, segment, 0); // generatedCodeColumn
		                if (segment.length === 1)
		                    continue;
		                pos = encodeInteger(buf, pos, state, segment, 1); // sourceFileIndex
		                pos = encodeInteger(buf, pos, state, segment, 2); // sourceCodeLine
		                pos = encodeInteger(buf, pos, state, segment, 3); // sourceCodeColumn
		                if (segment.length === 4)
		                    continue;
		                pos = encodeInteger(buf, pos, state, segment, 4); // nameIndex
		            }
		        }
		        return td.decode(buf.subarray(0, pos));
		    }
		    function reserve(buf, pos, count) {
		        if (buf.length > pos + count)
		            return buf;
		        const swap = new Uint8Array(buf.length * 2);
		        swap.set(buf);
		        return swap;
		    }
		    function encodeInteger(buf, pos, state, segment, j) {
		        const next = segment[j];
		        let num = next - state[j];
		        state[j] = next;
		        num = num < 0 ? (-num << 1) | 1 : num << 1;
		        do {
		            let clamped = num & 0b011111;
		            num >>>= 5;
		            if (num > 0)
		                clamped |= 0b100000;
		            buf[pos++] = intToChar[clamped];
		        } while (num > 0);
		        return pos;
		    }

		    // Matches the scheme of a URL, eg "http://"
		    const schemeRegex = /^[\w+.-]+:\/\//;
		    /**
		     * Matches the parts of a URL:
		     * 1. Scheme, including ":", guaranteed.
		     * 2. User/password, including "@", optional.
		     * 3. Host, guaranteed.
		     * 4. Port, including ":", optional.
		     * 5. Path, including "/", optional.
		     */
		    const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/;
		    /**
		     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
		     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
		     *
		     * 1. Host, optional.
		     * 2. Path, which may inclue "/", guaranteed.
		     */
		    const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/]*)?)?(\/?.*)/i;
		    function isAbsoluteUrl(input) {
		        return schemeRegex.test(input);
		    }
		    function isSchemeRelativeUrl(input) {
		        return input.startsWith('//');
		    }
		    function isAbsolutePath(input) {
		        return input.startsWith('/');
		    }
		    function isFileUrl(input) {
		        return input.startsWith('file:');
		    }
		    function parseAbsoluteUrl(input) {
		        const match = urlRegex.exec(input);
		        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');
		    }
		    function parseFileUrl(input) {
		        const match = fileRegex.exec(input);
		        const path = match[2];
		        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);
		    }
		    function makeUrl(scheme, user, host, port, path) {
		        return {
		            scheme,
		            user,
		            host,
		            port,
		            path,
		            relativePath: false,
		        };
		    }
		    function parseUrl(input) {
		        if (isSchemeRelativeUrl(input)) {
		            const url = parseAbsoluteUrl('http:' + input);
		            url.scheme = '';
		            return url;
		        }
		        if (isAbsolutePath(input)) {
		            const url = parseAbsoluteUrl('http://foo.com' + input);
		            url.scheme = '';
		            url.host = '';
		            return url;
		        }
		        if (isFileUrl(input))
		            return parseFileUrl(input);
		        if (isAbsoluteUrl(input))
		            return parseAbsoluteUrl(input);
		        const url = parseAbsoluteUrl('http://foo.com/' + input);
		        url.scheme = '';
		        url.host = '';
		        url.relativePath = true;
		        return url;
		    }
		    function stripPathFilename(path) {
		        // If a path ends with a parent directory "..", then it's a relative path with excess parent
		        // paths. It's not a file, so we can't strip it.
		        if (path.endsWith('/..'))
		            return path;
		        const index = path.lastIndexOf('/');
		        return path.slice(0, index + 1);
		    }
		    function mergePaths(url, base) {
		        // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.
		        if (!url.relativePath)
		            return;
		        normalizePath(base);
		        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
		        // path).
		        if (url.path === '/') {
		            url.path = base.path;
		        }
		        else {
		            // Resolution happens relative to the base path's directory, not the file.
		            url.path = stripPathFilename(base.path) + url.path;
		        }
		        // If the base path is absolute, then our path is now absolute too.
		        url.relativePath = base.relativePath;
		    }
		    /**
		     * The path can have empty directories "//", unneeded parents "foo/..", or current directory
		     * "foo/.". We need to normalize to a standard representation.
		     */
		    function normalizePath(url) {
		        const { relativePath } = url;
		        const pieces = url.path.split('/');
		        // We need to preserve the first piece always, so that we output a leading slash. The item at
		        // pieces[0] is an empty string.
		        let pointer = 1;
		        // Positive is the number of real directories we've output, used for popping a parent directory.
		        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
		        let positive = 0;
		        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
		        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
		        // real directory, we won't need to append, unless the other conditions happen again.
		        let addTrailingSlash = false;
		        for (let i = 1; i < pieces.length; i++) {
		            const piece = pieces[i];
		            // An empty directory, could be a trailing slash, or just a double "//" in the path.
		            if (!piece) {
		                addTrailingSlash = true;
		                continue;
		            }
		            // If we encounter a real directory, then we don't need to append anymore.
		            addTrailingSlash = false;
		            // A current directory, which we can always drop.
		            if (piece === '.')
		                continue;
		            // A parent directory, we need to see if there are any real directories we can pop. Else, we
		            // have an excess of parents, and we'll need to keep the "..".
		            if (piece === '..') {
		                if (positive) {
		                    addTrailingSlash = true;
		                    positive--;
		                    pointer--;
		                }
		                else if (relativePath) {
		                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
		                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
		                    pieces[pointer++] = piece;
		                }
		                continue;
		            }
		            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
		            // any popped or dropped directories.
		            pieces[pointer++] = piece;
		            positive++;
		        }
		        let path = '';
		        for (let i = 1; i < pointer; i++) {
		            path += '/' + pieces[i];
		        }
		        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
		            path += '/';
		        }
		        url.path = path;
		    }
		    /**
		     * Attempts to resolve `input` URL/path relative to `base`.
		     */
		    function resolve$1(input, base) {
		        if (!input && !base)
		            return '';
		        const url = parseUrl(input);
		        // If we have a base, and the input isn't already an absolute URL, then we need to merge.
		        if (base && !url.scheme) {
		            const baseUrl = parseUrl(base);
		            url.scheme = baseUrl.scheme;
		            // If there's no host, then we were just a path.
		            if (!url.host) {
		                // The host, user, and port are joined, you can't copy one without the others.
		                url.user = baseUrl.user;
		                url.host = baseUrl.host;
		                url.port = baseUrl.port;
		            }
		            mergePaths(url, baseUrl);
		        }
		        normalizePath(url);
		        // If the input (and base, if there was one) are both relative, then we need to output a relative.
		        if (url.relativePath) {
		            // The first char is always a "/".
		            const path = url.path.slice(1);
		            if (!path)
		                return '.';
		            // If base started with a leading ".", or there is no base and input started with a ".", then we
		            // need to ensure that the relative path starts with a ".". We don't know if relative starts
		            // with a "..", though, so check before prepending.
		            const keepRelative = (base || input).startsWith('.');
		            return !keepRelative || path.startsWith('.') ? path : './' + path;
		        }
		        // If there's no host (and no scheme/user/port), then we need to output an absolute path.
		        if (!url.scheme && !url.host)
		            return url.path;
		        // We're outputting either an absolute URL, or a protocol relative one.
		        return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;
		    }

		    function resolve(input, base) {
		        // The base is always treated as a directory, if it's not empty.
		        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
		        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
		        if (base && !base.endsWith('/'))
		            base += '/';
		        return resolve$1(input, base);
		    }

		    /**
		     * Removes everything after the last "/", but leaves the slash.
		     */
		    function stripFilename(path) {
		        if (!path)
		            return '';
		        const index = path.lastIndexOf('/');
		        return path.slice(0, index + 1);
		    }

		    const COLUMN$1 = 0;
		    const SOURCES_INDEX$1 = 1;
		    const SOURCE_LINE$1 = 2;
		    const SOURCE_COLUMN$1 = 3;
		    const NAMES_INDEX$1 = 4;

		    function maybeSort(mappings, owned) {
		        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
		        if (unsortedIndex === mappings.length)
		            return mappings;
		        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
		        // not, we do not want to modify the consumer's input array.
		        if (!owned)
		            mappings = mappings.slice();
		        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
		            mappings[i] = sortSegments(mappings[i], owned);
		        }
		        return mappings;
		    }
		    function nextUnsortedSegmentLine(mappings, start) {
		        for (let i = start; i < mappings.length; i++) {
		            if (!isSorted(mappings[i]))
		                return i;
		        }
		        return mappings.length;
		    }
		    function isSorted(line) {
		        for (let j = 1; j < line.length; j++) {
		            if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {
		                return false;
		            }
		        }
		        return true;
		    }
		    function sortSegments(line, owned) {
		        if (!owned)
		            line = line.slice();
		        return line.sort(sortComparator);
		    }
		    function sortComparator(a, b) {
		        return a[COLUMN$1] - b[COLUMN$1];
		    }

		    let found = false;
		    /**
		     * A binary search implementation that returns the index if a match is found.
		     * If no match is found, then the left-index (the index associated with the item that comes just
		     * before the desired index) is returned. To maintain proper sort order, a splice would happen at
		     * the next index:
		     *
		     * ```js
		     * const array = [1, 3];
		     * const needle = 2;
		     * const index = binarySearch(array, needle, (item, needle) => item - needle);
		     *
		     * assert.equal(index, 0);
		     * array.splice(index + 1, 0, needle);
		     * assert.deepEqual(array, [1, 2, 3]);
		     * ```
		     */
		    function binarySearch(haystack, needle, low, high) {
		        while (low <= high) {
		            const mid = low + ((high - low) >> 1);
		            const cmp = haystack[mid][COLUMN$1] - needle;
		            if (cmp === 0) {
		                found = true;
		                return mid;
		            }
		            if (cmp < 0) {
		                low = mid + 1;
		            }
		            else {
		                high = mid - 1;
		            }
		        }
		        found = false;
		        return low - 1;
		    }
		    function upperBound(haystack, needle, index) {
		        for (let i = index + 1; i < haystack.length; i++, index++) {
		            if (haystack[i][COLUMN$1] !== needle)
		                break;
		        }
		        return index;
		    }
		    function lowerBound(haystack, needle, index) {
		        for (let i = index - 1; i >= 0; i--, index--) {
		            if (haystack[i][COLUMN$1] !== needle)
		                break;
		        }
		        return index;
		    }
		    function memoizedState() {
		        return {
		            lastKey: -1,
		            lastNeedle: -1,
		            lastIndex: -1,
		        };
		    }
		    /**
		     * This overly complicated beast is just to record the last tested line/column and the resulting
		     * index, allowing us to skip a few tests if mappings are monotonically increasing.
		     */
		    function memoizedBinarySearch(haystack, needle, state, key) {
		        const { lastKey, lastNeedle, lastIndex } = state;
		        let low = 0;
		        let high = haystack.length - 1;
		        if (key === lastKey) {
		            if (needle === lastNeedle) {
		                found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
		                return lastIndex;
		            }
		            if (needle >= lastNeedle) {
		                // lastIndex may be -1 if the previous needle was not found.
		                low = lastIndex === -1 ? 0 : lastIndex;
		            }
		            else {
		                high = lastIndex;
		            }
		        }
		        state.lastKey = key;
		        state.lastNeedle = needle;
		        return (state.lastIndex = binarySearch(haystack, needle, low, high));
		    }

		    const AnyMap = function (map, mapUrl) {
		        const parsed = typeof map === 'string' ? JSON.parse(map) : map;
		        if (!('sections' in parsed))
		            return new TraceMap(parsed, mapUrl);
		        const mappings = [];
		        const sources = [];
		        const sourcesContent = [];
		        const names = [];
		        const { sections } = parsed;
		        let i = 0;
		        for (; i < sections.length - 1; i++) {
		            const no = sections[i + 1].offset;
		            addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);
		        }
		        if (sections.length > 0) {
		            addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);
		        }
		        const joined = {
		            version: 3,
		            file: parsed.file,
		            names,
		            sources,
		            sourcesContent,
		            mappings,
		        };
		        return presortedDecodedMap(joined);
		    };
		    function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {
		        const map = AnyMap(section.map, mapUrl);
		        const { line: lineOffset, column: columnOffset } = section.offset;
		        const sourcesOffset = sources.length;
		        const namesOffset = names.length;
		        const decoded = decodedMappings(map);
		        const { resolvedSources } = map;
		        append(sources, resolvedSources);
		        append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));
		        append(names, map.names);
		        // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.
		        for (let i = mappings.length; i <= lineOffset; i++)
		            mappings.push([]);
		        // We can only add so many lines before we step into the range that the next section's map
		        // controls. When we get to the last line, then we'll start checking the segments to see if
		        // they've crossed into the column range.
		        const stopI = stopLine - lineOffset;
		        const len = Math.min(decoded.length, stopI + 1);
		        for (let i = 0; i < len; i++) {
		            const line = decoded[i];
		            // On the 0th loop, the line will already exist due to a previous section, or the line catch up
		            // loop above.
		            const out = i === 0 ? mappings[lineOffset] : (mappings[lineOffset + i] = []);
		            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
		            // map can be multiple lines), it doesn't.
		            const cOffset = i === 0 ? columnOffset : 0;
		            for (let j = 0; j < line.length; j++) {
		                const seg = line[j];
		                const column = cOffset + seg[COLUMN$1];
		                // If this segment steps into the column range that the next section's map controls, we need
		                // to stop early.
		                if (i === stopI && column >= stopColumn)
		                    break;
		                if (seg.length === 1) {
		                    out.push([column]);
		                    continue;
		                }
		                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX$1];
		                const sourceLine = seg[SOURCE_LINE$1];
		                const sourceColumn = seg[SOURCE_COLUMN$1];
		                if (seg.length === 4) {
		                    out.push([column, sourcesIndex, sourceLine, sourceColumn]);
		                    continue;
		                }
		                out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX$1]]);
		            }
		        }
		    }
		    function append(arr, other) {
		        for (let i = 0; i < other.length; i++)
		            arr.push(other[i]);
		    }
		    // Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of
		    // equal length to the sources. This is because the sources and sourcesContent are paired arrays,
		    // where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined
		    // sourcemap would desynchronize the sources/contents.
		    function fillSourcesContent(len) {
		        const sourcesContent = [];
		        for (let i = 0; i < len; i++)
		            sourcesContent[i] = null;
		        return sourcesContent;
		    }

		    const INVALID_ORIGINAL_MAPPING = Object.freeze({
		        source: null,
		        line: null,
		        column: null,
		        name: null,
		    });
		    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
		    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
		    const LEAST_UPPER_BOUND = -1;
		    const GREATEST_LOWER_BOUND = 1;
		    /**
		     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
		     */
		    let decodedMappings;
		    /**
		     * A higher-level API to find the source/line/column associated with a generated line/column
		     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
		     * `source-map` library.
		     */
		    let originalPositionFor;
		    /**
		     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
		     * maps.
		     */
		    let presortedDecodedMap;
		    class TraceMap {
		        constructor(map, mapUrl) {
		            this._decodedMemo = memoizedState();
		            this._bySources = undefined;
		            this._bySourceMemos = undefined;
		            const isString = typeof map === 'string';
		            if (!isString && map.constructor === TraceMap)
		                return map;
		            const parsed = (isString ? JSON.parse(map) : map);
		            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
		            this.version = version;
		            this.file = file;
		            this.names = names;
		            this.sourceRoot = sourceRoot;
		            this.sources = sources;
		            this.sourcesContent = sourcesContent;
		            if (sourceRoot || mapUrl) {
		                const from = resolve(sourceRoot || '', stripFilename(mapUrl));
		                this.resolvedSources = sources.map((s) => resolve(s || '', from));
		            }
		            else {
		                this.resolvedSources = sources.map((s) => s || '');
		            }
		            const { mappings } = parsed;
		            if (typeof mappings === 'string') {
		                this._encoded = mappings;
		                this._decoded = undefined;
		            }
		            else {
		                this._encoded = undefined;
		                this._decoded = maybeSort(mappings, isString);
		            }
		        }
		    }
		    (() => {
		        decodedMappings = (map) => {
		            return (map._decoded || (map._decoded = decode(map._encoded)));
		        };
		        originalPositionFor = (map, { line, column, bias }) => {
		            line--;
		            if (line < 0)
		                throw new Error(LINE_GTR_ZERO);
		            if (column < 0)
		                throw new Error(COL_GTR_EQ_ZERO);
		            const decoded = decodedMappings(map);
		            // It's common for parent source maps to have pointers to lines that have no
		            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
		            if (line >= decoded.length)
		                return INVALID_ORIGINAL_MAPPING;
		            const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
		            if (segment == null)
		                return INVALID_ORIGINAL_MAPPING;
		            if (segment.length == 1)
		                return INVALID_ORIGINAL_MAPPING;
		            const { names, resolvedSources } = map;
		            return {
		                source: resolvedSources[segment[SOURCES_INDEX$1]],
		                line: segment[SOURCE_LINE$1] + 1,
		                column: segment[SOURCE_COLUMN$1],
		                name: segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null,
		            };
		        };
		        presortedDecodedMap = (map, mapUrl) => {
		            const clone = Object.assign({}, map);
		            clone.mappings = [];
		            const tracer = new TraceMap(clone, mapUrl);
		            tracer._decoded = map.mappings;
		            return tracer;
		        };
		    })();
		    function traceSegmentInternal(segments, memo, line, column, bias) {
		        let index = memoizedBinarySearch(segments, column, memo, line);
		        if (found) {
		            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
		        }
		        else if (bias === LEAST_UPPER_BOUND)
		            index++;
		        if (index === -1 || index === segments.length)
		            return null;
		        return segments[index];
		    }

		    /**
		     * Gets the index associated with `key` in the backing array, if it is already present.
		     */
		    let get;
		    /**
		     * Puts `key` into the backing array, if it is not already present. Returns
		     * the index of the `key` in the backing array.
		     */
		    let put;
		    /**
		     * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
		     * index of the `key` in the backing array.
		     *
		     * This is designed to allow synchronizing a second array with the contents of the backing array,
		     * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
		     * and there are never duplicates.
		     */
		    class SetArray {
		        constructor() {
		            this._indexes = { __proto__: null };
		            this.array = [];
		        }
		    }
		    (() => {
		        get = (strarr, key) => strarr._indexes[key];
		        put = (strarr, key) => {
		            // The key may or may not be present. If it is present, it's a number.
		            const index = get(strarr, key);
		            if (index !== undefined)
		                return index;
		            const { array, _indexes: indexes } = strarr;
		            return (indexes[key] = array.push(key) - 1);
		        };
		    })();

		    const COLUMN = 0;
		    const SOURCES_INDEX = 1;
		    const SOURCE_LINE = 2;
		    const SOURCE_COLUMN = 3;
		    const NAMES_INDEX = 4;

		    const NO_NAME = -1;
		    /**
		     * Same as `addMapping`, but will only add the mapping if it generates useful information in the
		     * resulting map. This only works correctly if mappings are added **in order**, meaning you should
		     * not add a mapping with a lower generated line/column than one that came before.
		     */
		    let maybeAddMapping;
		    /**
		     * Adds/removes the content of the source file to the source map.
		     */
		    let setSourceContent;
		    /**
		     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
		     * a sourcemap, or to JSON.stringify.
		     */
		    let toDecodedMap;
		    /**
		     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
		     * a sourcemap, or to JSON.stringify.
		     */
		    let toEncodedMap;
		    // This split declaration is only so that terser can elminiate the static initialization block.
		    let addSegmentInternal;
		    /**
		     * Provides the state to generate a sourcemap.
		     */
		    class GenMapping {
		        constructor({ file, sourceRoot } = {}) {
		            this._names = new SetArray();
		            this._sources = new SetArray();
		            this._sourcesContent = [];
		            this._mappings = [];
		            this.file = file;
		            this.sourceRoot = sourceRoot;
		        }
		    }
		    (() => {
		        maybeAddMapping = (map, mapping) => {
		            return addMappingInternal(true, map, mapping);
		        };
		        setSourceContent = (map, source, content) => {
		            const { _sources: sources, _sourcesContent: sourcesContent } = map;
		            sourcesContent[put(sources, source)] = content;
		        };
		        toDecodedMap = (map) => {
		            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;
		            removeEmptyFinalLines(mappings);
		            return {
		                version: 3,
		                file: file || undefined,
		                names: names.array,
		                sourceRoot: sourceRoot || undefined,
		                sources: sources.array,
		                sourcesContent,
		                mappings,
		            };
		        };
		        toEncodedMap = (map) => {
		            const decoded = toDecodedMap(map);
		            return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });
		        };
		        // Internal helpers
		        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {
		            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;
		            const line = getLine(mappings, genLine);
		            const index = getColumnIndex(line, genColumn);
		            if (!source) {
		                if (skipable && skipSourceless(line, index))
		                    return;
		                return insert(line, index, [genColumn]);
		            }
		            const sourcesIndex = put(sources, source);
		            const namesIndex = name ? put(names, name) : NO_NAME;
		            if (sourcesIndex === sourcesContent.length)
		                sourcesContent[sourcesIndex] = null;
		            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
		                return;
		            }
		            return insert(line, index, name
		                ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
		                : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
		        };
		    })();
		    function getLine(mappings, index) {
		        for (let i = mappings.length; i <= index; i++) {
		            mappings[i] = [];
		        }
		        return mappings[index];
		    }
		    function getColumnIndex(line, genColumn) {
		        let index = line.length;
		        for (let i = index - 1; i >= 0; index = i--) {
		            const current = line[i];
		            if (genColumn >= current[COLUMN])
		                break;
		        }
		        return index;
		    }
		    function insert(array, index, value) {
		        for (let i = array.length; i > index; i--) {
		            array[i] = array[i - 1];
		        }
		        array[index] = value;
		    }
		    function removeEmptyFinalLines(mappings) {
		        const { length } = mappings;
		        let len = length;
		        for (let i = len - 1; i >= 0; len = i, i--) {
		            if (mappings[i].length > 0)
		                break;
		        }
		        if (len < length)
		            mappings.length = len;
		    }
		    function skipSourceless(line, index) {
		        // The start of a line is already sourceless, so adding a sourceless segment to the beginning
		        // doesn't generate any useful information.
		        if (index === 0)
		            return true;
		        const prev = line[index - 1];
		        // If the previous segment is also sourceless, then adding another sourceless segment doesn't
		        // genrate any new information. Else, this segment will end the source/named segment and point to
		        // a sourceless position, which is useful.
		        return prev.length === 1;
		    }
		    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
		        // A source/named segment at the start of a line gives position at that genColumn
		        if (index === 0)
		            return false;
		        const prev = line[index - 1];
		        // If the previous segment is sourceless, then we're transitioning to a source.
		        if (prev.length === 1)
		            return false;
		        // If the previous segment maps to the exact same source position, then this segment doesn't
		        // provide any new position information.
		        return (sourcesIndex === prev[SOURCES_INDEX] &&
		            sourceLine === prev[SOURCE_LINE] &&
		            sourceColumn === prev[SOURCE_COLUMN] &&
		            namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));
		    }
		    function addMappingInternal(skipable, map, mapping) {
		        const { generated, source, original, name } = mapping;
		        if (!source) {
		            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null);
		        }
		        const s = source;
		        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name);
		    }

		    class SourceMapConsumer {
		        constructor(map, mapUrl) {
		            const trace = (this._map = new AnyMap(map, mapUrl));
		            this.file = trace.file;
		            this.names = trace.names;
		            this.sourceRoot = trace.sourceRoot;
		            this.sources = trace.resolvedSources;
		            this.sourcesContent = trace.sourcesContent;
		        }
		        originalPositionFor(needle) {
		            return originalPositionFor(this._map, needle);
		        }
		        destroy() {
		            // noop.
		        }
		    }
		    class SourceMapGenerator {
		        constructor(opts) {
		            this._map = new GenMapping(opts);
		        }
		        addMapping(mapping) {
		            maybeAddMapping(this._map, mapping);
		        }
		        setSourceContent(source, content) {
		            setSourceContent(this._map, source, content);
		        }
		        toJSON() {
		            return toEncodedMap(this._map);
		        }
		        toDecodedMap() {
		            return toDecodedMap(this._map);
		        }
		    }

		    exports.SourceMapConsumer = SourceMapConsumer;
		    exports.SourceMapGenerator = SourceMapGenerator;

		    Object.defineProperty(exports, '__esModule', { value: true });

		}));
		
	} (sourceMap_umd, sourceMap_umd.exports));
	return sourceMap_umd.exports;
}

var acorn = {exports: {}};

var hasRequiredAcorn;

function requireAcorn () {
	if (hasRequiredAcorn) return acorn.exports;
	hasRequiredAcorn = 1;
	(function (module, exports) {
		(function (global, factory) {
		  factory(exports) ;
		})(commonjsGlobal, (function (exports) {
		  // This file was generated. Do not modify manually!
		  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

		  // This file was generated. Do not modify manually!
		  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

		  // This file was generated. Do not modify manually!
		  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

		  // These are a run-length and offset encoded representation of the
		  // >0xffff code points that are a valid part of identifiers. The
		  // offset starts at 0x10000, and each pair of numbers represents an
		  // offset to the next range, and then a size of the range.

		  // Reserved word lists for various dialects of the language

		  var reservedWords = {
		    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
		    5: "class enum extends super const export import",
		    6: "enum",
		    strict: "implements interface let package private protected public static yield",
		    strictBind: "eval arguments"
		  };

		  // And the keywords

		  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

		  var keywords$1 = {
		    5: ecma5AndLessKeywords,
		    "5module": ecma5AndLessKeywords + " export import",
		    6: ecma5AndLessKeywords + " const class extends export import super"
		  };

		  var keywordRelationalOperator = /^in(stanceof)?$/;

		  // ## Character categories

		  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
		  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

		  // This has a complexity linear to the value of the code. The
		  // assumption is that looking up astral identifier characters is
		  // rare.
		  function isInAstralSet(code, set) {
		    var pos = 0x10000;
		    for (var i = 0; i < set.length; i += 2) {
		      pos += set[i];
		      if (pos > code) { return false }
		      pos += set[i + 1];
		      if (pos >= code) { return true }
		    }
		    return false
		  }

		  // Test whether a given character code starts an identifier.

		  function isIdentifierStart(code, astral) {
		    if (code < 65) { return code === 36 }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes)
		  }

		  // Test whether a given character is part of an identifier.

		  function isIdentifierChar(code, astral) {
		    if (code < 48) { return code === 36 }
		    if (code < 58) { return true }
		    if (code < 65) { return false }
		    if (code < 91) { return true }
		    if (code < 97) { return code === 95 }
		    if (code < 123) { return true }
		    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
		    if (astral === false) { return false }
		    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
		  }

		  // ## Token types

		  // The assignment of fine-grained, information-carrying type objects
		  // allows the tokenizer to store the information it has about a
		  // token in a way that is very cheap for the parser to look up.

		  // All token type variables start with an underscore, to make them
		  // easy to recognize.

		  // The `beforeExpr` property is used to disambiguate between regular
		  // expressions and divisions. It is set on all token types that can
		  // be followed by an expression (thus, a slash after them would be a
		  // regular expression).
		  //
		  // The `startsExpr` property is used to check if the token ends a
		  // `yield` expression. It is set on all token types that either can
		  // directly start an expression (like a quotation mark) or can
		  // continue an expression (like the body of a string).
		  //
		  // `isLoop` marks a keyword as starting a loop, which is important
		  // to know when parsing a label, in order to allow or disallow
		  // continue jumps to that label.

		  var TokenType = function TokenType(label, conf) {
		    if ( conf === void 0 ) conf = {};

		    this.label = label;
		    this.keyword = conf.keyword;
		    this.beforeExpr = !!conf.beforeExpr;
		    this.startsExpr = !!conf.startsExpr;
		    this.isLoop = !!conf.isLoop;
		    this.isAssign = !!conf.isAssign;
		    this.prefix = !!conf.prefix;
		    this.postfix = !!conf.postfix;
		    this.binop = conf.binop || null;
		    this.updateContext = null;
		  };

		  function binop(name, prec) {
		    return new TokenType(name, {beforeExpr: true, binop: prec})
		  }
		  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

		  // Map keyword names to token types.

		  var keywords = {};

		  // Succinct definitions of keyword token types
		  function kw(name, options) {
		    if ( options === void 0 ) options = {};

		    options.keyword = name;
		    return keywords[name] = new TokenType(name, options)
		  }

		  var types$1 = {
		    num: new TokenType("num", startsExpr),
		    regexp: new TokenType("regexp", startsExpr),
		    string: new TokenType("string", startsExpr),
		    name: new TokenType("name", startsExpr),
		    privateId: new TokenType("privateId", startsExpr),
		    eof: new TokenType("eof"),

		    // Punctuation token types.
		    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
		    bracketR: new TokenType("]"),
		    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
		    braceR: new TokenType("}"),
		    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
		    parenR: new TokenType(")"),
		    comma: new TokenType(",", beforeExpr),
		    semi: new TokenType(";", beforeExpr),
		    colon: new TokenType(":", beforeExpr),
		    dot: new TokenType("."),
		    question: new TokenType("?", beforeExpr),
		    questionDot: new TokenType("?."),
		    arrow: new TokenType("=>", beforeExpr),
		    template: new TokenType("template"),
		    invalidTemplate: new TokenType("invalidTemplate"),
		    ellipsis: new TokenType("...", beforeExpr),
		    backQuote: new TokenType("`", startsExpr),
		    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

		    // Operators. These carry several kinds of properties to help the
		    // parser use them properly (the presence of these properties is
		    // what categorizes them as operators).
		    //
		    // `binop`, when present, specifies that this operator is a binary
		    // operator, and will refer to its precedence.
		    //
		    // `prefix` and `postfix` mark the operator as a prefix or postfix
		    // unary operator.
		    //
		    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
		    // binary operators with a very low precedence, that should result
		    // in AssignmentExpression nodes.

		    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
		    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
		    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
		    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
		    logicalOR: binop("||", 1),
		    logicalAND: binop("&&", 2),
		    bitwiseOR: binop("|", 3),
		    bitwiseXOR: binop("^", 4),
		    bitwiseAND: binop("&", 5),
		    equality: binop("==/!=/===/!==", 6),
		    relational: binop("</>/<=/>=", 7),
		    bitShift: binop("<</>>/>>>", 8),
		    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
		    modulo: binop("%", 10),
		    star: binop("*", 10),
		    slash: binop("/", 10),
		    starstar: new TokenType("**", {beforeExpr: true}),
		    coalesce: binop("??", 1),

		    // Keyword token types.
		    _break: kw("break"),
		    _case: kw("case", beforeExpr),
		    _catch: kw("catch"),
		    _continue: kw("continue"),
		    _debugger: kw("debugger"),
		    _default: kw("default", beforeExpr),
		    _do: kw("do", {isLoop: true, beforeExpr: true}),
		    _else: kw("else", beforeExpr),
		    _finally: kw("finally"),
		    _for: kw("for", {isLoop: true}),
		    _function: kw("function", startsExpr),
		    _if: kw("if"),
		    _return: kw("return", beforeExpr),
		    _switch: kw("switch"),
		    _throw: kw("throw", beforeExpr),
		    _try: kw("try"),
		    _var: kw("var"),
		    _const: kw("const"),
		    _while: kw("while", {isLoop: true}),
		    _with: kw("with"),
		    _new: kw("new", {beforeExpr: true, startsExpr: true}),
		    _this: kw("this", startsExpr),
		    _super: kw("super", startsExpr),
		    _class: kw("class", startsExpr),
		    _extends: kw("extends", beforeExpr),
		    _export: kw("export"),
		    _import: kw("import", startsExpr),
		    _null: kw("null", startsExpr),
		    _true: kw("true", startsExpr),
		    _false: kw("false", startsExpr),
		    _in: kw("in", {beforeExpr: true, binop: 7}),
		    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
		    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
		    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
		  };

		  // Matches a whole line break (where CRLF is considered a single
		  // line break). Used to count lines.

		  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
		  var lineBreakG = new RegExp(lineBreak.source, "g");

		  function isNewLine(code) {
		    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
		  }

		  function nextLineBreak(code, from, end) {
		    if ( end === void 0 ) end = code.length;

		    for (var i = from; i < end; i++) {
		      var next = code.charCodeAt(i);
		      if (isNewLine(next))
		        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
		    }
		    return -1
		  }

		  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

		  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

		  var ref = Object.prototype;
		  var hasOwnProperty = ref.hasOwnProperty;
		  var toString = ref.toString;

		  var hasOwn = Object.hasOwn || (function (obj, propName) { return (
		    hasOwnProperty.call(obj, propName)
		  ); });

		  var isArray = Array.isArray || (function (obj) { return (
		    toString.call(obj) === "[object Array]"
		  ); });

		  function wordsRegexp(words) {
		    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
		  }

		  function codePointToString(code) {
		    // UTF-16 Decoding
		    if (code <= 0xFFFF) { return String.fromCharCode(code) }
		    code -= 0x10000;
		    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
		  }

		  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

		  // These are used when `options.locations` is on, for the
		  // `startLoc` and `endLoc` properties.

		  var Position = function Position(line, col) {
		    this.line = line;
		    this.column = col;
		  };

		  Position.prototype.offset = function offset (n) {
		    return new Position(this.line, this.column + n)
		  };

		  var SourceLocation = function SourceLocation(p, start, end) {
		    this.start = start;
		    this.end = end;
		    if (p.sourceFile !== null) { this.source = p.sourceFile; }
		  };

		  // The `getLineInfo` function is mostly useful when the
		  // `locations` option is off (for performance reasons) and you
		  // want to find the line/column position for a given character
		  // offset. `input` should be the code string that the offset refers
		  // into.

		  function getLineInfo(input, offset) {
		    for (var line = 1, cur = 0;;) {
		      var nextBreak = nextLineBreak(input, cur, offset);
		      if (nextBreak < 0) { return new Position(line, offset - cur) }
		      ++line;
		      cur = nextBreak;
		    }
		  }

		  // A second argument must be given to configure the parser process.
		  // These options are recognized (only `ecmaVersion` is required):

		  var defaultOptions = {
		    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
		    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
		    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
		    // (the latest version the library supports). This influences
		    // support for strict mode, the set of reserved words, and support
		    // for new syntax features.
		    ecmaVersion: null,
		    // `sourceType` indicates the mode the code should be parsed in.
		    // Can be either `"script"` or `"module"`. This influences global
		    // strict mode and parsing of `import` and `export` declarations.
		    sourceType: "script",
		    // `onInsertedSemicolon` can be a callback that will be called
		    // when a semicolon is automatically inserted. It will be passed
		    // the position of the comma as an offset, and if `locations` is
		    // enabled, it is given the location as a `{line, column}` object
		    // as second argument.
		    onInsertedSemicolon: null,
		    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
		    // trailing commas.
		    onTrailingComma: null,
		    // By default, reserved words are only enforced if ecmaVersion >= 5.
		    // Set `allowReserved` to a boolean value to explicitly turn this on
		    // an off. When this option has the value "never", reserved words
		    // and keywords can also not be used as property names.
		    allowReserved: null,
		    // When enabled, a return at the top level is not considered an
		    // error.
		    allowReturnOutsideFunction: false,
		    // When enabled, import/export statements are not constrained to
		    // appearing at the top of the program, and an import.meta expression
		    // in a script isn't considered an error.
		    allowImportExportEverywhere: false,
		    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
		    // When enabled, await identifiers are allowed to appear at the top-level scope,
		    // but they are still not allowed in non-async functions.
		    allowAwaitOutsideFunction: null,
		    // When enabled, super identifiers are not constrained to
		    // appearing in methods and do not raise an error when they appear elsewhere.
		    allowSuperOutsideMethod: null,
		    // When enabled, hashbang directive in the beginning of file is
		    // allowed and treated as a line comment. Enabled by default when
		    // `ecmaVersion` >= 2023.
		    allowHashBang: false,
		    // By default, the parser will verify that private properties are
		    // only used in places where they are valid and have been declared.
		    // Set this to false to turn such checks off.
		    checkPrivateFields: true,
		    // When `locations` is on, `loc` properties holding objects with
		    // `start` and `end` properties in `{line, column}` form (with
		    // line being 1-based and column 0-based) will be attached to the
		    // nodes.
		    locations: false,
		    // A function can be passed as `onToken` option, which will
		    // cause Acorn to call that function with object in the same
		    // format as tokens returned from `tokenizer().getToken()`. Note
		    // that you are not allowed to call the parser from the
		    // callback—that will corrupt its internal state.
		    onToken: null,
		    // A function can be passed as `onComment` option, which will
		    // cause Acorn to call that function with `(block, text, start,
		    // end)` parameters whenever a comment is skipped. `block` is a
		    // boolean indicating whether this is a block (`/* */`) comment,
		    // `text` is the content of the comment, and `start` and `end` are
		    // character offsets that denote the start and end of the comment.
		    // When the `locations` option is on, two more parameters are
		    // passed, the full `{line, column}` locations of the start and
		    // end of the comments. Note that you are not allowed to call the
		    // parser from the callback—that will corrupt its internal state.
		    onComment: null,
		    // Nodes have their start and end characters offsets recorded in
		    // `start` and `end` properties (directly on the node, rather than
		    // the `loc` object, which holds line/column data. To also add a
		    // [semi-standardized][range] `range` property holding a `[start,
		    // end]` array with the same numbers, set the `ranges` option to
		    // `true`.
		    //
		    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
		    ranges: false,
		    // It is possible to parse multiple files into a single AST by
		    // passing the tree produced by parsing the first file as
		    // `program` option in subsequent parses. This will add the
		    // toplevel forms of the parsed file to the `Program` (top) node
		    // of an existing parse tree.
		    program: null,
		    // When `locations` is on, you can pass this to record the source
		    // file in every node's `loc` object.
		    sourceFile: null,
		    // This value, if given, is stored in every node, whether
		    // `locations` is on or off.
		    directSourceFile: null,
		    // When enabled, parenthesized expressions are represented by
		    // (non-standard) ParenthesizedExpression nodes
		    preserveParens: false
		  };

		  // Interpret and default an options object

		  var warnedAboutEcmaVersion = false;

		  function getOptions(opts) {
		    var options = {};

		    for (var opt in defaultOptions)
		      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

		    if (options.ecmaVersion === "latest") {
		      options.ecmaVersion = 1e8;
		    } else if (options.ecmaVersion == null) {
		      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
		        warnedAboutEcmaVersion = true;
		        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		      }
		      options.ecmaVersion = 11;
		    } else if (options.ecmaVersion >= 2015) {
		      options.ecmaVersion -= 2009;
		    }

		    if (options.allowReserved == null)
		      { options.allowReserved = options.ecmaVersion < 5; }

		    if (!opts || opts.allowHashBang == null)
		      { options.allowHashBang = options.ecmaVersion >= 14; }

		    if (isArray(options.onToken)) {
		      var tokens = options.onToken;
		      options.onToken = function (token) { return tokens.push(token); };
		    }
		    if (isArray(options.onComment))
		      { options.onComment = pushComment(options, options.onComment); }

		    return options
		  }

		  function pushComment(options, array) {
		    return function(block, text, start, end, startLoc, endLoc) {
		      var comment = {
		        type: block ? "Block" : "Line",
		        value: text,
		        start: start,
		        end: end
		      };
		      if (options.locations)
		        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
		      if (options.ranges)
		        { comment.range = [start, end]; }
		      array.push(comment);
		    }
		  }

		  // Each scope gets a bitset that may contain these flags
		  var
		      SCOPE_TOP = 1,
		      SCOPE_FUNCTION = 2,
		      SCOPE_ASYNC = 4,
		      SCOPE_GENERATOR = 8,
		      SCOPE_ARROW = 16,
		      SCOPE_SIMPLE_CATCH = 32,
		      SCOPE_SUPER = 64,
		      SCOPE_DIRECT_SUPER = 128,
		      SCOPE_CLASS_STATIC_BLOCK = 256,
		      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

		  function functionFlags(async, generator) {
		    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
		  }

		  // Used in checkLVal* and declareName to determine the type of a binding
		  var
		      BIND_NONE = 0, // Not a binding
		      BIND_VAR = 1, // Var-style binding
		      BIND_LEXICAL = 2, // Let- or const-style binding
		      BIND_FUNCTION = 3, // Function declaration
		      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
		      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

		  var Parser = function Parser(options, input, startPos) {
		    this.options = options = getOptions(options);
		    this.sourceFile = options.sourceFile;
		    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
		    var reserved = "";
		    if (options.allowReserved !== true) {
		      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		      if (options.sourceType === "module") { reserved += " await"; }
		    }
		    this.reservedWords = wordsRegexp(reserved);
		    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
		    this.reservedWordsStrict = wordsRegexp(reservedStrict);
		    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
		    this.input = String(input);

		    // Used to signal to callers of `readWord1` whether the word
		    // contained any escape sequences. This is needed because words with
		    // escape sequences must not be interpreted as keywords.
		    this.containsEsc = false;

		    // Set up token state

		    // The current position of the tokenizer in the input.
		    if (startPos) {
		      this.pos = startPos;
		      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
		    } else {
		      this.pos = this.lineStart = 0;
		      this.curLine = 1;
		    }

		    // Properties of the current token:
		    // Its type
		    this.type = types$1.eof;
		    // For tokens that include more information than their type, the value
		    this.value = null;
		    // Its start and end offset
		    this.start = this.end = this.pos;
		    // And, if locations are used, the {line, column} object
		    // corresponding to those offsets
		    this.startLoc = this.endLoc = this.curPosition();

		    // Position information for the previous token
		    this.lastTokEndLoc = this.lastTokStartLoc = null;
		    this.lastTokStart = this.lastTokEnd = this.pos;

		    // The context stack is used to superficially track syntactic
		    // context to predict whether a regular expression is allowed in a
		    // given position.
		    this.context = this.initialContext();
		    this.exprAllowed = true;

		    // Figure out if it's a module code.
		    this.inModule = options.sourceType === "module";
		    this.strict = this.inModule || this.strictDirective(this.pos);

		    // Used to signify the start of a potential arrow function
		    this.potentialArrowAt = -1;
		    this.potentialArrowInForAwait = false;

		    // Positions to delayed-check that yield/await does not exist in default parameters.
		    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
		    // Labels in scope.
		    this.labels = [];
		    // Thus-far undefined exports.
		    this.undefinedExports = Object.create(null);

		    // If enabled, skip leading hashbang line.
		    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
		      { this.skipLineComment(2); }

		    // Scope tracking for duplicate variable names (see scope.js)
		    this.scopeStack = [];
		    this.enterScope(SCOPE_TOP);

		    // For RegExp validation
		    this.regexpState = null;

		    // The stack of private names.
		    // Each element has two properties: 'declared' and 'used'.
		    // When it exited from the outermost class definition, all used private names must be declared.
		    this.privateNameStack = [];
		  };

		  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

		  Parser.prototype.parse = function parse () {
		    var node = this.options.program || this.startNode();
		    this.nextToken();
		    return this.parseTopLevel(node)
		  };

		  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

		  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

		  prototypeAccessors.canAwait.get = function () {
		    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
		      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
		    }
		    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
		  };

		  prototypeAccessors.allowSuper.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
		  };

		  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

		  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

		  prototypeAccessors.allowNewDotTarget.get = function () {
		    var ref = this.currentThisScope();
		      var flags = ref.flags;
		      var inClassFieldInit = ref.inClassFieldInit;
		    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
		  };

		  prototypeAccessors.inClassStaticBlock.get = function () {
		    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
		  };

		  Parser.extend = function extend () {
		      var plugins = [], len = arguments.length;
		      while ( len-- ) plugins[ len ] = arguments[ len ];

		    var cls = this;
		    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
		    return cls
		  };

		  Parser.parse = function parse (input, options) {
		    return new this(options, input).parse()
		  };

		  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
		    var parser = new this(options, input, pos);
		    parser.nextToken();
		    return parser.parseExpression()
		  };

		  Parser.tokenizer = function tokenizer (input, options) {
		    return new this(options, input)
		  };

		  Object.defineProperties( Parser.prototype, prototypeAccessors );

		  var pp$9 = Parser.prototype;

		  // ## Parser utilities

		  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
		  pp$9.strictDirective = function(start) {
		    if (this.options.ecmaVersion < 5) { return false }
		    for (;;) {
		      // Try to find string literal.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      var match = literal.exec(this.input.slice(start));
		      if (!match) { return false }
		      if ((match[1] || match[2]) === "use strict") {
		        skipWhiteSpace.lastIndex = start + match[0].length;
		        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
		        var next = this.input.charAt(end);
		        return next === ";" || next === "}" ||
		          (lineBreak.test(spaceAfter[0]) &&
		           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
		      }
		      start += match[0].length;

		      // Skip semicolon, if any.
		      skipWhiteSpace.lastIndex = start;
		      start += skipWhiteSpace.exec(this.input)[0].length;
		      if (this.input[start] === ";")
		        { start++; }
		    }
		  };

		  // Predicate that tests whether the next token is of the given
		  // type, and if yes, consumes it as a side effect.

		  pp$9.eat = function(type) {
		    if (this.type === type) {
		      this.next();
		      return true
		    } else {
		      return false
		    }
		  };

		  // Tests whether parsed token is a contextual keyword.

		  pp$9.isContextual = function(name) {
		    return this.type === types$1.name && this.value === name && !this.containsEsc
		  };

		  // Consumes contextual keyword if possible.

		  pp$9.eatContextual = function(name) {
		    if (!this.isContextual(name)) { return false }
		    this.next();
		    return true
		  };

		  // Asserts that following token is given contextual keyword.

		  pp$9.expectContextual = function(name) {
		    if (!this.eatContextual(name)) { this.unexpected(); }
		  };

		  // Test whether a semicolon can be inserted at the current position.

		  pp$9.canInsertSemicolon = function() {
		    return this.type === types$1.eof ||
		      this.type === types$1.braceR ||
		      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  pp$9.insertSemicolon = function() {
		    if (this.canInsertSemicolon()) {
		      if (this.options.onInsertedSemicolon)
		        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
		      return true
		    }
		  };

		  // Consume a semicolon, or, failing that, see if we are allowed to
		  // pretend that there is a semicolon at this position.

		  pp$9.semicolon = function() {
		    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
		  };

		  pp$9.afterTrailingComma = function(tokType, notNext) {
		    if (this.type === tokType) {
		      if (this.options.onTrailingComma)
		        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
		      if (!notNext)
		        { this.next(); }
		      return true
		    }
		  };

		  // Expect a token of a given type. If found, consume it, otherwise,
		  // raise an unexpected token error.

		  pp$9.expect = function(type) {
		    this.eat(type) || this.unexpected();
		  };

		  // Raise an unexpected token error.

		  pp$9.unexpected = function(pos) {
		    this.raise(pos != null ? pos : this.start, "Unexpected token");
		  };

		  var DestructuringErrors = function DestructuringErrors() {
		    this.shorthandAssign =
		    this.trailingComma =
		    this.parenthesizedAssign =
		    this.parenthesizedBind =
		    this.doubleProto =
		      -1;
		  };

		  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
		    if (!refDestructuringErrors) { return }
		    if (refDestructuringErrors.trailingComma > -1)
		      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
		    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
		    if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
		  };

		  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
		    if (!refDestructuringErrors) { return false }
		    var shorthandAssign = refDestructuringErrors.shorthandAssign;
		    var doubleProto = refDestructuringErrors.doubleProto;
		    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
		    if (shorthandAssign >= 0)
		      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
		    if (doubleProto >= 0)
		      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
		  };

		  pp$9.checkYieldAwaitInDefaultParams = function() {
		    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
		      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
		    if (this.awaitPos)
		      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
		  };

		  pp$9.isSimpleAssignTarget = function(expr) {
		    if (expr.type === "ParenthesizedExpression")
		      { return this.isSimpleAssignTarget(expr.expression) }
		    return expr.type === "Identifier" || expr.type === "MemberExpression"
		  };

		  var pp$8 = Parser.prototype;

		  // ### Statement parsing

		  // Parse a program. Initializes the parser, reads any number of
		  // statements, and wraps them in a Program node.  Optionally takes a
		  // `program` argument.  If present, the statements will be appended
		  // to its body instead of creating a new node.

		  pp$8.parseTopLevel = function(node) {
		    var exports = Object.create(null);
		    if (!node.body) { node.body = []; }
		    while (this.type !== types$1.eof) {
		      var stmt = this.parseStatement(null, true, exports);
		      node.body.push(stmt);
		    }
		    if (this.inModule)
		      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
		        {
		          var name = list[i];

		          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
		        } }
		    this.adaptDirectivePrologue(node.body);
		    this.next();
		    node.sourceType = this.options.sourceType;
		    return this.finishNode(node, "Program")
		  };

		  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

		  pp$8.isLet = function(context) {
		    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		    // For ambiguous cases, determine if a LexicalDeclaration (or only a
		    // Statement) is allowed here. If context is not empty then only a Statement
		    // is allowed. However, `let [` is an explicit negative lookahead for
		    // ExpressionStatement, so special-case it first.
		    if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
		    if (context) { return false }

		    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
		    if (isIdentifierStart(nextCh, true)) {
		      var pos = next + 1;
		      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
		      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
		      var ident = this.input.slice(next, pos);
		      if (!keywordRelationalOperator.test(ident)) { return true }
		    }
		    return false
		  };

		  // check 'async [no LineTerminator here] function'
		  // - 'async /*foo*/ function' is OK.
		  // - 'async /*\n*/ function' is invalid.
		  pp$8.isAsyncFunction = function() {
		    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
		      { return false }

		    skipWhiteSpace.lastIndex = this.pos;
		    var skip = skipWhiteSpace.exec(this.input);
		    var next = this.pos + skip[0].length, after;
		    return !lineBreak.test(this.input.slice(this.pos, next)) &&
		      this.input.slice(next, next + 8) === "function" &&
		      (next + 8 === this.input.length ||
		       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
		  };

		  // Parse a single statement.
		  //
		  // If expecting a statement and finding a slash operator, parse a
		  // regular expression literal. This is to handle cases like
		  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
		  // does not help.

		  pp$8.parseStatement = function(context, topLevel, exports) {
		    var starttype = this.type, node = this.startNode(), kind;

		    if (this.isLet(context)) {
		      starttype = types$1._var;
		      kind = "let";
		    }

		    // Most types of statements are recognized by the keyword they
		    // start with. Many are trivial to parse, some require a bit of
		    // complexity.

		    switch (starttype) {
		    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
		    case types$1._debugger: return this.parseDebuggerStatement(node)
		    case types$1._do: return this.parseDoStatement(node)
		    case types$1._for: return this.parseForStatement(node)
		    case types$1._function:
		      // Function as sole body of either an if statement or a labeled statement
		      // works, but not when it is part of a labeled statement that is the sole
		      // body of an if statement.
		      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
		      return this.parseFunctionStatement(node, false, !context)
		    case types$1._class:
		      if (context) { this.unexpected(); }
		      return this.parseClass(node, true)
		    case types$1._if: return this.parseIfStatement(node)
		    case types$1._return: return this.parseReturnStatement(node)
		    case types$1._switch: return this.parseSwitchStatement(node)
		    case types$1._throw: return this.parseThrowStatement(node)
		    case types$1._try: return this.parseTryStatement(node)
		    case types$1._const: case types$1._var:
		      kind = kind || this.value;
		      if (context && kind !== "var") { this.unexpected(); }
		      return this.parseVarStatement(node, kind)
		    case types$1._while: return this.parseWhileStatement(node)
		    case types$1._with: return this.parseWithStatement(node)
		    case types$1.braceL: return this.parseBlock(true, node)
		    case types$1.semi: return this.parseEmptyStatement(node)
		    case types$1._export:
		    case types$1._import:
		      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
		        skipWhiteSpace.lastIndex = this.pos;
		        var skip = skipWhiteSpace.exec(this.input);
		        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		        if (nextCh === 40 || nextCh === 46) // '(' or '.'
		          { return this.parseExpressionStatement(node, this.parseExpression()) }
		      }

		      if (!this.options.allowImportExportEverywhere) {
		        if (!topLevel)
		          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
		        if (!this.inModule)
		          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
		      }
		      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

		      // If the statement does not start with a statement keyword or a
		      // brace, it's an ExpressionStatement or LabeledStatement. We
		      // simply start parsing an expression, and afterwards, if the
		      // next token is a colon and the expression was a simple
		      // Identifier node, we switch to interpreting it as a label.
		    default:
		      if (this.isAsyncFunction()) {
		        if (context) { this.unexpected(); }
		        this.next();
		        return this.parseFunctionStatement(node, true, !context)
		      }

		      var maybeName = this.value, expr = this.parseExpression();
		      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
		        { return this.parseLabeledStatement(node, maybeName, expr, context) }
		      else { return this.parseExpressionStatement(node, expr) }
		    }
		  };

		  pp$8.parseBreakContinueStatement = function(node, keyword) {
		    var isBreak = keyword === "break";
		    this.next();
		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
		    else if (this.type !== types$1.name) { this.unexpected(); }
		    else {
		      node.label = this.parseIdent();
		      this.semicolon();
		    }

		    // Verify that there is an actual destination to break or
		    // continue to.
		    var i = 0;
		    for (; i < this.labels.length; ++i) {
		      var lab = this.labels[i];
		      if (node.label == null || lab.name === node.label.name) {
		        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
		        if (node.label && isBreak) { break }
		      }
		    }
		    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
		    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
		  };

		  pp$8.parseDebuggerStatement = function(node) {
		    this.next();
		    this.semicolon();
		    return this.finishNode(node, "DebuggerStatement")
		  };

		  pp$8.parseDoStatement = function(node) {
		    this.next();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("do");
		    this.labels.pop();
		    this.expect(types$1._while);
		    node.test = this.parseParenExpression();
		    if (this.options.ecmaVersion >= 6)
		      { this.eat(types$1.semi); }
		    else
		      { this.semicolon(); }
		    return this.finishNode(node, "DoWhileStatement")
		  };

		  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
		  // loop is non-trivial. Basically, we have to parse the init `var`
		  // statement or expression, disallowing the `in` operator (see
		  // the second parameter to `parseExpression`), and then check
		  // whether the next token is `in` or `of`. When there is no init
		  // part (semicolon immediately after the opening parenthesis), it
		  // is a regular `for` loop.

		  pp$8.parseForStatement = function(node) {
		    this.next();
		    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
		    this.labels.push(loopLabel);
		    this.enterScope(0);
		    this.expect(types$1.parenL);
		    if (this.type === types$1.semi) {
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, null)
		    }
		    var isLet = this.isLet();
		    if (this.type === types$1._var || this.type === types$1._const || isLet) {
		      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		      this.next();
		      this.parseVar(init$1, true, kind);
		      this.finishNode(init$1, "VariableDeclaration");
		      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
		        if (this.options.ecmaVersion >= 9) {
		          if (this.type === types$1._in) {
		            if (awaitAt > -1) { this.unexpected(awaitAt); }
		          } else { node.await = awaitAt > -1; }
		        }
		        return this.parseForIn(node, init$1)
		      }
		      if (awaitAt > -1) { this.unexpected(awaitAt); }
		      return this.parseFor(node, init$1)
		    }
		    var startsWithLet = this.isContextual("let"), isForOf = false;
		    var refDestructuringErrors = new DestructuringErrors;
		    var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
		    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		      if (this.options.ecmaVersion >= 9) {
		        if (this.type === types$1._in) {
		          if (awaitAt > -1) { this.unexpected(awaitAt); }
		        } else { node.await = awaitAt > -1; }
		      }
		      if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
		      this.toAssignable(init, false, refDestructuringErrors);
		      this.checkLValPattern(init);
		      return this.parseForIn(node, init)
		    } else {
		      this.checkExpressionErrors(refDestructuringErrors, true);
		    }
		    if (awaitAt > -1) { this.unexpected(awaitAt); }
		    return this.parseFor(node, init)
		  };

		  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
		    this.next();
		    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
		  };

		  pp$8.parseIfStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    // allow function declarations in branches, but only in non-strict mode
		    node.consequent = this.parseStatement("if");
		    node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
		    return this.finishNode(node, "IfStatement")
		  };

		  pp$8.parseReturnStatement = function(node) {
		    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
		      { this.raise(this.start, "'return' outside of function"); }
		    this.next();

		    // In `return` (and `break`/`continue`), the keywords with
		    // optional arguments, we eagerly look for a semicolon or the
		    // possibility to insert one.

		    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
		    else { node.argument = this.parseExpression(); this.semicolon(); }
		    return this.finishNode(node, "ReturnStatement")
		  };

		  pp$8.parseSwitchStatement = function(node) {
		    this.next();
		    node.discriminant = this.parseParenExpression();
		    node.cases = [];
		    this.expect(types$1.braceL);
		    this.labels.push(switchLabel);
		    this.enterScope(0);

		    // Statements under must be grouped (by label) in SwitchCase
		    // nodes. `cur` is used to keep the node that we are currently
		    // adding statements to.

		    var cur;
		    for (var sawDefault = false; this.type !== types$1.braceR;) {
		      if (this.type === types$1._case || this.type === types$1._default) {
		        var isCase = this.type === types$1._case;
		        if (cur) { this.finishNode(cur, "SwitchCase"); }
		        node.cases.push(cur = this.startNode());
		        cur.consequent = [];
		        this.next();
		        if (isCase) {
		          cur.test = this.parseExpression();
		        } else {
		          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
		          sawDefault = true;
		          cur.test = null;
		        }
		        this.expect(types$1.colon);
		      } else {
		        if (!cur) { this.unexpected(); }
		        cur.consequent.push(this.parseStatement(null));
		      }
		    }
		    this.exitScope();
		    if (cur) { this.finishNode(cur, "SwitchCase"); }
		    this.next(); // Closing brace
		    this.labels.pop();
		    return this.finishNode(node, "SwitchStatement")
		  };

		  pp$8.parseThrowStatement = function(node) {
		    this.next();
		    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
		      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
		    node.argument = this.parseExpression();
		    this.semicolon();
		    return this.finishNode(node, "ThrowStatement")
		  };

		  // Reused empty array added for node fields that are always empty.

		  var empty$1 = [];

		  pp$8.parseCatchClauseParam = function() {
		    var param = this.parseBindingAtom();
		    var simple = param.type === "Identifier";
		    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
		    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
		    this.expect(types$1.parenR);

		    return param
		  };

		  pp$8.parseTryStatement = function(node) {
		    this.next();
		    node.block = this.parseBlock();
		    node.handler = null;
		    if (this.type === types$1._catch) {
		      var clause = this.startNode();
		      this.next();
		      if (this.eat(types$1.parenL)) {
		        clause.param = this.parseCatchClauseParam();
		      } else {
		        if (this.options.ecmaVersion < 10) { this.unexpected(); }
		        clause.param = null;
		        this.enterScope(0);
		      }
		      clause.body = this.parseBlock(false);
		      this.exitScope();
		      node.handler = this.finishNode(clause, "CatchClause");
		    }
		    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
		    if (!node.handler && !node.finalizer)
		      { this.raise(node.start, "Missing catch or finally clause"); }
		    return this.finishNode(node, "TryStatement")
		  };

		  pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
		    this.next();
		    this.parseVar(node, false, kind, allowMissingInitializer);
		    this.semicolon();
		    return this.finishNode(node, "VariableDeclaration")
		  };

		  pp$8.parseWhileStatement = function(node) {
		    this.next();
		    node.test = this.parseParenExpression();
		    this.labels.push(loopLabel);
		    node.body = this.parseStatement("while");
		    this.labels.pop();
		    return this.finishNode(node, "WhileStatement")
		  };

		  pp$8.parseWithStatement = function(node) {
		    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
		    this.next();
		    node.object = this.parseParenExpression();
		    node.body = this.parseStatement("with");
		    return this.finishNode(node, "WithStatement")
		  };

		  pp$8.parseEmptyStatement = function(node) {
		    this.next();
		    return this.finishNode(node, "EmptyStatement")
		  };

		  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
		    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
		      {
		      var label = list[i$1];

		      if (label.name === maybeName)
		        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
		    } }
		    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
		    for (var i = this.labels.length - 1; i >= 0; i--) {
		      var label$1 = this.labels[i];
		      if (label$1.statementStart === node.start) {
		        // Update information about previous labels on this node
		        label$1.statementStart = this.start;
		        label$1.kind = kind;
		      } else { break }
		    }
		    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
		    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
		    this.labels.pop();
		    node.label = expr;
		    return this.finishNode(node, "LabeledStatement")
		  };

		  pp$8.parseExpressionStatement = function(node, expr) {
		    node.expression = expr;
		    this.semicolon();
		    return this.finishNode(node, "ExpressionStatement")
		  };

		  // Parse a semicolon-enclosed block of statements, handling `"use
		  // strict"` declarations when `allowStrict` is true (used for
		  // function bodies).

		  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
		    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
		    if ( node === void 0 ) node = this.startNode();

		    node.body = [];
		    this.expect(types$1.braceL);
		    if (createNewLexicalScope) { this.enterScope(0); }
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    if (exitStrict) { this.strict = false; }
		    this.next();
		    if (createNewLexicalScope) { this.exitScope(); }
		    return this.finishNode(node, "BlockStatement")
		  };

		  // Parse a regular `for` loop. The disambiguation code in
		  // `parseStatement` will already have parsed the init statement or
		  // expression.

		  pp$8.parseFor = function(node, init) {
		    node.init = init;
		    this.expect(types$1.semi);
		    node.test = this.type === types$1.semi ? null : this.parseExpression();
		    this.expect(types$1.semi);
		    node.update = this.type === types$1.parenR ? null : this.parseExpression();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, "ForStatement")
		  };

		  // Parse a `for`/`in` and `for`/`of` loop, which are almost
		  // same from parser's perspective.

		  pp$8.parseForIn = function(node, init) {
		    var isForIn = this.type === types$1._in;
		    this.next();

		    if (
		      init.type === "VariableDeclaration" &&
		      init.declarations[0].init != null &&
		      (
		        !isForIn ||
		        this.options.ecmaVersion < 8 ||
		        this.strict ||
		        init.kind !== "var" ||
		        init.declarations[0].id.type !== "Identifier"
		      )
		    ) {
		      this.raise(
		        init.start,
		        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
		      );
		    }
		    node.left = init;
		    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
		    this.expect(types$1.parenR);
		    node.body = this.parseStatement("for");
		    this.exitScope();
		    this.labels.pop();
		    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
		  };

		  // Parse a list of variable declarations.

		  pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
		    node.declarations = [];
		    node.kind = kind;
		    for (;;) {
		      var decl = this.startNode();
		      this.parseVarId(decl, kind);
		      if (this.eat(types$1.eq)) {
		        decl.init = this.parseMaybeAssign(isFor);
		      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
		        this.unexpected();
		      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
		        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		      } else {
		        decl.init = null;
		      }
		      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		      if (!this.eat(types$1.comma)) { break }
		    }
		    return node
		  };

		  pp$8.parseVarId = function(decl, kind) {
		    decl.id = this.parseBindingAtom();
		    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
		  };

		  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

		  // Parse a function declaration or literal (depending on the
		  // `statement & FUNC_STATEMENT`).

		  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
		  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
		        { this.unexpected(); }
		      node.generator = this.eat(types$1.star);
		    }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    if (statement & FUNC_STATEMENT) {
		      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
		      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
		        // If it is a regular function declaration in sloppy mode, then it is
		        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
		        // mode depends on properties of the current scope (see
		        // treatFunctionsAsVar).
		        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
		    }

		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(node.async, node.generator));

		    if (!(statement & FUNC_STATEMENT))
		      { node.id = this.type === types$1.name ? this.parseIdent() : null; }

		    this.parseFunctionParams(node);
		    this.parseFunctionBody(node, allowExpressionBody, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
		  };

		  pp$8.parseFunctionParams = function(node) {
		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		  };

		  // Parse a class declaration or literal (depending on the
		  // `isStatement` parameter).

		  pp$8.parseClass = function(node, isStatement) {
		    this.next();

		    // ecma-262 14.6 Class Definitions
		    // A class definition is always strict mode code.
		    var oldStrict = this.strict;
		    this.strict = true;

		    this.parseClassId(node, isStatement);
		    this.parseClassSuper(node);
		    var privateNameMap = this.enterClassBody();
		    var classBody = this.startNode();
		    var hadConstructor = false;
		    classBody.body = [];
		    this.expect(types$1.braceL);
		    while (this.type !== types$1.braceR) {
		      var element = this.parseClassElement(node.superClass !== null);
		      if (element) {
		        classBody.body.push(element);
		        if (element.type === "MethodDefinition" && element.kind === "constructor") {
		          if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
		          hadConstructor = true;
		        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
		          this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
		        }
		      }
		    }
		    this.strict = oldStrict;
		    this.next();
		    node.body = this.finishNode(classBody, "ClassBody");
		    this.exitClassBody();
		    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
		  };

		  pp$8.parseClassElement = function(constructorAllowsSuper) {
		    if (this.eat(types$1.semi)) { return null }

		    var ecmaVersion = this.options.ecmaVersion;
		    var node = this.startNode();
		    var keyName = "";
		    var isGenerator = false;
		    var isAsync = false;
		    var kind = "method";
		    var isStatic = false;

		    if (this.eatContextual("static")) {
		      // Parse static init block
		      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
		        this.parseClassStaticBlock(node);
		        return node
		      }
		      if (this.isClassElementNameStart() || this.type === types$1.star) {
		        isStatic = true;
		      } else {
		        keyName = "static";
		      }
		    }
		    node.static = isStatic;
		    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
		      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
		        isAsync = true;
		      } else {
		        keyName = "async";
		      }
		    }
		    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
		      isGenerator = true;
		    }
		    if (!keyName && !isAsync && !isGenerator) {
		      var lastValue = this.value;
		      if (this.eatContextual("get") || this.eatContextual("set")) {
		        if (this.isClassElementNameStart()) {
		          kind = lastValue;
		        } else {
		          keyName = lastValue;
		        }
		      }
		    }

		    // Parse element name
		    if (keyName) {
		      // 'async', 'get', 'set', or 'static' were not a keyword contextually.
		      // The last token is any of those. Make it the element name.
		      node.computed = false;
		      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		      node.key.name = keyName;
		      this.finishNode(node.key, "Identifier");
		    } else {
		      this.parseClassElementName(node);
		    }

		    // Parse element value
		    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		      var isConstructor = !node.static && checkKeyName(node, "constructor");
		      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
		      if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
		      node.kind = isConstructor ? "constructor" : kind;
		      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
		    } else {
		      this.parseClassField(node);
		    }

		    return node
		  };

		  pp$8.isClassElementNameStart = function() {
		    return (
		      this.type === types$1.name ||
		      this.type === types$1.privateId ||
		      this.type === types$1.num ||
		      this.type === types$1.string ||
		      this.type === types$1.bracketL ||
		      this.type.keyword
		    )
		  };

		  pp$8.parseClassElementName = function(element) {
		    if (this.type === types$1.privateId) {
		      if (this.value === "constructor") {
		        this.raise(this.start, "Classes can't have an element named '#constructor'");
		      }
		      element.computed = false;
		      element.key = this.parsePrivateIdent();
		    } else {
		      this.parsePropertyName(element);
		    }
		  };

		  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
		    // Check key and flags
		    var key = method.key;
		    if (method.kind === "constructor") {
		      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
		      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
		    } else if (method.static && checkKeyName(method, "prototype")) {
		      this.raise(key.start, "Classes may not have a static property named prototype");
		    }

		    // Parse value
		    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

		    // Check value
		    if (method.kind === "get" && value.params.length !== 0)
		      { this.raiseRecoverable(value.start, "getter should have no params"); }
		    if (method.kind === "set" && value.params.length !== 1)
		      { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
		    if (method.kind === "set" && value.params[0].type === "RestElement")
		      { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

		    return this.finishNode(method, "MethodDefinition")
		  };

		  pp$8.parseClassField = function(field) {
		    if (checkKeyName(field, "constructor")) {
		      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
		    } else if (field.static && checkKeyName(field, "prototype")) {
		      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
		    }

		    if (this.eat(types$1.eq)) {
		      // To raise SyntaxError if 'arguments' exists in the initializer.
		      var scope = this.currentThisScope();
		      var inClassFieldInit = scope.inClassFieldInit;
		      scope.inClassFieldInit = true;
		      field.value = this.parseMaybeAssign();
		      scope.inClassFieldInit = inClassFieldInit;
		    } else {
		      field.value = null;
		    }
		    this.semicolon();

		    return this.finishNode(field, "PropertyDefinition")
		  };

		  pp$8.parseClassStaticBlock = function(node) {
		    node.body = [];

		    var oldLabels = this.labels;
		    this.labels = [];
		    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
		    while (this.type !== types$1.braceR) {
		      var stmt = this.parseStatement(null);
		      node.body.push(stmt);
		    }
		    this.next();
		    this.exitScope();
		    this.labels = oldLabels;

		    return this.finishNode(node, "StaticBlock")
		  };

		  pp$8.parseClassId = function(node, isStatement) {
		    if (this.type === types$1.name) {
		      node.id = this.parseIdent();
		      if (isStatement)
		        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
		    } else {
		      if (isStatement === true)
		        { this.unexpected(); }
		      node.id = null;
		    }
		  };

		  pp$8.parseClassSuper = function(node) {
		    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
		  };

		  pp$8.enterClassBody = function() {
		    var element = {declared: Object.create(null), used: []};
		    this.privateNameStack.push(element);
		    return element.declared
		  };

		  pp$8.exitClassBody = function() {
		    var ref = this.privateNameStack.pop();
		    var declared = ref.declared;
		    var used = ref.used;
		    if (!this.options.checkPrivateFields) { return }
		    var len = this.privateNameStack.length;
		    var parent = len === 0 ? null : this.privateNameStack[len - 1];
		    for (var i = 0; i < used.length; ++i) {
		      var id = used[i];
		      if (!hasOwn(declared, id.name)) {
		        if (parent) {
		          parent.used.push(id);
		        } else {
		          this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
		        }
		      }
		    }
		  };

		  function isPrivateNameConflicted(privateNameMap, element) {
		    var name = element.key.name;
		    var curr = privateNameMap[name];

		    var next = "true";
		    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
		      next = (element.static ? "s" : "i") + element.kind;
		    }

		    // `class { get #a(){}; static set #a(_){} }` is also conflict.
		    if (
		      curr === "iget" && next === "iset" ||
		      curr === "iset" && next === "iget" ||
		      curr === "sget" && next === "sset" ||
		      curr === "sset" && next === "sget"
		    ) {
		      privateNameMap[name] = "true";
		      return false
		    } else if (!curr) {
		      privateNameMap[name] = next;
		      return false
		    } else {
		      return true
		    }
		  }

		  function checkKeyName(node, name) {
		    var computed = node.computed;
		    var key = node.key;
		    return !computed && (
		      key.type === "Identifier" && key.name === name ||
		      key.type === "Literal" && key.value === name
		    )
		  }

		  // Parses module export declaration.

		  pp$8.parseExportAllDeclaration = function(node, exports) {
		    if (this.options.ecmaVersion >= 11) {
		      if (this.eatContextual("as")) {
		        node.exported = this.parseModuleExportName();
		        this.checkExport(exports, node.exported, this.lastTokStart);
		      } else {
		        node.exported = null;
		      }
		    }
		    this.expectContextual("from");
		    if (this.type !== types$1.string) { this.unexpected(); }
		    node.source = this.parseExprAtom();
		    this.semicolon();
		    return this.finishNode(node, "ExportAllDeclaration")
		  };

		  pp$8.parseExport = function(node, exports) {
		    this.next();
		    // export * from '...'
		    if (this.eat(types$1.star)) {
		      return this.parseExportAllDeclaration(node, exports)
		    }
		    if (this.eat(types$1._default)) { // export default ...
		      this.checkExport(exports, "default", this.lastTokStart);
		      node.declaration = this.parseExportDefaultDeclaration();
		      return this.finishNode(node, "ExportDefaultDeclaration")
		    }
		    // export var|const|let|function|class ...
		    if (this.shouldParseExportStatement()) {
		      node.declaration = this.parseExportDeclaration(node);
		      if (node.declaration.type === "VariableDeclaration")
		        { this.checkVariableExport(exports, node.declaration.declarations); }
		      else
		        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
		      node.specifiers = [];
		      node.source = null;
		    } else { // export { x, y as z } [from '...']
		      node.declaration = null;
		      node.specifiers = this.parseExportSpecifiers(exports);
		      if (this.eatContextual("from")) {
		        if (this.type !== types$1.string) { this.unexpected(); }
		        node.source = this.parseExprAtom();
		      } else {
		        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
		          // check for keywords used as local names
		          var spec = list[i];

		          this.checkUnreserved(spec.local);
		          // check if export is defined
		          this.checkLocalExport(spec.local);

		          if (spec.local.type === "Literal") {
		            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
		          }
		        }

		        node.source = null;
		      }
		      this.semicolon();
		    }
		    return this.finishNode(node, "ExportNamedDeclaration")
		  };

		  pp$8.parseExportDeclaration = function(node) {
		    return this.parseStatement(null)
		  };

		  pp$8.parseExportDefaultDeclaration = function() {
		    var isAsync;
		    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		      var fNode = this.startNode();
		      this.next();
		      if (isAsync) { this.next(); }
		      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
		    } else if (this.type === types$1._class) {
		      var cNode = this.startNode();
		      return this.parseClass(cNode, "nullableID")
		    } else {
		      var declaration = this.parseMaybeAssign();
		      this.semicolon();
		      return declaration
		    }
		  };

		  pp$8.checkExport = function(exports, name, pos) {
		    if (!exports) { return }
		    if (typeof name !== "string")
		      { name = name.type === "Identifier" ? name.name : name.value; }
		    if (hasOwn(exports, name))
		      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
		    exports[name] = true;
		  };

		  pp$8.checkPatternExport = function(exports, pat) {
		    var type = pat.type;
		    if (type === "Identifier")
		      { this.checkExport(exports, pat, pat.start); }
		    else if (type === "ObjectPattern")
		      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
		        {
		          var prop = list[i];

		          this.checkPatternExport(exports, prop);
		        } }
		    else if (type === "ArrayPattern")
		      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
		        var elt = list$1[i$1];

		          if (elt) { this.checkPatternExport(exports, elt); }
		      } }
		    else if (type === "Property")
		      { this.checkPatternExport(exports, pat.value); }
		    else if (type === "AssignmentPattern")
		      { this.checkPatternExport(exports, pat.left); }
		    else if (type === "RestElement")
		      { this.checkPatternExport(exports, pat.argument); }
		    else if (type === "ParenthesizedExpression")
		      { this.checkPatternExport(exports, pat.expression); }
		  };

		  pp$8.checkVariableExport = function(exports, decls) {
		    if (!exports) { return }
		    for (var i = 0, list = decls; i < list.length; i += 1)
		      {
		      var decl = list[i];

		      this.checkPatternExport(exports, decl.id);
		    }
		  };

		  pp$8.shouldParseExportStatement = function() {
		    return this.type.keyword === "var" ||
		      this.type.keyword === "const" ||
		      this.type.keyword === "class" ||
		      this.type.keyword === "function" ||
		      this.isLet() ||
		      this.isAsyncFunction()
		  };

		  // Parses a comma-separated list of module exports.

		  pp$8.parseExportSpecifier = function(exports) {
		    var node = this.startNode();
		    node.local = this.parseModuleExportName();

		    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
		    this.checkExport(
		      exports,
		      node.exported,
		      node.exported.start
		    );

		    return this.finishNode(node, "ExportSpecifier")
		  };

		  pp$8.parseExportSpecifiers = function(exports) {
		    var nodes = [], first = true;
		    // export { x, y as z } [from '...']
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseExportSpecifier(exports));
		    }
		    return nodes
		  };

		  // Parses import declaration.

		  pp$8.parseImport = function(node) {
		    this.next();

		    // import '...'
		    if (this.type === types$1.string) {
		      node.specifiers = empty$1;
		      node.source = this.parseExprAtom();
		    } else {
		      node.specifiers = this.parseImportSpecifiers();
		      this.expectContextual("from");
		      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
		    }
		    this.semicolon();
		    return this.finishNode(node, "ImportDeclaration")
		  };

		  // Parses a comma-separated list of module imports.

		  pp$8.parseImportSpecifier = function() {
		    var node = this.startNode();
		    node.imported = this.parseModuleExportName();

		    if (this.eatContextual("as")) {
		      node.local = this.parseIdent();
		    } else {
		      this.checkUnreserved(node.imported);
		      node.local = node.imported;
		    }
		    this.checkLValSimple(node.local, BIND_LEXICAL);

		    return this.finishNode(node, "ImportSpecifier")
		  };

		  pp$8.parseImportDefaultSpecifier = function() {
		    // import defaultObj, { x, y as z } from '...'
		    var node = this.startNode();
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportDefaultSpecifier")
		  };

		  pp$8.parseImportNamespaceSpecifier = function() {
		    var node = this.startNode();
		    this.next();
		    this.expectContextual("as");
		    node.local = this.parseIdent();
		    this.checkLValSimple(node.local, BIND_LEXICAL);
		    return this.finishNode(node, "ImportNamespaceSpecifier")
		  };

		  pp$8.parseImportSpecifiers = function() {
		    var nodes = [], first = true;
		    if (this.type === types$1.name) {
		      nodes.push(this.parseImportDefaultSpecifier());
		      if (!this.eat(types$1.comma)) { return nodes }
		    }
		    if (this.type === types$1.star) {
		      nodes.push(this.parseImportNamespaceSpecifier());
		      return nodes
		    }
		    this.expect(types$1.braceL);
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      nodes.push(this.parseImportSpecifier());
		    }
		    return nodes
		  };

		  pp$8.parseModuleExportName = function() {
		    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		      var stringLiteral = this.parseLiteral(this.value);
		      if (loneSurrogate.test(stringLiteral.value)) {
		        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		      }
		      return stringLiteral
		    }
		    return this.parseIdent(true)
		  };

		  // Set `ExpressionStatement#directive` property for directive prologues.
		  pp$8.adaptDirectivePrologue = function(statements) {
		    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
		      statements[i].directive = statements[i].expression.raw.slice(1, -1);
		    }
		  };
		  pp$8.isDirectiveCandidate = function(statement) {
		    return (
		      this.options.ecmaVersion >= 5 &&
		      statement.type === "ExpressionStatement" &&
		      statement.expression.type === "Literal" &&
		      typeof statement.expression.value === "string" &&
		      // Reject parenthesized strings.
		      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
		    )
		  };

		  var pp$7 = Parser.prototype;

		  // Convert existing expression atom to assignable pattern
		  // if possible.

		  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 6 && node) {
		      switch (node.type) {
		      case "Identifier":
		        if (this.inAsync && node.name === "await")
		          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
		        break

		      case "ObjectPattern":
		      case "ArrayPattern":
		      case "AssignmentPattern":
		      case "RestElement":
		        break

		      case "ObjectExpression":
		        node.type = "ObjectPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        for (var i = 0, list = node.properties; i < list.length; i += 1) {
		          var prop = list[i];

		        this.toAssignable(prop, isBinding);
		          // Early error:
		          //   AssignmentRestProperty[Yield, Await] :
		          //     `...` DestructuringAssignmentTarget[Yield, Await]
		          //
		          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
		          if (
		            prop.type === "RestElement" &&
		            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
		          ) {
		            this.raise(prop.argument.start, "Unexpected token");
		          }
		        }
		        break

		      case "Property":
		        // AssignmentProperty has type === "Property"
		        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
		        this.toAssignable(node.value, isBinding);
		        break

		      case "ArrayExpression":
		        node.type = "ArrayPattern";
		        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		        this.toAssignableList(node.elements, isBinding);
		        break

		      case "SpreadElement":
		        node.type = "RestElement";
		        this.toAssignable(node.argument, isBinding);
		        if (node.argument.type === "AssignmentPattern")
		          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
		        break

		      case "AssignmentExpression":
		        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
		        node.type = "AssignmentPattern";
		        delete node.operator;
		        this.toAssignable(node.left, isBinding);
		        break

		      case "ParenthesizedExpression":
		        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
		        break

		      case "ChainExpression":
		        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
		        break

		      case "MemberExpression":
		        if (!isBinding) { break }

		      default:
		        this.raise(node.start, "Assigning to rvalue");
		      }
		    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
		    return node
		  };

		  // Convert list of expression atoms to binding list.

		  pp$7.toAssignableList = function(exprList, isBinding) {
		    var end = exprList.length;
		    for (var i = 0; i < end; i++) {
		      var elt = exprList[i];
		      if (elt) { this.toAssignable(elt, isBinding); }
		    }
		    if (end) {
		      var last = exprList[end - 1];
		      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
		        { this.unexpected(last.argument.start); }
		    }
		    return exprList
		  };

		  // Parses spread element.

		  pp$7.parseSpread = function(refDestructuringErrors) {
		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		    return this.finishNode(node, "SpreadElement")
		  };

		  pp$7.parseRestBinding = function() {
		    var node = this.startNode();
		    this.next();

		    // RestElement inside of a function parameter must be an identifier
		    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
		      { this.unexpected(); }

		    node.argument = this.parseBindingAtom();

		    return this.finishNode(node, "RestElement")
		  };

		  // Parses lvalue (assignable) atom.

		  pp$7.parseBindingAtom = function() {
		    if (this.options.ecmaVersion >= 6) {
		      switch (this.type) {
		      case types$1.bracketL:
		        var node = this.startNode();
		        this.next();
		        node.elements = this.parseBindingList(types$1.bracketR, true, true);
		        return this.finishNode(node, "ArrayPattern")

		      case types$1.braceL:
		        return this.parseObj(true)
		      }
		    }
		    return this.parseIdent()
		  };

		  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (first) { first = false; }
		      else { this.expect(types$1.comma); }
		      if (allowEmpty && this.type === types$1.comma) {
		        elts.push(null);
		      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
		        break
		      } else if (this.type === types$1.ellipsis) {
		        var rest = this.parseRestBinding();
		        this.parseBindingListItem(rest);
		        elts.push(rest);
		        if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
		        this.expect(close);
		        break
		      } else {
		        elts.push(this.parseAssignableListItem(allowModifiers));
		      }
		    }
		    return elts
		  };

		  pp$7.parseAssignableListItem = function(allowModifiers) {
		    var elem = this.parseMaybeDefault(this.start, this.startLoc);
		    this.parseBindingListItem(elem);
		    return elem
		  };

		  pp$7.parseBindingListItem = function(param) {
		    return param
		  };

		  // Parses assignment pattern around given atom if possible.

		  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
		    left = left || this.parseBindingAtom();
		    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.right = this.parseMaybeAssign();
		    return this.finishNode(node, "AssignmentPattern")
		  };

		  // The following three functions all verify that a node is an lvalue —
		  // something that can be bound, or assigned to. In order to do so, they perform
		  // a variety of checks:
		  //
		  // - Check that none of the bound/assigned-to identifiers are reserved words.
		  // - Record name declarations for bindings in the appropriate scope.
		  // - Check duplicate argument names, if checkClashes is set.
		  //
		  // If a complex binding pattern is encountered (e.g., object and array
		  // destructuring), the entire pattern is recursively checked.
		  //
		  // There are three versions of checkLVal*() appropriate for different
		  // circumstances:
		  //
		  // - checkLValSimple() shall be used if the syntactic construct supports
		  //   nothing other than identifiers and member expressions. Parenthesized
		  //   expressions are also correctly handled. This is generally appropriate for
		  //   constructs for which the spec says
		  //
		  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   It is also appropriate for checking if an identifier is valid and not
		  //   defined elsewhere, like import declarations or function/class identifiers.
		  //
		  //   Examples where this is used include:
		  //     a += …;
		  //     import a from '…';
		  //   where a is the node to be checked.
		  //
		  // - checkLValPattern() shall be used if the syntactic construct supports
		  //   anything checkLValSimple() supports, as well as object and array
		  //   destructuring patterns. This is generally appropriate for constructs for
		  //   which the spec says
		  //
		  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
		  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
		  //   > simple.
		  //
		  //   Examples where this is used include:
		  //     (a = …);
		  //     const a = …;
		  //     try { … } catch (a) { … }
		  //   where a is the node to be checked.
		  //
		  // - checkLValInnerPattern() shall be used if the syntactic construct supports
		  //   anything checkLValPattern() supports, as well as default assignment
		  //   patterns, rest elements, and other constructs that may appear within an
		  //   object or array destructuring pattern.
		  //
		  //   As a special case, function parameters also use checkLValInnerPattern(),
		  //   as they also support defaults and rest constructs.
		  //
		  // These functions deliberately support both assignment and binding constructs,
		  // as the logic for both is exceedingly similar. If the node is the target of
		  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
		  // should be set to the appropriate BIND_* constant, like BIND_VAR or
		  // BIND_LEXICAL.
		  //
		  // If the function is called with a non-BIND_NONE bindingType, then
		  // additionally a checkClashes object may be specified to allow checking for
		  // duplicate argument names. checkClashes is ignored if the provided construct
		  // is an assignment (i.e., bindingType is BIND_NONE).

		  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    var isBind = bindingType !== BIND_NONE;

		    switch (expr.type) {
		    case "Identifier":
		      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
		        { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
		      if (isBind) {
		        if (bindingType === BIND_LEXICAL && expr.name === "let")
		          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
		        if (checkClashes) {
		          if (hasOwn(checkClashes, expr.name))
		            { this.raiseRecoverable(expr.start, "Argument name clash"); }
		          checkClashes[expr.name] = true;
		        }
		        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
		      }
		      break

		    case "ChainExpression":
		      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
		      break

		    case "MemberExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
		      break

		    case "ParenthesizedExpression":
		      if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
		      return this.checkLValSimple(expr.expression, bindingType, checkClashes)

		    default:
		      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
		    }
		  };

		  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "ObjectPattern":
		      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
		        var prop = list[i];

		      this.checkLValInnerPattern(prop, bindingType, checkClashes);
		      }
		      break

		    case "ArrayPattern":
		      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
		        var elem = list$1[i$1];

		      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
		      }
		      break

		    default:
		      this.checkLValSimple(expr, bindingType, checkClashes);
		    }
		  };

		  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
		    if ( bindingType === void 0 ) bindingType = BIND_NONE;

		    switch (expr.type) {
		    case "Property":
		      // AssignmentProperty has type === "Property"
		      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
		      break

		    case "AssignmentPattern":
		      this.checkLValPattern(expr.left, bindingType, checkClashes);
		      break

		    case "RestElement":
		      this.checkLValPattern(expr.argument, bindingType, checkClashes);
		      break

		    default:
		      this.checkLValPattern(expr, bindingType, checkClashes);
		    }
		  };

		  // The algorithm used to determine whether a regexp can appear at a
		  // given point in the program is loosely based on sweet.js' approach.
		  // See https://github.com/mozilla/sweet.js/wiki/design


		  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
		    this.token = token;
		    this.isExpr = !!isExpr;
		    this.preserveSpace = !!preserveSpace;
		    this.override = override;
		    this.generator = !!generator;
		  };

		  var types = {
		    b_stat: new TokContext("{", false),
		    b_expr: new TokContext("{", true),
		    b_tmpl: new TokContext("${", false),
		    p_stat: new TokContext("(", false),
		    p_expr: new TokContext("(", true),
		    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
		    f_stat: new TokContext("function", false),
		    f_expr: new TokContext("function", true),
		    f_expr_gen: new TokContext("function", true, false, null, true),
		    f_gen: new TokContext("function", false, false, null, true)
		  };

		  var pp$6 = Parser.prototype;

		  pp$6.initialContext = function() {
		    return [types.b_stat]
		  };

		  pp$6.curContext = function() {
		    return this.context[this.context.length - 1]
		  };

		  pp$6.braceIsBlock = function(prevType) {
		    var parent = this.curContext();
		    if (parent === types.f_expr || parent === types.f_stat)
		      { return true }
		    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
		      { return !parent.isExpr }

		    // The check for `tt.name && exprAllowed` detects whether we are
		    // after a `yield` or `of` construct. See the `updateContext` for
		    // `tt.name`.
		    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
		      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
		    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
		      { return true }
		    if (prevType === types$1.braceL)
		      { return parent === types.b_stat }
		    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
		      { return false }
		    return !this.exprAllowed
		  };

		  pp$6.inGeneratorContext = function() {
		    for (var i = this.context.length - 1; i >= 1; i--) {
		      var context = this.context[i];
		      if (context.token === "function")
		        { return context.generator }
		    }
		    return false
		  };

		  pp$6.updateContext = function(prevType) {
		    var update, type = this.type;
		    if (type.keyword && prevType === types$1.dot)
		      { this.exprAllowed = false; }
		    else if (update = type.updateContext)
		      { update.call(this, prevType); }
		    else
		      { this.exprAllowed = type.beforeExpr; }
		  };

		  // Used to handle egde cases when token context could not be inferred correctly during tokenization phase

		  pp$6.overrideContext = function(tokenCtx) {
		    if (this.curContext() !== tokenCtx) {
		      this.context[this.context.length - 1] = tokenCtx;
		    }
		  };

		  // Token-specific context update code

		  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
		    if (this.context.length === 1) {
		      this.exprAllowed = true;
		      return
		    }
		    var out = this.context.pop();
		    if (out === types.b_stat && this.curContext().token === "function") {
		      out = this.context.pop();
		    }
		    this.exprAllowed = !out.isExpr;
		  };

		  types$1.braceL.updateContext = function(prevType) {
		    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
		    this.exprAllowed = true;
		  };

		  types$1.dollarBraceL.updateContext = function() {
		    this.context.push(types.b_tmpl);
		    this.exprAllowed = true;
		  };

		  types$1.parenL.updateContext = function(prevType) {
		    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
		    this.context.push(statementParens ? types.p_stat : types.p_expr);
		    this.exprAllowed = true;
		  };

		  types$1.incDec.updateContext = function() {
		    // tokExprAllowed stays unchanged
		  };

		  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
		    if (prevType.beforeExpr && prevType !== types$1._else &&
		        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
		        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
		        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
		      { this.context.push(types.f_expr); }
		    else
		      { this.context.push(types.f_stat); }
		    this.exprAllowed = false;
		  };

		  types$1.backQuote.updateContext = function() {
		    if (this.curContext() === types.q_tmpl)
		      { this.context.pop(); }
		    else
		      { this.context.push(types.q_tmpl); }
		    this.exprAllowed = false;
		  };

		  types$1.star.updateContext = function(prevType) {
		    if (prevType === types$1._function) {
		      var index = this.context.length - 1;
		      if (this.context[index] === types.f_expr)
		        { this.context[index] = types.f_expr_gen; }
		      else
		        { this.context[index] = types.f_gen; }
		    }
		    this.exprAllowed = true;
		  };

		  types$1.name.updateContext = function(prevType) {
		    var allowed = false;
		    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		      if (this.value === "of" && !this.exprAllowed ||
		          this.value === "yield" && this.inGeneratorContext())
		        { allowed = true; }
		    }
		    this.exprAllowed = allowed;
		  };

		  // A recursive descent parser operates by defining functions for all
		  // syntactic elements, and recursively calling those, each function
		  // advancing the input stream and returning an AST node. Precedence
		  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
		  // instead of `(!x)[1]` is handled by the fact that the parser
		  // function that parses unary prefix operators is called first, and
		  // in turn calls the function that parses `[]` subscripts — that
		  // way, it'll receive the node for `x[1]` already parsed, and wraps
		  // *that* in the unary operator node.
		  //
		  // Acorn uses an [operator precedence parser][opp] to handle binary
		  // operator precedence, because it is much more compact than using
		  // the technique outlined above, which uses different, nesting
		  // functions to specify precedence, for all of the ten binary
		  // precedence levels that JavaScript defines.
		  //
		  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


		  var pp$5 = Parser.prototype;

		  // Check if property name clashes with already added.
		  // Object/class getters and setters are not allowed to clash —
		  // either with each other or with an init property — and in
		  // strict mode, init properties are also not allowed to be repeated.

		  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
		    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
		      { return }
		    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
		      { return }
		    var key = prop.key;
		    var name;
		    switch (key.type) {
		    case "Identifier": name = key.name; break
		    case "Literal": name = String(key.value); break
		    default: return
		    }
		    var kind = prop.kind;
		    if (this.options.ecmaVersion >= 6) {
		      if (name === "__proto__" && kind === "init") {
		        if (propHash.proto) {
		          if (refDestructuringErrors) {
		            if (refDestructuringErrors.doubleProto < 0) {
		              refDestructuringErrors.doubleProto = key.start;
		            }
		          } else {
		            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
		          }
		        }
		        propHash.proto = true;
		      }
		      return
		    }
		    name = "$" + name;
		    var other = propHash[name];
		    if (other) {
		      var redefinition;
		      if (kind === "init") {
		        redefinition = this.strict && other.init || other.get || other.set;
		      } else {
		        redefinition = other.init || other[kind];
		      }
		      if (redefinition)
		        { this.raiseRecoverable(key.start, "Redefinition of property"); }
		    } else {
		      other = propHash[name] = {
		        init: false,
		        get: false,
		        set: false
		      };
		    }
		    other[kind] = true;
		  };

		  // ### Expression parsing

		  // These nest, from the most general expression type at the top to
		  // 'atomic', nondivisible expression types at the bottom. Most of
		  // the functions will simply let the function(s) below them parse,
		  // and, *if* the syntactic construct they handle is present, wrap
		  // the AST node that the inner parser gave them in another node.

		  // Parse a full expression. The optional arguments are used to
		  // forbid the `in` operator (in for loops initalization expressions)
		  // and provide reference for storing '=' operator inside shorthand
		  // property assignment in contexts where both object expression
		  // and object pattern might appear (so it's possible to raise
		  // delayed syntax error at correct position).

		  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
		    if (this.type === types$1.comma) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.expressions = [expr];
		      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
		      return this.finishNode(node, "SequenceExpression")
		    }
		    return expr
		  };

		  // Parse an assignment expression. This includes applications of
		  // operators like `+=`.

		  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
		    if (this.isContextual("yield")) {
		      if (this.inGenerator) { return this.parseYield(forInit) }
		      // The tokenizer will assume an expression is allowed after
		      // `yield`, but this isn't that kind of yield
		      else { this.exprAllowed = false; }
		    }

		    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
		    if (refDestructuringErrors) {
		      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		      oldTrailingComma = refDestructuringErrors.trailingComma;
		      oldDoubleProto = refDestructuringErrors.doubleProto;
		      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
		    } else {
		      refDestructuringErrors = new DestructuringErrors;
		      ownDestructuringErrors = true;
		    }

		    var startPos = this.start, startLoc = this.startLoc;
		    if (this.type === types$1.parenL || this.type === types$1.name) {
		      this.potentialArrowAt = this.start;
		      this.potentialArrowInForAwait = forInit === "await";
		    }
		    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
		    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
		    if (this.type.isAssign) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.operator = this.value;
		      if (this.type === types$1.eq)
		        { left = this.toAssignable(left, false, refDestructuringErrors); }
		      if (!ownDestructuringErrors) {
		        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		      }
		      if (refDestructuringErrors.shorthandAssign >= left.start)
		        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
		      if (this.type === types$1.eq)
		        { this.checkLValPattern(left); }
		      else
		        { this.checkLValSimple(left); }
		      node.left = left;
		      this.next();
		      node.right = this.parseMaybeAssign(forInit);
		      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
		      return this.finishNode(node, "AssignmentExpression")
		    } else {
		      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
		    }
		    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
		    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
		    return left
		  };

		  // Parse a ternary conditional (`?:`) operator.

		  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprOps(forInit, refDestructuringErrors);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    if (this.eat(types$1.question)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.test = expr;
		      node.consequent = this.parseMaybeAssign();
		      this.expect(types$1.colon);
		      node.alternate = this.parseMaybeAssign(forInit);
		      return this.finishNode(node, "ConditionalExpression")
		    }
		    return expr
		  };

		  // Start the precedence parser.

		  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
		    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
		  };

		  // Parse binary operators with the operator precedence parsing
		  // algorithm. `left` is the left-hand side of the operator.
		  // `minPrec` provides context that allows the function to stop and
		  // defer further parser to one of its callers when it encounters an
		  // operator that has a lower precedence than the set it is parsing.

		  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
		    var prec = this.type.binop;
		    if (prec != null && (!forInit || this.type !== types$1._in)) {
		      if (prec > minPrec) {
		        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
		        var coalesce = this.type === types$1.coalesce;
		        if (coalesce) {
		          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
		          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
		          prec = types$1.logicalAND.binop;
		        }
		        var op = this.value;
		        this.next();
		        var startPos = this.start, startLoc = this.startLoc;
		        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
		        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
		        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
		          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
		        }
		        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
		      }
		    }
		    return left
		  };

		  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
		    if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
		    var node = this.startNodeAt(startPos, startLoc);
		    node.left = left;
		    node.operator = op;
		    node.right = right;
		    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
		  };

		  // Parse unary operators, both prefix and postfix.

		  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, expr;
		    if (this.isContextual("await") && this.canAwait) {
		      expr = this.parseAwait(forInit);
		      sawUnary = true;
		    } else if (this.type.prefix) {
		      var node = this.startNode(), update = this.type === types$1.incDec;
		      node.operator = this.value;
		      node.prefix = true;
		      this.next();
		      node.argument = this.parseMaybeUnary(null, true, update, forInit);
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      if (update) { this.checkLValSimple(node.argument); }
		      else if (this.strict && node.operator === "delete" &&
		               node.argument.type === "Identifier")
		        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
		      else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
		        { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
		      else { sawUnary = true; }
		      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
		    } else if (!sawUnary && this.type === types$1.privateId) {
		      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
		      expr = this.parsePrivateIdent();
		      // only could be private fields in 'in', such as #x in obj
		      if (this.type !== types$1._in) { this.unexpected(); }
		    } else {
		      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
		      while (this.type.postfix && !this.canInsertSemicolon()) {
		        var node$1 = this.startNodeAt(startPos, startLoc);
		        node$1.operator = this.value;
		        node$1.prefix = false;
		        node$1.argument = expr;
		        this.checkLValSimple(expr);
		        this.next();
		        expr = this.finishNode(node$1, "UpdateExpression");
		      }
		    }

		    if (!incDec && this.eat(types$1.starstar)) {
		      if (sawUnary)
		        { this.unexpected(this.lastTokStart); }
		      else
		        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
		    } else {
		      return expr
		    }
		  };

		  function isPrivateFieldAccess(node) {
		    return (
		      node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
		      node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
		    )
		  }

		  // Parse call, dot, and `[]`-subscript expressions.

		  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
		    var startPos = this.start, startLoc = this.startLoc;
		    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
		    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
		      { return expr }
		    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
		    if (refDestructuringErrors && result.type === "MemberExpression") {
		      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
		      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
		      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
		    }
		    return result
		  };

		  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
		    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
		        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
		        this.potentialArrowAt === base.start;
		    var optionalChained = false;

		    while (true) {
		      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

		      if (element.optional) { optionalChained = true; }
		      if (element === base || element.type === "ArrowFunctionExpression") {
		        if (optionalChained) {
		          var chainNode = this.startNodeAt(startPos, startLoc);
		          chainNode.expression = element;
		          element = this.finishNode(chainNode, "ChainExpression");
		        }
		        return element
		      }

		      base = element;
		    }
		  };

		  pp$5.shouldParseAsyncArrow = function() {
		    return !this.canInsertSemicolon() && this.eat(types$1.arrow)
		  };

		  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
		  };

		  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
		    var optionalSupported = this.options.ecmaVersion >= 11;
		    var optional = optionalSupported && this.eat(types$1.questionDot);
		    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

		    var computed = this.eat(types$1.bracketL);
		    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
		      var node = this.startNodeAt(startPos, startLoc);
		      node.object = base;
		      if (computed) {
		        node.property = this.parseExpression();
		        this.expect(types$1.bracketR);
		      } else if (this.type === types$1.privateId && base.type !== "Super") {
		        node.property = this.parsePrivateIdent();
		      } else {
		        node.property = this.parseIdent(this.options.allowReserved !== "never");
		      }
		      node.computed = !!computed;
		      if (optionalSupported) {
		        node.optional = optional;
		      }
		      base = this.finishNode(node, "MemberExpression");
		    } else if (!noCalls && this.eat(types$1.parenL)) {
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      this.awaitIdentPos = 0;
		      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        if (this.awaitIdentPos > 0)
		          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        this.awaitIdentPos = oldAwaitIdentPos;
		        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
		      }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;
		      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		      var node$1 = this.startNodeAt(startPos, startLoc);
		      node$1.callee = base;
		      node$1.arguments = exprList;
		      if (optionalSupported) {
		        node$1.optional = optional;
		      }
		      base = this.finishNode(node$1, "CallExpression");
		    } else if (this.type === types$1.backQuote) {
		      if (optional || optionalChained) {
		        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		      }
		      var node$2 = this.startNodeAt(startPos, startLoc);
		      node$2.tag = base;
		      node$2.quasi = this.parseTemplate({isTagged: true});
		      base = this.finishNode(node$2, "TaggedTemplateExpression");
		    }
		    return base
		  };

		  // Parse an atomic expression — either a single token that is an
		  // expression, an expression started by a keyword like `function` or
		  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
		  // or `{}`.

		  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
		    // If a division operator appears in an expression position, the
		    // tokenizer got confused, and we force it to read a regexp instead.
		    if (this.type === types$1.slash) { this.readRegexp(); }

		    var node, canBeArrow = this.potentialArrowAt === this.start;
		    switch (this.type) {
		    case types$1._super:
		      if (!this.allowSuper)
		        { this.raise(this.start, "'super' keyword outside a method"); }
		      node = this.startNode();
		      this.next();
		      if (this.type === types$1.parenL && !this.allowDirectSuper)
		        { this.raise(node.start, "super() call outside constructor of a subclass"); }
		      // The `super` keyword can appear at below:
		      // SuperProperty:
		      //     super [ Expression ]
		      //     super . IdentifierName
		      // SuperCall:
		      //     super ( Arguments )
		      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
		        { this.unexpected(); }
		      return this.finishNode(node, "Super")

		    case types$1._this:
		      node = this.startNode();
		      this.next();
		      return this.finishNode(node, "ThisExpression")

		    case types$1.name:
		      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
		      var id = this.parseIdent(false);
		      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
		        this.overrideContext(types.f_expr);
		        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
		      }
		      if (canBeArrow && !this.canInsertSemicolon()) {
		        if (this.eat(types$1.arrow))
		          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
		        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
		            (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
		          id = this.parseIdent(false);
		          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
		            { this.unexpected(); }
		          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
		        }
		      }
		      return id

		    case types$1.regexp:
		      var value = this.value;
		      node = this.parseLiteral(value.value);
		      node.regex = {pattern: value.pattern, flags: value.flags};
		      return node

		    case types$1.num: case types$1.string:
		      return this.parseLiteral(this.value)

		    case types$1._null: case types$1._true: case types$1._false:
		      node = this.startNode();
		      node.value = this.type === types$1._null ? null : this.type === types$1._true;
		      node.raw = this.type.keyword;
		      this.next();
		      return this.finishNode(node, "Literal")

		    case types$1.parenL:
		      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
		      if (refDestructuringErrors) {
		        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
		          { refDestructuringErrors.parenthesizedAssign = start; }
		        if (refDestructuringErrors.parenthesizedBind < 0)
		          { refDestructuringErrors.parenthesizedBind = start; }
		      }
		      return expr

		    case types$1.bracketL:
		      node = this.startNode();
		      this.next();
		      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
		      return this.finishNode(node, "ArrayExpression")

		    case types$1.braceL:
		      this.overrideContext(types.b_expr);
		      return this.parseObj(false, refDestructuringErrors)

		    case types$1._function:
		      node = this.startNode();
		      this.next();
		      return this.parseFunction(node, 0)

		    case types$1._class:
		      return this.parseClass(this.startNode(), false)

		    case types$1._new:
		      return this.parseNew()

		    case types$1.backQuote:
		      return this.parseTemplate()

		    case types$1._import:
		      if (this.options.ecmaVersion >= 11) {
		        return this.parseExprImport(forNew)
		      } else {
		        return this.unexpected()
		      }

		    default:
		      return this.parseExprAtomDefault()
		    }
		  };

		  pp$5.parseExprAtomDefault = function() {
		    this.unexpected();
		  };

		  pp$5.parseExprImport = function(forNew) {
		    var node = this.startNode();

		    // Consume `import` as an identifier for `import.meta`.
		    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
		    var meta = this.parseIdent(true);

		    if (this.type === types$1.parenL && !forNew) {
		      return this.parseDynamicImport(node)
		    } else if (this.type === types$1.dot) {
		      node.meta = meta;
		      return this.parseImportMeta(node)
		    } else {
		      this.unexpected();
		    }
		  };

		  pp$5.parseDynamicImport = function(node) {
		    this.next(); // skip `(`

		    // Parse node.source.
		    node.source = this.parseMaybeAssign();

		    // Verify ending.
		    if (!this.eat(types$1.parenR)) {
		      var errorPos = this.start;
		      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
		        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		      } else {
		        this.unexpected(errorPos);
		      }
		    }

		    return this.finishNode(node, "ImportExpression")
		  };

		  pp$5.parseImportMeta = function(node) {
		    this.next(); // skip `.`

		    var containsEsc = this.containsEsc;
		    node.property = this.parseIdent(true);

		    if (node.property.name !== "meta")
		      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
		    if (containsEsc)
		      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
		    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
		      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

		    return this.finishNode(node, "MetaProperty")
		  };

		  pp$5.parseLiteral = function(value) {
		    var node = this.startNode();
		    node.value = value;
		    node.raw = this.input.slice(this.start, this.end);
		    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
		    this.next();
		    return this.finishNode(node, "Literal")
		  };

		  pp$5.parseParenExpression = function() {
		    this.expect(types$1.parenL);
		    var val = this.parseExpression();
		    this.expect(types$1.parenR);
		    return val
		  };

		  pp$5.shouldParseArrow = function(exprList) {
		    return !this.canInsertSemicolon()
		  };

		  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
		    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
		    if (this.options.ecmaVersion >= 6) {
		      this.next();

		      var innerStartPos = this.start, innerStartLoc = this.startLoc;
		      var exprList = [], first = true, lastIsComma = false;
		      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		      this.yieldPos = 0;
		      this.awaitPos = 0;
		      // Do not save awaitIdentPos to allow checking awaits nested in parameters
		      while (this.type !== types$1.parenR) {
		        first ? first = false : this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
		          lastIsComma = true;
		          break
		        } else if (this.type === types$1.ellipsis) {
		          spreadStart = this.start;
		          exprList.push(this.parseParenItem(this.parseRestBinding()));
		          if (this.type === types$1.comma) {
		            this.raiseRecoverable(
		              this.start,
		              "Comma is not permitted after the rest element"
		            );
		          }
		          break
		        } else {
		          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		        }
		      }
		      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		      this.expect(types$1.parenR);

		      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
		        this.checkPatternErrors(refDestructuringErrors, false);
		        this.checkYieldAwaitInDefaultParams();
		        this.yieldPos = oldYieldPos;
		        this.awaitPos = oldAwaitPos;
		        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
		      }

		      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
		      if (spreadStart) { this.unexpected(spreadStart); }
		      this.checkExpressionErrors(refDestructuringErrors, true);
		      this.yieldPos = oldYieldPos || this.yieldPos;
		      this.awaitPos = oldAwaitPos || this.awaitPos;

		      if (exprList.length > 1) {
		        val = this.startNodeAt(innerStartPos, innerStartLoc);
		        val.expressions = exprList;
		        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		      } else {
		        val = exprList[0];
		      }
		    } else {
		      val = this.parseParenExpression();
		    }

		    if (this.options.preserveParens) {
		      var par = this.startNodeAt(startPos, startLoc);
		      par.expression = val;
		      return this.finishNode(par, "ParenthesizedExpression")
		    } else {
		      return val
		    }
		  };

		  pp$5.parseParenItem = function(item) {
		    return item
		  };

		  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
		    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
		  };

		  // New's precedence is slightly tricky. It must allow its argument to
		  // be a `[]` or dot subscript expression, but not a call — at least,
		  // not without wrapping it in parentheses. Thus, it uses the noCalls
		  // argument to parseSubscripts to prevent it from consuming the
		  // argument list.

		  var empty = [];

		  pp$5.parseNew = function() {
		    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
		    var node = this.startNode();
		    var meta = this.parseIdent(true);
		    if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
		      node.meta = meta;
		      var containsEsc = this.containsEsc;
		      node.property = this.parseIdent(true);
		      if (node.property.name !== "target")
		        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
		      if (containsEsc)
		        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
		      if (!this.allowNewDotTarget)
		        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
		      return this.finishNode(node, "MetaProperty")
		    }
		    var startPos = this.start, startLoc = this.startLoc;
		    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
		    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
		    else { node.arguments = empty; }
		    return this.finishNode(node, "NewExpression")
		  };

		  // Parse template expression.

		  pp$5.parseTemplateElement = function(ref) {
		    var isTagged = ref.isTagged;

		    var elem = this.startNode();
		    if (this.type === types$1.invalidTemplate) {
		      if (!isTagged) {
		        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		      }
		      elem.value = {
		        raw: this.value,
		        cooked: null
		      };
		    } else {
		      elem.value = {
		        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		        cooked: this.value
		      };
		    }
		    this.next();
		    elem.tail = this.type === types$1.backQuote;
		    return this.finishNode(elem, "TemplateElement")
		  };

		  pp$5.parseTemplate = function(ref) {
		    if ( ref === void 0 ) ref = {};
		    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

		    var node = this.startNode();
		    this.next();
		    node.expressions = [];
		    var curElt = this.parseTemplateElement({isTagged: isTagged});
		    node.quasis = [curElt];
		    while (!curElt.tail) {
		      if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
		      this.expect(types$1.dollarBraceL);
		      node.expressions.push(this.parseExpression());
		      this.expect(types$1.braceR);
		      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
		    }
		    this.next();
		    return this.finishNode(node, "TemplateLiteral")
		  };

		  pp$5.isAsyncProp = function(prop) {
		    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
		      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
		      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
		  };

		  // Parse an object literal or binding pattern.

		  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
		    var node = this.startNode(), first = true, propHash = {};
		    node.properties = [];
		    this.next();
		    while (!this.eat(types$1.braceR)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
		      } else { first = false; }

		      var prop = this.parseProperty(isPattern, refDestructuringErrors);
		      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
		      node.properties.push(prop);
		    }
		    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
		  };

		  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
		    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
		    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		      if (isPattern) {
		        prop.argument = this.parseIdent(false);
		        if (this.type === types$1.comma) {
		          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
		        }
		        return this.finishNode(prop, "RestElement")
		      }
		      // Parse argument.
		      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		      // To disallow trailing comma via `this.toAssignable()`.
		      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
		        refDestructuringErrors.trailingComma = this.start;
		      }
		      // Finish
		      return this.finishNode(prop, "SpreadElement")
		    }
		    if (this.options.ecmaVersion >= 6) {
		      prop.method = false;
		      prop.shorthand = false;
		      if (isPattern || refDestructuringErrors) {
		        startPos = this.start;
		        startLoc = this.startLoc;
		      }
		      if (!isPattern)
		        { isGenerator = this.eat(types$1.star); }
		    }
		    var containsEsc = this.containsEsc;
		    this.parsePropertyName(prop);
		    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		      isAsync = true;
		      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		      this.parsePropertyName(prop);
		    } else {
		      isAsync = false;
		    }
		    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
		    return this.finishNode(prop, "Property")
		  };

		  pp$5.parseGetterSetter = function(prop) {
		    prop.kind = prop.key.name;
		    this.parsePropertyName(prop);
		    prop.value = this.parseMethod(false);
		    var paramCount = prop.kind === "get" ? 0 : 1;
		    if (prop.value.params.length !== paramCount) {
		      var start = prop.value.start;
		      if (prop.kind === "get")
		        { this.raiseRecoverable(start, "getter should have no params"); }
		      else
		        { this.raiseRecoverable(start, "setter should have exactly one param"); }
		    } else {
		      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
		        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
		    }
		  };

		  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
		    if ((isGenerator || isAsync) && this.type === types$1.colon)
		      { this.unexpected(); }

		    if (this.eat(types$1.colon)) {
		      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		      prop.kind = "init";
		    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		      if (isPattern) { this.unexpected(); }
		      prop.kind = "init";
		      prop.method = true;
		      prop.value = this.parseMethod(isGenerator, isAsync);
		    } else if (!isPattern && !containsEsc &&
		               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
		               (prop.key.name === "get" || prop.key.name === "set") &&
		               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.parseGetterSetter(prop);
		    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		      if (isGenerator || isAsync) { this.unexpected(); }
		      this.checkUnreserved(prop.key);
		      if (prop.key.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = startPos; }
		      prop.kind = "init";
		      if (isPattern) {
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else if (this.type === types$1.eq && refDestructuringErrors) {
		        if (refDestructuringErrors.shorthandAssign < 0)
		          { refDestructuringErrors.shorthandAssign = this.start; }
		        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		      } else {
		        prop.value = this.copyNode(prop.key);
		      }
		      prop.shorthand = true;
		    } else { this.unexpected(); }
		  };

		  pp$5.parsePropertyName = function(prop) {
		    if (this.options.ecmaVersion >= 6) {
		      if (this.eat(types$1.bracketL)) {
		        prop.computed = true;
		        prop.key = this.parseMaybeAssign();
		        this.expect(types$1.bracketR);
		        return prop.key
		      } else {
		        prop.computed = false;
		      }
		    }
		    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
		  };

		  // Initialize empty function node.

		  pp$5.initFunction = function(node) {
		    node.id = null;
		    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
		    if (this.options.ecmaVersion >= 8) { node.async = false; }
		  };

		  // Parse object or class method.

		  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
		    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 6)
		      { node.generator = isGenerator; }
		    if (this.options.ecmaVersion >= 8)
		      { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;
		    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

		    this.expect(types$1.parenL);
		    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		    this.checkYieldAwaitInDefaultParams();
		    this.parseFunctionBody(node, false, true, false);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "FunctionExpression")
		  };

		  // Parse arrow function expression with given parameters.

		  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
		    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

		    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
		    this.initFunction(node);
		    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

		    this.yieldPos = 0;
		    this.awaitPos = 0;
		    this.awaitIdentPos = 0;

		    node.params = this.toAssignableList(params, true);
		    this.parseFunctionBody(node, true, false, forInit);

		    this.yieldPos = oldYieldPos;
		    this.awaitPos = oldAwaitPos;
		    this.awaitIdentPos = oldAwaitIdentPos;
		    return this.finishNode(node, "ArrowFunctionExpression")
		  };

		  // Parse function body and check parameters.

		  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
		    var isExpression = isArrowFunction && this.type !== types$1.braceL;
		    var oldStrict = this.strict, useStrict = false;

		    if (isExpression) {
		      node.body = this.parseMaybeAssign(forInit);
		      node.expression = true;
		      this.checkParams(node, false);
		    } else {
		      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		      if (!oldStrict || nonSimple) {
		        useStrict = this.strictDirective(this.end);
		        // If this is a strict mode function, verify that argument names
		        // are not repeated, and it does not try to bind the words `eval`
		        // or `arguments`.
		        if (useStrict && nonSimple)
		          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
		      }
		      // Start a new scope with regard to labels and the `inFunction`
		      // flag (restore them to their old value afterwards).
		      var oldLabels = this.labels;
		      this.labels = [];
		      if (useStrict) { this.strict = true; }

		      // Add the params to varDeclaredNames to ensure that an error is thrown
		      // if a let/const declaration in the function clashes with one of the params.
		      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
		      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
		      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
		      node.expression = false;
		      this.adaptDirectivePrologue(node.body.body);
		      this.labels = oldLabels;
		    }
		    this.exitScope();
		  };

		  pp$5.isSimpleParamList = function(params) {
		    for (var i = 0, list = params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      if (param.type !== "Identifier") { return false
		    } }
		    return true
		  };

		  // Checks function params for various disallowed patterns such as using "eval"
		  // or "arguments" and duplicate parameters.

		  pp$5.checkParams = function(node, allowDuplicates) {
		    var nameHash = Object.create(null);
		    for (var i = 0, list = node.params; i < list.length; i += 1)
		      {
		      var param = list[i];

		      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
		    }
		  };

		  // Parses a comma-separated list of expressions, and returns them as
		  // an array. `close` is the token type that ends the list, and
		  // `allowEmpty` can be turned on to allow subsequent commas with
		  // nothing in between them to be parsed as `null` (which is needed
		  // for array literals).

		  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
		    var elts = [], first = true;
		    while (!this.eat(close)) {
		      if (!first) {
		        this.expect(types$1.comma);
		        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
		      } else { first = false; }

		      var elt = (void 0);
		      if (allowEmpty && this.type === types$1.comma)
		        { elt = null; }
		      else if (this.type === types$1.ellipsis) {
		        elt = this.parseSpread(refDestructuringErrors);
		        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
		          { refDestructuringErrors.trailingComma = this.start; }
		      } else {
		        elt = this.parseMaybeAssign(false, refDestructuringErrors);
		      }
		      elts.push(elt);
		    }
		    return elts
		  };

		  pp$5.checkUnreserved = function(ref) {
		    var start = ref.start;
		    var end = ref.end;
		    var name = ref.name;

		    if (this.inGenerator && name === "yield")
		      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
		    if (this.inAsync && name === "await")
		      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
		    if (this.currentThisScope().inClassFieldInit && name === "arguments")
		      { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
		    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
		      { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
		    if (this.keywords.test(name))
		      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
		    if (this.options.ecmaVersion < 6 &&
		      this.input.slice(start, end).indexOf("\\") !== -1) { return }
		    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
		    if (re.test(name)) {
		      if (!this.inAsync && name === "await")
		        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
		      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
		    }
		  };

		  // Parse the next token as an identifier. If `liberal` is true (used
		  // when parsing properties), it will also convert keywords into
		  // identifiers.

		  pp$5.parseIdent = function(liberal) {
		    var node = this.parseIdentNode();
		    this.next(!!liberal);
		    this.finishNode(node, "Identifier");
		    if (!liberal) {
		      this.checkUnreserved(node);
		      if (node.name === "await" && !this.awaitIdentPos)
		        { this.awaitIdentPos = node.start; }
		    }
		    return node
		  };

		  pp$5.parseIdentNode = function() {
		    var node = this.startNode();
		    if (this.type === types$1.name) {
		      node.name = this.value;
		    } else if (this.type.keyword) {
		      node.name = this.type.keyword;

		      // To fix https://github.com/acornjs/acorn/issues/575
		      // `class` and `function` keywords push new context into this.context.
		      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
		      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
		      if ((node.name === "class" || node.name === "function") &&
		        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
		        this.context.pop();
		      }
		    } else {
		      this.unexpected();
		    }
		    return node
		  };

		  pp$5.parsePrivateIdent = function() {
		    var node = this.startNode();
		    if (this.type === types$1.privateId) {
		      node.name = this.value;
		    } else {
		      this.unexpected();
		    }
		    this.next();
		    this.finishNode(node, "PrivateIdentifier");

		    // For validating existence
		    if (this.options.checkPrivateFields) {
		      if (this.privateNameStack.length === 0) {
		        this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
		      } else {
		        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
		      }
		    }

		    return node
		  };

		  // Parses yield expression inside generator.

		  pp$5.parseYield = function(forInit) {
		    if (!this.yieldPos) { this.yieldPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
		      node.delegate = false;
		      node.argument = null;
		    } else {
		      node.delegate = this.eat(types$1.star);
		      node.argument = this.parseMaybeAssign(forInit);
		    }
		    return this.finishNode(node, "YieldExpression")
		  };

		  pp$5.parseAwait = function(forInit) {
		    if (!this.awaitPos) { this.awaitPos = this.start; }

		    var node = this.startNode();
		    this.next();
		    node.argument = this.parseMaybeUnary(null, true, false, forInit);
		    return this.finishNode(node, "AwaitExpression")
		  };

		  var pp$4 = Parser.prototype;

		  // This function is used to raise exceptions on parse errors. It
		  // takes an offset integer (into the current `input`) to indicate
		  // the location of the error, attaches the position to the end
		  // of the error message, and then raises a `SyntaxError` with that
		  // message.

		  pp$4.raise = function(pos, message) {
		    var loc = getLineInfo(this.input, pos);
		    message += " (" + loc.line + ":" + loc.column + ")";
		    var err = new SyntaxError(message);
		    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
		    throw err
		  };

		  pp$4.raiseRecoverable = pp$4.raise;

		  pp$4.curPosition = function() {
		    if (this.options.locations) {
		      return new Position(this.curLine, this.pos - this.lineStart)
		    }
		  };

		  var pp$3 = Parser.prototype;

		  var Scope = function Scope(flags) {
		    this.flags = flags;
		    // A list of var-declared names in the current lexical scope
		    this.var = [];
		    // A list of lexically-declared names in the current lexical scope
		    this.lexical = [];
		    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
		    this.functions = [];
		    // A switch to disallow the identifier reference 'arguments'
		    this.inClassFieldInit = false;
		  };

		  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

		  pp$3.enterScope = function(flags) {
		    this.scopeStack.push(new Scope(flags));
		  };

		  pp$3.exitScope = function() {
		    this.scopeStack.pop();
		  };

		  // The spec says:
		  // > At the top level of a function, or script, function declarations are
		  // > treated like var declarations rather than like lexical declarations.
		  pp$3.treatFunctionsAsVarInScope = function(scope) {
		    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
		  };

		  pp$3.declareName = function(name, bindingType, pos) {
		    var redeclared = false;
		    if (bindingType === BIND_LEXICAL) {
		      var scope = this.currentScope();
		      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		      scope.lexical.push(name);
		      if (this.inModule && (scope.flags & SCOPE_TOP))
		        { delete this.undefinedExports[name]; }
		    } else if (bindingType === BIND_SIMPLE_CATCH) {
		      var scope$1 = this.currentScope();
		      scope$1.lexical.push(name);
		    } else if (bindingType === BIND_FUNCTION) {
		      var scope$2 = this.currentScope();
		      if (this.treatFunctionsAsVar)
		        { redeclared = scope$2.lexical.indexOf(name) > -1; }
		      else
		        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
		      scope$2.functions.push(name);
		    } else {
		      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
		        var scope$3 = this.scopeStack[i];
		        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
		            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
		          redeclared = true;
		          break
		        }
		        scope$3.var.push(name);
		        if (this.inModule && (scope$3.flags & SCOPE_TOP))
		          { delete this.undefinedExports[name]; }
		        if (scope$3.flags & SCOPE_VAR) { break }
		      }
		    }
		    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
		  };

		  pp$3.checkLocalExport = function(id) {
		    // scope.functions must be empty as Module code is always strict.
		    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
		        this.scopeStack[0].var.indexOf(id.name) === -1) {
		      this.undefinedExports[id.name] = id;
		    }
		  };

		  pp$3.currentScope = function() {
		    return this.scopeStack[this.scopeStack.length - 1]
		  };

		  pp$3.currentVarScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR) { return scope }
		    }
		  };

		  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
		  pp$3.currentThisScope = function() {
		    for (var i = this.scopeStack.length - 1;; i--) {
		      var scope = this.scopeStack[i];
		      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
		    }
		  };

		  var Node = function Node(parser, pos, loc) {
		    this.type = "";
		    this.start = pos;
		    this.end = 0;
		    if (parser.options.locations)
		      { this.loc = new SourceLocation(parser, loc); }
		    if (parser.options.directSourceFile)
		      { this.sourceFile = parser.options.directSourceFile; }
		    if (parser.options.ranges)
		      { this.range = [pos, 0]; }
		  };

		  // Start an AST node, attaching a start offset.

		  var pp$2 = Parser.prototype;

		  pp$2.startNode = function() {
		    return new Node(this, this.start, this.startLoc)
		  };

		  pp$2.startNodeAt = function(pos, loc) {
		    return new Node(this, pos, loc)
		  };

		  // Finish an AST node, adding `type` and `end` properties.

		  function finishNodeAt(node, type, pos, loc) {
		    node.type = type;
		    node.end = pos;
		    if (this.options.locations)
		      { node.loc.end = loc; }
		    if (this.options.ranges)
		      { node.range[1] = pos; }
		    return node
		  }

		  pp$2.finishNode = function(node, type) {
		    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
		  };

		  // Finish node at given position

		  pp$2.finishNodeAt = function(node, type, pos, loc) {
		    return finishNodeAt.call(this, node, type, pos, loc)
		  };

		  pp$2.copyNode = function(node) {
		    var newNode = new Node(this, node.start, this.startLoc);
		    for (var prop in node) { newNode[prop] = node[prop]; }
		    return newNode
		  };

		  // This file contains Unicode properties extracted from the ECMAScript specification.
		  // The lists are extracted like so:
		  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

		  // #table-binary-unicode-properties
		  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
		  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
		  var ecma11BinaryProperties = ecma10BinaryProperties;
		  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
		  var ecma13BinaryProperties = ecma12BinaryProperties;
		  var ecma14BinaryProperties = ecma13BinaryProperties;

		  var unicodeBinaryProperties = {
		    9: ecma9BinaryProperties,
		    10: ecma10BinaryProperties,
		    11: ecma11BinaryProperties,
		    12: ecma12BinaryProperties,
		    13: ecma13BinaryProperties,
		    14: ecma14BinaryProperties
		  };

		  // #table-binary-unicode-properties-of-strings
		  var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

		  var unicodeBinaryPropertiesOfStrings = {
		    9: "",
		    10: "",
		    11: "",
		    12: "",
		    13: "",
		    14: ecma14BinaryPropertiesOfStrings
		  };

		  // #table-unicode-general-category-values
		  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

		  // #table-unicode-script-values
		  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
		  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
		  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
		  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
		  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
		  var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";

		  var unicodeScriptValues = {
		    9: ecma9ScriptValues,
		    10: ecma10ScriptValues,
		    11: ecma11ScriptValues,
		    12: ecma12ScriptValues,
		    13: ecma13ScriptValues,
		    14: ecma14ScriptValues
		  };

		  var data = {};
		  function buildUnicodeData(ecmaVersion) {
		    var d = data[ecmaVersion] = {
		      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
		      binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
		      nonBinary: {
		        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
		        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
		      }
		    };
		    d.nonBinary.Script_Extensions = d.nonBinary.Script;

		    d.nonBinary.gc = d.nonBinary.General_Category;
		    d.nonBinary.sc = d.nonBinary.Script;
		    d.nonBinary.scx = d.nonBinary.Script_Extensions;
		  }

		  for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
		    var ecmaVersion = list[i];

		    buildUnicodeData(ecmaVersion);
		  }

		  var pp$1 = Parser.prototype;

		  var RegExpValidationState = function RegExpValidationState(parser) {
		    this.parser = parser;
		    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
		    this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
		    this.source = "";
		    this.flags = "";
		    this.start = 0;
		    this.switchU = false;
		    this.switchV = false;
		    this.switchN = false;
		    this.pos = 0;
		    this.lastIntValue = 0;
		    this.lastStringValue = "";
		    this.lastAssertionIsQuantifiable = false;
		    this.numCapturingParens = 0;
		    this.maxBackReference = 0;
		    this.groupNames = [];
		    this.backReferenceNames = [];
		  };

		  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
		    var unicodeSets = flags.indexOf("v") !== -1;
		    var unicode = flags.indexOf("u") !== -1;
		    this.start = start | 0;
		    this.source = pattern + "";
		    this.flags = flags;
		    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		      this.switchU = true;
		      this.switchV = true;
		      this.switchN = true;
		    } else {
		      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		      this.switchV = false;
		      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
		    }
		  };

		  RegExpValidationState.prototype.raise = function raise (message) {
		    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
		  };

		  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
		  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
		  RegExpValidationState.prototype.at = function at (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return -1
		    }
		    var c = s.charCodeAt(i);
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
		      return c
		    }
		    var next = s.charCodeAt(i + 1);
		    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
		  };

		  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var s = this.source;
		    var l = s.length;
		    if (i >= l) {
		      return l
		    }
		    var c = s.charCodeAt(i), next;
		    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
		        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
		      return i + 1
		    }
		    return i + 2
		  };

		  RegExpValidationState.prototype.current = function current (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.pos, forceU)
		  };

		  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    return this.at(this.nextIndex(this.pos, forceU), forceU)
		  };

		  RegExpValidationState.prototype.advance = function advance (forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    this.pos = this.nextIndex(this.pos, forceU);
		  };

		  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    if (this.current(forceU) === ch) {
		      this.advance(forceU);
		      return true
		    }
		    return false
		  };

		  RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
		      if ( forceU === void 0 ) forceU = false;

		    var pos = this.pos;
		    for (var i = 0, list = chs; i < list.length; i += 1) {
		      var ch = list[i];

		        var current = this.at(pos, forceU);
		      if (current === -1 || current !== ch) {
		        return false
		      }
		      pos = this.nextIndex(pos, forceU);
		    }
		    this.pos = pos;
		    return true
		  };

		  /**
		   * Validate the flags part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpFlags = function(state) {
		    var validFlags = state.validFlags;
		    var flags = state.flags;

		    var u = false;
		    var v = false;

		    for (var i = 0; i < flags.length; i++) {
		      var flag = flags.charAt(i);
		      if (validFlags.indexOf(flag) === -1) {
		        this.raise(state.start, "Invalid regular expression flag");
		      }
		      if (flags.indexOf(flag, i + 1) > -1) {
		        this.raise(state.start, "Duplicate regular expression flag");
		      }
		      if (flag === "u") { u = true; }
		      if (flag === "v") { v = true; }
		    }
		    if (this.options.ecmaVersion >= 15 && u && v) {
		      this.raise(state.start, "Invalid regular expression flag");
		    }
		  };

		  /**
		   * Validate the pattern part of a given RegExpLiteral.
		   *
		   * @param {RegExpValidationState} state The state to validate RegExp.
		   * @returns {void}
		   */
		  pp$1.validateRegExpPattern = function(state) {
		    this.regexp_pattern(state);

		    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
		    // parsing contains a |GroupName|, reparse with the goal symbol
		    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
		    // exception if _P_ did not conform to the grammar, if any elements of _P_
		    // were not matched by the parse, or if any Early Error conditions exist.
		    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
		      state.switchN = true;
		      this.regexp_pattern(state);
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
		  pp$1.regexp_pattern = function(state) {
		    state.pos = 0;
		    state.lastIntValue = 0;
		    state.lastStringValue = "";
		    state.lastAssertionIsQuantifiable = false;
		    state.numCapturingParens = 0;
		    state.maxBackReference = 0;
		    state.groupNames.length = 0;
		    state.backReferenceNames.length = 0;

		    this.regexp_disjunction(state);

		    if (state.pos !== state.source.length) {
		      // Make the same messages as V8.
		      if (state.eat(0x29 /* ) */)) {
		        state.raise("Unmatched ')'");
		      }
		      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
		        state.raise("Lone quantifier brackets");
		      }
		    }
		    if (state.maxBackReference > state.numCapturingParens) {
		      state.raise("Invalid escape");
		    }
		    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
		      var name = list[i];

		      if (state.groupNames.indexOf(name) === -1) {
		        state.raise("Invalid named capture referenced");
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
		  pp$1.regexp_disjunction = function(state) {
		    this.regexp_alternative(state);
		    while (state.eat(0x7C /* | */)) {
		      this.regexp_alternative(state);
		    }

		    // Make the same message as V8.
		    if (this.regexp_eatQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    if (state.eat(0x7B /* { */)) {
		      state.raise("Lone quantifier brackets");
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
		  pp$1.regexp_alternative = function(state) {
		    while (state.pos < state.source.length && this.regexp_eatTerm(state))
		      { }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
		  pp$1.regexp_eatTerm = function(state) {
		    if (this.regexp_eatAssertion(state)) {
		      // Handle `QuantifiableAssertion Quantifier` alternative.
		      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
		      // is a QuantifiableAssertion.
		      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
		        // Make the same message as V8.
		        if (state.switchU) {
		          state.raise("Invalid quantifier");
		        }
		      }
		      return true
		    }

		    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		      this.regexp_eatQuantifier(state);
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
		  pp$1.regexp_eatAssertion = function(state) {
		    var start = state.pos;
		    state.lastAssertionIsQuantifiable = false;

		    // ^, $
		    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
		      return true
		    }

		    // \b \B
		    if (state.eat(0x5C /* \ */)) {
		      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
		        return true
		      }
		      state.pos = start;
		    }

		    // Lookahead / Lookbehind
		    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
		      var lookbehind = false;
		      if (this.options.ecmaVersion >= 9) {
		        lookbehind = state.eat(0x3C /* < */);
		      }
		      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
		        this.regexp_disjunction(state);
		        if (!state.eat(0x29 /* ) */)) {
		          state.raise("Unterminated group");
		        }
		        state.lastAssertionIsQuantifiable = !lookbehind;
		        return true
		      }
		    }

		    state.pos = start;
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
		  pp$1.regexp_eatQuantifier = function(state, noError) {
		    if ( noError === void 0 ) noError = false;

		    if (this.regexp_eatQuantifierPrefix(state, noError)) {
		      state.eat(0x3F /* ? */);
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
		  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
		    return (
		      state.eat(0x2A /* * */) ||
		      state.eat(0x2B /* + */) ||
		      state.eat(0x3F /* ? */) ||
		      this.regexp_eatBracedQuantifier(state, noError)
		    )
		  };
		  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
		    var start = state.pos;
		    if (state.eat(0x7B /* { */)) {
		      var min = 0, max = -1;
		      if (this.regexp_eatDecimalDigits(state)) {
		        min = state.lastIntValue;
		        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
		          max = state.lastIntValue;
		        }
		        if (state.eat(0x7D /* } */)) {
		          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
		          if (max !== -1 && max < min && !noError) {
		            state.raise("numbers out of order in {} quantifier");
		          }
		          return true
		        }
		      }
		      if (state.switchU && !noError) {
		        state.raise("Incomplete quantifier");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
		  pp$1.regexp_eatAtom = function(state) {
		    return (
		      this.regexp_eatPatternCharacters(state) ||
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state)
		    )
		  };
		  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatAtomEscape(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatUncapturingGroup = function(state) {
		    var start = state.pos;
		    if (state.eat(0x28 /* ( */)) {
		      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
		        this.regexp_disjunction(state);
		        if (state.eat(0x29 /* ) */)) {
		          return true
		        }
		        state.raise("Unterminated group");
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatCapturingGroup = function(state) {
		    if (state.eat(0x28 /* ( */)) {
		      if (this.options.ecmaVersion >= 9) {
		        this.regexp_groupSpecifier(state);
		      } else if (state.current() === 0x3F /* ? */) {
		        state.raise("Invalid group");
		      }
		      this.regexp_disjunction(state);
		      if (state.eat(0x29 /* ) */)) {
		        state.numCapturingParens += 1;
		        return true
		      }
		      state.raise("Unterminated group");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
		  pp$1.regexp_eatExtendedAtom = function(state) {
		    return (
		      state.eat(0x2E /* . */) ||
		      this.regexp_eatReverseSolidusAtomEscape(state) ||
		      this.regexp_eatCharacterClass(state) ||
		      this.regexp_eatUncapturingGroup(state) ||
		      this.regexp_eatCapturingGroup(state) ||
		      this.regexp_eatInvalidBracedQuantifier(state) ||
		      this.regexp_eatExtendedPatternCharacter(state)
		    )
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
		  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
		    if (this.regexp_eatBracedQuantifier(state, true)) {
		      state.raise("Nothing to repeat");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
		  pp$1.regexp_eatSyntaxCharacter = function(state) {
		    var ch = state.current();
		    if (isSyntaxCharacter(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isSyntaxCharacter(ch) {
		    return (
		      ch === 0x24 /* $ */ ||
		      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
		      ch === 0x2E /* . */ ||
		      ch === 0x3F /* ? */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
		  // But eat eager.
		  pp$1.regexp_eatPatternCharacters = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
		      state.advance();
		    }
		    return state.pos !== start
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
		  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
		    var ch = state.current();
		    if (
		      ch !== -1 &&
		      ch !== 0x24 /* $ */ &&
		      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
		      ch !== 0x2E /* . */ &&
		      ch !== 0x3F /* ? */ &&
		      ch !== 0x5B /* [ */ &&
		      ch !== 0x5E /* ^ */ &&
		      ch !== 0x7C /* | */
		    ) {
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // GroupSpecifier ::
		  //   [empty]
		  //   `?` GroupName
		  pp$1.regexp_groupSpecifier = function(state) {
		    if (state.eat(0x3F /* ? */)) {
		      if (this.regexp_eatGroupName(state)) {
		        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
		          state.raise("Duplicate capture group name");
		        }
		        state.groupNames.push(state.lastStringValue);
		        return
		      }
		      state.raise("Invalid group");
		    }
		  };

		  // GroupName ::
		  //   `<` RegExpIdentifierName `>`
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatGroupName = function(state) {
		    state.lastStringValue = "";
		    if (state.eat(0x3C /* < */)) {
		      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
		        return true
		      }
		      state.raise("Invalid capture group name");
		    }
		    return false
		  };

		  // RegExpIdentifierName ::
		  //   RegExpIdentifierStart
		  //   RegExpIdentifierName RegExpIdentifierPart
		  // Note: this updates `state.lastStringValue` property with the eaten name.
		  pp$1.regexp_eatRegExpIdentifierName = function(state) {
		    state.lastStringValue = "";
		    if (this.regexp_eatRegExpIdentifierStart(state)) {
		      state.lastStringValue += codePointToString(state.lastIntValue);
		      while (this.regexp_eatRegExpIdentifierPart(state)) {
		        state.lastStringValue += codePointToString(state.lastIntValue);
		      }
		      return true
		    }
		    return false
		  };

		  // RegExpIdentifierStart ::
		  //   UnicodeIDStart
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierStart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierStart(ch) {
		    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
		  }

		  // RegExpIdentifierPart ::
		  //   UnicodeIDContinue
		  //   `$`
		  //   `_`
		  //   `\` RegExpUnicodeEscapeSequence[+U]
		  //   <ZWNJ>
		  //   <ZWJ>
		  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
		    var start = state.pos;
		    var forceU = this.options.ecmaVersion >= 11;
		    var ch = state.current(forceU);
		    state.advance(forceU);

		    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
		      ch = state.lastIntValue;
		    }
		    if (isRegExpIdentifierPart(ch)) {
		      state.lastIntValue = ch;
		      return true
		    }

		    state.pos = start;
		    return false
		  };
		  function isRegExpIdentifierPart(ch) {
		    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
		  pp$1.regexp_eatAtomEscape = function(state) {
		    if (
		      this.regexp_eatBackReference(state) ||
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state) ||
		      (state.switchN && this.regexp_eatKGroupName(state))
		    ) {
		      return true
		    }
		    if (state.switchU) {
		      // Make the same message as V8.
		      if (state.current() === 0x63 /* c */) {
		        state.raise("Invalid unicode escape");
		      }
		      state.raise("Invalid escape");
		    }
		    return false
		  };
		  pp$1.regexp_eatBackReference = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatDecimalEscape(state)) {
		      var n = state.lastIntValue;
		      if (state.switchU) {
		        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
		        if (n > state.maxBackReference) {
		          state.maxBackReference = n;
		        }
		        return true
		      }
		      if (n <= state.numCapturingParens) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatKGroupName = function(state) {
		    if (state.eat(0x6B /* k */)) {
		      if (this.regexp_eatGroupName(state)) {
		        state.backReferenceNames.push(state.lastStringValue);
		        return true
		      }
		      state.raise("Invalid named reference");
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
		  pp$1.regexp_eatCharacterEscape = function(state) {
		    return (
		      this.regexp_eatControlEscape(state) ||
		      this.regexp_eatCControlLetter(state) ||
		      this.regexp_eatZero(state) ||
		      this.regexp_eatHexEscapeSequence(state) ||
		      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
		      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
		      this.regexp_eatIdentityEscape(state)
		    )
		  };
		  pp$1.regexp_eatCControlLetter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x63 /* c */)) {
		      if (this.regexp_eatControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };
		  pp$1.regexp_eatZero = function(state) {
		    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
		      state.lastIntValue = 0;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
		  pp$1.regexp_eatControlEscape = function(state) {
		    var ch = state.current();
		    if (ch === 0x74 /* t */) {
		      state.lastIntValue = 0x09; /* \t */
		      state.advance();
		      return true
		    }
		    if (ch === 0x6E /* n */) {
		      state.lastIntValue = 0x0A; /* \n */
		      state.advance();
		      return true
		    }
		    if (ch === 0x76 /* v */) {
		      state.lastIntValue = 0x0B; /* \v */
		      state.advance();
		      return true
		    }
		    if (ch === 0x66 /* f */) {
		      state.lastIntValue = 0x0C; /* \f */
		      state.advance();
		      return true
		    }
		    if (ch === 0x72 /* r */) {
		      state.lastIntValue = 0x0D; /* \r */
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
		  pp$1.regexp_eatControlLetter = function(state) {
		    var ch = state.current();
		    if (isControlLetter(ch)) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };
		  function isControlLetter(ch) {
		    return (
		      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
		  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
		    if ( forceU === void 0 ) forceU = false;

		    var start = state.pos;
		    var switchU = forceU || state.switchU;

		    if (state.eat(0x75 /* u */)) {
		      if (this.regexp_eatFixedHexDigits(state, 4)) {
		        var lead = state.lastIntValue;
		        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
		          var leadSurrogateEnd = state.pos;
		          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
		            var trail = state.lastIntValue;
		            if (trail >= 0xDC00 && trail <= 0xDFFF) {
		              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
		              return true
		            }
		          }
		          state.pos = leadSurrogateEnd;
		          state.lastIntValue = lead;
		        }
		        return true
		      }
		      if (
		        switchU &&
		        state.eat(0x7B /* { */) &&
		        this.regexp_eatHexDigits(state) &&
		        state.eat(0x7D /* } */) &&
		        isValidUnicode(state.lastIntValue)
		      ) {
		        return true
		      }
		      if (switchU) {
		        state.raise("Invalid unicode escape");
		      }
		      state.pos = start;
		    }

		    return false
		  };
		  function isValidUnicode(ch) {
		    return ch >= 0 && ch <= 0x10FFFF
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
		  pp$1.regexp_eatIdentityEscape = function(state) {
		    if (state.switchU) {
		      if (this.regexp_eatSyntaxCharacter(state)) {
		        return true
		      }
		      if (state.eat(0x2F /* / */)) {
		        state.lastIntValue = 0x2F; /* / */
		        return true
		      }
		      return false
		    }

		    var ch = state.current();
		    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
		  pp$1.regexp_eatDecimalEscape = function(state) {
		    state.lastIntValue = 0;
		    var ch = state.current();
		    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
		      do {
		        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		        state.advance();
		      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
		      return true
		    }
		    return false
		  };

		  // Return values used by character set parsing methods, needed to
		  // forbid negation of sets that can match strings.
		  var CharSetNone = 0; // Nothing parsed
		  var CharSetOk = 1; // Construct parsed, cannot contain strings
		  var CharSetString = 2; // Construct parsed, can contain strings

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
		  pp$1.regexp_eatCharacterClassEscape = function(state) {
		    var ch = state.current();

		    if (isCharacterClassEscape(ch)) {
		      state.lastIntValue = -1;
		      state.advance();
		      return CharSetOk
		    }

		    var negate = false;
		    if (
		      state.switchU &&
		      this.options.ecmaVersion >= 9 &&
		      ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
		    ) {
		      state.lastIntValue = -1;
		      state.advance();
		      var result;
		      if (
		        state.eat(0x7B /* { */) &&
		        (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
		        state.eat(0x7D /* } */)
		      ) {
		        if (negate && result === CharSetString) { state.raise("Invalid property name"); }
		        return result
		      }
		      state.raise("Invalid property name");
		    }

		    return CharSetNone
		  };

		  function isCharacterClassEscape(ch) {
		    return (
		      ch === 0x64 /* d */ ||
		      ch === 0x44 /* D */ ||
		      ch === 0x73 /* s */ ||
		      ch === 0x53 /* S */ ||
		      ch === 0x77 /* w */ ||
		      ch === 0x57 /* W */
		    )
		  }

		  // UnicodePropertyValueExpression ::
		  //   UnicodePropertyName `=` UnicodePropertyValue
		  //   LoneUnicodePropertyNameOrValue
		  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
		    var start = state.pos;

		    // UnicodePropertyName `=` UnicodePropertyValue
		    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
		      var name = state.lastStringValue;
		      if (this.regexp_eatUnicodePropertyValue(state)) {
		        var value = state.lastStringValue;
		        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
		        return CharSetOk
		      }
		    }
		    state.pos = start;

		    // LoneUnicodePropertyNameOrValue
		    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		      var nameOrValue = state.lastStringValue;
		      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
		    }
		    return CharSetNone
		  };

		  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
		    if (!hasOwn(state.unicodeProperties.nonBinary, name))
		      { state.raise("Invalid property name"); }
		    if (!state.unicodeProperties.nonBinary[name].test(value))
		      { state.raise("Invalid property value"); }
		  };

		  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
		    if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
		    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
		    state.raise("Invalid property name");
		  };

		  // UnicodePropertyName ::
		  //   UnicodePropertyNameCharacters
		  pp$1.regexp_eatUnicodePropertyName = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyNameCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };

		  function isUnicodePropertyNameCharacter(ch) {
		    return isControlLetter(ch) || ch === 0x5F /* _ */
		  }

		  // UnicodePropertyValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatUnicodePropertyValue = function(state) {
		    var ch = 0;
		    state.lastStringValue = "";
		    while (isUnicodePropertyValueCharacter(ch = state.current())) {
		      state.lastStringValue += codePointToString(ch);
		      state.advance();
		    }
		    return state.lastStringValue !== ""
		  };
		  function isUnicodePropertyValueCharacter(ch) {
		    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
		  }

		  // LoneUnicodePropertyNameOrValue ::
		  //   UnicodePropertyValueCharacters
		  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
		    return this.regexp_eatUnicodePropertyValue(state)
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
		  pp$1.regexp_eatCharacterClass = function(state) {
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (!state.eat(0x5D /* ] */))
		        { state.raise("Unterminated character class"); }
		      if (negate && result === CharSetString)
		        { state.raise("Negated character class may contain strings"); }
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassContents
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
		  pp$1.regexp_classContents = function(state) {
		    if (state.current() === 0x5D /* ] */) { return CharSetOk }
		    if (state.switchV) { return this.regexp_classSetExpression(state) }
		    this.regexp_nonEmptyClassRanges(state);
		    return CharSetOk
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
		  pp$1.regexp_nonEmptyClassRanges = function(state) {
		    while (this.regexp_eatClassAtom(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
		        var right = state.lastIntValue;
		        if (state.switchU && (left === -1 || right === -1)) {
		          state.raise("Invalid character class");
		        }
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		      }
		    }
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
		  pp$1.regexp_eatClassAtom = function(state) {
		    var start = state.pos;

		    if (state.eat(0x5C /* \ */)) {
		      if (this.regexp_eatClassEscape(state)) {
		        return true
		      }
		      if (state.switchU) {
		        // Make the same message as V8.
		        var ch$1 = state.current();
		        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
		          state.raise("Invalid class escape");
		        }
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }

		    var ch = state.current();
		    if (ch !== 0x5D /* ] */) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }

		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
		  pp$1.regexp_eatClassEscape = function(state) {
		    var start = state.pos;

		    if (state.eat(0x62 /* b */)) {
		      state.lastIntValue = 0x08; /* <BS> */
		      return true
		    }

		    if (state.switchU && state.eat(0x2D /* - */)) {
		      state.lastIntValue = 0x2D; /* - */
		      return true
		    }

		    if (!state.switchU && state.eat(0x63 /* c */)) {
		      if (this.regexp_eatClassControlLetter(state)) {
		        return true
		      }
		      state.pos = start;
		    }

		    return (
		      this.regexp_eatCharacterClassEscape(state) ||
		      this.regexp_eatCharacterEscape(state)
		    )
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetExpression
		  // https://tc39.es/ecma262/#prod-ClassUnion
		  // https://tc39.es/ecma262/#prod-ClassIntersection
		  // https://tc39.es/ecma262/#prod-ClassSubtraction
		  pp$1.regexp_classSetExpression = function(state) {
		    var result = CharSetOk, subResult;
		    if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
		      if (subResult === CharSetString) { result = CharSetString; }
		      // https://tc39.es/ecma262/#prod-ClassIntersection
		      var start = state.pos;
		      while (state.eatChars([0x26, 0x26] /* && */)) {
		        if (
		          state.current() !== 0x26 /* & */ &&
		          (subResult = this.regexp_eatClassSetOperand(state))
		        ) {
		          if (subResult !== CharSetString) { result = CharSetOk; }
		          continue
		        }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		      // https://tc39.es/ecma262/#prod-ClassSubtraction
		      while (state.eatChars([0x2D, 0x2D] /* -- */)) {
		        if (this.regexp_eatClassSetOperand(state)) { continue }
		        state.raise("Invalid character in character class");
		      }
		      if (start !== state.pos) { return result }
		    } else {
		      state.raise("Invalid character in character class");
		    }
		    // https://tc39.es/ecma262/#prod-ClassUnion
		    for (;;) {
		      if (this.regexp_eatClassSetRange(state)) { continue }
		      subResult = this.regexp_eatClassSetOperand(state);
		      if (!subResult) { return result }
		      if (subResult === CharSetString) { result = CharSetString; }
		    }
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetRange
		  pp$1.regexp_eatClassSetRange = function(state) {
		    var start = state.pos;
		    if (this.regexp_eatClassSetCharacter(state)) {
		      var left = state.lastIntValue;
		      if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
		        var right = state.lastIntValue;
		        if (left !== -1 && right !== -1 && left > right) {
		          state.raise("Range out of order in character class");
		        }
		        return true
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetOperand
		  pp$1.regexp_eatClassSetOperand = function(state) {
		    if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
		    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
		  };

		  // https://tc39.es/ecma262/#prod-NestedClass
		  pp$1.regexp_eatNestedClass = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5B /* [ */)) {
		      var negate = state.eat(0x5E /* ^ */);
		      var result = this.regexp_classContents(state);
		      if (state.eat(0x5D /* ] */)) {
		        if (negate && result === CharSetString) {
		          state.raise("Negated character class may contain strings");
		        }
		        return result
		      }
		      state.pos = start;
		    }
		    if (state.eat(0x5C /* \ */)) {
		      var result$1 = this.regexp_eatCharacterClassEscape(state);
		      if (result$1) {
		        return result$1
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunction
		  pp$1.regexp_eatClassStringDisjunction = function(state) {
		    var start = state.pos;
		    if (state.eatChars([0x5C, 0x71] /* \q */)) {
		      if (state.eat(0x7B /* { */)) {
		        var result = this.regexp_classStringDisjunctionContents(state);
		        if (state.eat(0x7D /* } */)) {
		          return result
		        }
		      } else {
		        // Make the same message as V8.
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return null
		  };

		  // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
		  pp$1.regexp_classStringDisjunctionContents = function(state) {
		    var result = this.regexp_classString(state);
		    while (state.eat(0x7C /* | */)) {
		      if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
		    }
		    return result
		  };

		  // https://tc39.es/ecma262/#prod-ClassString
		  // https://tc39.es/ecma262/#prod-NonEmptyClassString
		  pp$1.regexp_classString = function(state) {
		    var count = 0;
		    while (this.regexp_eatClassSetCharacter(state)) { count++; }
		    return count === 1 ? CharSetOk : CharSetString
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetCharacter
		  pp$1.regexp_eatClassSetCharacter = function(state) {
		    var start = state.pos;
		    if (state.eat(0x5C /* \ */)) {
		      if (
		        this.regexp_eatCharacterEscape(state) ||
		        this.regexp_eatClassSetReservedPunctuator(state)
		      ) {
		        return true
		      }
		      if (state.eat(0x62 /* b */)) {
		        state.lastIntValue = 0x08; /* <BS> */
		        return true
		      }
		      state.pos = start;
		      return false
		    }
		    var ch = state.current();
		    if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
		    if (isClassSetSyntaxCharacter(ch)) { return false }
		    state.advance();
		    state.lastIntValue = ch;
		    return true
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
		  function isClassSetReservedDoublePunctuatorCharacter(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
		      ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
		      ch === 0x2E /* . */ ||
		      ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
		      ch === 0x5E /* ^ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
		  function isClassSetSyntaxCharacter(ch) {
		    return (
		      ch === 0x28 /* ( */ ||
		      ch === 0x29 /* ) */ ||
		      ch === 0x2D /* - */ ||
		      ch === 0x2F /* / */ ||
		      ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
		      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
		    )
		  }

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
		    var ch = state.current();
		    if (isClassSetReservedPunctuator(ch)) {
		      state.lastIntValue = ch;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
		  function isClassSetReservedPunctuator(ch) {
		    return (
		      ch === 0x21 /* ! */ ||
		      ch === 0x23 /* # */ ||
		      ch === 0x25 /* % */ ||
		      ch === 0x26 /* & */ ||
		      ch === 0x2C /* , */ ||
		      ch === 0x2D /* - */ ||
		      ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
		      ch === 0x40 /* @ */ ||
		      ch === 0x60 /* ` */ ||
		      ch === 0x7E /* ~ */
		    )
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
		  pp$1.regexp_eatClassControlLetter = function(state) {
		    var ch = state.current();
		    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
		      state.lastIntValue = ch % 0x20;
		      state.advance();
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatHexEscapeSequence = function(state) {
		    var start = state.pos;
		    if (state.eat(0x78 /* x */)) {
		      if (this.regexp_eatFixedHexDigits(state, 2)) {
		        return true
		      }
		      if (state.switchU) {
		        state.raise("Invalid escape");
		      }
		      state.pos = start;
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
		  pp$1.regexp_eatDecimalDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isDecimalDigit(ch = state.current())) {
		      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isDecimalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
		  pp$1.regexp_eatHexDigits = function(state) {
		    var start = state.pos;
		    var ch = 0;
		    state.lastIntValue = 0;
		    while (isHexDigit(ch = state.current())) {
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return state.pos !== start
		  };
		  function isHexDigit(ch) {
		    return (
		      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
		      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
		      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
		    )
		  }
		  function hexToInt(ch) {
		    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
		      return 10 + (ch - 0x41 /* A */)
		    }
		    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
		      return 10 + (ch - 0x61 /* a */)
		    }
		    return ch - 0x30 /* 0 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
		  // Allows only 0-377(octal) i.e. 0-255(decimal).
		  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
		    if (this.regexp_eatOctalDigit(state)) {
		      var n1 = state.lastIntValue;
		      if (this.regexp_eatOctalDigit(state)) {
		        var n2 = state.lastIntValue;
		        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
		          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
		        } else {
		          state.lastIntValue = n1 * 8 + n2;
		        }
		      } else {
		        state.lastIntValue = n1;
		      }
		      return true
		    }
		    return false
		  };

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
		  pp$1.regexp_eatOctalDigit = function(state) {
		    var ch = state.current();
		    if (isOctalDigit(ch)) {
		      state.lastIntValue = ch - 0x30; /* 0 */
		      state.advance();
		      return true
		    }
		    state.lastIntValue = 0;
		    return false
		  };
		  function isOctalDigit(ch) {
		    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
		  }

		  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
		  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
		  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
		  pp$1.regexp_eatFixedHexDigits = function(state, length) {
		    var start = state.pos;
		    state.lastIntValue = 0;
		    for (var i = 0; i < length; ++i) {
		      var ch = state.current();
		      if (!isHexDigit(ch)) {
		        state.pos = start;
		        return false
		      }
		      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		      state.advance();
		    }
		    return true
		  };

		  // Object type used to represent tokens. Note that normally, tokens
		  // simply exist as properties on the parser object. This is only
		  // used for the onToken callback and the external tokenizer.

		  var Token = function Token(p) {
		    this.type = p.type;
		    this.value = p.value;
		    this.start = p.start;
		    this.end = p.end;
		    if (p.options.locations)
		      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
		    if (p.options.ranges)
		      { this.range = [p.start, p.end]; }
		  };

		  // ## Tokenizer

		  var pp = Parser.prototype;

		  // Move to the next token

		  pp.next = function(ignoreEscapeSequenceInKeyword) {
		    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
		      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
		    if (this.options.onToken)
		      { this.options.onToken(new Token(this)); }

		    this.lastTokEnd = this.end;
		    this.lastTokStart = this.start;
		    this.lastTokEndLoc = this.endLoc;
		    this.lastTokStartLoc = this.startLoc;
		    this.nextToken();
		  };

		  pp.getToken = function() {
		    this.next();
		    return new Token(this)
		  };

		  // If we're in an ES6 environment, make parsers iterable
		  if (typeof Symbol !== "undefined")
		    { pp[Symbol.iterator] = function() {
		      var this$1$1 = this;

		      return {
		        next: function () {
		          var token = this$1$1.getToken();
		          return {
		            done: token.type === types$1.eof,
		            value: token
		          }
		        }
		      }
		    }; }

		  // Toggle strict mode. Re-reads the next number or string to please
		  // pedantic tests (`"use strict"; 010;` should fail).

		  // Read a single token, updating the parser object's token-related
		  // properties.

		  pp.nextToken = function() {
		    var curContext = this.curContext();
		    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

		    this.start = this.pos;
		    if (this.options.locations) { this.startLoc = this.curPosition(); }
		    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

		    if (curContext.override) { return curContext.override(this) }
		    else { this.readToken(this.fullCharCodeAtPos()); }
		  };

		  pp.readToken = function(code) {
		    // Identifier or keyword. '\uXXXX' sequences are allowed in
		    // identifiers, so '\' also dispatches to that.
		    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
		      { return this.readWord() }

		    return this.getTokenFromCode(code)
		  };

		  pp.fullCharCodeAtPos = function() {
		    var code = this.input.charCodeAt(this.pos);
		    if (code <= 0xd7ff || code >= 0xdc00) { return code }
		    var next = this.input.charCodeAt(this.pos + 1);
		    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
		  };

		  pp.skipBlockComment = function() {
		    var startLoc = this.options.onComment && this.curPosition();
		    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
		    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
		    this.pos = end + 2;
		    if (this.options.locations) {
		      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		        ++this.curLine;
		        pos = this.lineStart = nextBreak;
		      }
		    }
		    if (this.options.onComment)
		      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  pp.skipLineComment = function(startSkip) {
		    var start = this.pos;
		    var startLoc = this.options.onComment && this.curPosition();
		    var ch = this.input.charCodeAt(this.pos += startSkip);
		    while (this.pos < this.input.length && !isNewLine(ch)) {
		      ch = this.input.charCodeAt(++this.pos);
		    }
		    if (this.options.onComment)
		      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
		                             startLoc, this.curPosition()); }
		  };

		  // Called at the start of the parse and after every token. Skips
		  // whitespace and comments, and.

		  pp.skipSpace = function() {
		    loop: while (this.pos < this.input.length) {
		      var ch = this.input.charCodeAt(this.pos);
		      switch (ch) {
		      case 32: case 160: // ' '
		        ++this.pos;
		        break
		      case 13:
		        if (this.input.charCodeAt(this.pos + 1) === 10) {
		          ++this.pos;
		        }
		      case 10: case 8232: case 8233:
		        ++this.pos;
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        break
		      case 47: // '/'
		        switch (this.input.charCodeAt(this.pos + 1)) {
		        case 42: // '*'
		          this.skipBlockComment();
		          break
		        case 47:
		          this.skipLineComment(2);
		          break
		        default:
		          break loop
		        }
		        break
		      default:
		        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		          ++this.pos;
		        } else {
		          break loop
		        }
		      }
		    }
		  };

		  // Called at the end of every token. Sets `end`, `val`, and
		  // maintains `context` and `exprAllowed`, and skips the space after
		  // the token, so that the next one's `start` will point at the
		  // right position.

		  pp.finishToken = function(type, val) {
		    this.end = this.pos;
		    if (this.options.locations) { this.endLoc = this.curPosition(); }
		    var prevType = this.type;
		    this.type = type;
		    this.value = val;

		    this.updateContext(prevType);
		  };

		  // ### Token reading

		  // This is the function that is called to fetch the next token. It
		  // is somewhat obscure, because it works in character codes rather
		  // than characters, and because operator parsing has been inlined
		  // into it.
		  //
		  // All in the name of speed.
		  //
		  pp.readToken_dot = function() {
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next >= 48 && next <= 57) { return this.readNumber(true) }
		    var next2 = this.input.charCodeAt(this.pos + 2);
		    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
		      this.pos += 3;
		      return this.finishToken(types$1.ellipsis)
		    } else {
		      ++this.pos;
		      return this.finishToken(types$1.dot)
		    }
		  };

		  pp.readToken_slash = function() { // '/'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.slash, 1)
		  };

		  pp.readToken_mult_modulo_exp = function(code) { // '%*'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    var tokentype = code === 42 ? types$1.star : types$1.modulo;

		    // exponentiation operator ** and **=
		    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		      ++size;
		      tokentype = types$1.starstar;
		      next = this.input.charCodeAt(this.pos + 2);
		    }

		    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
		    return this.finishOp(tokentype, size)
		  };

		  pp.readToken_pipe_amp = function(code) { // '|&'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (this.options.ecmaVersion >= 12) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
		      }
		      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
		  };

		  pp.readToken_caret = function() { // '^'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.bitwiseXOR, 1)
		  };

		  pp.readToken_plus_min = function(code) { // '+-'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === code) {
		      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
		          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
		        // A `-->` line comment
		        this.skipLineComment(3);
		        this.skipSpace();
		        return this.nextToken()
		      }
		      return this.finishOp(types$1.incDec, 2)
		    }
		    if (next === 61) { return this.finishOp(types$1.assign, 2) }
		    return this.finishOp(types$1.plusMin, 1)
		  };

		  pp.readToken_lt_gt = function(code) { // '<>'
		    var next = this.input.charCodeAt(this.pos + 1);
		    var size = 1;
		    if (next === code) {
		      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
		      return this.finishOp(types$1.bitShift, size)
		    }
		    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
		        this.input.charCodeAt(this.pos + 3) === 45) {
		      // `<!--`, an XML-style comment that should be interpreted as a line comment
		      this.skipLineComment(4);
		      this.skipSpace();
		      return this.nextToken()
		    }
		    if (next === 61) { size = 2; }
		    return this.finishOp(types$1.relational, size)
		  };

		  pp.readToken_eq_excl = function(code) { // '=!'
		    var next = this.input.charCodeAt(this.pos + 1);
		    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
		    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
		      this.pos += 2;
		      return this.finishToken(types$1.arrow)
		    }
		    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
		  };

		  pp.readToken_question = function() { // '?'
		    var ecmaVersion = this.options.ecmaVersion;
		    if (ecmaVersion >= 11) {
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 46) {
		        var next2 = this.input.charCodeAt(this.pos + 2);
		        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
		      }
		      if (next === 63) {
		        if (ecmaVersion >= 12) {
		          var next2$1 = this.input.charCodeAt(this.pos + 2);
		          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
		        }
		        return this.finishOp(types$1.coalesce, 2)
		      }
		    }
		    return this.finishOp(types$1.question, 1)
		  };

		  pp.readToken_numberSign = function() { // '#'
		    var ecmaVersion = this.options.ecmaVersion;
		    var code = 35; // '#'
		    if (ecmaVersion >= 13) {
		      ++this.pos;
		      code = this.fullCharCodeAtPos();
		      if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
		        return this.finishToken(types$1.privateId, this.readWord1())
		      }
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.getTokenFromCode = function(code) {
		    switch (code) {
		    // The interpretation of a dot depends on whether it is followed
		    // by a digit or another two dots.
		    case 46: // '.'
		      return this.readToken_dot()

		    // Punctuation tokens.
		    case 40: ++this.pos; return this.finishToken(types$1.parenL)
		    case 41: ++this.pos; return this.finishToken(types$1.parenR)
		    case 59: ++this.pos; return this.finishToken(types$1.semi)
		    case 44: ++this.pos; return this.finishToken(types$1.comma)
		    case 91: ++this.pos; return this.finishToken(types$1.bracketL)
		    case 93: ++this.pos; return this.finishToken(types$1.bracketR)
		    case 123: ++this.pos; return this.finishToken(types$1.braceL)
		    case 125: ++this.pos; return this.finishToken(types$1.braceR)
		    case 58: ++this.pos; return this.finishToken(types$1.colon)

		    case 96: // '`'
		      if (this.options.ecmaVersion < 6) { break }
		      ++this.pos;
		      return this.finishToken(types$1.backQuote)

		    case 48: // '0'
		      var next = this.input.charCodeAt(this.pos + 1);
		      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
		      if (this.options.ecmaVersion >= 6) {
		        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
		        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
		      }

		    // Anything else beginning with a digit is an integer, octal
		    // number, or float.
		    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
		      return this.readNumber(false)

		    // Quotes produce strings.
		    case 34: case 39: // '"', "'"
		      return this.readString(code)

		    // Operators are parsed inline in tiny state machines. '=' (61) is
		    // often referred to. `finishOp` simply skips the amount of
		    // characters it is given as second argument, and returns a token
		    // of the type given by its first argument.
		    case 47: // '/'
		      return this.readToken_slash()

		    case 37: case 42: // '%*'
		      return this.readToken_mult_modulo_exp(code)

		    case 124: case 38: // '|&'
		      return this.readToken_pipe_amp(code)

		    case 94: // '^'
		      return this.readToken_caret()

		    case 43: case 45: // '+-'
		      return this.readToken_plus_min(code)

		    case 60: case 62: // '<>'
		      return this.readToken_lt_gt(code)

		    case 61: case 33: // '=!'
		      return this.readToken_eq_excl(code)

		    case 63: // '?'
		      return this.readToken_question()

		    case 126: // '~'
		      return this.finishOp(types$1.prefix, 1)

		    case 35: // '#'
		      return this.readToken_numberSign()
		    }

		    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
		  };

		  pp.finishOp = function(type, size) {
		    var str = this.input.slice(this.pos, this.pos + size);
		    this.pos += size;
		    return this.finishToken(type, str)
		  };

		  pp.readRegexp = function() {
		    var escaped, inClass, start = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
		      var ch = this.input.charAt(this.pos);
		      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
		      if (!escaped) {
		        if (ch === "[") { inClass = true; }
		        else if (ch === "]" && inClass) { inClass = false; }
		        else if (ch === "/" && !inClass) { break }
		        escaped = ch === "\\";
		      } else { escaped = false; }
		      ++this.pos;
		    }
		    var pattern = this.input.slice(start, this.pos);
		    ++this.pos;
		    var flagsStart = this.pos;
		    var flags = this.readWord1();
		    if (this.containsEsc) { this.unexpected(flagsStart); }

		    // Validate pattern
		    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
		    state.reset(start, pattern, flags);
		    this.validateRegExpFlags(state);
		    this.validateRegExpPattern(state);

		    // Create Literal#value property value.
		    var value = null;
		    try {
		      value = new RegExp(pattern, flags);
		    } catch (e) {
		      // ESTree requires null if it failed to instantiate RegExp object.
		      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
		    }

		    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
		  };

		  // Read an integer in the given radix. Return null if zero digits
		  // were read, the integer value otherwise. When `len` is given, this
		  // will return `null` unless the integer has exactly `len` digits.

		  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
		    // `len` is used for character escape sequences. In that case, disallow separators.
		    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

		    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
		    // and isn't fraction part nor exponent part. In that case, if the first digit
		    // is zero then disallow separators.
		    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

		    var start = this.pos, total = 0, lastCode = 0;
		    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
		      var code = this.input.charCodeAt(this.pos), val = (void 0);

		      if (allowSeparators && code === 95) {
		        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
		        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
		        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
		        lastCode = code;
		        continue
		      }

		      if (code >= 97) { val = code - 97 + 10; } // a
		      else if (code >= 65) { val = code - 65 + 10; } // A
		      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
		      else { val = Infinity; }
		      if (val >= radix) { break }
		      lastCode = code;
		      total = total * radix + val;
		    }

		    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
		    if (this.pos === start || len != null && this.pos - start !== len) { return null }

		    return total
		  };

		  function stringToNumber(str, isLegacyOctalNumericLiteral) {
		    if (isLegacyOctalNumericLiteral) {
		      return parseInt(str, 8)
		    }

		    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
		    return parseFloat(str.replace(/_/g, ""))
		  }

		  function stringToBigInt(str) {
		    if (typeof BigInt !== "function") {
		      return null
		    }

		    // `BigInt(value)` throws syntax error if the string contains numeric separators.
		    return BigInt(str.replace(/_/g, ""))
		  }

		  pp.readRadixNumber = function(radix) {
		    var start = this.pos;
		    this.pos += 2; // 0x
		    var val = this.readInt(radix);
		    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
		    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		      val = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		    return this.finishToken(types$1.num, val)
		  };

		  // Read an integer, octal integer, or floating-point number.

		  pp.readNumber = function(startsWithDot) {
		    var start = this.pos;
		    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
		    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
		    if (octal && this.strict) { this.raise(start, "Invalid number"); }
		    var next = this.input.charCodeAt(this.pos);
		    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		      ++this.pos;
		      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
		      return this.finishToken(types$1.num, val$1)
		    }
		    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
		    if (next === 46 && !octal) { // '.'
		      ++this.pos;
		      this.readInt(10);
		      next = this.input.charCodeAt(this.pos);
		    }
		    if ((next === 69 || next === 101) && !octal) { // 'eE'
		      next = this.input.charCodeAt(++this.pos);
		      if (next === 43 || next === 45) { ++this.pos; } // '+-'
		      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
		    }
		    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

		    var val = stringToNumber(this.input.slice(start, this.pos), octal);
		    return this.finishToken(types$1.num, val)
		  };

		  // Read a string value, interpreting backslash-escapes.

		  pp.readCodePoint = function() {
		    var ch = this.input.charCodeAt(this.pos), code;

		    if (ch === 123) { // '{'
		      if (this.options.ecmaVersion < 6) { this.unexpected(); }
		      var codePos = ++this.pos;
		      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		      ++this.pos;
		      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
		    } else {
		      code = this.readHexChar(4);
		    }
		    return code
		  };

		  pp.readString = function(quote) {
		    var out = "", chunkStart = ++this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === quote) { break }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(false);
		        chunkStart = this.pos;
		      } else if (ch === 0x2028 || ch === 0x2029) {
		        if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		        if (this.options.locations) {
		          this.curLine++;
		          this.lineStart = this.pos;
		        }
		      } else {
		        if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
		        ++this.pos;
		      }
		    }
		    out += this.input.slice(chunkStart, this.pos++);
		    return this.finishToken(types$1.string, out)
		  };

		  // Reads template string tokens.

		  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

		  pp.tryReadTemplateToken = function() {
		    this.inTemplateElement = true;
		    try {
		      this.readTmplToken();
		    } catch (err) {
		      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
		        this.readInvalidTemplateToken();
		      } else {
		        throw err
		      }
		    }

		    this.inTemplateElement = false;
		  };

		  pp.invalidStringToken = function(position, message) {
		    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
		      throw INVALID_TEMPLATE_ESCAPE_ERROR
		    } else {
		      this.raise(position, message);
		    }
		  };

		  pp.readTmplToken = function() {
		    var out = "", chunkStart = this.pos;
		    for (;;) {
		      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
		      var ch = this.input.charCodeAt(this.pos);
		      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
		        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
		          if (ch === 36) {
		            this.pos += 2;
		            return this.finishToken(types$1.dollarBraceL)
		          } else {
		            ++this.pos;
		            return this.finishToken(types$1.backQuote)
		          }
		        }
		        out += this.input.slice(chunkStart, this.pos);
		        return this.finishToken(types$1.template, out)
		      }
		      if (ch === 92) { // '\'
		        out += this.input.slice(chunkStart, this.pos);
		        out += this.readEscapedChar(true);
		        chunkStart = this.pos;
		      } else if (isNewLine(ch)) {
		        out += this.input.slice(chunkStart, this.pos);
		        ++this.pos;
		        switch (ch) {
		        case 13:
		          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
		        case 10:
		          out += "\n";
		          break
		        default:
		          out += String.fromCharCode(ch);
		          break
		        }
		        if (this.options.locations) {
		          ++this.curLine;
		          this.lineStart = this.pos;
		        }
		        chunkStart = this.pos;
		      } else {
		        ++this.pos;
		      }
		    }
		  };

		  // Reads a template token to search for the end, without validating any escape sequences
		  pp.readInvalidTemplateToken = function() {
		    for (; this.pos < this.input.length; this.pos++) {
		      switch (this.input[this.pos]) {
		      case "\\":
		        ++this.pos;
		        break

		      case "$":
		        if (this.input[this.pos + 1] !== "{") {
		          break
		        }

		      // falls through
		      case "`":
		        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

		      // no default
		      }
		    }
		    this.raise(this.start, "Unterminated template");
		  };

		  // Used to read escaped characters

		  pp.readEscapedChar = function(inTemplate) {
		    var ch = this.input.charCodeAt(++this.pos);
		    ++this.pos;
		    switch (ch) {
		    case 110: return "\n" // 'n' -> '\n'
		    case 114: return "\r" // 'r' -> '\r'
		    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
		    case 117: return codePointToString(this.readCodePoint()) // 'u'
		    case 116: return "\t" // 't' -> '\t'
		    case 98: return "\b" // 'b' -> '\b'
		    case 118: return "\u000b" // 'v' -> '\u000b'
		    case 102: return "\f" // 'f' -> '\f'
		    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
		    case 10: // ' \n'
		      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
		      return ""
		    case 56:
		    case 57:
		      if (this.strict) {
		        this.invalidStringToken(
		          this.pos - 1,
		          "Invalid escape sequence"
		        );
		      }
		      if (inTemplate) {
		        var codePos = this.pos - 1;

		        this.invalidStringToken(
		          codePos,
		          "Invalid escape sequence in template string"
		        );
		      }
		    default:
		      if (ch >= 48 && ch <= 55) {
		        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
		        var octal = parseInt(octalStr, 8);
		        if (octal > 255) {
		          octalStr = octalStr.slice(0, -1);
		          octal = parseInt(octalStr, 8);
		        }
		        this.pos += octalStr.length - 1;
		        ch = this.input.charCodeAt(this.pos);
		        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
		          this.invalidStringToken(
		            this.pos - 1 - octalStr.length,
		            inTemplate
		              ? "Octal literal in template string"
		              : "Octal literal in strict mode"
		          );
		        }
		        return String.fromCharCode(octal)
		      }
		      if (isNewLine(ch)) {
		        // Unicode new line characters after \ get removed from output in both
		        // template literals and strings
		        return ""
		      }
		      return String.fromCharCode(ch)
		    }
		  };

		  // Used to read character escape sequences ('\x', '\u', '\U').

		  pp.readHexChar = function(len) {
		    var codePos = this.pos;
		    var n = this.readInt(16, len);
		    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
		    return n
		  };

		  // Read an identifier, and return it as a string. Sets `this.containsEsc`
		  // to whether the word contained a '\u' escape.
		  //
		  // Incrementally adds only escaped chars, adding other chunks as-is
		  // as a micro-optimization.

		  pp.readWord1 = function() {
		    this.containsEsc = false;
		    var word = "", first = true, chunkStart = this.pos;
		    var astral = this.options.ecmaVersion >= 6;
		    while (this.pos < this.input.length) {
		      var ch = this.fullCharCodeAtPos();
		      if (isIdentifierChar(ch, astral)) {
		        this.pos += ch <= 0xffff ? 1 : 2;
		      } else if (ch === 92) { // "\"
		        this.containsEsc = true;
		        word += this.input.slice(chunkStart, this.pos);
		        var escStart = this.pos;
		        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
		          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
		        ++this.pos;
		        var esc = this.readCodePoint();
		        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
		          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
		        word += codePointToString(esc);
		        chunkStart = this.pos;
		      } else {
		        break
		      }
		      first = false;
		    }
		    return word + this.input.slice(chunkStart, this.pos)
		  };

		  // Read an identifier or keyword token. Will check for reserved
		  // words when necessary.

		  pp.readWord = function() {
		    var word = this.readWord1();
		    var type = types$1.name;
		    if (this.keywords.test(word)) {
		      type = keywords[word];
		    }
		    return this.finishToken(type, word)
		  };

		  // Acorn is a tiny, fast JavaScript parser written in JavaScript.
		  //
		  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
		  // various contributors and released under an MIT license.
		  //
		  // Git repositories for Acorn are available at
		  //
		  //     http://marijnhaverbeke.nl/git/acorn
		  //     https://github.com/acornjs/acorn.git
		  //
		  // Please use the [github bug tracker][ghbt] to report issues.
		  //
		  // [ghbt]: https://github.com/acornjs/acorn/issues
		  //
		  // [walk]: util/walk.js


		  var version = "8.10.0";

		  Parser.acorn = {
		    Parser: Parser,
		    version: version,
		    defaultOptions: defaultOptions,
		    Position: Position,
		    SourceLocation: SourceLocation,
		    getLineInfo: getLineInfo,
		    Node: Node,
		    TokenType: TokenType,
		    tokTypes: types$1,
		    keywordTypes: keywords,
		    TokContext: TokContext,
		    tokContexts: types,
		    isIdentifierChar: isIdentifierChar,
		    isIdentifierStart: isIdentifierStart,
		    Token: Token,
		    isNewLine: isNewLine,
		    lineBreak: lineBreak,
		    lineBreakG: lineBreakG,
		    nonASCIIwhitespace: nonASCIIwhitespace
		  };

		  // The main exported interface (under `self.acorn` when in the
		  // browser) is a `parse` function that takes a code string and
		  // returns an abstract syntax tree as specified by [Mozilla parser
		  // API][api].
		  //
		  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

		  function parse(input, options) {
		    return Parser.parse(input, options)
		  }

		  // This function tries to parse a single expression at a given
		  // offset in a string. Useful for parsing mixed-language formats
		  // that embed JavaScript expressions.

		  function parseExpressionAt(input, pos, options) {
		    return Parser.parseExpressionAt(input, pos, options)
		  }

		  // Acorn is organized as a tokenizer and a recursive-descent parser.
		  // The `tokenizer` export provides an interface to the tokenizer.

		  function tokenizer(input, options) {
		    return Parser.tokenizer(input, options)
		  }

		  exports.Node = Node;
		  exports.Parser = Parser;
		  exports.Position = Position;
		  exports.SourceLocation = SourceLocation;
		  exports.TokContext = TokContext;
		  exports.Token = Token;
		  exports.TokenType = TokenType;
		  exports.defaultOptions = defaultOptions;
		  exports.getLineInfo = getLineInfo;
		  exports.isIdentifierChar = isIdentifierChar;
		  exports.isIdentifierStart = isIdentifierStart;
		  exports.isNewLine = isNewLine;
		  exports.keywordTypes = keywords;
		  exports.lineBreak = lineBreak;
		  exports.lineBreakG = lineBreakG;
		  exports.nonASCIIwhitespace = nonASCIIwhitespace;
		  exports.parse = parse;
		  exports.parseExpressionAt = parseExpressionAt;
		  exports.tokContexts = types;
		  exports.tokTypes = types$1;
		  exports.tokenizer = tokenizer;
		  exports.version = version;

		})); 
	} (acorn, acorn.exports));
	return acorn.exports;
}

var hasRequiredBundle_min;

function requireBundle_min () {
	if (hasRequiredBundle_min) return bundle_min.exports;
	hasRequiredBundle_min = 1;
	(function (module, exports) {
		(function (global, factory) {
		factory(exports, requireSourceMap_umd()) ;
		}(commonjsGlobal, (function (exports, sourceMap) {
		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function characters(str) {
		    return str.split("");
		}

		function member(name, array) {
		    return array.includes(name);
		}

		class DefaultsError extends Error {
		    constructor(msg, defs) {
		        super();

		        this.name = "DefaultsError";
		        this.message = msg;
		        this.defs = defs;
		    }
		}

		function defaults(args, defs, croak) {
		    if (args === true) {
		        args = {};
		    } else if (args != null && typeof args === "object") {
		        args = {...args};
		    }

		    const ret = args || {};

		    if (croak) for (const i in ret) if (HOP(ret, i) && !HOP(defs, i)) {
		        throw new DefaultsError("`" + i + "` is not a supported option", defs);
		    }

		    for (const i in defs) if (HOP(defs, i)) {
		        if (!args || !HOP(args, i)) {
		            ret[i] = defs[i];
		        } else if (i === "ecma") {
		            let ecma = args[i] | 0;
		            if (ecma > 5 && ecma < 2015) ecma += 2009;
		            ret[i] = ecma;
		        } else {
		            ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
		        }
		    }

		    return ret;
		}

		function noop() {}
		function return_false() { return false; }
		function return_true() { return true; }
		function return_this() { return this; }
		function return_null() { return null; }

		var MAP = (function() {
		    function MAP(a, tw, allow_splicing = true) {
		        const new_a = [];

		        for (let i = 0; i < a.length; ++i) {
		            let item = a[i];
		            let ret = item.transform(tw, allow_splicing);

		            if (ret instanceof AST_Node) {
		                new_a.push(ret);
		            } else if (ret instanceof Splice) {
		                new_a.push(...ret.v);
		            }
		        }

		        return new_a;
		    }

		    MAP.splice = function(val) { return new Splice(val); };
		    MAP.skip = {};
		    function Splice(val) { this.v = val; }
		    return MAP;
		})();

		function make_node(ctor, orig, props) {
		    if (!props) props = {};
		    if (orig) {
		        if (!props.start) props.start = orig.start;
		        if (!props.end) props.end = orig.end;
		    }
		    return new ctor(props);
		}

		function push_uniq(array, el) {
		    if (!array.includes(el))
		        array.push(el);
		}

		function string_template(text, props) {
		    return text.replace(/{(.+?)}/g, function(str, p) {
		        return props && props[p];
		    });
		}

		function remove(array, el) {
		    for (var i = array.length; --i >= 0;) {
		        if (array[i] === el) array.splice(i, 1);
		    }
		}

		function mergeSort(array, cmp) {
		    if (array.length < 2) return array.slice();
		    function merge(a, b) {
		        var r = [], ai = 0, bi = 0, i = 0;
		        while (ai < a.length && bi < b.length) {
		            cmp(a[ai], b[bi]) <= 0
		                ? r[i++] = a[ai++]
		                : r[i++] = b[bi++];
		        }
		        if (ai < a.length) r.push.apply(r, a.slice(ai));
		        if (bi < b.length) r.push.apply(r, b.slice(bi));
		        return r;
		    }
		    function _ms(a) {
		        if (a.length <= 1)
		            return a;
		        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
		        left = _ms(left);
		        right = _ms(right);
		        return merge(left, right);
		    }
		    return _ms(array);
		}

		function makePredicate(words) {
		    if (!Array.isArray(words)) words = words.split(" ");

		    return new Set(words.sort());
		}

		function map_add(map, key, value) {
		    if (map.has(key)) {
		        map.get(key).push(value);
		    } else {
		        map.set(key, [ value ]);
		    }
		}

		function map_from_object(obj) {
		    var map = new Map();
		    for (var key in obj) {
		        if (HOP(obj, key) && key.charAt(0) === "$") {
		            map.set(key.substr(1), obj[key]);
		        }
		    }
		    return map;
		}

		function map_to_object(map) {
		    var obj = Object.create(null);
		    map.forEach(function (value, key) {
		        obj["$" + key] = value;
		    });
		    return obj;
		}

		function HOP(obj, prop) {
		    return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		function keep_name(keep_setting, name) {
		    return keep_setting === true
		        || (keep_setting instanceof RegExp && keep_setting.test(name));
		}

		var lineTerminatorEscape = {
		    "\0": "0",
		    "\n": "n",
		    "\r": "r",
		    "\u2028": "u2028",
		    "\u2029": "u2029",
		};
		function regexp_source_fix(source) {
		    // V8 does not escape line terminators in regexp patterns in node 12
		    // We'll also remove literal \0
		    return source.replace(/[\0\n\r\u2028\u2029]/g, function (match, offset) {
		        var escaped = source[offset - 1] == "\\"
		            && (source[offset - 2] != "\\"
		            || /(?:^|[^\\])(?:\\{2})*$/.test(source.slice(0, offset - 1)));
		        return (escaped ? "" : "\\") + lineTerminatorEscape[match];
		    });
		}

		// Subset of regexps that is not going to cause regexp based DDOS
		// https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS
		const re_safe_regexp = /^[\\/|\0\s\w^$.[\]()]*$/;

		/** Check if the regexp is safe for Terser to create without risking a RegExp DOS */
		const regexp_is_safe = (source) => re_safe_regexp.test(source);

		const all_flags = "dgimsuyv";
		function sort_regexp_flags(flags) {
		    const existing_flags = new Set(flags.split(""));
		    let out = "";
		    for (const flag of all_flags) {
		        if (existing_flags.has(flag)) {
		            out += flag;
		            existing_flags.delete(flag);
		        }
		    }
		    if (existing_flags.size) {
		        // Flags Terser doesn't know about
		        existing_flags.forEach(flag => { out += flag; });
		    }
		    return out;
		}

		function has_annotation(node, annotation) {
		    return node._annotations & annotation;
		}

		function set_annotation(node, annotation) {
		    node._annotations |= annotation;
		}

		function clear_annotation(node, annotation) {
		    node._annotations &= ~annotation;
		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
		    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		var LATEST_RAW = "";  // Only used for numbers and template strings
		var TEMPLATE_RAWS = new Map();  // Raw template strings

		var KEYWORDS = "break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with";
		var KEYWORDS_ATOM = "false null true";
		var RESERVED_WORDS = "enum import super this " + KEYWORDS_ATOM + " " + KEYWORDS;
		var ALL_RESERVED_WORDS = "implements interface package private protected public static " + RESERVED_WORDS;
		var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case yield await";

		KEYWORDS = makePredicate(KEYWORDS);
		RESERVED_WORDS = makePredicate(RESERVED_WORDS);
		KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
		KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
		ALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);

		var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));

		var RE_NUM_LITERAL = /[0-9a-f]/i;
		var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
		var RE_OCT_NUMBER = /^0[0-7]+$/;
		var RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;
		var RE_BIN_NUMBER = /^0b[01]+$/i;
		var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
		var RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;

		var OPERATORS = makePredicate([
		    "in",
		    "instanceof",
		    "typeof",
		    "new",
		    "void",
		    "delete",
		    "++",
		    "--",
		    "+",
		    "-",
		    "!",
		    "~",
		    "&",
		    "|",
		    "^",
		    "*",
		    "**",
		    "/",
		    "%",
		    ">>",
		    "<<",
		    ">>>",
		    "<",
		    ">",
		    "<=",
		    ">=",
		    "==",
		    "===",
		    "!=",
		    "!==",
		    "?",
		    "=",
		    "+=",
		    "-=",
		    "||=",
		    "&&=",
		    "??=",
		    "/=",
		    "*=",
		    "**=",
		    "%=",
		    ">>=",
		    "<<=",
		    ">>>=",
		    "|=",
		    "^=",
		    "&=",
		    "&&",
		    "??",
		    "||",
		]);

		var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\uFEFF"));

		var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));

		var PUNC_AFTER_EXPRESSION = makePredicate(characters(";]),:"));

		var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));

		var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));

		/* -----[ Tokenizer ]----- */

		// surrogate safe regexps adapted from https://github.com/mathiasbynens/unicode-8.0.0/tree/89b412d8a71ecca9ed593d9e9fa073ab64acfebe/Binary_Property
		var UNICODE = {
		    ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
		    ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/,
		};

		try {
		    UNICODE = {
		        // https://262.ecma-international.org/13.0/#prod-IdentifierStartChar
		        // $, _, ID_Start
		        ID_Start: new RegExp("[_$\\p{ID_Start}]", "u"),
		        // https://262.ecma-international.org/13.0/#prod-IdentifierPartChar
		        // $, zero-width-joiner, zero-width-non-joiner, ID_Continue
		        ID_Continue: new RegExp("[$\\u200C\\u200D\\p{ID_Continue}]+", "u"),
		    };
		} catch(e) {
		    // Could not use modern JS \p{...}. UNICODE is already defined above so let's continue
		}

		function get_full_char(str, pos) {
		    if (is_surrogate_pair_head(str.charCodeAt(pos))) {
		        if (is_surrogate_pair_tail(str.charCodeAt(pos + 1))) {
		            return str.charAt(pos) + str.charAt(pos + 1);
		        }
		    } else if (is_surrogate_pair_tail(str.charCodeAt(pos))) {
		        if (is_surrogate_pair_head(str.charCodeAt(pos - 1))) {
		            return str.charAt(pos - 1) + str.charAt(pos);
		        }
		    }
		    return str.charAt(pos);
		}

		function get_full_char_code(str, pos) {
		    // https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
		    if (is_surrogate_pair_head(str.charCodeAt(pos))) {
		        return 0x10000 + (str.charCodeAt(pos) - 0xd800 << 10) + str.charCodeAt(pos + 1) - 0xdc00;
		    }
		    return str.charCodeAt(pos);
		}

		function get_full_char_length(str) {
		    var surrogates = 0;

		    for (var i = 0; i < str.length; i++) {
		        if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
		            surrogates++;
		            i++;
		        }
		    }

		    return str.length - surrogates;
		}

		function from_char_code(code) {
		    // Based on https://github.com/mathiasbynens/String.fromCodePoint/blob/master/fromcodepoint.js
		    if (code > 0xFFFF) {
		        code -= 0x10000;
		        return (String.fromCharCode((code >> 10) + 0xD800) +
		            String.fromCharCode((code % 0x400) + 0xDC00));
		    }
		    return String.fromCharCode(code);
		}

		function is_surrogate_pair_head(code) {
		    return code >= 0xd800 && code <= 0xdbff;
		}

		function is_surrogate_pair_tail(code) {
		    return code >= 0xdc00 && code <= 0xdfff;
		}

		function is_digit(code) {
		    return code >= 48 && code <= 57;
		}

		function is_identifier_start(ch) {
		    return UNICODE.ID_Start.test(ch);
		}

		function is_identifier_char(ch) {
		    return UNICODE.ID_Continue.test(ch);
		}

		const BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;

		function is_basic_identifier_string(str) {
		    return BASIC_IDENT.test(str);
		}

		function is_identifier_string(str, allow_surrogates) {
		    if (BASIC_IDENT.test(str)) {
		        return true;
		    }
		    if (!allow_surrogates && /[\ud800-\udfff]/.test(str)) {
		        return false;
		    }
		    var match = UNICODE.ID_Start.exec(str);
		    if (!match || match.index !== 0) {
		        return false;
		    }

		    str = str.slice(match[0].length);
		    if (!str) {
		        return true;
		    }

		    match = UNICODE.ID_Continue.exec(str);
		    return !!match && match[0].length === str.length;
		}

		function parse_js_number(num, allow_e = true) {
		    if (!allow_e && num.includes("e")) {
		        return NaN;
		    }
		    if (RE_HEX_NUMBER.test(num)) {
		        return parseInt(num.substr(2), 16);
		    } else if (RE_OCT_NUMBER.test(num)) {
		        return parseInt(num.substr(1), 8);
		    } else if (RE_ES6_OCT_NUMBER.test(num)) {
		        return parseInt(num.substr(2), 8);
		    } else if (RE_BIN_NUMBER.test(num)) {
		        return parseInt(num.substr(2), 2);
		    } else if (RE_DEC_NUMBER.test(num)) {
		        return parseFloat(num);
		    } else {
		        var val = parseFloat(num);
		        if (val == num) return val;
		    }
		}

		class JS_Parse_Error extends Error {
		    constructor(message, filename, line, col, pos) {
		        super();

		        this.name = "SyntaxError";
		        this.message = message;
		        this.filename = filename;
		        this.line = line;
		        this.col = col;
		        this.pos = pos;
		    }
		}

		function js_error(message, filename, line, col, pos) {
		    throw new JS_Parse_Error(message, filename, line, col, pos);
		}

		function is_token(token, type, val) {
		    return token.type == type && (val == null || token.value == val);
		}

		var EX_EOF = {};

		function tokenizer($TEXT, filename, html5_comments, shebang) {
		    var S = {
		        text            : $TEXT,
		        filename        : filename,
		        pos             : 0,
		        tokpos          : 0,
		        line            : 1,
		        tokline         : 0,
		        col             : 0,
		        tokcol          : 0,
		        newline_before  : false,
		        regex_allowed   : false,
		        brace_counter   : 0,
		        template_braces : [],
		        comments_before : [],
		        directives      : {},
		        directive_stack : []
		    };

		    function peek() { return get_full_char(S.text, S.pos); }

		    // Used because parsing ?. involves a lookahead for a digit
		    function is_option_chain_op() {
		        const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;
		        if (!must_be_dot) return false;

		        const cannot_be_digit = S.text.charCodeAt(S.pos + 2);
		        return cannot_be_digit < 48 || cannot_be_digit > 57;
		    }

		    function next(signal_eof, in_string) {
		        var ch = get_full_char(S.text, S.pos++);
		        if (signal_eof && !ch)
		            throw EX_EOF;
		        if (NEWLINE_CHARS.has(ch)) {
		            S.newline_before = S.newline_before || !in_string;
		            ++S.line;
		            S.col = 0;
		            if (ch == "\r" && peek() == "\n") {
		                // treat a \r\n sequence as a single \n
		                ++S.pos;
		                ch = "\n";
		            }
		        } else {
		            if (ch.length > 1) {
		                ++S.pos;
		                ++S.col;
		            }
		            ++S.col;
		        }
		        return ch;
		    }

		    function forward(i) {
		        while (i--) next();
		    }

		    function looking_at(str) {
		        return S.text.substr(S.pos, str.length) == str;
		    }

		    function find_eol() {
		        var text = S.text;
		        for (var i = S.pos, n = S.text.length; i < n; ++i) {
		            var ch = text[i];
		            if (NEWLINE_CHARS.has(ch))
		                return i;
		        }
		        return -1;
		    }

		    function find(what, signal_eof) {
		        var pos = S.text.indexOf(what, S.pos);
		        if (signal_eof && pos == -1) throw EX_EOF;
		        return pos;
		    }

		    function start_token() {
		        S.tokline = S.line;
		        S.tokcol = S.col;
		        S.tokpos = S.pos;
		    }

		    var prev_was_dot = false;
		    var previous_token = null;
		    function token(type, value, is_comment) {
		        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX.has(value)) ||
		                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION.has(value)) ||
		                           (type == "punc" && PUNC_BEFORE_EXPRESSION.has(value))) ||
		                           (type == "arrow");
		        if (type == "punc" && (value == "." || value == "?.")) {
		            prev_was_dot = true;
		        } else if (!is_comment) {
		            prev_was_dot = false;
		        }
		        const line     = S.tokline;
		        const col      = S.tokcol;
		        const pos      = S.tokpos;
		        const nlb      = S.newline_before;
		        const file     = filename;
		        let comments_before = [];
		        let comments_after  = [];

		        if (!is_comment) {
		            comments_before = S.comments_before;
		            comments_after = S.comments_before = [];
		        }
		        S.newline_before = false;
		        const tok = new AST_Token(type, value, line, col, pos, nlb, comments_before, comments_after, file);

		        if (!is_comment) previous_token = tok;
		        return tok;
		    }

		    function skip_whitespace() {
		        while (WHITESPACE_CHARS.has(peek()))
		            next();
		    }

		    function read_while(pred) {
		        var ret = "", ch, i = 0;
		        while ((ch = peek()) && pred(ch, i++))
		            ret += next();
		        return ret;
		    }

		    function parse_error(err) {
		        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
		    }

		    function read_num(prefix) {
		        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".", is_big_int = false, numeric_separator = false;
		        var num = read_while(function(ch, i) {
		            if (is_big_int) return false;

		            var code = ch.charCodeAt(0);
		            switch (code) {
		              case 95: // _
		                return (numeric_separator = true);
		              case 98: case 66: // bB
		                return (has_x = true); // Can occur in hex sequence, don't return false yet
		              case 111: case 79: // oO
		              case 120: case 88: // xX
		                return has_x ? false : (has_x = true);
		              case 101: case 69: // eE
		                return has_x ? true : has_e ? false : (has_e = after_e = true);
		              case 45: // -
		                return after_e || (i == 0 && !prefix);
		              case 43: // +
		                return after_e;
		              case (after_e = false, 46): // .
		                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
		            }

		            if (ch === "n") {
		                is_big_int = true;

		                return true;
		            }

		            return RE_NUM_LITERAL.test(ch);
		        });
		        if (prefix) num = prefix + num;

		        LATEST_RAW = num;

		        if (RE_OCT_NUMBER.test(num) && next_token.has_directive("use strict")) {
		            parse_error("Legacy octal literals are not allowed in strict mode");
		        }
		        if (numeric_separator) {
		            if (num.endsWith("_")) {
		                parse_error("Numeric separators are not allowed at the end of numeric literals");
		            } else if (num.includes("__")) {
		                parse_error("Only one underscore is allowed as numeric separator");
		            }
		            num = num.replace(/_/g, "");
		        }
		        if (num.endsWith("n")) {
		            const without_n = num.slice(0, -1);
		            const allow_e = RE_HEX_NUMBER.test(without_n);
		            const valid = parse_js_number(without_n, allow_e);
		            if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid))
		                return token("big_int", without_n);
		            parse_error("Invalid or unexpected token");
		        }
		        var valid = parse_js_number(num);
		        if (!isNaN(valid)) {
		            return token("num", valid);
		        } else {
		            parse_error("Invalid syntax: " + num);
		        }
		    }

		    function is_octal(ch) {
		        return ch >= "0" && ch <= "7";
		    }

		    function read_escaped_char(in_string, strict_hex, template_string) {
		        var ch = next(true, in_string);
		        switch (ch.charCodeAt(0)) {
		          case 110 : return "\n";
		          case 114 : return "\r";
		          case 116 : return "\t";
		          case 98  : return "\b";
		          case 118 : return "\u000b"; // \v
		          case 102 : return "\f";
		          case 120 : return String.fromCharCode(hex_bytes(2, strict_hex)); // \x
		          case 117 : // \u
		            if (peek() == "{") {
		                next(true);
		                if (peek() === "}")
		                    parse_error("Expecting hex-character between {}");
		                while (peek() == "0") next(true); // No significance
		                var result, length = find("}", true) - S.pos;
		                // Avoid 32 bit integer overflow (1 << 32 === 1)
		                // We know first character isn't 0 and thus out of range anyway
		                if (length > 6 || (result = hex_bytes(length, strict_hex)) > 0x10FFFF) {
		                    parse_error("Unicode reference out of bounds");
		                }
		                next(true);
		                return from_char_code(result);
		            }
		            return String.fromCharCode(hex_bytes(4, strict_hex));
		          case 10  : return ""; // newline
		          case 13  :            // \r
		            if (peek() == "\n") { // DOS newline
		                next(true, in_string);
		                return "";
		            }
		        }
		        if (is_octal(ch)) {
		            if (template_string && strict_hex) {
		                const represents_null_character = ch === "0" && !is_octal(peek());
		                if (!represents_null_character) {
		                    parse_error("Octal escape sequences are not allowed in template strings");
		                }
		            }
		            return read_octal_escape_sequence(ch, strict_hex);
		        }
		        return ch;
		    }

		    function read_octal_escape_sequence(ch, strict_octal) {
		        // Read
		        var p = peek();
		        if (p >= "0" && p <= "7") {
		            ch += next(true);
		            if (ch[0] <= "3" && (p = peek()) >= "0" && p <= "7")
		                ch += next(true);
		        }

		        // Parse
		        if (ch === "0") return "\0";
		        if (ch.length > 0 && next_token.has_directive("use strict") && strict_octal)
		            parse_error("Legacy octal escape sequences are not allowed in strict mode");
		        return String.fromCharCode(parseInt(ch, 8));
		    }

		    function hex_bytes(n, strict_hex) {
		        var num = 0;
		        for (; n > 0; --n) {
		            if (!strict_hex && isNaN(parseInt(peek(), 16))) {
		                return parseInt(num, 16) || "";
		            }
		            var digit = next(true);
		            if (isNaN(parseInt(digit, 16)))
		                parse_error("Invalid hex-character pattern in string");
		            num += digit;
		        }
		        return parseInt(num, 16);
		    }

		    var read_string = with_eof_error("Unterminated string constant", function() {
		        const start_pos = S.pos;
		        var quote = next(), ret = [];
		        for (;;) {
		            var ch = next(true, true);
		            if (ch == "\\") ch = read_escaped_char(true, true);
		            else if (ch == "\r" || ch == "\n") parse_error("Unterminated string constant");
		            else if (ch == quote) break;
		            ret.push(ch);
		        }
		        var tok = token("string", ret.join(""));
		        LATEST_RAW = S.text.slice(start_pos, S.pos);
		        tok.quote = quote;
		        return tok;
		    });

		    var read_template_characters = with_eof_error("Unterminated template", function(begin) {
		        if (begin) {
		            S.template_braces.push(S.brace_counter);
		        }
		        var content = "", raw = "", ch, tok;
		        next(true, true);
		        while ((ch = next(true, true)) != "`") {
		            if (ch == "\r") {
		                if (peek() == "\n") ++S.pos;
		                ch = "\n";
		            } else if (ch == "$" && peek() == "{") {
		                next(true, true);
		                S.brace_counter++;
		                tok = token(begin ? "template_head" : "template_substitution", content);
		                TEMPLATE_RAWS.set(tok, raw);
		                tok.template_end = false;
		                return tok;
		            }

		            raw += ch;
		            if (ch == "\\") {
		                var tmp = S.pos;
		                var prev_is_tag = previous_token && (previous_token.type === "name" || previous_token.type === "punc" && (previous_token.value === ")" || previous_token.value === "]"));
		                ch = read_escaped_char(true, !prev_is_tag, true);
		                raw += S.text.substr(tmp, S.pos - tmp);
		            }

		            content += ch;
		        }
		        S.template_braces.pop();
		        tok = token(begin ? "template_head" : "template_substitution", content);
		        TEMPLATE_RAWS.set(tok, raw);
		        tok.template_end = true;
		        return tok;
		    });

		    function skip_line_comment(type) {
		        var regex_allowed = S.regex_allowed;
		        var i = find_eol(), ret;
		        if (i == -1) {
		            ret = S.text.substr(S.pos);
		            S.pos = S.text.length;
		        } else {
		            ret = S.text.substring(S.pos, i);
		            S.pos = i;
		        }
		        S.col = S.tokcol + (S.pos - S.tokpos);
		        S.comments_before.push(token(type, ret, true));
		        S.regex_allowed = regex_allowed;
		        return next_token;
		    }

		    var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
		        var regex_allowed = S.regex_allowed;
		        var i = find("*/", true);
		        var text = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, "\n");
		        // update stream position
		        forward(get_full_char_length(text) /* text length doesn't count \r\n as 2 char while S.pos - i does */ + 2);
		        S.comments_before.push(token("comment2", text, true));
		        S.newline_before = S.newline_before || text.includes("\n");
		        S.regex_allowed = regex_allowed;
		        return next_token;
		    });

		    var read_name = with_eof_error("Unterminated identifier name", function() {
		        var name = [], ch, escaped = false;
		        var read_escaped_identifier_char = function() {
		            escaped = true;
		            next();
		            if (peek() !== "u") {
		                parse_error("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}");
		            }
		            return read_escaped_char(false, true);
		        };

		        // Read first character (ID_Start)
		        if ((ch = peek()) === "\\") {
		            ch = read_escaped_identifier_char();
		            if (!is_identifier_start(ch)) {
		                parse_error("First identifier char is an invalid identifier char");
		            }
		        } else if (is_identifier_start(ch)) {
		            next();
		        } else {
		            return "";
		        }

		        name.push(ch);

		        // Read ID_Continue
		        while ((ch = peek()) != null) {
		            if ((ch = peek()) === "\\") {
		                ch = read_escaped_identifier_char();
		                if (!is_identifier_char(ch)) {
		                    parse_error("Invalid escaped identifier char");
		                }
		            } else {
		                if (!is_identifier_char(ch)) {
		                    break;
		                }
		                next();
		            }
		            name.push(ch);
		        }
		        const name_str = name.join("");
		        if (RESERVED_WORDS.has(name_str) && escaped) {
		            parse_error("Escaped characters are not allowed in keywords");
		        }
		        return name_str;
		    });

		    var read_regexp = with_eof_error("Unterminated regular expression", function(source) {
		        var prev_backslash = false, ch, in_class = false;
		        while ((ch = next(true))) if (NEWLINE_CHARS.has(ch)) {
		            parse_error("Unexpected line terminator");
		        } else if (prev_backslash) {
		            source += "\\" + ch;
		            prev_backslash = false;
		        } else if (ch == "[") {
		            in_class = true;
		            source += ch;
		        } else if (ch == "]" && in_class) {
		            in_class = false;
		            source += ch;
		        } else if (ch == "/" && !in_class) {
		            break;
		        } else if (ch == "\\") {
		            prev_backslash = true;
		        } else {
		            source += ch;
		        }
		        const flags = read_name();
		        return token("regexp", "/" + source + "/" + flags);
		    });

		    function read_operator(prefix) {
		        function grow(op) {
		            if (!peek()) return op;
		            var bigger = op + peek();
		            if (OPERATORS.has(bigger)) {
		                next();
		                return grow(bigger);
		            } else {
		                return op;
		            }
		        }
		        return token("operator", grow(prefix || next()));
		    }

		    function handle_slash() {
		        next();
		        switch (peek()) {
		          case "/":
		            next();
		            return skip_line_comment("comment1");
		          case "*":
		            next();
		            return skip_multiline_comment();
		        }
		        return S.regex_allowed ? read_regexp("") : read_operator("/");
		    }

		    function handle_eq_sign() {
		        next();
		        if (peek() === ">") {
		            next();
		            return token("arrow", "=>");
		        } else {
		            return read_operator("=");
		        }
		    }

		    function handle_dot() {
		        next();
		        if (is_digit(peek().charCodeAt(0))) {
		            return read_num(".");
		        }
		        if (peek() === ".") {
		            next();  // Consume second dot
		            next();  // Consume third dot
		            return token("expand", "...");
		        }

		        return token("punc", ".");
		    }

		    function read_word() {
		        var word = read_name();
		        if (prev_was_dot) return token("name", word);
		        return KEYWORDS_ATOM.has(word) ? token("atom", word)
		            : !KEYWORDS.has(word) ? token("name", word)
		            : OPERATORS.has(word) ? token("operator", word)
		            : token("keyword", word);
		    }

		    function read_private_word() {
		        next();
		        return token("privatename", read_name());
		    }

		    function with_eof_error(eof_error, cont) {
		        return function(x) {
		            try {
		                return cont(x);
		            } catch(ex) {
		                if (ex === EX_EOF) parse_error(eof_error);
		                else throw ex;
		            }
		        };
		    }

		    function next_token(force_regexp) {
		        if (force_regexp != null)
		            return read_regexp(force_regexp);
		        if (shebang && S.pos == 0 && looking_at("#!")) {
		            start_token();
		            forward(2);
		            skip_line_comment("comment5");
		        }
		        for (;;) {
		            skip_whitespace();
		            start_token();
		            if (html5_comments) {
		                if (looking_at("<!--")) {
		                    forward(4);
		                    skip_line_comment("comment3");
		                    continue;
		                }
		                if (looking_at("-->") && S.newline_before) {
		                    forward(3);
		                    skip_line_comment("comment4");
		                    continue;
		                }
		            }
		            var ch = peek();
		            if (!ch) return token("eof");
		            var code = ch.charCodeAt(0);
		            switch (code) {
		              case 34: case 39: return read_string();
		              case 46: return handle_dot();
		              case 47: {
		                  var tok = handle_slash();
		                  if (tok === next_token) continue;
		                  return tok;
		              }
		              case 61: return handle_eq_sign();
		              case 63: {
		                  if (!is_option_chain_op()) break;  // Handled below

		                  next(); // ?
		                  next(); // .

		                  return token("punc", "?.");
		              }
		              case 96: return read_template_characters(true);
		              case 123:
		                S.brace_counter++;
		                break;
		              case 125:
		                S.brace_counter--;
		                if (S.template_braces.length > 0
		                    && S.template_braces[S.template_braces.length - 1] === S.brace_counter)
		                    return read_template_characters(false);
		                break;
		            }
		            if (is_digit(code)) return read_num();
		            if (PUNC_CHARS.has(ch)) return token("punc", next());
		            if (OPERATOR_CHARS.has(ch)) return read_operator();
		            if (code == 92 || is_identifier_start(ch)) return read_word();
		            if (code == 35) return read_private_word();
		            break;
		        }
		        parse_error("Unexpected character '" + ch + "'");
		    }

		    next_token.next = next;
		    next_token.peek = peek;

		    next_token.context = function(nc) {
		        if (nc) S = nc;
		        return S;
		    };

		    next_token.add_directive = function(directive) {
		        S.directive_stack[S.directive_stack.length - 1].push(directive);

		        if (S.directives[directive] === undefined) {
		            S.directives[directive] = 1;
		        } else {
		            S.directives[directive]++;
		        }
		    };

		    next_token.push_directives_stack = function() {
		        S.directive_stack.push([]);
		    };

		    next_token.pop_directives_stack = function() {
		        var directives = S.directive_stack[S.directive_stack.length - 1];

		        for (var i = 0; i < directives.length; i++) {
		            S.directives[directives[i]]--;
		        }

		        S.directive_stack.pop();
		    };

		    next_token.has_directive = function(directive) {
		        return S.directives[directive] > 0;
		    };

		    return next_token;

		}

		/* -----[ Parser (constants) ]----- */

		var UNARY_PREFIX = makePredicate([
		    "typeof",
		    "void",
		    "delete",
		    "--",
		    "++",
		    "!",
		    "~",
		    "-",
		    "+"
		]);

		var UNARY_POSTFIX = makePredicate([ "--", "++" ]);

		var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "??=", "&&=", "||=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);

		var LOGICAL_ASSIGNMENT = makePredicate([ "??=", "&&=", "||=" ]);

		var PRECEDENCE = (function(a, ret) {
		    for (var i = 0; i < a.length; ++i) {
		        var b = a[i];
		        for (var j = 0; j < b.length; ++j) {
		            ret[b[j]] = i + 1;
		        }
		    }
		    return ret;
		})(
		    [
		        ["||"],
		        ["??"],
		        ["&&"],
		        ["|"],
		        ["^"],
		        ["&"],
		        ["==", "===", "!=", "!=="],
		        ["<", ">", "<=", ">=", "in", "instanceof"],
		        [">>", "<<", ">>>"],
		        ["+", "-"],
		        ["*", "/", "%"],
		        ["**"]
		    ],
		    {}
		);

		var ATOMIC_START_TOKEN = makePredicate([ "atom", "num", "big_int", "string", "regexp", "name"]);

		/* -----[ Parser ]----- */

		function parse($TEXT, options) {
		    // maps start tokens to count of comments found outside of their parens
		    // Example: /* I count */ ( /* I don't */ foo() )
		    // Useful because comments_before property of call with parens outside
		    // contains both comments inside and outside these parens. Used to find the
		    
		    const outer_comments_before_counts = new WeakMap();

		    options = defaults(options, {
		        bare_returns   : false,
		        ecma           : null,  // Legacy
		        expression     : false,
		        filename       : null,
		        html5_comments : true,
		        module         : false,
		        shebang        : true,
		        strict         : false,
		        toplevel       : null,
		    }, true);

		    var S = {
		        input         : (typeof $TEXT == "string"
		                         ? tokenizer($TEXT, options.filename,
		                                     options.html5_comments, options.shebang)
		                         : $TEXT),
		        token         : null,
		        prev          : null,
		        peeked        : null,
		        in_function   : 0,
		        in_async      : -1,
		        in_generator  : -1,
		        in_directives : true,
		        in_loop       : 0,
		        labels        : []
		    };

		    S.token = next();

		    function is(type, value) {
		        return is_token(S.token, type, value);
		    }

		    function peek() { return S.peeked || (S.peeked = S.input()); }

		    function next() {
		        S.prev = S.token;

		        if (!S.peeked) peek();
		        S.token = S.peeked;
		        S.peeked = null;
		        S.in_directives = S.in_directives && (
		            S.token.type == "string" || is("punc", ";")
		        );
		        return S.token;
		    }

		    function prev() {
		        return S.prev;
		    }

		    function croak(msg, line, col, pos) {
		        var ctx = S.input.context();
		        js_error(msg,
		                 ctx.filename,
		                 line != null ? line : ctx.tokline,
		                 col != null ? col : ctx.tokcol,
		                 pos != null ? pos : ctx.tokpos);
		    }

		    function token_error(token, msg) {
		        croak(msg, token.line, token.col);
		    }

		    function unexpected(token) {
		        if (token == null)
		            token = S.token;
		        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
		    }

		    function expect_token(type, val) {
		        if (is(type, val)) {
		            return next();
		        }
		        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
		    }

		    function expect(punc) { return expect_token("punc", punc); }

		    function has_newline_before(token) {
		        return token.nlb || !token.comments_before.every((comment) => !comment.nlb);
		    }

		    function can_insert_semicolon() {
		        return !options.strict
		            && (is("eof") || is("punc", "}") || has_newline_before(S.token));
		    }

		    function is_in_generator() {
		        return S.in_generator === S.in_function;
		    }

		    function is_in_async() {
		        return S.in_async === S.in_function;
		    }

		    function can_await() {
		        return (
		            S.in_async === S.in_function
		            || S.in_function === 0 && S.input.has_directive("use strict")
		        );
		    }

		    function semicolon(optional) {
		        if (is("punc", ";")) next();
		        else if (!optional && !can_insert_semicolon()) unexpected();
		    }

		    function parenthesised() {
		        expect("(");
		        var exp = expression(true);
		        expect(")");
		        return exp;
		    }

		    function embed_tokens(parser) {
		        return function _embed_tokens_wrapper(...args) {
		            const start = S.token;
		            const expr = parser(...args);
		            expr.start = start;
		            expr.end = prev();
		            return expr;
		        };
		    }

		    function handle_regexp() {
		        if (is("operator", "/") || is("operator", "/=")) {
		            S.peeked = null;
		            S.token = S.input(S.token.value.substr(1)); // force regexp
		        }
		    }

		    var statement = embed_tokens(function statement(is_export_default, is_for_body, is_if_body) {
		        handle_regexp();
		        switch (S.token.type) {
		          case "string":
		            if (S.in_directives) {
		                var token = peek();
		                if (!LATEST_RAW.includes("\\")
		                    && (is_token(token, "punc", ";")
		                        || is_token(token, "punc", "}")
		                        || has_newline_before(token)
		                        || is_token(token, "eof"))) {
		                    S.input.add_directive(S.token.value);
		                } else {
		                    S.in_directives = false;
		                }
		            }
		            var dir = S.in_directives, stat = simple_statement();
		            return dir && stat.body instanceof AST_String ? new AST_Directive(stat.body) : stat;
		          case "template_head":
		          case "num":
		          case "big_int":
		          case "regexp":
		          case "operator":
		          case "atom":
		            return simple_statement();

		          case "name":
		          case "privatename":
		            if(is("privatename") && !S.in_class)
		                croak("Private field must be used in an enclosing class");

		            if (S.token.value == "async" && is_token(peek(), "keyword", "function")) {
		                next();
		                next();
		                if (is_for_body) {
		                    croak("functions are not allowed as the body of a loop");
		                }
		                return function_(AST_Defun, false, true, is_export_default);
		            }
		            if (S.token.value == "import" && !is_token(peek(), "punc", "(") && !is_token(peek(), "punc", ".")) {
		                next();
		                var node = import_statement();
		                semicolon();
		                return node;
		            }
		            return is_token(peek(), "punc", ":")
		                ? labeled_statement()
		                : simple_statement();

		          case "punc":
		            switch (S.token.value) {
		              case "{":
		                return new AST_BlockStatement({
		                    start : S.token,
		                    body  : block_(),
		                    end   : prev()
		                });
		              case "[":
		              case "(":
		                return simple_statement();
		              case ";":
		                S.in_directives = false;
		                next();
		                return new AST_EmptyStatement();
		              default:
		                unexpected();
		            }

		          case "keyword":
		            switch (S.token.value) {
		              case "break":
		                next();
		                return break_cont(AST_Break);

		              case "continue":
		                next();
		                return break_cont(AST_Continue);

		              case "debugger":
		                next();
		                semicolon();
		                return new AST_Debugger();

		              case "do":
		                next();
		                var body = in_loop(statement);
		                expect_token("keyword", "while");
		                var condition = parenthesised();
		                semicolon(true);
		                return new AST_Do({
		                    body      : body,
		                    condition : condition
		                });

		              case "while":
		                next();
		                return new AST_While({
		                    condition : parenthesised(),
		                    body      : in_loop(function() { return statement(false, true); })
		                });

		              case "for":
		                next();
		                return for_();

		              case "class":
		                next();
		                if (is_for_body) {
		                    croak("classes are not allowed as the body of a loop");
		                }
		                if (is_if_body) {
		                    croak("classes are not allowed as the body of an if");
		                }
		                return class_(AST_DefClass, is_export_default);

		              case "function":
		                next();
		                if (is_for_body) {
		                    croak("functions are not allowed as the body of a loop");
		                }
		                return function_(AST_Defun, false, false, is_export_default);

		              case "if":
		                next();
		                return if_();

		              case "return":
		                if (S.in_function == 0 && !options.bare_returns)
		                    croak("'return' outside of function");
		                next();
		                var value = null;
		                if (is("punc", ";")) {
		                    next();
		                } else if (!can_insert_semicolon()) {
		                    value = expression(true);
		                    semicolon();
		                }
		                return new AST_Return({
		                    value: value
		                });

		              case "switch":
		                next();
		                return new AST_Switch({
		                    expression : parenthesised(),
		                    body       : in_loop(switch_body_)
		                });

		              case "throw":
		                next();
		                if (has_newline_before(S.token))
		                    croak("Illegal newline after 'throw'");
		                var value = expression(true);
		                semicolon();
		                return new AST_Throw({
		                    value: value
		                });

		              case "try":
		                next();
		                return try_();

		              case "var":
		                next();
		                var node = var_();
		                semicolon();
		                return node;

		              case "let":
		                next();
		                var node = let_();
		                semicolon();
		                return node;

		              case "const":
		                next();
		                var node = const_();
		                semicolon();
		                return node;

		              case "with":
		                if (S.input.has_directive("use strict")) {
		                    croak("Strict mode may not include a with statement");
		                }
		                next();
		                return new AST_With({
		                    expression : parenthesised(),
		                    body       : statement()
		                });

		              case "export":
		                if (!is_token(peek(), "punc", "(")) {
		                    next();
		                    var node = export_statement();
		                    if (is("punc", ";")) semicolon();
		                    return node;
		                }
		            }
		        }
		        unexpected();
		    });

		    function labeled_statement() {
		        var label = as_symbol(AST_Label);
		        if (label.name === "await" && is_in_async()) {
		            token_error(S.prev, "await cannot be used as label inside async function");
		        }
		        if (S.labels.some((l) => l.name === label.name)) {
		            // ECMA-262, 12.12: An ECMAScript program is considered
		            // syntactically incorrect if it contains a
		            // LabelledStatement that is enclosed by a
		            // LabelledStatement with the same Identifier as label.
		            croak("Label " + label.name + " defined twice");
		        }
		        expect(":");
		        S.labels.push(label);
		        var stat = statement();
		        S.labels.pop();
		        if (!(stat instanceof AST_IterationStatement)) {
		            // check for `continue` that refers to this label.
		            // those should be reported as syntax errors.
		            // https://github.com/mishoo/UglifyJS2/issues/287
		            label.references.forEach(function(ref) {
		                if (ref instanceof AST_Continue) {
		                    ref = ref.label.start;
		                    croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
		                          ref.line, ref.col, ref.pos);
		                }
		            });
		        }
		        return new AST_LabeledStatement({ body: stat, label: label });
		    }

		    function simple_statement(tmp) {
		        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
		    }

		    function break_cont(type) {
		        var label = null, ldef;
		        if (!can_insert_semicolon()) {
		            label = as_symbol(AST_LabelRef, true);
		        }
		        if (label != null) {
		            ldef = S.labels.find((l) => l.name === label.name);
		            if (!ldef)
		                croak("Undefined label " + label.name);
		            label.thedef = ldef;
		        } else if (S.in_loop == 0)
		            croak(type.TYPE + " not inside a loop or switch");
		        semicolon();
		        var stat = new type({ label: label });
		        if (ldef) ldef.references.push(stat);
		        return stat;
		    }

		    function for_() {
		        var for_await_error = "`for await` invalid in this context";
		        var await_tok = S.token;
		        if (await_tok.type == "name" && await_tok.value == "await") {
		            if (!can_await()) {
		                token_error(await_tok, for_await_error);
		            }
		            next();
		        } else {
		            await_tok = false;
		        }
		        expect("(");
		        var init = null;
		        if (!is("punc", ";")) {
		            init =
		                is("keyword", "var") ? (next(), var_(true)) :
		                is("keyword", "let") ? (next(), let_(true)) :
		                is("keyword", "const") ? (next(), const_(true)) :
		                                       expression(true, true);
		            var is_in = is("operator", "in");
		            var is_of = is("name", "of");
		            if (await_tok && !is_of) {
		                token_error(await_tok, for_await_error);
		            }
		            if (is_in || is_of) {
		                if (init instanceof AST_Definitions) {
		                    if (init.definitions.length > 1)
		                        token_error(init.start, "Only one variable declaration allowed in for..in loop");
		                } else if (!(is_assignable(init) || (init = to_destructuring(init)) instanceof AST_Destructuring)) {
		                    token_error(init.start, "Invalid left-hand side in for..in loop");
		                }
		                next();
		                if (is_in) {
		                    return for_in(init);
		                } else {
		                    return for_of(init, !!await_tok);
		                }
		            }
		        } else if (await_tok) {
		            token_error(await_tok, for_await_error);
		        }
		        return regular_for(init);
		    }

		    function regular_for(init) {
		        expect(";");
		        var test = is("punc", ";") ? null : expression(true);
		        expect(";");
		        var step = is("punc", ")") ? null : expression(true);
		        expect(")");
		        return new AST_For({
		            init      : init,
		            condition : test,
		            step      : step,
		            body      : in_loop(function() { return statement(false, true); })
		        });
		    }

		    function for_of(init, is_await) {
		        var lhs = init instanceof AST_Definitions ? init.definitions[0].name : null;
		        var obj = expression(true);
		        expect(")");
		        return new AST_ForOf({
		            await  : is_await,
		            init   : init,
		            name   : lhs,
		            object : obj,
		            body   : in_loop(function() { return statement(false, true); })
		        });
		    }

		    function for_in(init) {
		        var obj = expression(true);
		        expect(")");
		        return new AST_ForIn({
		            init   : init,
		            object : obj,
		            body   : in_loop(function() { return statement(false, true); })
		        });
		    }

		    var arrow_function = function(start, argnames, is_async) {
		        if (has_newline_before(S.token)) {
		            croak("Unexpected newline before arrow (=>)");
		        }

		        expect_token("arrow", "=>");

		        var body = _function_body(is("punc", "{"), false, is_async);

		        var end =
		            body instanceof Array && body.length ? body[body.length - 1].end :
		            body instanceof Array ? start :
		                body.end;

		        return new AST_Arrow({
		            start    : start,
		            end      : end,
		            async    : is_async,
		            argnames : argnames,
		            body     : body
		        });
		    };

		    var function_ = function(ctor, is_generator_property, is_async, is_export_default) {
		        var in_statement = ctor === AST_Defun;
		        var is_generator = is("operator", "*");
		        if (is_generator) {
		            next();
		        }

		        var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
		        if (in_statement && !name) {
		            if (is_export_default) {
		                ctor = AST_Function;
		            } else {
		                unexpected();
		            }
		        }

		        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))
		            unexpected(prev());

		        var args = [];
		        var body = _function_body(true, is_generator || is_generator_property, is_async, name, args);
		        return new ctor({
		            start : args.start,
		            end   : body.end,
		            is_generator: is_generator,
		            async : is_async,
		            name  : name,
		            argnames: args,
		            body  : body
		        });
		    };

		    class UsedParametersTracker {
		        constructor(is_parameter, strict, duplicates_ok = false) {
		            this.is_parameter = is_parameter;
		            this.duplicates_ok = duplicates_ok;
		            this.parameters = new Set();
		            this.duplicate = null;
		            this.default_assignment = false;
		            this.spread = false;
		            this.strict_mode = !!strict;
		        }
		        add_parameter(token) {
		            if (this.parameters.has(token.value)) {
		                if (this.duplicate === null) {
		                    this.duplicate = token;
		                }
		                this.check_strict();
		            } else {
		                this.parameters.add(token.value);
		                if (this.is_parameter) {
		                    switch (token.value) {
		                      case "arguments":
		                      case "eval":
		                      case "yield":
		                        if (this.strict_mode) {
		                            token_error(token, "Unexpected " + token.value + " identifier as parameter inside strict mode");
		                        }
		                        break;
		                      default:
		                        if (RESERVED_WORDS.has(token.value)) {
		                            unexpected();
		                        }
		                    }
		                }
		            }
		        }
		        mark_default_assignment(token) {
		            if (this.default_assignment === false) {
		                this.default_assignment = token;
		            }
		        }
		        mark_spread(token) {
		            if (this.spread === false) {
		                this.spread = token;
		            }
		        }
		        mark_strict_mode() {
		            this.strict_mode = true;
		        }
		        is_strict() {
		            return this.default_assignment !== false || this.spread !== false || this.strict_mode;
		        }
		        check_strict() {
		            if (this.is_strict() && this.duplicate !== null && !this.duplicates_ok) {
		                token_error(this.duplicate, "Parameter " + this.duplicate.value + " was used already");
		            }
		        }
		    }

		    function parameters(params) {
		        var used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));

		        expect("(");

		        while (!is("punc", ")")) {
		            var param = parameter(used_parameters);
		            params.push(param);

		            if (!is("punc", ")")) {
		                expect(",");
		            }

		            if (param instanceof AST_Expansion) {
		                break;
		            }
		        }

		        next();
		    }

		    function parameter(used_parameters, symbol_type) {
		        var param;
		        var expand = false;
		        if (used_parameters === undefined) {
		            used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
		        }
		        if (is("expand", "...")) {
		            expand = S.token;
		            used_parameters.mark_spread(S.token);
		            next();
		        }
		        param = binding_element(used_parameters, symbol_type);

		        if (is("operator", "=") && expand === false) {
		            used_parameters.mark_default_assignment(S.token);
		            next();
		            param = new AST_DefaultAssign({
		                start: param.start,
		                left: param,
		                operator: "=",
		                right: expression(false),
		                end: S.token
		            });
		        }

		        if (expand !== false) {
		            if (!is("punc", ")")) {
		                unexpected();
		            }
		            param = new AST_Expansion({
		                start: expand,
		                expression: param,
		                end: expand
		            });
		        }
		        used_parameters.check_strict();

		        return param;
		    }

		    function binding_element(used_parameters, symbol_type) {
		        var elements = [];
		        var first = true;
		        var is_expand = false;
		        var expand_token;
		        var first_token = S.token;
		        if (used_parameters === undefined) {
		            const strict = S.input.has_directive("use strict");
		            const duplicates_ok = symbol_type === AST_SymbolVar;
		            used_parameters = new UsedParametersTracker(false, strict, duplicates_ok);
		        }
		        symbol_type = symbol_type === undefined ? AST_SymbolFunarg : symbol_type;
		        if (is("punc", "[")) {
		            next();
		            while (!is("punc", "]")) {
		                if (first) {
		                    first = false;
		                } else {
		                    expect(",");
		                }

		                if (is("expand", "...")) {
		                    is_expand = true;
		                    expand_token = S.token;
		                    used_parameters.mark_spread(S.token);
		                    next();
		                }
		                if (is("punc")) {
		                    switch (S.token.value) {
		                      case ",":
		                        elements.push(new AST_Hole({
		                            start: S.token,
		                            end: S.token
		                        }));
		                        continue;
		                      case "]": // Trailing comma after last element
		                        break;
		                      case "[":
		                      case "{":
		                        elements.push(binding_element(used_parameters, symbol_type));
		                        break;
		                      default:
		                        unexpected();
		                    }
		                } else if (is("name")) {
		                    used_parameters.add_parameter(S.token);
		                    elements.push(as_symbol(symbol_type));
		                } else {
		                    croak("Invalid function parameter");
		                }
		                if (is("operator", "=") && is_expand === false) {
		                    used_parameters.mark_default_assignment(S.token);
		                    next();
		                    elements[elements.length - 1] = new AST_DefaultAssign({
		                        start: elements[elements.length - 1].start,
		                        left: elements[elements.length - 1],
		                        operator: "=",
		                        right: expression(false),
		                        end: S.token
		                    });
		                }
		                if (is_expand) {
		                    if (!is("punc", "]")) {
		                        croak("Rest element must be last element");
		                    }
		                    elements[elements.length - 1] = new AST_Expansion({
		                        start: expand_token,
		                        expression: elements[elements.length - 1],
		                        end: expand_token
		                    });
		                }
		            }
		            expect("]");
		            used_parameters.check_strict();
		            return new AST_Destructuring({
		                start: first_token,
		                names: elements,
		                is_array: true,
		                end: prev()
		            });
		        } else if (is("punc", "{")) {
		            next();
		            while (!is("punc", "}")) {
		                if (first) {
		                    first = false;
		                } else {
		                    expect(",");
		                }
		                if (is("expand", "...")) {
		                    is_expand = true;
		                    expand_token = S.token;
		                    used_parameters.mark_spread(S.token);
		                    next();
		                }
		                if (is("name") && (is_token(peek(), "punc") || is_token(peek(), "operator")) && [",", "}", "="].includes(peek().value)) {
		                    used_parameters.add_parameter(S.token);
		                    var start = prev();
		                    var value = as_symbol(symbol_type);
		                    if (is_expand) {
		                        elements.push(new AST_Expansion({
		                            start: expand_token,
		                            expression: value,
		                            end: value.end,
		                        }));
		                    } else {
		                        elements.push(new AST_ObjectKeyVal({
		                            start: start,
		                            key: value.name,
		                            value: value,
		                            end: value.end,
		                        }));
		                    }
		                } else if (is("punc", "}")) {
		                    continue; // Allow trailing hole
		                } else {
		                    var property_token = S.token;
		                    var property = as_property_name();
		                    if (property === null) {
		                        unexpected(prev());
		                    } else if (prev().type === "name" && !is("punc", ":")) {
		                        elements.push(new AST_ObjectKeyVal({
		                            start: prev(),
		                            key: property,
		                            value: new symbol_type({
		                                start: prev(),
		                                name: property,
		                                end: prev()
		                            }),
		                            end: prev()
		                        }));
		                    } else {
		                        expect(":");
		                        elements.push(new AST_ObjectKeyVal({
		                            start: property_token,
		                            quote: property_token.quote,
		                            key: property,
		                            value: binding_element(used_parameters, symbol_type),
		                            end: prev()
		                        }));
		                    }
		                }
		                if (is_expand) {
		                    if (!is("punc", "}")) {
		                        croak("Rest element must be last element");
		                    }
		                } else if (is("operator", "=")) {
		                    used_parameters.mark_default_assignment(S.token);
		                    next();
		                    elements[elements.length - 1].value = new AST_DefaultAssign({
		                        start: elements[elements.length - 1].value.start,
		                        left: elements[elements.length - 1].value,
		                        operator: "=",
		                        right: expression(false),
		                        end: S.token
		                    });
		                }
		            }
		            expect("}");
		            used_parameters.check_strict();
		            return new AST_Destructuring({
		                start: first_token,
		                names: elements,
		                is_array: false,
		                end: prev()
		            });
		        } else if (is("name")) {
		            used_parameters.add_parameter(S.token);
		            return as_symbol(symbol_type);
		        } else {
		            croak("Invalid function parameter");
		        }
		    }

		    function params_or_seq_(allow_arrows, maybe_sequence) {
		        var spread_token;
		        var invalid_sequence;
		        var trailing_comma;
		        var a = [];
		        expect("(");
		        while (!is("punc", ")")) {
		            if (spread_token) unexpected(spread_token);
		            if (is("expand", "...")) {
		                spread_token = S.token;
		                if (maybe_sequence) invalid_sequence = S.token;
		                next();
		                a.push(new AST_Expansion({
		                    start: prev(),
		                    expression: expression(),
		                    end: S.token,
		                }));
		            } else {
		                a.push(expression());
		            }
		            if (!is("punc", ")")) {
		                expect(",");
		                if (is("punc", ")")) {
		                    trailing_comma = prev();
		                    if (maybe_sequence) invalid_sequence = trailing_comma;
		                }
		            }
		        }
		        expect(")");
		        if (allow_arrows && is("arrow", "=>")) {
		            if (spread_token && trailing_comma) unexpected(trailing_comma);
		        } else if (invalid_sequence) {
		            unexpected(invalid_sequence);
		        }
		        return a;
		    }

		    function _function_body(block, generator, is_async, name, args) {
		        var loop = S.in_loop;
		        var labels = S.labels;
		        var current_generator = S.in_generator;
		        var current_async = S.in_async;
		        ++S.in_function;
		        if (generator)
		            S.in_generator = S.in_function;
		        if (is_async)
		            S.in_async = S.in_function;
		        if (args) parameters(args);
		        if (block)
		            S.in_directives = true;
		        S.in_loop = 0;
		        S.labels = [];
		        if (block) {
		            S.input.push_directives_stack();
		            var a = block_();
		            if (name) _verify_symbol(name);
		            if (args) args.forEach(_verify_symbol);
		            S.input.pop_directives_stack();
		        } else {
		            var a = [new AST_Return({
		                start: S.token,
		                value: expression(false),
		                end: S.token
		            })];
		        }
		        --S.in_function;
		        S.in_loop = loop;
		        S.labels = labels;
		        S.in_generator = current_generator;
		        S.in_async = current_async;
		        return a;
		    }

		    function _await_expression() {
		        // Previous token must be "await" and not be interpreted as an identifier
		        if (!can_await()) {
		            croak("Unexpected await expression outside async function",
		                S.prev.line, S.prev.col, S.prev.pos);
		        }
		        // the await expression is parsed as a unary expression in Babel
		        return new AST_Await({
		            start: prev(),
		            end: S.token,
		            expression : maybe_unary(true),
		        });
		    }

		    function _yield_expression() {
		        // Previous token must be keyword yield and not be interpret as an identifier
		        if (!is_in_generator()) {
		            croak("Unexpected yield expression outside generator function",
		                S.prev.line, S.prev.col, S.prev.pos);
		        }
		        var start = S.token;
		        var star = false;
		        var has_expression = true;

		        // Attempt to get expression or star (and then the mandatory expression)
		        // behind yield on the same line.
		        //
		        // If nothing follows on the same line of the yieldExpression,
		        // it should default to the value `undefined` for yield to return.
		        // In that case, the `undefined` stored as `null` in ast.
		        //
		        // Note 1: It isn't allowed for yield* to close without an expression
		        // Note 2: If there is a nlb between yield and star, it is interpret as
		        //         yield <explicit undefined> <inserted automatic semicolon> *
		        if (can_insert_semicolon() ||
		            (is("punc") && PUNC_AFTER_EXPRESSION.has(S.token.value))) {
		            has_expression = false;

		        } else if (is("operator", "*")) {
		            star = true;
		            next();
		        }

		        return new AST_Yield({
		            start      : start,
		            is_star    : star,
		            expression : has_expression ? expression() : null,
		            end        : prev()
		        });
		    }

		    function if_() {
		        var cond = parenthesised(), body = statement(false, false, true), belse = null;
		        if (is("keyword", "else")) {
		            next();
		            belse = statement(false, false, true);
		        }
		        return new AST_If({
		            condition   : cond,
		            body        : body,
		            alternative : belse
		        });
		    }

		    function block_() {
		        expect("{");
		        var a = [];
		        while (!is("punc", "}")) {
		            if (is("eof")) unexpected();
		            a.push(statement());
		        }
		        next();
		        return a;
		    }

		    function switch_body_() {
		        expect("{");
		        var a = [], cur = null, branch = null, tmp;
		        while (!is("punc", "}")) {
		            if (is("eof")) unexpected();
		            if (is("keyword", "case")) {
		                if (branch) branch.end = prev();
		                cur = [];
		                branch = new AST_Case({
		                    start      : (tmp = S.token, next(), tmp),
		                    expression : expression(true),
		                    body       : cur
		                });
		                a.push(branch);
		                expect(":");
		            } else if (is("keyword", "default")) {
		                if (branch) branch.end = prev();
		                cur = [];
		                branch = new AST_Default({
		                    start : (tmp = S.token, next(), expect(":"), tmp),
		                    body  : cur
		                });
		                a.push(branch);
		            } else {
		                if (!cur) unexpected();
		                cur.push(statement());
		            }
		        }
		        if (branch) branch.end = prev();
		        next();
		        return a;
		    }

		    function try_() {
		        var body, bcatch = null, bfinally = null;
		        body = new AST_TryBlock({
		            start : S.token,
		            body  : block_(),
		            end   : prev(),
		        });
		        if (is("keyword", "catch")) {
		            var start = S.token;
		            next();
		            if (is("punc", "{")) {
		                var name = null;
		            } else {
		                expect("(");
		                var name = parameter(undefined, AST_SymbolCatch);
		                expect(")");
		            }
		            bcatch = new AST_Catch({
		                start   : start,
		                argname : name,
		                body    : block_(),
		                end     : prev()
		            });
		        }
		        if (is("keyword", "finally")) {
		            var start = S.token;
		            next();
		            bfinally = new AST_Finally({
		                start : start,
		                body  : block_(),
		                end   : prev()
		            });
		        }
		        if (!bcatch && !bfinally)
		            croak("Missing catch/finally blocks");
		        return new AST_Try({
		            body     : body,
		            bcatch   : bcatch,
		            bfinally : bfinally
		        });
		    }

		    /**
		     * var
		     *   vardef1 = 2,
		     *   vardef2 = 3;
		     */
		    function vardefs(no_in, kind) {
		        var var_defs = [];
		        var def;
		        for (;;) {
		            var sym_type =
		                kind === "var" ? AST_SymbolVar :
		                kind === "const" ? AST_SymbolConst :
		                kind === "let" ? AST_SymbolLet : null;
		            // var { a } = b
		            if (is("punc", "{") || is("punc", "[")) {
		                def = new AST_VarDef({
		                    start: S.token,
		                    name: binding_element(undefined, sym_type),
		                    value: is("operator", "=") ? (expect_token("operator", "="), expression(false, no_in)) : null,
		                    end: prev()
		                });
		            } else {
		                def = new AST_VarDef({
		                    start : S.token,
		                    name  : as_symbol(sym_type),
		                    value : is("operator", "=")
		                        ? (next(), expression(false, no_in))
		                        : !no_in && kind === "const"
		                            ? croak("Missing initializer in const declaration") : null,
		                    end   : prev()
		                });
		                if (def.name.name == "import") croak("Unexpected token: import");
		            }
		            var_defs.push(def);
		            if (!is("punc", ","))
		                break;
		            next();
		        }
		        return var_defs;
		    }

		    var var_ = function(no_in) {
		        return new AST_Var({
		            start       : prev(),
		            definitions : vardefs(no_in, "var"),
		            end         : prev()
		        });
		    };

		    var let_ = function(no_in) {
		        return new AST_Let({
		            start       : prev(),
		            definitions : vardefs(no_in, "let"),
		            end         : prev()
		        });
		    };

		    var const_ = function(no_in) {
		        return new AST_Const({
		            start       : prev(),
		            definitions : vardefs(no_in, "const"),
		            end         : prev()
		        });
		    };

		    var new_ = function(allow_calls) {
		        var start = S.token;
		        expect_token("operator", "new");
		        if (is("punc", ".")) {
		            next();
		            expect_token("name", "target");
		            return subscripts(new AST_NewTarget({
		                start : start,
		                end   : prev()
		            }), allow_calls);
		        }
		        var newexp = expr_atom(false), args;
		        if (is("punc", "(")) {
		            next();
		            args = expr_list(")", true);
		        } else {
		            args = [];
		        }
		        var call = new AST_New({
		            start      : start,
		            expression : newexp,
		            args       : args,
		            end        : prev()
		        });
		        annotate(call);
		        return subscripts(call, allow_calls);
		    };

		    function as_atom_node() {
		        var tok = S.token, ret;
		        switch (tok.type) {
		          case "name":
		            ret = _make_symbol(AST_SymbolRef);
		            break;
		          case "num":
		            ret = new AST_Number({
		                start: tok,
		                end: tok,
		                value: tok.value,
		                raw: LATEST_RAW
		            });
		            break;
		          case "big_int":
		            ret = new AST_BigInt({ start: tok, end: tok, value: tok.value });
		            break;
		          case "string":
		            ret = new AST_String({
		                start : tok,
		                end   : tok,
		                value : tok.value,
		                quote : tok.quote
		            });
		            annotate(ret);
		            break;
		          case "regexp":
		            const [_, source, flags] = tok.value.match(/^\/(.*)\/(\w*)$/);

		            ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });
		            break;
		          case "atom":
		            switch (tok.value) {
		              case "false":
		                ret = new AST_False({ start: tok, end: tok });
		                break;
		              case "true":
		                ret = new AST_True({ start: tok, end: tok });
		                break;
		              case "null":
		                ret = new AST_Null({ start: tok, end: tok });
		                break;
		            }
		            break;
		        }
		        next();
		        return ret;
		    }

		    function to_fun_args(ex, default_seen_above) {
		        var insert_default = function(ex, default_value) {
		            if (default_value) {
		                return new AST_DefaultAssign({
		                    start: ex.start,
		                    left: ex,
		                    operator: "=",
		                    right: default_value,
		                    end: default_value.end
		                });
		            }
		            return ex;
		        };
		        if (ex instanceof AST_Object) {
		            return insert_default(new AST_Destructuring({
		                start: ex.start,
		                end: ex.end,
		                is_array: false,
		                names: ex.properties.map(prop => to_fun_args(prop))
		            }), default_seen_above);
		        } else if (ex instanceof AST_ObjectKeyVal) {
		            ex.value = to_fun_args(ex.value);
		            return insert_default(ex, default_seen_above);
		        } else if (ex instanceof AST_Hole) {
		            return ex;
		        } else if (ex instanceof AST_Destructuring) {
		            ex.names = ex.names.map(name => to_fun_args(name));
		            return insert_default(ex, default_seen_above);
		        } else if (ex instanceof AST_SymbolRef) {
		            return insert_default(new AST_SymbolFunarg({
		                name: ex.name,
		                start: ex.start,
		                end: ex.end
		            }), default_seen_above);
		        } else if (ex instanceof AST_Expansion) {
		            ex.expression = to_fun_args(ex.expression);
		            return insert_default(ex, default_seen_above);
		        } else if (ex instanceof AST_Array) {
		            return insert_default(new AST_Destructuring({
		                start: ex.start,
		                end: ex.end,
		                is_array: true,
		                names: ex.elements.map(elm => to_fun_args(elm))
		            }), default_seen_above);
		        } else if (ex instanceof AST_Assign) {
		            return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);
		        } else if (ex instanceof AST_DefaultAssign) {
		            ex.left = to_fun_args(ex.left);
		            return ex;
		        } else {
		            croak("Invalid function parameter", ex.start.line, ex.start.col);
		        }
		    }

		    var expr_atom = function(allow_calls, allow_arrows) {
		        if (is("operator", "new")) {
		            return new_(allow_calls);
		        }
		        if (is("name", "import") && is_token(peek(), "punc", ".")) {
		            return import_meta(allow_calls);
		        }
		        var start = S.token;
		        var peeked;
		        var async = is("name", "async")
		            && (peeked = peek()).value != "["
		            && peeked.type != "arrow"
		            && as_atom_node();
		        if (is("punc")) {
		            switch (S.token.value) {
		              case "(":
		                if (async && !allow_calls) break;
		                var exprs = params_or_seq_(allow_arrows, !async);
		                if (allow_arrows && is("arrow", "=>")) {
		                    return arrow_function(start, exprs.map(e => to_fun_args(e)), !!async);
		                }
		                var ex = async ? new AST_Call({
		                    expression: async,
		                    args: exprs
		                }) : exprs.length == 1 ? exprs[0] : new AST_Sequence({
		                    expressions: exprs
		                });
		                if (ex.start) {
		                    const outer_comments_before = start.comments_before.length;
		                    outer_comments_before_counts.set(start, outer_comments_before);
		                    ex.start.comments_before.unshift(...start.comments_before);
		                    start.comments_before = ex.start.comments_before;
		                    if (outer_comments_before == 0 && start.comments_before.length > 0) {
		                        var comment = start.comments_before[0];
		                        if (!comment.nlb) {
		                            comment.nlb = start.nlb;
		                            start.nlb = false;
		                        }
		                    }
		                    start.comments_after = ex.start.comments_after;
		                }
		                ex.start = start;
		                var end = prev();
		                if (ex.end) {
		                    end.comments_before = ex.end.comments_before;
		                    ex.end.comments_after.push(...end.comments_after);
		                    end.comments_after = ex.end.comments_after;
		                }
		                ex.end = end;
		                if (ex instanceof AST_Call) annotate(ex);
		                return subscripts(ex, allow_calls);
		              case "[":
		                return subscripts(array_(), allow_calls);
		              case "{":
		                return subscripts(object_or_destructuring_(), allow_calls);
		            }
		            if (!async) unexpected();
		        }
		        if (allow_arrows && is("name") && is_token(peek(), "arrow")) {
		            var param = new AST_SymbolFunarg({
		                name: S.token.value,
		                start: start,
		                end: start,
		            });
		            next();
		            return arrow_function(start, [param], !!async);
		        }
		        if (is("keyword", "function")) {
		            next();
		            var func = function_(AST_Function, false, !!async);
		            func.start = start;
		            func.end = prev();
		            return subscripts(func, allow_calls);
		        }
		        if (async) return subscripts(async, allow_calls);
		        if (is("keyword", "class")) {
		            next();
		            var cls = class_(AST_ClassExpression);
		            cls.start = start;
		            cls.end = prev();
		            return subscripts(cls, allow_calls);
		        }
		        if (is("template_head")) {
		            return subscripts(template_string(), allow_calls);
		        }
		        if (is("privatename")) {
		            if(!S.in_class) {
		                croak("Private field must be used in an enclosing class");
		            }

		            const start = S.token;
		            const key = new AST_SymbolPrivateProperty({
		                start,
		                name: start.value,
		                end: start
		            });
		            next();
		            expect_token("operator", "in");

		            const private_in = new AST_PrivateIn({
		                start,
		                key,
		                value: subscripts(as_atom_node(), allow_calls),
		                end: prev()
		            });

		            return subscripts(private_in, allow_calls);
		        }
		        if (ATOMIC_START_TOKEN.has(S.token.type)) {
		            return subscripts(as_atom_node(), allow_calls);
		        }
		        unexpected();
		    };

		    function template_string() {
		        var segments = [], start = S.token;

		        segments.push(new AST_TemplateSegment({
		            start: S.token,
		            raw: TEMPLATE_RAWS.get(S.token),
		            value: S.token.value,
		            end: S.token
		        }));

		        while (!S.token.template_end) {
		            next();
		            handle_regexp();
		            segments.push(expression(true));

		            segments.push(new AST_TemplateSegment({
		                start: S.token,
		                raw: TEMPLATE_RAWS.get(S.token),
		                value: S.token.value,
		                end: S.token
		            }));
		        }
		        next();

		        return new AST_TemplateString({
		            start: start,
		            segments: segments,
		            end: S.token
		        });
		    }

		    function expr_list(closing, allow_trailing_comma, allow_empty) {
		        var first = true, a = [];
		        while (!is("punc", closing)) {
		            if (first) first = false; else expect(",");
		            if (allow_trailing_comma && is("punc", closing)) break;
		            if (is("punc", ",") && allow_empty) {
		                a.push(new AST_Hole({ start: S.token, end: S.token }));
		            } else if (is("expand", "...")) {
		                next();
		                a.push(new AST_Expansion({start: prev(), expression: expression(),end: S.token}));
		            } else {
		                a.push(expression(false));
		            }
		        }
		        next();
		        return a;
		    }

		    var array_ = embed_tokens(function() {
		        expect("[");
		        return new AST_Array({
		            elements: expr_list("]", !options.strict, true)
		        });
		    });

		    var create_accessor = embed_tokens((is_generator, is_async) => {
		        return function_(AST_Accessor, is_generator, is_async);
		    });

		    var object_or_destructuring_ = embed_tokens(function object_or_destructuring_() {
		        var start = S.token, first = true, a = [];
		        expect("{");
		        while (!is("punc", "}")) {
		            if (first) first = false; else expect(",");
		            if (!options.strict && is("punc", "}"))
		                // allow trailing comma
		                break;

		            start = S.token;
		            if (start.type == "expand") {
		                next();
		                a.push(new AST_Expansion({
		                    start: start,
		                    expression: expression(false),
		                    end: prev(),
		                }));
		                continue;
		            }
		            if(is("privatename")) {
		                croak("private fields are not allowed in an object");
		            }
		            var name = as_property_name();
		            var value;

		            // Check property and fetch value
		            if (!is("punc", ":")) {
		                var concise = concise_method_or_getset(name, start);
		                if (concise) {
		                    a.push(concise);
		                    continue;
		                }

		                value = new AST_SymbolRef({
		                    start: prev(),
		                    name: name,
		                    end: prev()
		                });
		            } else if (name === null) {
		                unexpected(prev());
		            } else {
		                next(); // `:` - see first condition
		                value = expression(false);
		            }

		            // Check for default value and alter value accordingly if necessary
		            if (is("operator", "=")) {
		                next();
		                value = new AST_Assign({
		                    start: start,
		                    left: value,
		                    operator: "=",
		                    right: expression(false),
		                    logical: false,
		                    end: prev()
		                });
		            }

		            // Create property
		            const kv = new AST_ObjectKeyVal({
		                start: start,
		                quote: start.quote,
		                key: name instanceof AST_Node ? name : "" + name,
		                value: value,
		                end: prev()
		            });
		            a.push(annotate(kv));
		        }
		        next();
		        return new AST_Object({ properties: a });
		    });

		    function class_(KindOfClass, is_export_default) {
		        var start, method, class_name, extends_, a = [];

		        S.input.push_directives_stack(); // Push directive stack, but not scope stack
		        S.input.add_directive("use strict");

		        if (S.token.type == "name" && S.token.value != "extends") {
		            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);
		        }

		        if (KindOfClass === AST_DefClass && !class_name) {
		            if (is_export_default) {
		                KindOfClass = AST_ClassExpression;
		            } else {
		                unexpected();
		            }
		        }

		        if (S.token.value == "extends") {
		            next();
		            extends_ = expression(true);
		        }

		        expect("{");
		        // mark in class feild,
		        const save_in_class = S.in_class;
		        S.in_class = true;
		        while (is("punc", ";")) { next(); }  // Leading semicolons are okay in class bodies.
		        while (!is("punc", "}")) {
		            start = S.token;
		            method = concise_method_or_getset(as_property_name(), start, true);
		            if (!method) { unexpected(); }
		            a.push(method);
		            while (is("punc", ";")) { next(); }
		        }
		        // mark in class feild,
		        S.in_class = save_in_class;

		        S.input.pop_directives_stack();

		        next();

		        return new KindOfClass({
		            start: start,
		            name: class_name,
		            extends: extends_,
		            properties: a,
		            end: prev(),
		        });
		    }

		    function concise_method_or_getset(name, start, is_class) {
		        const get_symbol_ast = (name, SymbolClass = AST_SymbolMethod) => {
		            if (typeof name === "string" || typeof name === "number") {
		                return new SymbolClass({
		                    start,
		                    name: "" + name,
		                    end: prev()
		                });
		            } else if (name === null) {
		                unexpected();
		            }
		            return name;
		        };

		        const is_not_method_start = () =>
		            !is("punc", "(") && !is("punc", ",") && !is("punc", "}") && !is("punc", ";") && !is("operator", "=");

		        var is_async = false;
		        var is_static = false;
		        var is_generator = false;
		        var is_private = false;
		        var accessor_type = null;

		        if (is_class && name === "static" && is_not_method_start()) {
		            const static_block = class_static_block();
		            if (static_block != null) {
		                return static_block;
		            }
		            is_static = true;
		            name = as_property_name();
		        }
		        if (name === "async" && is_not_method_start()) {
		            is_async = true;
		            name = as_property_name();
		        }
		        if (prev().type === "operator" && prev().value === "*") {
		            is_generator = true;
		            name = as_property_name();
		        }
		        if ((name === "get" || name === "set") && is_not_method_start()) {
		            accessor_type = name;
		            name = as_property_name();
		        }
		        if (prev().type === "privatename") {
		            is_private = true;
		        }

		        const property_token = prev();

		        if (accessor_type != null) {
		            if (!is_private) {
		                const AccessorClass = accessor_type === "get"
		                    ? AST_ObjectGetter
		                    : AST_ObjectSetter;

		                name = get_symbol_ast(name);
		                return annotate(new AccessorClass({
		                    start,
		                    static: is_static,
		                    key: name,
		                    quote: name instanceof AST_SymbolMethod ? property_token.quote : undefined,
		                    value: create_accessor(),
		                    end: prev()
		                }));
		            } else {
		                const AccessorClass = accessor_type === "get"
		                    ? AST_PrivateGetter
		                    : AST_PrivateSetter;

		                return annotate(new AccessorClass({
		                    start,
		                    static: is_static,
		                    key: get_symbol_ast(name),
		                    value: create_accessor(),
		                    end: prev(),
		                }));
		            }
		        }

		        if (is("punc", "(")) {
		            name = get_symbol_ast(name);
		            const AST_MethodVariant = is_private
		                ? AST_PrivateMethod
		                : AST_ConciseMethod;
		            var node = new AST_MethodVariant({
		                start       : start,
		                static      : is_static,
		                is_generator: is_generator,
		                async       : is_async,
		                key         : name,
		                quote       : name instanceof AST_SymbolMethod ?
		                              property_token.quote : undefined,
		                value       : create_accessor(is_generator, is_async),
		                end         : prev()
		            });
		            return annotate(node);
		        }

		        if (is_class) {
		            const key = get_symbol_ast(name, AST_SymbolClassProperty);
		            const quote = key instanceof AST_SymbolClassProperty
		                ? property_token.quote
		                : undefined;
		            const AST_ClassPropertyVariant = is_private
		                ? AST_ClassPrivateProperty
		                : AST_ClassProperty;
		            if (is("operator", "=")) {
		                next();
		                return annotate(
		                    new AST_ClassPropertyVariant({
		                        start,
		                        static: is_static,
		                        quote,
		                        key,
		                        value: expression(false),
		                        end: prev()
		                    })
		                );
		            } else if (
		                is("name")
		                || is("privatename")
		                || is("operator", "*")
		                || is("punc", ";")
		                || is("punc", "}")
		            ) {
		                return annotate(
		                    new AST_ClassPropertyVariant({
		                        start,
		                        static: is_static,
		                        quote,
		                        key,
		                        end: prev()
		                    })
		                );
		            }
		        }
		    }

		    function class_static_block() {
		        if (!is("punc", "{")) {
		            return null;
		        }

		        const start = S.token;
		        const body = [];

		        next();

		        while (!is("punc", "}")) {
		            body.push(statement());
		        }

		        next();

		        return new AST_ClassStaticBlock({ start, body, end: prev() });
		    }

		    function maybe_import_assertion() {
		        if (is("name", "assert") && !has_newline_before(S.token)) {
		            next();
		            return object_or_destructuring_();
		        }
		        return null;
		    }

		    function import_statement() {
		        var start = prev();

		        var imported_name;
		        var imported_names;
		        if (is("name")) {
		            imported_name = as_symbol(AST_SymbolImport);
		        }

		        if (is("punc", ",")) {
		            next();
		        }

		        imported_names = map_names(true);

		        if (imported_names || imported_name) {
		            expect_token("name", "from");
		        }
		        var mod_str = S.token;
		        if (mod_str.type !== "string") {
		            unexpected();
		        }
		        next();

		        const assert_clause = maybe_import_assertion();

		        return new AST_Import({
		            start,
		            imported_name,
		            imported_names,
		            module_name: new AST_String({
		                start: mod_str,
		                value: mod_str.value,
		                quote: mod_str.quote,
		                end: mod_str,
		            }),
		            assert_clause,
		            end: S.token,
		        });
		    }

		    function import_meta(allow_calls) {
		        var start = S.token;
		        expect_token("name", "import");
		        expect_token("punc", ".");
		        expect_token("name", "meta");
		        return subscripts(new AST_ImportMeta({
		            start: start,
		            end: prev()
		        }), allow_calls);
		    }

		    function map_name(is_import) {
		        function make_symbol(type, quote) {
		            return new type({
		                name: as_property_name(),
		                quote: quote || undefined,
		                start: prev(),
		                end: prev()
		            });
		        }

		        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
		        var type = is_import ? AST_SymbolImport : AST_SymbolExport;
		        var start = S.token;
		        var foreign_name;
		        var name;

		        if (is_import) {
		            foreign_name = make_symbol(foreign_type, start.quote);
		        } else {
		            name = make_symbol(type, start.quote);
		        }
		        if (is("name", "as")) {
		            next();  // The "as" word
		            if (is_import) {
		                name = make_symbol(type);
		            } else {
		                foreign_name = make_symbol(foreign_type, S.token.quote);
		            }
		        } else if (is_import) {
		            name = new type(foreign_name);
		        } else {
		            foreign_name = new foreign_type(name);
		        }

		        return new AST_NameMapping({
		            start: start,
		            foreign_name: foreign_name,
		            name: name,
		            end: prev(),
		        });
		    }

		    function map_nameAsterisk(is_import, import_or_export_foreign_name) {
		        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
		        var type = is_import ? AST_SymbolImport : AST_SymbolExport;
		        var start = S.token;
		        var name, foreign_name;
		        var end = prev();

		        if (is_import) {
		            name = import_or_export_foreign_name;
		        } else {
		            foreign_name = import_or_export_foreign_name;
		        }

		        name = name || new type({
		            start: start,
		            name: "*",
		            end: end,
		        });

		        foreign_name = foreign_name || new foreign_type({
		            start: start,
		            name: "*",
		            end: end,
		        });

		        return new AST_NameMapping({
		            start: start,
		            foreign_name: foreign_name,
		            name: name,
		            end: end,
		        });
		    }

		    function map_names(is_import) {
		        var names;
		        if (is("punc", "{")) {
		            next();
		            names = [];
		            while (!is("punc", "}")) {
		                names.push(map_name(is_import));
		                if (is("punc", ",")) {
		                    next();
		                }
		            }
		            next();
		        } else if (is("operator", "*")) {
		            var name;
		            next();
		            if (is("name", "as")) {
		                next();  // The "as" word
		                name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);
		            }
		            names = [map_nameAsterisk(is_import, name)];
		        }
		        return names;
		    }

		    function export_statement() {
		        var start = S.token;
		        var is_default;
		        var exported_names;

		        if (is("keyword", "default")) {
		            is_default = true;
		            next();
		        } else if (exported_names = map_names(false)) {
		            if (is("name", "from")) {
		                next();

		                var mod_str = S.token;
		                if (mod_str.type !== "string") {
		                    unexpected();
		                }
		                next();

		                const assert_clause = maybe_import_assertion();

		                return new AST_Export({
		                    start: start,
		                    is_default: is_default,
		                    exported_names: exported_names,
		                    module_name: new AST_String({
		                        start: mod_str,
		                        value: mod_str.value,
		                        quote: mod_str.quote,
		                        end: mod_str,
		                    }),
		                    end: prev(),
		                    assert_clause
		                });
		            } else {
		                return new AST_Export({
		                    start: start,
		                    is_default: is_default,
		                    exported_names: exported_names,
		                    end: prev(),
		                });
		            }
		        }

		        var node;
		        var exported_value;
		        var exported_definition;
		        if (is("punc", "{")
		            || is_default
		                && (is("keyword", "class") || is("keyword", "function"))
		                && is_token(peek(), "punc")) {
		            exported_value = expression(false);
		            semicolon();
		        } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {
		            unexpected(node.start);
		        } else if (
		            node instanceof AST_Definitions
		            || node instanceof AST_Defun
		            || node instanceof AST_DefClass
		        ) {
		            exported_definition = node;
		        } else if (
		            node instanceof AST_ClassExpression
		            || node instanceof AST_Function
		        ) {
		            exported_value = node;
		        } else if (node instanceof AST_SimpleStatement) {
		            exported_value = node.body;
		        } else {
		            unexpected(node.start);
		        }

		        return new AST_Export({
		            start: start,
		            is_default: is_default,
		            exported_value: exported_value,
		            exported_definition: exported_definition,
		            end: prev(),
		            assert_clause: null
		        });
		    }

		    function as_property_name() {
		        var tmp = S.token;
		        switch (tmp.type) {
		          case "punc":
		            if (tmp.value === "[") {
		                next();
		                var ex = expression(false);
		                expect("]");
		                return ex;
		            } else unexpected(tmp);
		          case "operator":
		            if (tmp.value === "*") {
		                next();
		                return null;
		            }
		            if (!["delete", "in", "instanceof", "new", "typeof", "void"].includes(tmp.value)) {
		                unexpected(tmp);
		            }
		            /* falls through */
		          case "name":
		          case "privatename":
		          case "string":
		          case "num":
		          case "big_int":
		          case "keyword":
		          case "atom":
		            next();
		            return tmp.value;
		          default:
		            unexpected(tmp);
		        }
		    }

		    function as_name() {
		        var tmp = S.token;
		        if (tmp.type != "name" && tmp.type != "privatename") unexpected();
		        next();
		        return tmp.value;
		    }

		    function _make_symbol(type) {
		        var name = S.token.value;
		        return new (name == "this" ? AST_This :
		                    name == "super" ? AST_Super :
		                    type)({
		            name  : String(name),
		            start : S.token,
		            end   : S.token
		        });
		    }

		    function _verify_symbol(sym) {
		        var name = sym.name;
		        if (is_in_generator() && name == "yield") {
		            token_error(sym.start, "Yield cannot be used as identifier inside generators");
		        }
		        if (S.input.has_directive("use strict")) {
		            if (name == "yield") {
		                token_error(sym.start, "Unexpected yield identifier inside strict mode");
		            }
		            if (sym instanceof AST_SymbolDeclaration && (name == "arguments" || name == "eval")) {
		                token_error(sym.start, "Unexpected " + name + " in strict mode");
		            }
		        }
		    }

		    function as_symbol(type, noerror) {
		        if (!is("name")) {
		            if (!noerror) croak("Name expected");
		            return null;
		        }
		        var sym = _make_symbol(type);
		        _verify_symbol(sym);
		        next();
		        return sym;
		    }

		    function as_symbol_or_string(type) {
		        if (!is("name")) {
		            if (!is("string")) {
		                croak("Name or string expected");
		            }
		            var tok = S.token;
		            var ret = new type({
		                start : tok,
		                end   : tok,
		                name : tok.value,
		                quote : tok.quote
		            });
		            next();
		            return ret;
		        }
		        var sym = _make_symbol(type);
		        _verify_symbol(sym);
		        next();
		        return sym;
		    }

		    // Annotate AST_Call, AST_Lambda or AST_New with the special comments
		    function annotate(node, before_token = node.start) {
		        var comments = before_token.comments_before;
		        const comments_outside_parens = outer_comments_before_counts.get(before_token);
		        var i = comments_outside_parens != null ? comments_outside_parens : comments.length;
		        while (--i >= 0) {
		            var comment = comments[i];
		            if (/[@#]__/.test(comment.value)) {
		                if (/[@#]__PURE__/.test(comment.value)) {
		                    set_annotation(node, _PURE);
		                    break;
		                }
		                if (/[@#]__INLINE__/.test(comment.value)) {
		                    set_annotation(node, _INLINE);
		                    break;
		                }
		                if (/[@#]__NOINLINE__/.test(comment.value)) {
		                    set_annotation(node, _NOINLINE);
		                    break;
		                }
		                if (/[@#]__KEY__/.test(comment.value)) {
		                    set_annotation(node, _KEY);
		                    break;
		                }
		                if (/[@#]__MANGLE_PROP__/.test(comment.value)) {
		                    set_annotation(node, _MANGLEPROP);
		                    break;
		                }
		            }
		        }
		        return node;
		    }

		    var subscripts = function(expr, allow_calls, is_chain) {
		        var start = expr.start;
		        if (is("punc", ".")) {
		            next();
		            if(is("privatename") && !S.in_class) 
		                croak("Private field must be used in an enclosing class");
		            const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
		            return annotate(subscripts(new AST_DotVariant({
		                start      : start,
		                expression : expr,
		                optional   : false,
		                property   : as_name(),
		                end        : prev()
		            }), allow_calls, is_chain));
		        }
		        if (is("punc", "[")) {
		            next();
		            var prop = expression(true);
		            expect("]");
		            return annotate(subscripts(new AST_Sub({
		                start      : start,
		                expression : expr,
		                optional   : false,
		                property   : prop,
		                end        : prev()
		            }), allow_calls, is_chain));
		        }
		        if (allow_calls && is("punc", "(")) {
		            next();
		            var call = new AST_Call({
		                start      : start,
		                expression : expr,
		                optional   : false,
		                args       : call_args(),
		                end        : prev()
		            });
		            annotate(call);
		            return subscripts(call, true, is_chain);
		        }

		        if (is("punc", "?.")) {
		            next();

		            let chain_contents;

		            if (allow_calls && is("punc", "(")) {
		                next();

		                const call = new AST_Call({
		                    start,
		                    optional: true,
		                    expression: expr,
		                    args: call_args(),
		                    end: prev()
		                });
		                annotate(call);

		                chain_contents = subscripts(call, true, true);
		            } else if (is("name") || is("privatename")) {
		                if(is("privatename") && !S.in_class) 
		                    croak("Private field must be used in an enclosing class");
		                const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
		                chain_contents = annotate(subscripts(new AST_DotVariant({
		                    start,
		                    expression: expr,
		                    optional: true,
		                    property: as_name(),
		                    end: prev()
		                }), allow_calls, true));
		            } else if (is("punc", "[")) {
		                next();
		                const property = expression(true);
		                expect("]");
		                chain_contents = annotate(subscripts(new AST_Sub({
		                    start,
		                    expression: expr,
		                    optional: true,
		                    property,
		                    end: prev()
		                }), allow_calls, true));
		            }

		            if (!chain_contents) unexpected();

		            if (chain_contents instanceof AST_Chain) return chain_contents;

		            return new AST_Chain({
		                start,
		                expression: chain_contents,
		                end: prev()
		            });
		        }

		        if (is("template_head")) {
		            if (is_chain) {
		                // a?.b`c` is a syntax error
		                unexpected();
		            }

		            return subscripts(new AST_PrefixedTemplateString({
		                start: start,
		                prefix: expr,
		                template_string: template_string(),
		                end: prev()
		            }), allow_calls);
		        }
		        return expr;
		    };

		    function call_args() {
		        var args = [];
		        while (!is("punc", ")")) {
		            if (is("expand", "...")) {
		                next();
		                args.push(new AST_Expansion({
		                    start: prev(),
		                    expression: expression(false),
		                    end: prev()
		                }));
		            } else {
		                args.push(expression(false));
		            }
		            if (!is("punc", ")")) {
		                expect(",");
		            }
		        }
		        next();
		        return args;
		    }

		    var maybe_unary = function(allow_calls, allow_arrows) {
		        var start = S.token;
		        if (start.type == "name" && start.value == "await" && can_await()) {
		            next();
		            return _await_expression();
		        }
		        if (is("operator") && UNARY_PREFIX.has(start.value)) {
		            next();
		            handle_regexp();
		            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));
		            ex.start = start;
		            ex.end = prev();
		            return ex;
		        }
		        var val = expr_atom(allow_calls, allow_arrows);
		        while (is("operator") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {
		            if (val instanceof AST_Arrow) unexpected();
		            val = make_unary(AST_UnaryPostfix, S.token, val);
		            val.start = start;
		            val.end = S.token;
		            next();
		        }
		        return val;
		    };

		    function make_unary(ctor, token, expr) {
		        var op = token.value;
		        switch (op) {
		          case "++":
		          case "--":
		            if (!is_assignable(expr))
		                croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
		            break;
		          case "delete":
		            if (expr instanceof AST_SymbolRef && S.input.has_directive("use strict"))
		                croak("Calling delete on expression not allowed in strict mode", expr.start.line, expr.start.col, expr.start.pos);
		            break;
		        }
		        return new ctor({ operator: op, expression: expr });
		    }

		    var expr_op = function(left, min_prec, no_in) {
		        var op = is("operator") ? S.token.value : null;
		        if (op == "in" && no_in) op = null;
		        if (op == "**" && left instanceof AST_UnaryPrefix
		            /* unary token in front not allowed - parenthesis required */
		            && !is_token(left.start, "punc", "(")
		            && left.operator !== "--" && left.operator !== "++")
		                unexpected(left.start);
		        var prec = op != null ? PRECEDENCE[op] : null;
		        if (prec != null && (prec > min_prec || (op === "**" && min_prec === prec))) {
		            next();
		            var right = expr_op(maybe_unary(true), prec, no_in);
		            return expr_op(new AST_Binary({
		                start    : left.start,
		                left     : left,
		                operator : op,
		                right    : right,
		                end      : right.end
		            }), min_prec, no_in);
		        }
		        return left;
		    };

		    function expr_ops(no_in) {
		        return expr_op(maybe_unary(true, true), 0, no_in);
		    }

		    var maybe_conditional = function(no_in) {
		        var start = S.token;
		        var expr = expr_ops(no_in);
		        if (is("operator", "?")) {
		            next();
		            var yes = expression(false);
		            expect(":");
		            return new AST_Conditional({
		                start       : start,
		                condition   : expr,
		                consequent  : yes,
		                alternative : expression(false, no_in),
		                end         : prev()
		            });
		        }
		        return expr;
		    };

		    function is_assignable(expr) {
		        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
		    }

		    function to_destructuring(node) {
		        if (node instanceof AST_Object) {
		            node = new AST_Destructuring({
		                start: node.start,
		                names: node.properties.map(to_destructuring),
		                is_array: false,
		                end: node.end
		            });
		        } else if (node instanceof AST_Array) {
		            var names = [];

		            for (var i = 0; i < node.elements.length; i++) {
		                // Only allow expansion as last element
		                if (node.elements[i] instanceof AST_Expansion) {
		                    if (i + 1 !== node.elements.length) {
		                        token_error(node.elements[i].start, "Spread must the be last element in destructuring array");
		                    }
		                    node.elements[i].expression = to_destructuring(node.elements[i].expression);
		                }

		                names.push(to_destructuring(node.elements[i]));
		            }

		            node = new AST_Destructuring({
		                start: node.start,
		                names: names,
		                is_array: true,
		                end: node.end
		            });
		        } else if (node instanceof AST_ObjectProperty) {
		            node.value = to_destructuring(node.value);
		        } else if (node instanceof AST_Assign) {
		            node = new AST_DefaultAssign({
		                start: node.start,
		                left: node.left,
		                operator: "=",
		                right: node.right,
		                end: node.end
		            });
		        }
		        return node;
		    }

		    // In ES6, AssignmentExpression can also be an ArrowFunction
		    var maybe_assign = function(no_in) {
		        handle_regexp();
		        var start = S.token;

		        if (start.type == "name" && start.value == "yield") {
		            if (is_in_generator()) {
		                next();
		                return _yield_expression();
		            } else if (S.input.has_directive("use strict")) {
		                token_error(S.token, "Unexpected yield identifier inside strict mode");
		            }
		        }

		        var left = maybe_conditional(no_in);
		        var val = S.token.value;

		        if (is("operator") && ASSIGNMENT.has(val)) {
		            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {
		                next();

		                return new AST_Assign({
		                    start    : start,
		                    left     : left,
		                    operator : val,
		                    right    : maybe_assign(no_in),
		                    logical  : LOGICAL_ASSIGNMENT.has(val),
		                    end      : prev()
		                });
		            }
		            croak("Invalid assignment");
		        }
		        return left;
		    };

		    var expression = function(commas, no_in) {
		        var start = S.token;
		        var exprs = [];
		        while (true) {
		            exprs.push(maybe_assign(no_in));
		            if (!commas || !is("punc", ",")) break;
		            next();
		            commas = true;
		        }
		        return exprs.length == 1 ? exprs[0] : new AST_Sequence({
		            start       : start,
		            expressions : exprs,
		            end         : peek()
		        });
		    };

		    function in_loop(cont) {
		        ++S.in_loop;
		        var ret = cont();
		        --S.in_loop;
		        return ret;
		    }

		    if (options.expression) {
		        return expression(true);
		    }

		    return (function parse_toplevel() {
		        var start = S.token;
		        var body = [];
		        S.input.push_directives_stack();
		        if (options.module) S.input.add_directive("use strict");
		        while (!is("eof")) {
		            body.push(statement());
		        }
		        S.input.pop_directives_stack();
		        var end = prev();
		        var toplevel = options.toplevel;
		        if (toplevel) {
		            toplevel.body = toplevel.body.concat(body);
		            toplevel.end = end;
		        } else {
		            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
		        }
		        TEMPLATE_RAWS = new Map();
		        return toplevel;
		    })();

		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function DEFNODE(type, props, ctor, methods, base = AST_Node) {
		    if (!props) props = [];
		    else props = props.split(/\s+/);
		    var self_props = props;
		    if (base && base.PROPS)
		        props = props.concat(base.PROPS);
		    const proto = base && Object.create(base.prototype);
		    if (proto) {
		        ctor.prototype = proto;
		        ctor.BASE = base;
		    }
		    if (base) base.SUBCLASSES.push(ctor);
		    ctor.prototype.CTOR = ctor;
		    ctor.prototype.constructor = ctor;
		    ctor.PROPS = props || null;
		    ctor.SELF_PROPS = self_props;
		    ctor.SUBCLASSES = [];
		    if (type) {
		        ctor.prototype.TYPE = ctor.TYPE = type;
		    }
		    if (methods) for (let i in methods) if (HOP(methods, i)) {
		        if (i[0] === "$") {
		            ctor[i.substr(1)] = methods[i];
		        } else {
		            ctor.prototype[i] = methods[i];
		        }
		    }
		    ctor.DEFMETHOD = function(name, method) {
		        this.prototype[name] = method;
		    };
		    return ctor;
		}

		const has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);
		const set_tok_flag = (tok, flag, truth) => {
		    if (truth) {
		        tok.flags |= flag;
		    } else {
		        tok.flags &= ~flag;
		    }
		};

		const TOK_FLAG_NLB          = 0b0001;
		const TOK_FLAG_QUOTE_SINGLE = 0b0010;
		const TOK_FLAG_QUOTE_EXISTS = 0b0100;
		const TOK_FLAG_TEMPLATE_END = 0b1000;

		class AST_Token {
		    constructor(type, value, line, col, pos, nlb, comments_before, comments_after, file) {
		        this.flags = (nlb ? 1 : 0);

		        this.type = type;
		        this.value = value;
		        this.line = line;
		        this.col = col;
		        this.pos = pos;
		        this.comments_before = comments_before;
		        this.comments_after = comments_after;
		        this.file = file;

		        Object.seal(this);
		    }

		    // Return a string summary of the token for node.js console.log
		    [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
		        const special = str => options.stylize(str, "special");
		        const quote = typeof this.value === "string" && this.value.includes("`") ? "'" : "`";
		        const value = `${quote}${this.value}${quote}`;
		        return `${special("[AST_Token")} ${value} at ${this.line}:${this.col}${special("]")}`;
		    }

		    get nlb() {
		        return has_tok_flag(this, TOK_FLAG_NLB);
		    }

		    set nlb(new_nlb) {
		        set_tok_flag(this, TOK_FLAG_NLB, new_nlb);
		    }

		    get quote() {
		        return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS)
		            ? ""
		            : (has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? "'" : '"');
		    }

		    set quote(quote_type) {
		        set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === "'");
		        set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);
		    }

		    get template_end() {
		        return has_tok_flag(this, TOK_FLAG_TEMPLATE_END);
		    }

		    set template_end(new_template_end) {
		        set_tok_flag(this, TOK_FLAG_TEMPLATE_END, new_template_end);
		    }
		}

		var AST_Node = DEFNODE("Node", "start end", function AST_Node(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    _clone: function(deep) {
		        if (deep) {
		            var self = this.clone();
		            return self.transform(new TreeTransformer(function(node) {
		                if (node !== self) {
		                    return node.clone(true);
		                }
		            }));
		        }
		        return new this.CTOR(this);
		    },
		    clone: function(deep) {
		        return this._clone(deep);
		    },
		    $documentation: "Base class of all AST nodes",
		    $propdoc: {
		        start: "[AST_Token] The first token of this node",
		        end: "[AST_Token] The last token of this node"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this);
		    },
		    walk: function(visitor) {
		        return this._walk(visitor); // not sure the indirection will be any help
		    },
		    _children_backwards: () => {}
		}, null);

		/* -----[ statements ]----- */

		var AST_Statement = DEFNODE("Statement", null, function AST_Statement(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class of all statements",
		});

		var AST_Debugger = DEFNODE("Debugger", null, function AST_Debugger(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Represents a debugger statement",
		}, AST_Statement);

		var AST_Directive = DEFNODE("Directive", "value quote", function AST_Directive(props) {
		    if (props) {
		        this.value = props.value;
		        this.quote = props.quote;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Represents a directive, like \"use strict\";",
		    $propdoc: {
		        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
		        quote: "[string] the original quote character"
		    },
		}, AST_Statement);

		var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", function AST_SimpleStatement(props) {
		    if (props) {
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
		    $propdoc: {
		        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		    }
		}, AST_Statement);

		function walk_body(node, visitor) {
		    const body = node.body;
		    for (var i = 0, len = body.length; i < len; i++) {
		        body[i]._walk(visitor);
		    }
		}

		function clone_block_scope(deep) {
		    var clone = this._clone(deep);
		    if (this.block_scope) {
		        clone.block_scope = this.block_scope.clone();
		    }
		    return clone;
		}

		var AST_Block = DEFNODE("Block", "body block_scope", function AST_Block(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A body of statements (usually braced)",
		    $propdoc: {
		        body: "[AST_Statement*] an array of statements",
		        block_scope: "[AST_Scope] the block scope"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            walk_body(this, visitor);
		        });
		    },
		    _children_backwards(push) {
		        let i = this.body.length;
		        while (i--) push(this.body[i]);
		    },
		    clone: clone_block_scope
		}, AST_Statement);

		var AST_BlockStatement = DEFNODE("BlockStatement", null, function AST_BlockStatement(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A block statement",
		}, AST_Block);

		var AST_EmptyStatement = DEFNODE("EmptyStatement", null, function AST_EmptyStatement(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The empty statement (empty block or simply a semicolon)"
		}, AST_Statement);

		var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", function AST_StatementWithBody(props) {
		    if (props) {
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
		    $propdoc: {
		        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
		    }
		}, AST_Statement);

		var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", function AST_LabeledStatement(props) {
		    if (props) {
		        this.label = props.label;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Statement with a label",
		    $propdoc: {
		        label: "[AST_Label] a label definition"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.label._walk(visitor);
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		        push(this.label);
		    },
		    clone: function(deep) {
		        var node = this._clone(deep);
		        if (deep) {
		            var label = node.label;
		            var def = this.label;
		            node.walk(new TreeWalker(function(node) {
		                if (node instanceof AST_LoopControl
		                    && node.label && node.label.thedef === def) {
		                    node.label.thedef = label;
		                    label.references.push(node);
		                }
		            }));
		        }
		        return node;
		    }
		}, AST_StatementWithBody);

		var AST_IterationStatement = DEFNODE(
		    "IterationStatement",
		    "block_scope",
		    function AST_IterationStatement(props) {
		        if (props) {
		            this.block_scope = props.block_scope;
		            this.body = props.body;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Internal class.  All loops inherit from it.",
		        $propdoc: {
		            block_scope: "[AST_Scope] the block scope for this iteration statement."
		        },
		        clone: clone_block_scope
		    },
		    AST_StatementWithBody
		);

		var AST_DWLoop = DEFNODE("DWLoop", "condition", function AST_DWLoop(props) {
		    if (props) {
		        this.condition = props.condition;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for do/while statements",
		    $propdoc: {
		        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
		    }
		}, AST_IterationStatement);

		var AST_Do = DEFNODE("Do", null, function AST_Do(props) {
		    if (props) {
		        this.condition = props.condition;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `do` statement",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.body._walk(visitor);
		            this.condition._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.condition);
		        push(this.body);
		    }
		}, AST_DWLoop);

		var AST_While = DEFNODE("While", null, function AST_While(props) {
		    if (props) {
		        this.condition = props.condition;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `while` statement",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.condition._walk(visitor);
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		        push(this.condition);
		    },
		}, AST_DWLoop);

		var AST_For = DEFNODE("For", "init condition step", function AST_For(props) {
		    if (props) {
		        this.init = props.init;
		        this.condition = props.condition;
		        this.step = props.step;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `for` statement",
		    $propdoc: {
		        init: "[AST_Node?] the `for` initialization code, or null if empty",
		        condition: "[AST_Node?] the `for` termination clause, or null if empty",
		        step: "[AST_Node?] the `for` update clause, or null if empty"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            if (this.init) this.init._walk(visitor);
		            if (this.condition) this.condition._walk(visitor);
		            if (this.step) this.step._walk(visitor);
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		        if (this.step) push(this.step);
		        if (this.condition) push(this.condition);
		        if (this.init) push(this.init);
		    },
		}, AST_IterationStatement);

		var AST_ForIn = DEFNODE("ForIn", "init object", function AST_ForIn(props) {
		    if (props) {
		        this.init = props.init;
		        this.object = props.object;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `for ... in` statement",
		    $propdoc: {
		        init: "[AST_Node] the `for/in` initialization code",
		        object: "[AST_Node] the object that we're looping through"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.init._walk(visitor);
		            this.object._walk(visitor);
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		        if (this.object) push(this.object);
		        if (this.init) push(this.init);
		    },
		}, AST_IterationStatement);

		var AST_ForOf = DEFNODE("ForOf", "await", function AST_ForOf(props) {
		    if (props) {
		        this.await = props.await;
		        this.init = props.init;
		        this.object = props.object;
		        this.block_scope = props.block_scope;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `for ... of` statement",
		}, AST_ForIn);

		var AST_With = DEFNODE("With", "expression", function AST_With(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `with` statement",
		    $propdoc: {
		        expression: "[AST_Node] the `with` expression"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		            this.body._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.body);
		        push(this.expression);
		    },
		}, AST_StatementWithBody);

		/* -----[ scope and functions ]----- */

		var AST_Scope = DEFNODE(
		    "Scope",
		    "variables uses_with uses_eval parent_scope enclosed cname",
		    function AST_Scope(props) {
		        if (props) {
		            this.variables = props.variables;
		            this.uses_with = props.uses_with;
		            this.uses_eval = props.uses_eval;
		            this.parent_scope = props.parent_scope;
		            this.enclosed = props.enclosed;
		            this.cname = props.cname;
		            this.body = props.body;
		            this.block_scope = props.block_scope;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Base class for all statements introducing a lexical scope",
		        $propdoc: {
		            variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
		            uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
		            uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
		            parent_scope: "[AST_Scope?/S] link to the parent scope",
		            enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
		            cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
		        },
		        get_defun_scope: function() {
		            var self = this;
		            while (self.is_block_scope()) {
		                self = self.parent_scope;
		            }
		            return self;
		        },
		        clone: function(deep, toplevel) {
		            var node = this._clone(deep);
		            if (deep && this.variables && toplevel && !this._block_scope) {
		                node.figure_out_scope({}, {
		                    toplevel: toplevel,
		                    parent_scope: this.parent_scope
		                });
		            } else {
		                if (this.variables) node.variables = new Map(this.variables);
		                if (this.enclosed) node.enclosed = this.enclosed.slice();
		                if (this._block_scope) node._block_scope = this._block_scope;
		            }
		            return node;
		        },
		        pinned: function() {
		            return this.uses_eval || this.uses_with;
		        }
		    },
		    AST_Block
		);

		var AST_Toplevel = DEFNODE("Toplevel", "globals", function AST_Toplevel(props) {
		    if (props) {
		        this.globals = props.globals;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The toplevel scope",
		    $propdoc: {
		        globals: "[Map/S] a map of name -> SymbolDef for all undeclared names",
		    },
		    wrap_commonjs: function(name) {
		        var body = this.body;
		        var wrapped_tl = "(function(exports){'$ORIG';})(typeof " + name + "=='undefined'?(" + name + "={}):" + name + ");";
		        wrapped_tl = parse(wrapped_tl);
		        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
		            if (node instanceof AST_Directive && node.value == "$ORIG") {
		                return MAP.splice(body);
		            }
		        }));
		        return wrapped_tl;
		    },
		    wrap_enclose: function(args_values) {
		        if (typeof args_values != "string") args_values = "";
		        var index = args_values.indexOf(":");
		        if (index < 0) index = args_values.length;
		        var body = this.body;
		        return parse([
		            "(function(",
		            args_values.slice(0, index),
		            '){"$ORIG"})(',
		            args_values.slice(index + 1),
		            ")"
		        ].join("")).transform(new TreeTransformer(function(node) {
		            if (node instanceof AST_Directive && node.value == "$ORIG") {
		                return MAP.splice(body);
		            }
		        }));
		    }
		}, AST_Scope);

		var AST_Expansion = DEFNODE("Expansion", "expression", function AST_Expansion(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
		    $propdoc: {
		        expression: "[AST_Node] the thing to be expanded"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression.walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		});

		var AST_Lambda = DEFNODE(
		    "Lambda",
		    "name argnames uses_arguments is_generator async",
		    function AST_Lambda(props) {
		        if (props) {
		            this.name = props.name;
		            this.argnames = props.argnames;
		            this.uses_arguments = props.uses_arguments;
		            this.is_generator = props.is_generator;
		            this.async = props.async;
		            this.variables = props.variables;
		            this.uses_with = props.uses_with;
		            this.uses_eval = props.uses_eval;
		            this.parent_scope = props.parent_scope;
		            this.enclosed = props.enclosed;
		            this.cname = props.cname;
		            this.body = props.body;
		            this.block_scope = props.block_scope;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Base class for functions",
		        $propdoc: {
		            name: "[AST_SymbolDeclaration?] the name of this function",
		            argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
		            uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
		            is_generator: "[boolean] is this a generator method",
		            async: "[boolean] is this method async",
		        },
		        args_as_names: function () {
		            var out = [];
		            for (var i = 0; i < this.argnames.length; i++) {
		                if (this.argnames[i] instanceof AST_Destructuring) {
		                    out.push(...this.argnames[i].all_symbols());
		                } else {
		                    out.push(this.argnames[i]);
		                }
		            }
		            return out;
		        },
		        _walk: function(visitor) {
		            return visitor._visit(this, function() {
		                if (this.name) this.name._walk(visitor);
		                var argnames = this.argnames;
		                for (var i = 0, len = argnames.length; i < len; i++) {
		                    argnames[i]._walk(visitor);
		                }
		                walk_body(this, visitor);
		            });
		        },
		        _children_backwards(push) {
		            let i = this.body.length;
		            while (i--) push(this.body[i]);

		            i = this.argnames.length;
		            while (i--) push(this.argnames[i]);

		            if (this.name) push(this.name);
		        },
		        is_braceless() {
		            return this.body[0] instanceof AST_Return && this.body[0].value;
		        },
		        // Default args and expansion don't count, so .argnames.length doesn't cut it
		        length_property() {
		            let length = 0;

		            for (const arg of this.argnames) {
		                if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {
		                    length++;
		                }
		            }

		            return length;
		        }
		    },
		    AST_Scope
		);

		var AST_Accessor = DEFNODE("Accessor", null, function AST_Accessor(props) {
		    if (props) {
		        this.name = props.name;
		        this.argnames = props.argnames;
		        this.uses_arguments = props.uses_arguments;
		        this.is_generator = props.is_generator;
		        this.async = props.async;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A setter/getter function.  The `name` property is always null."
		}, AST_Lambda);

		var AST_Function = DEFNODE("Function", null, function AST_Function(props) {
		    if (props) {
		        this.name = props.name;
		        this.argnames = props.argnames;
		        this.uses_arguments = props.uses_arguments;
		        this.is_generator = props.is_generator;
		        this.async = props.async;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A function expression"
		}, AST_Lambda);

		var AST_Arrow = DEFNODE("Arrow", null, function AST_Arrow(props) {
		    if (props) {
		        this.name = props.name;
		        this.argnames = props.argnames;
		        this.uses_arguments = props.uses_arguments;
		        this.is_generator = props.is_generator;
		        this.async = props.async;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An ES6 Arrow function ((a) => b)"
		}, AST_Lambda);

		var AST_Defun = DEFNODE("Defun", null, function AST_Defun(props) {
		    if (props) {
		        this.name = props.name;
		        this.argnames = props.argnames;
		        this.uses_arguments = props.uses_arguments;
		        this.is_generator = props.is_generator;
		        this.async = props.async;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A function definition"
		}, AST_Lambda);

		/* -----[ DESTRUCTURING ]----- */
		var AST_Destructuring = DEFNODE("Destructuring", "names is_array", function AST_Destructuring(props) {
		    if (props) {
		        this.names = props.names;
		        this.is_array = props.is_array;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
		    $propdoc: {
		        "names": "[AST_Node*] Array of properties or elements",
		        "is_array": "[Boolean] Whether the destructuring represents an object or array"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.names.forEach(function(name) {
		                name._walk(visitor);
		            });
		        });
		    },
		    _children_backwards(push) {
		        let i = this.names.length;
		        while (i--) push(this.names[i]);
		    },
		    all_symbols: function() {
		        var out = [];
		        walk(this, node => {
		            if (node instanceof AST_SymbolDeclaration) {
		                out.push(node);
		            }
		            if (node instanceof AST_Lambda) {
		                return true;
		            }
		        });
		        return out;
		    }
		});

		var AST_PrefixedTemplateString = DEFNODE(
		    "PrefixedTemplateString",
		    "template_string prefix",
		    function AST_PrefixedTemplateString(props) {
		        if (props) {
		            this.template_string = props.template_string;
		            this.prefix = props.prefix;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
		        $propdoc: {
		            template_string: "[AST_TemplateString] The template string",
		            prefix: "[AST_Node] The prefix, which will get called."
		        },
		        _walk: function(visitor) {
		            return visitor._visit(this, function () {
		                this.prefix._walk(visitor);
		                this.template_string._walk(visitor);
		            });
		        },
		        _children_backwards(push) {
		            push(this.template_string);
		            push(this.prefix);
		        },
		    }
		);

		var AST_TemplateString = DEFNODE("TemplateString", "segments", function AST_TemplateString(props) {
		    if (props) {
		        this.segments = props.segments;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A template string literal",
		    $propdoc: {
		        segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.segments.forEach(function(seg) {
		                seg._walk(visitor);
		            });
		        });
		    },
		    _children_backwards(push) {
		        let i = this.segments.length;
		        while (i--) push(this.segments[i]);
		    }
		});

		var AST_TemplateSegment = DEFNODE("TemplateSegment", "value raw", function AST_TemplateSegment(props) {
		    if (props) {
		        this.value = props.value;
		        this.raw = props.raw;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A segment of a template string literal",
		    $propdoc: {
		        value: "Content of the segment",
		        raw: "Raw source of the segment",
		    }
		});

		/* -----[ JUMPS ]----- */

		var AST_Jump = DEFNODE("Jump", null, function AST_Jump(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
		}, AST_Statement);

		/** Base class for “exits” (`return` and `throw`) */
		var AST_Exit = DEFNODE("Exit", "value", function AST_Exit(props) {
		    if (props) {
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for “exits” (`return` and `throw`)",
		    $propdoc: {
		        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, this.value && function() {
		            this.value._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.value) push(this.value);
		    },
		}, AST_Jump);

		var AST_Return = DEFNODE("Return", null, function AST_Return(props) {
		    if (props) {
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `return` statement"
		}, AST_Exit);

		var AST_Throw = DEFNODE("Throw", null, function AST_Throw(props) {
		    if (props) {
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `throw` statement"
		}, AST_Exit);

		var AST_LoopControl = DEFNODE("LoopControl", "label", function AST_LoopControl(props) {
		    if (props) {
		        this.label = props.label;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for loop control statements (`break` and `continue`)",
		    $propdoc: {
		        label: "[AST_LabelRef?] the label, or null if none",
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, this.label && function() {
		            this.label._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.label) push(this.label);
		    },
		}, AST_Jump);

		var AST_Break = DEFNODE("Break", null, function AST_Break(props) {
		    if (props) {
		        this.label = props.label;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `break` statement"
		}, AST_LoopControl);

		var AST_Continue = DEFNODE("Continue", null, function AST_Continue(props) {
		    if (props) {
		        this.label = props.label;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `continue` statement"
		}, AST_LoopControl);

		var AST_Await = DEFNODE("Await", "expression", function AST_Await(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An `await` statement",
		    $propdoc: {
		        expression: "[AST_Node] the mandatory expression being awaited",
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		});

		var AST_Yield = DEFNODE("Yield", "expression is_star", function AST_Yield(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.is_star = props.is_star;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `yield` statement",
		    $propdoc: {
		        expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
		        is_star: "[Boolean] Whether this is a yield or yield* statement"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, this.expression && function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.expression) push(this.expression);
		    }
		});

		/* -----[ IF ]----- */

		var AST_If = DEFNODE("If", "condition alternative", function AST_If(props) {
		    if (props) {
		        this.condition = props.condition;
		        this.alternative = props.alternative;
		        this.body = props.body;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `if` statement",
		    $propdoc: {
		        condition: "[AST_Node] the `if` condition",
		        alternative: "[AST_Statement?] the `else` part, or null if not present"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.condition._walk(visitor);
		            this.body._walk(visitor);
		            if (this.alternative) this.alternative._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.alternative) {
		            push(this.alternative);
		        }
		        push(this.body);
		        push(this.condition);
		    }
		}, AST_StatementWithBody);

		/* -----[ SWITCH ]----- */

		var AST_Switch = DEFNODE("Switch", "expression", function AST_Switch(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `switch` statement",
		    $propdoc: {
		        expression: "[AST_Node] the `switch` “discriminant”"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		            walk_body(this, visitor);
		        });
		    },
		    _children_backwards(push) {
		        let i = this.body.length;
		        while (i--) push(this.body[i]);
		        push(this.expression);
		    }
		}, AST_Block);

		var AST_SwitchBranch = DEFNODE("SwitchBranch", null, function AST_SwitchBranch(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for `switch` branches",
		}, AST_Block);

		var AST_Default = DEFNODE("Default", null, function AST_Default(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `default` switch branch",
		}, AST_SwitchBranch);

		var AST_Case = DEFNODE("Case", "expression", function AST_Case(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `case` switch branch",
		    $propdoc: {
		        expression: "[AST_Node] the `case` expression"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		            walk_body(this, visitor);
		        });
		    },
		    _children_backwards(push) {
		        let i = this.body.length;
		        while (i--) push(this.body[i]);
		        push(this.expression);
		    },
		}, AST_SwitchBranch);

		/* -----[ EXCEPTIONS ]----- */

		var AST_Try = DEFNODE("Try", "body bcatch bfinally", function AST_Try(props) {
		    if (props) {
		        this.body = props.body;
		        this.bcatch = props.bcatch;
		        this.bfinally = props.bfinally;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `try` statement",
		    $propdoc: {
		        body: "[AST_TryBlock] the try block",
		        bcatch: "[AST_Catch?] the catch block, or null if not present",
		        bfinally: "[AST_Finally?] the finally block, or null if not present"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.body._walk(visitor);
		            if (this.bcatch) this.bcatch._walk(visitor);
		            if (this.bfinally) this.bfinally._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.bfinally) push(this.bfinally);
		        if (this.bcatch) push(this.bcatch);
		        push(this.body);
		    },
		}, AST_Statement);

		var AST_TryBlock = DEFNODE("TryBlock", null, function AST_TryBlock(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `try` block of a try statement"
		}, AST_Block);

		var AST_Catch = DEFNODE("Catch", "argname", function AST_Catch(props) {
		    if (props) {
		        this.argname = props.argname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
		    $propdoc: {
		        argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            if (this.argname) this.argname._walk(visitor);
		            walk_body(this, visitor);
		        });
		    },
		    _children_backwards(push) {
		        let i = this.body.length;
		        while (i--) push(this.body[i]);
		        if (this.argname) push(this.argname);
		    },
		}, AST_Block);

		var AST_Finally = DEFNODE("Finally", null, function AST_Finally(props) {
		    if (props) {
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
		}, AST_Block);

		/* -----[ VAR/CONST ]----- */

		var AST_Definitions = DEFNODE("Definitions", "definitions", function AST_Definitions(props) {
		    if (props) {
		        this.definitions = props.definitions;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
		    $propdoc: {
		        definitions: "[AST_VarDef*] array of variable definitions"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            var definitions = this.definitions;
		            for (var i = 0, len = definitions.length; i < len; i++) {
		                definitions[i]._walk(visitor);
		            }
		        });
		    },
		    _children_backwards(push) {
		        let i = this.definitions.length;
		        while (i--) push(this.definitions[i]);
		    },
		}, AST_Statement);

		var AST_Var = DEFNODE("Var", null, function AST_Var(props) {
		    if (props) {
		        this.definitions = props.definitions;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `var` statement"
		}, AST_Definitions);

		var AST_Let = DEFNODE("Let", null, function AST_Let(props) {
		    if (props) {
		        this.definitions = props.definitions;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `let` statement"
		}, AST_Definitions);

		var AST_Const = DEFNODE("Const", null, function AST_Const(props) {
		    if (props) {
		        this.definitions = props.definitions;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A `const` statement"
		}, AST_Definitions);

		var AST_VarDef = DEFNODE("VarDef", "name value", function AST_VarDef(props) {
		    if (props) {
		        this.name = props.name;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A variable declaration; only appears in a AST_Definitions node",
		    $propdoc: {
		        name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
		        value: "[AST_Node?] initializer, or null of there's no initializer"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.name._walk(visitor);
		            if (this.value) this.value._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.value) push(this.value);
		        push(this.name);
		    },
		    declarations_as_names() {
		        if (this.name instanceof AST_SymbolDeclaration) {
		            return [this];
		        } else {
		            return this.name.all_symbols();
		        }
		    }
		});

		var AST_NameMapping = DEFNODE("NameMapping", "foreign_name name", function AST_NameMapping(props) {
		    if (props) {
		        this.foreign_name = props.foreign_name;
		        this.name = props.name;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The part of the export/import statement that declare names from a module.",
		    $propdoc: {
		        foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
		        name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
		    },
		    _walk: function (visitor) {
		        return visitor._visit(this, function() {
		            this.foreign_name._walk(visitor);
		            this.name._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.name);
		        push(this.foreign_name);
		    },
		});

		var AST_Import = DEFNODE(
		    "Import",
		    "imported_name imported_names module_name assert_clause",
		    function AST_Import(props) {
		        if (props) {
		            this.imported_name = props.imported_name;
		            this.imported_names = props.imported_names;
		            this.module_name = props.module_name;
		            this.assert_clause = props.assert_clause;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "An `import` statement",
		        $propdoc: {
		            imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
		            imported_names: "[AST_NameMapping*] The names of non-default imported variables",
		            module_name: "[AST_String] String literal describing where this module came from",
		            assert_clause: "[AST_Object?] The import assertion"
		        },
		        _walk: function(visitor) {
		            return visitor._visit(this, function() {
		                if (this.imported_name) {
		                    this.imported_name._walk(visitor);
		                }
		                if (this.imported_names) {
		                    this.imported_names.forEach(function(name_import) {
		                        name_import._walk(visitor);
		                    });
		                }
		                this.module_name._walk(visitor);
		            });
		        },
		        _children_backwards(push) {
		            push(this.module_name);
		            if (this.imported_names) {
		                let i = this.imported_names.length;
		                while (i--) push(this.imported_names[i]);
		            }
		            if (this.imported_name) push(this.imported_name);
		        },
		    }
		);

		var AST_ImportMeta = DEFNODE("ImportMeta", null, function AST_ImportMeta(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A reference to import.meta",
		});

		var AST_Export = DEFNODE(
		    "Export",
		    "exported_definition exported_value is_default exported_names module_name assert_clause",
		    function AST_Export(props) {
		        if (props) {
		            this.exported_definition = props.exported_definition;
		            this.exported_value = props.exported_value;
		            this.is_default = props.is_default;
		            this.exported_names = props.exported_names;
		            this.module_name = props.module_name;
		            this.assert_clause = props.assert_clause;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "An `export` statement",
		        $propdoc: {
		            exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
		            exported_value: "[AST_Node?] An exported value",
		            exported_names: "[AST_NameMapping*?] List of exported names",
		            module_name: "[AST_String?] Name of the file to load exports from",
		            is_default: "[Boolean] Whether this is the default exported value of this module",
		            assert_clause: "[AST_Object?] The import assertion"
		        },
		        _walk: function (visitor) {
		            return visitor._visit(this, function () {
		                if (this.exported_definition) {
		                    this.exported_definition._walk(visitor);
		                }
		                if (this.exported_value) {
		                    this.exported_value._walk(visitor);
		                }
		                if (this.exported_names) {
		                    this.exported_names.forEach(function(name_export) {
		                        name_export._walk(visitor);
		                    });
		                }
		                if (this.module_name) {
		                    this.module_name._walk(visitor);
		                }
		            });
		        },
		        _children_backwards(push) {
		            if (this.module_name) push(this.module_name);
		            if (this.exported_names) {
		                let i = this.exported_names.length;
		                while (i--) push(this.exported_names[i]);
		            }
		            if (this.exported_value) push(this.exported_value);
		            if (this.exported_definition) push(this.exported_definition);
		        }
		    },
		    AST_Statement
		);

		/* -----[ OTHER ]----- */

		var AST_Call = DEFNODE(
		    "Call",
		    "expression args optional _annotations",
		    function AST_Call(props) {
		        if (props) {
		            this.expression = props.expression;
		            this.args = props.args;
		            this.optional = props.optional;
		            this._annotations = props._annotations;
		            this.start = props.start;
		            this.end = props.end;
		            this.initialize();
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "A function call expression",
		        $propdoc: {
		            expression: "[AST_Node] expression to invoke as function",
		            args: "[AST_Node*] array of arguments",
		            optional: "[boolean] whether this is an optional call (IE ?.() )",
		            _annotations: "[number] bitfield containing information about the call"
		        },
		        initialize() {
		            if (this._annotations == null) this._annotations = 0;
		        },
		        _walk(visitor) {
		            return visitor._visit(this, function() {
		                var args = this.args;
		                for (var i = 0, len = args.length; i < len; i++) {
		                    args[i]._walk(visitor);
		                }
		                this.expression._walk(visitor);  // TODO why do we need to crawl this last?
		            });
		        },
		        _children_backwards(push) {
		            let i = this.args.length;
		            while (i--) push(this.args[i]);
		            push(this.expression);
		        },
		    }
		);

		var AST_New = DEFNODE("New", null, function AST_New(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.args = props.args;
		        this.optional = props.optional;
		        this._annotations = props._annotations;
		        this.start = props.start;
		        this.end = props.end;
		        this.initialize();
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
		}, AST_Call);

		var AST_Sequence = DEFNODE("Sequence", "expressions", function AST_Sequence(props) {
		    if (props) {
		        this.expressions = props.expressions;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A sequence expression (comma-separated expressions)",
		    $propdoc: {
		        expressions: "[AST_Node*] array of expressions (at least two)"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expressions.forEach(function(node) {
		                node._walk(visitor);
		            });
		        });
		    },
		    _children_backwards(push) {
		        let i = this.expressions.length;
		        while (i--) push(this.expressions[i]);
		    },
		});

		var AST_PropAccess = DEFNODE(
		    "PropAccess",
		    "expression property optional",
		    function AST_PropAccess(props) {
		        if (props) {
		            this.expression = props.expression;
		            this.property = props.property;
		            this.optional = props.optional;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
		        $propdoc: {
		            expression: "[AST_Node] the “container” expression",
		            property: "[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",

		            optional: "[boolean] whether this is an optional property access (IE ?.)"
		        }
		    }
		);

		var AST_Dot = DEFNODE("Dot", "quote", function AST_Dot(props) {
		    if (props) {
		        this.quote = props.quote;
		        this.expression = props.expression;
		        this.property = props.property;
		        this.optional = props.optional;
		        this._annotations = props._annotations;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A dotted property access expression",
		    $propdoc: {
		        quote: "[string] the original quote character when transformed from AST_Sub",
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		}, AST_PropAccess);

		var AST_DotHash = DEFNODE("DotHash", "", function AST_DotHash(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.property = props.property;
		        this.optional = props.optional;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A dotted property access to a private property",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		}, AST_PropAccess);

		var AST_Sub = DEFNODE("Sub", null, function AST_Sub(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.property = props.property;
		        this.optional = props.optional;
		        this._annotations = props._annotations;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		            this.property._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.property);
		        push(this.expression);
		    },
		}, AST_PropAccess);

		var AST_Chain = DEFNODE("Chain", "expression", function AST_Chain(props) {
		    if (props) {
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A chain expression like a?.b?.(c)?.[d]",
		    $propdoc: {
		        expression: "[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."
		    },
		    _walk: function (visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		});

		var AST_Unary = DEFNODE("Unary", "operator expression", function AST_Unary(props) {
		    if (props) {
		        this.operator = props.operator;
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for unary expressions",
		    $propdoc: {
		        operator: "[string] the operator",
		        expression: "[AST_Node] expression that this unary operator applies to"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.expression._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.expression);
		    },
		});

		var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, function AST_UnaryPrefix(props) {
		    if (props) {
		        this.operator = props.operator;
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
		}, AST_Unary);

		var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, function AST_UnaryPostfix(props) {
		    if (props) {
		        this.operator = props.operator;
		        this.expression = props.expression;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Unary postfix expression, i.e. `i++`"
		}, AST_Unary);

		var AST_Binary = DEFNODE("Binary", "operator left right", function AST_Binary(props) {
		    if (props) {
		        this.operator = props.operator;
		        this.left = props.left;
		        this.right = props.right;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Binary expression, i.e. `a + b`",
		    $propdoc: {
		        left: "[AST_Node] left-hand side expression",
		        operator: "[string] the operator",
		        right: "[AST_Node] right-hand side expression"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.left._walk(visitor);
		            this.right._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.right);
		        push(this.left);
		    },
		});

		var AST_Conditional = DEFNODE(
		    "Conditional",
		    "condition consequent alternative",
		    function AST_Conditional(props) {
		        if (props) {
		            this.condition = props.condition;
		            this.consequent = props.consequent;
		            this.alternative = props.alternative;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
		        $propdoc: {
		            condition: "[AST_Node]",
		            consequent: "[AST_Node]",
		            alternative: "[AST_Node]"
		        },
		        _walk: function(visitor) {
		            return visitor._visit(this, function() {
		                this.condition._walk(visitor);
		                this.consequent._walk(visitor);
		                this.alternative._walk(visitor);
		            });
		        },
		        _children_backwards(push) {
		            push(this.alternative);
		            push(this.consequent);
		            push(this.condition);
		        },
		    }
		);

		var AST_Assign = DEFNODE("Assign", "logical", function AST_Assign(props) {
		    if (props) {
		        this.logical = props.logical;
		        this.operator = props.operator;
		        this.left = props.left;
		        this.right = props.right;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An assignment expression — `a = b + 5`",
		    $propdoc: {
		        logical: "Whether it's a logical assignment"
		    }
		}, AST_Binary);

		var AST_DefaultAssign = DEFNODE("DefaultAssign", null, function AST_DefaultAssign(props) {
		    if (props) {
		        this.operator = props.operator;
		        this.left = props.left;
		        this.right = props.right;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A default assignment expression like in `(a = 3) => a`"
		}, AST_Binary);

		/* -----[ LITERALS ]----- */

		var AST_Array = DEFNODE("Array", "elements", function AST_Array(props) {
		    if (props) {
		        this.elements = props.elements;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An array literal",
		    $propdoc: {
		        elements: "[AST_Node*] array of elements"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            var elements = this.elements;
		            for (var i = 0, len = elements.length; i < len; i++) {
		                elements[i]._walk(visitor);
		            }
		        });
		    },
		    _children_backwards(push) {
		        let i = this.elements.length;
		        while (i--) push(this.elements[i]);
		    },
		});

		var AST_Object = DEFNODE("Object", "properties", function AST_Object(props) {
		    if (props) {
		        this.properties = props.properties;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An object literal",
		    $propdoc: {
		        properties: "[AST_ObjectProperty*] array of properties"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            var properties = this.properties;
		            for (var i = 0, len = properties.length; i < len; i++) {
		                properties[i]._walk(visitor);
		            }
		        });
		    },
		    _children_backwards(push) {
		        let i = this.properties.length;
		        while (i--) push(this.properties[i]);
		    },
		});

		var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", function AST_ObjectProperty(props) {
		    if (props) {
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for literal object properties",
		    $propdoc: {
		        key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
		        value: "[AST_Node] property value.  For getters and setters this is an AST_Accessor."
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            if (this.key instanceof AST_Node)
		                this.key._walk(visitor);
		            this.value._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.value);
		        if (this.key instanceof AST_Node) push(this.key);
		    }
		});

		var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", function AST_ObjectKeyVal(props) {
		    if (props) {
		        this.quote = props.quote;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A key: value object property",
		    $propdoc: {
		        quote: "[string] the original quote character"
		    },
		    computed_key() {
		        return this.key instanceof AST_Node;
		    }
		}, AST_ObjectProperty);

		var AST_PrivateSetter = DEFNODE("PrivateSetter", "static", function AST_PrivateSetter(props) {
		    if (props) {
		        this.static = props.static;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        static: "[boolean] whether this is a static private setter"
		    },
		    $documentation: "A private setter property",
		    computed_key() {
		        return false;
		    }
		}, AST_ObjectProperty);

		var AST_PrivateGetter = DEFNODE("PrivateGetter", "static", function AST_PrivateGetter(props) {
		    if (props) {
		        this.static = props.static;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        static: "[boolean] whether this is a static private getter"
		    },
		    $documentation: "A private getter property",
		    computed_key() {
		        return false;
		    }
		}, AST_ObjectProperty);

		var AST_ObjectSetter = DEFNODE("ObjectSetter", "quote static", function AST_ObjectSetter(props) {
		    if (props) {
		        this.quote = props.quote;
		        this.static = props.static;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        quote: "[string|undefined] the original quote character, if any",
		        static: "[boolean] whether this is a static setter (classes only)"
		    },
		    $documentation: "An object setter property",
		    computed_key() {
		        return !(this.key instanceof AST_SymbolMethod);
		    }
		}, AST_ObjectProperty);

		var AST_ObjectGetter = DEFNODE("ObjectGetter", "quote static", function AST_ObjectGetter(props) {
		    if (props) {
		        this.quote = props.quote;
		        this.static = props.static;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        quote: "[string|undefined] the original quote character, if any",
		        static: "[boolean] whether this is a static getter (classes only)"
		    },
		    $documentation: "An object getter property",
		    computed_key() {
		        return !(this.key instanceof AST_SymbolMethod);
		    }
		}, AST_ObjectProperty);

		var AST_ConciseMethod = DEFNODE(
		    "ConciseMethod",
		    "quote static is_generator async",
		    function AST_ConciseMethod(props) {
		        if (props) {
		            this.quote = props.quote;
		            this.static = props.static;
		            this.is_generator = props.is_generator;
		            this.async = props.async;
		            this.key = props.key;
		            this.value = props.value;
		            this.start = props.start;
		            this.end = props.end;
		            this._annotations = props._annotations;
		        }

		        this.flags = 0;
		    },
		    {
		        $propdoc: {
		            quote: "[string|undefined] the original quote character, if any",
		            static: "[boolean] is this method static (classes only)",
		            is_generator: "[boolean] is this a generator method",
		            async: "[boolean] is this method async",
		        },
		        $documentation: "An ES6 concise method inside an object or class",
		        computed_key() {
		            return !(this.key instanceof AST_SymbolMethod);
		        }
		    },
		    AST_ObjectProperty
		);

		var AST_PrivateMethod = DEFNODE("PrivateMethod", "", function AST_PrivateMethod(props) {
		    if (props) {
		        this.quote = props.quote;
		        this.static = props.static;
		        this.is_generator = props.is_generator;
		        this.async = props.async;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A private class method inside a class",
		}, AST_ConciseMethod);

		var AST_Class = DEFNODE("Class", "name extends properties", function AST_Class(props) {
		    if (props) {
		        this.name = props.name;
		        this.extends = props.extends;
		        this.properties = props.properties;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
		        extends: "[AST_Node]? optional parent class",
		        properties: "[AST_ObjectProperty*] array of properties"
		    },
		    $documentation: "An ES6 class",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            if (this.name) {
		                this.name._walk(visitor);
		            }
		            if (this.extends) {
		                this.extends._walk(visitor);
		            }
		            this.properties.forEach((prop) => prop._walk(visitor));
		        });
		    },
		    _children_backwards(push) {
		        let i = this.properties.length;
		        while (i--) push(this.properties[i]);
		        if (this.extends) push(this.extends);
		        if (this.name) push(this.name);
		    },
		    /** go through the bits that are executed instantly, not when the class is `new`'d. Doesn't walk the name. */
		    visit_nondeferred_class_parts(visitor) {
		        if (this.extends) {
		            this.extends._walk(visitor);
		        }
		        this.properties.forEach((prop) => {
		            if (prop instanceof AST_ClassStaticBlock) {
		                prop._walk(visitor);
		                return;
		            }
		            if (prop.computed_key()) {
		                visitor.push(prop);
		                prop.key._walk(visitor);
		                visitor.pop();
		            }
		            if ((prop instanceof AST_ClassPrivateProperty || prop instanceof AST_ClassProperty) && prop.static && prop.value) {
		                visitor.push(prop);
		                prop.value._walk(visitor);
		                visitor.pop();
		            }
		        });
		    },
		    /** go through the bits that are executed later, when the class is `new`'d or a static method is called */
		    visit_deferred_class_parts(visitor) {
		        this.properties.forEach((prop) => {
		            if (prop instanceof AST_ConciseMethod) {
		                prop.walk(visitor);
		            } else if (prop instanceof AST_ClassProperty && !prop.static && prop.value) {
		                visitor.push(prop);
		                prop.value._walk(visitor);
		                visitor.pop();
		            }
		        });
		    },
		}, AST_Scope /* TODO a class might have a scope but it's not a scope */);

		var AST_ClassProperty = DEFNODE("ClassProperty", "static quote", function AST_ClassProperty(props) {
		    if (props) {
		        this.static = props.static;
		        this.quote = props.quote;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A class property",
		    $propdoc: {
		        static: "[boolean] whether this is a static key",
		        quote: "[string] which quote is being used"
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            if (this.key instanceof AST_Node)
		                this.key._walk(visitor);
		            if (this.value instanceof AST_Node)
		                this.value._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        if (this.value instanceof AST_Node) push(this.value);
		        if (this.key instanceof AST_Node) push(this.key);
		    },
		    computed_key() {
		        return !(this.key instanceof AST_SymbolClassProperty);
		    }
		}, AST_ObjectProperty);

		var AST_ClassPrivateProperty = DEFNODE("ClassPrivateProperty", "", function AST_ClassPrivateProperty(props) {
		    if (props) {
		        this.static = props.static;
		        this.quote = props.quote;
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A class property for a private property",
		}, AST_ClassProperty);

		var AST_PrivateIn = DEFNODE("PrivateIn", "key value", function AST_PrivateIn(props) {
		    if (props) {
		        this.key = props.key;
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "An `in` binop when the key is private, eg #x in this",
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            this.key._walk(visitor);
		            this.value._walk(visitor);
		        });
		    },
		    _children_backwards(push) {
		        push(this.value);
		        push(this.key);
		    },
		});

		var AST_DefClass = DEFNODE("DefClass", null, function AST_DefClass(props) {
		    if (props) {
		        this.name = props.name;
		        this.extends = props.extends;
		        this.properties = props.properties;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A class definition",
		}, AST_Class);

		var AST_ClassStaticBlock = DEFNODE("ClassStaticBlock", "body block_scope", function AST_ClassStaticBlock (props) {
		    this.body = props.body;
		    this.block_scope = props.block_scope;
		    this.start = props.start;
		    this.end = props.end;
		}, {
		    $documentation: "A block containing statements to be executed in the context of the class",
		    $propdoc: {
		        body: "[AST_Statement*] an array of statements",
		    },
		    _walk: function(visitor) {
		        return visitor._visit(this, function() {
		            walk_body(this, visitor);
		        });
		    },
		    _children_backwards(push) {
		        let i = this.body.length;
		        while (i--) push(this.body[i]);
		    },
		    clone: clone_block_scope,
		    computed_key: () => false
		}, AST_Scope);

		var AST_ClassExpression = DEFNODE("ClassExpression", null, function AST_ClassExpression(props) {
		    if (props) {
		        this.name = props.name;
		        this.extends = props.extends;
		        this.properties = props.properties;
		        this.variables = props.variables;
		        this.uses_with = props.uses_with;
		        this.uses_eval = props.uses_eval;
		        this.parent_scope = props.parent_scope;
		        this.enclosed = props.enclosed;
		        this.cname = props.cname;
		        this.body = props.body;
		        this.block_scope = props.block_scope;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A class expression."
		}, AST_Class);

		var AST_Symbol = DEFNODE("Symbol", "scope name thedef", function AST_Symbol(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $propdoc: {
		        name: "[string] name of this symbol",
		        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
		        thedef: "[SymbolDef/S] the definition of this symbol"
		    },
		    $documentation: "Base class for all symbols"
		});

		var AST_NewTarget = DEFNODE("NewTarget", null, function AST_NewTarget(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A reference to new.target"
		});

		var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", function AST_SymbolDeclaration(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
		}, AST_Symbol);

		var AST_SymbolVar = DEFNODE("SymbolVar", null, function AST_SymbolVar(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol defining a variable",
		}, AST_SymbolDeclaration);

		var AST_SymbolBlockDeclaration = DEFNODE(
		    "SymbolBlockDeclaration",
		    null,
		    function AST_SymbolBlockDeclaration(props) {
		        if (props) {
		            this.init = props.init;
		            this.scope = props.scope;
		            this.name = props.name;
		            this.thedef = props.thedef;
		            this.start = props.start;
		            this.end = props.end;
		        }

		        this.flags = 0;
		    },
		    {
		        $documentation: "Base class for block-scoped declaration symbols"
		    },
		    AST_SymbolDeclaration
		);

		var AST_SymbolConst = DEFNODE("SymbolConst", null, function AST_SymbolConst(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A constant declaration"
		}, AST_SymbolBlockDeclaration);

		var AST_SymbolLet = DEFNODE("SymbolLet", null, function AST_SymbolLet(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A block-scoped `let` declaration"
		}, AST_SymbolBlockDeclaration);

		var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, function AST_SymbolFunarg(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming a function argument",
		}, AST_SymbolVar);

		var AST_SymbolDefun = DEFNODE("SymbolDefun", null, function AST_SymbolDefun(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol defining a function",
		}, AST_SymbolDeclaration);

		var AST_SymbolMethod = DEFNODE("SymbolMethod", null, function AST_SymbolMethod(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol in an object defining a method",
		}, AST_Symbol);

		var AST_SymbolClassProperty = DEFNODE("SymbolClassProperty", null, function AST_SymbolClassProperty(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol for a class property",
		}, AST_Symbol);

		var AST_SymbolLambda = DEFNODE("SymbolLambda", null, function AST_SymbolLambda(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming a function expression",
		}, AST_SymbolDeclaration);

		var AST_SymbolDefClass = DEFNODE("SymbolDefClass", null, function AST_SymbolDefClass(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
		}, AST_SymbolBlockDeclaration);

		var AST_SymbolClass = DEFNODE("SymbolClass", null, function AST_SymbolClass(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming a class's name. Lexically scoped to the class."
		}, AST_SymbolDeclaration);

		var AST_SymbolCatch = DEFNODE("SymbolCatch", null, function AST_SymbolCatch(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming the exception in catch",
		}, AST_SymbolBlockDeclaration);

		var AST_SymbolImport = DEFNODE("SymbolImport", null, function AST_SymbolImport(props) {
		    if (props) {
		        this.init = props.init;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol referring to an imported name",
		}, AST_SymbolBlockDeclaration);

		var AST_SymbolImportForeign = DEFNODE("SymbolImportForeign", null, function AST_SymbolImportForeign(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.quote = props.quote;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes",
		}, AST_Symbol);

		var AST_Label = DEFNODE("Label", "references", function AST_Label(props) {
		    if (props) {
		        this.references = props.references;
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		        this.initialize();
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol naming a label (declaration)",
		    $propdoc: {
		        references: "[AST_LoopControl*] a list of nodes referring to this label"
		    },
		    initialize: function() {
		        this.references = [];
		        this.thedef = this;
		    }
		}, AST_Symbol);

		var AST_SymbolRef = DEFNODE("SymbolRef", null, function AST_SymbolRef(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Reference to some symbol (not definition/declaration)",
		}, AST_Symbol);

		var AST_SymbolExport = DEFNODE("SymbolExport", null, function AST_SymbolExport(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.quote = props.quote;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Symbol referring to a name to export",
		}, AST_SymbolRef);

		var AST_SymbolExportForeign = DEFNODE("SymbolExportForeign", null, function AST_SymbolExportForeign(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.quote = props.quote;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes",
		}, AST_Symbol);

		var AST_LabelRef = DEFNODE("LabelRef", null, function AST_LabelRef(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Reference to a label symbol",
		}, AST_Symbol);

		var AST_SymbolPrivateProperty = DEFNODE("SymbolPrivateProperty", null, function AST_SymbolPrivateProperty(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A symbol that refers to a private property",
		}, AST_Symbol);

		var AST_This = DEFNODE("This", null, function AST_This(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `this` symbol",
		}, AST_Symbol);

		var AST_Super = DEFNODE("Super", null, function AST_Super(props) {
		    if (props) {
		        this.scope = props.scope;
		        this.name = props.name;
		        this.thedef = props.thedef;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `super` symbol",
		}, AST_This);

		var AST_Constant = DEFNODE("Constant", null, function AST_Constant(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for all constants",
		    getValue: function() {
		        return this.value;
		    }
		});

		var AST_String = DEFNODE("String", "value quote", function AST_String(props) {
		    if (props) {
		        this.value = props.value;
		        this.quote = props.quote;
		        this.start = props.start;
		        this.end = props.end;
		        this._annotations = props._annotations;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A string literal",
		    $propdoc: {
		        value: "[string] the contents of this string",
		        quote: "[string] the original quote character"
		    }
		}, AST_Constant);

		var AST_Number = DEFNODE("Number", "value raw", function AST_Number(props) {
		    if (props) {
		        this.value = props.value;
		        this.raw = props.raw;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A number literal",
		    $propdoc: {
		        value: "[number] the numeric value",
		        raw: "[string] numeric value as string"
		    }
		}, AST_Constant);

		var AST_BigInt = DEFNODE("BigInt", "value", function AST_BigInt(props) {
		    if (props) {
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A big int literal",
		    $propdoc: {
		        value: "[string] big int value"
		    }
		}, AST_Constant);

		var AST_RegExp = DEFNODE("RegExp", "value", function AST_RegExp(props) {
		    if (props) {
		        this.value = props.value;
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A regexp literal",
		    $propdoc: {
		        value: "[RegExp] the actual regexp",
		    }
		}, AST_Constant);

		var AST_Atom = DEFNODE("Atom", null, function AST_Atom(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for atoms",
		}, AST_Constant);

		var AST_Null = DEFNODE("Null", null, function AST_Null(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `null` atom",
		    value: null
		}, AST_Atom);

		var AST_NaN = DEFNODE("NaN", null, function AST_NaN(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The impossible value",
		    value: 0/0
		}, AST_Atom);

		var AST_Undefined = DEFNODE("Undefined", null, function AST_Undefined(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `undefined` value",
		    value: (function() {}())
		}, AST_Atom);

		var AST_Hole = DEFNODE("Hole", null, function AST_Hole(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "A hole in an array",
		    value: (function() {}())
		}, AST_Atom);

		var AST_Infinity = DEFNODE("Infinity", null, function AST_Infinity(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `Infinity` value",
		    value: 1/0
		}, AST_Atom);

		var AST_Boolean = DEFNODE("Boolean", null, function AST_Boolean(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "Base class for booleans",
		}, AST_Atom);

		var AST_False = DEFNODE("False", null, function AST_False(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `false` atom",
		    value: false
		}, AST_Boolean);

		var AST_True = DEFNODE("True", null, function AST_True(props) {
		    if (props) {
		        this.start = props.start;
		        this.end = props.end;
		    }

		    this.flags = 0;
		}, {
		    $documentation: "The `true` atom",
		    value: true
		}, AST_Boolean);

		/* -----[ Walk function ]---- */

		/**
		 * Walk nodes in depth-first search fashion.
		 * Callback can return `walk_abort` symbol to stop iteration.
		 * It can also return `true` to stop iteration just for child nodes.
		 * Iteration can be stopped and continued by passing the `to_visit` argument,
		 * which is given to the callback in the second argument.
		 **/
		function walk(node, cb, to_visit = [node]) {
		    const push = to_visit.push.bind(to_visit);
		    while (to_visit.length) {
		        const node = to_visit.pop();
		        const ret = cb(node, to_visit);

		        if (ret) {
		            if (ret === walk_abort) return true;
		            continue;
		        }

		        node._children_backwards(push);
		    }
		    return false;
		}

		/**
		 * Walks an AST node and its children.
		 *
		 * {cb} can return `walk_abort` to interrupt the walk.
		 *
		 * @param node
		 * @param cb {(node, info: { parent: (nth) => any }) => (boolean | undefined)}
		 *
		 * @returns {boolean} whether the walk was aborted
		 *
		 * @example
		 * const found_some_cond = walk_parent(my_ast_node, (node, { parent }) => {
		 *   if (some_cond(node, parent())) return walk_abort
		 * });
		 */
		function walk_parent(node, cb, initial_stack) {
		    const to_visit = [node];
		    const push = to_visit.push.bind(to_visit);
		    const stack = initial_stack ? initial_stack.slice() : [];
		    const parent_pop_indices = [];

		    let current;

		    const info = {
		        parent: (n = 0) => {
		            if (n === -1) {
		                return current;
		            }

		            // [ p1 p0 ] [ 1 0 ]
		            if (initial_stack && n >= stack.length) {
		                n -= stack.length;
		                return initial_stack[
		                    initial_stack.length - (n + 1)
		                ];
		            }

		            return stack[stack.length - (1 + n)];
		        },
		    };

		    while (to_visit.length) {
		        current = to_visit.pop();

		        while (
		            parent_pop_indices.length &&
		            to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]
		        ) {
		            stack.pop();
		            parent_pop_indices.pop();
		        }

		        const ret = cb(current, info);

		        if (ret) {
		            if (ret === walk_abort) return true;
		            continue;
		        }

		        const visit_length = to_visit.length;

		        current._children_backwards(push);

		        // Push only if we're going to traverse the children
		        if (to_visit.length > visit_length) {
		            stack.push(current);
		            parent_pop_indices.push(visit_length - 1);
		        }
		    }

		    return false;
		}

		const walk_abort = Symbol("abort walk");

		/* -----[ TreeWalker ]----- */

		class TreeWalker {
		    constructor(callback) {
		        this.visit = callback;
		        this.stack = [];
		        this.directives = Object.create(null);
		    }

		    _visit(node, descend) {
		        this.push(node);
		        var ret = this.visit(node, descend ? function() {
		            descend.call(node);
		        } : noop);
		        if (!ret && descend) {
		            descend.call(node);
		        }
		        this.pop();
		        return ret;
		    }

		    parent(n) {
		        return this.stack[this.stack.length - 2 - (n || 0)];
		    }

		    push(node) {
		        if (node instanceof AST_Lambda) {
		            this.directives = Object.create(this.directives);
		        } else if (node instanceof AST_Directive && !this.directives[node.value]) {
		            this.directives[node.value] = node;
		        } else if (node instanceof AST_Class) {
		            this.directives = Object.create(this.directives);
		            if (!this.directives["use strict"]) {
		                this.directives["use strict"] = node;
		            }
		        }
		        this.stack.push(node);
		    }

		    pop() {
		        var node = this.stack.pop();
		        if (node instanceof AST_Lambda || node instanceof AST_Class) {
		            this.directives = Object.getPrototypeOf(this.directives);
		        }
		    }

		    self() {
		        return this.stack[this.stack.length - 1];
		    }

		    find_parent(type) {
		        var stack = this.stack;
		        for (var i = stack.length; --i >= 0;) {
		            var x = stack[i];
		            if (x instanceof type) return x;
		        }
		    }

		    find_scope() {
		        var stack = this.stack;
		        for (var i = stack.length; --i >= 0;) {
		            const p = stack[i];
		            if (p instanceof AST_Toplevel) return p;
		            if (p instanceof AST_Lambda) return p;
		            if (p.block_scope) return p.block_scope;
		        }
		    }

		    has_directive(type) {
		        var dir = this.directives[type];
		        if (dir) return dir;
		        var node = this.stack[this.stack.length - 1];
		        if (node instanceof AST_Scope && node.body) {
		            for (var i = 0; i < node.body.length; ++i) {
		                var st = node.body[i];
		                if (!(st instanceof AST_Directive)) break;
		                if (st.value == type) return st;
		            }
		        }
		    }

		    loopcontrol_target(node) {
		        var stack = this.stack;
		        if (node.label) for (var i = stack.length; --i >= 0;) {
		            var x = stack[i];
		            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)
		                return x.body;
		        } else for (var i = stack.length; --i >= 0;) {
		            var x = stack[i];
		            if (x instanceof AST_IterationStatement
		                || node instanceof AST_Break && x instanceof AST_Switch)
		                return x;
		        }
		    }
		}

		// Tree transformer helpers.
		class TreeTransformer extends TreeWalker {
		    constructor(before, after) {
		        super();
		        this.before = before;
		        this.after = after;
		    }
		}

		const _PURE       = 0b00000001;
		const _INLINE     = 0b00000010;
		const _NOINLINE   = 0b00000100;
		const _KEY        = 0b00001000;
		const _MANGLEPROP = 0b00010000;

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function def_transform(node, descend) {
		    node.DEFMETHOD("transform", function(tw, in_list) {
		        let transformed = undefined;
		        tw.push(this);
		        if (tw.before) transformed = tw.before(this, descend, in_list);
		        if (transformed === undefined) {
		            transformed = this;
		            descend(transformed, tw);
		            if (tw.after) {
		                const after_ret = tw.after(transformed, in_list);
		                if (after_ret !== undefined) transformed = after_ret;
		            }
		        }
		        tw.pop();
		        return transformed;
		    });
		}

		def_transform(AST_Node, noop);

		def_transform(AST_LabeledStatement, function(self, tw) {
		    self.label = self.label.transform(tw);
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_SimpleStatement, function(self, tw) {
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_Block, function(self, tw) {
		    self.body = MAP(self.body, tw);
		});

		def_transform(AST_Do, function(self, tw) {
		    self.body = self.body.transform(tw);
		    self.condition = self.condition.transform(tw);
		});

		def_transform(AST_While, function(self, tw) {
		    self.condition = self.condition.transform(tw);
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_For, function(self, tw) {
		    if (self.init) self.init = self.init.transform(tw);
		    if (self.condition) self.condition = self.condition.transform(tw);
		    if (self.step) self.step = self.step.transform(tw);
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_ForIn, function(self, tw) {
		    self.init = self.init.transform(tw);
		    self.object = self.object.transform(tw);
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_With, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		    self.body = self.body.transform(tw);
		});

		def_transform(AST_Exit, function(self, tw) {
		    if (self.value) self.value = self.value.transform(tw);
		});

		def_transform(AST_LoopControl, function(self, tw) {
		    if (self.label) self.label = self.label.transform(tw);
		});

		def_transform(AST_If, function(self, tw) {
		    self.condition = self.condition.transform(tw);
		    self.body = self.body.transform(tw);
		    if (self.alternative) self.alternative = self.alternative.transform(tw);
		});

		def_transform(AST_Switch, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		    self.body = MAP(self.body, tw);
		});

		def_transform(AST_Case, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		    self.body = MAP(self.body, tw);
		});

		def_transform(AST_Try, function(self, tw) {
		    self.body = self.body.transform(tw);
		    if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
		    if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
		});

		def_transform(AST_Catch, function(self, tw) {
		    if (self.argname) self.argname = self.argname.transform(tw);
		    self.body = MAP(self.body, tw);
		});

		def_transform(AST_Definitions, function(self, tw) {
		    self.definitions = MAP(self.definitions, tw);
		});

		def_transform(AST_VarDef, function(self, tw) {
		    self.name = self.name.transform(tw);
		    if (self.value) self.value = self.value.transform(tw);
		});

		def_transform(AST_Destructuring, function(self, tw) {
		    self.names = MAP(self.names, tw);
		});

		def_transform(AST_Lambda, function(self, tw) {
		    if (self.name) self.name = self.name.transform(tw);
		    self.argnames = MAP(self.argnames, tw, /* allow_splicing */ false);
		    if (self.body instanceof AST_Node) {
		        self.body = self.body.transform(tw);
		    } else {
		        self.body = MAP(self.body, tw);
		    }
		});

		def_transform(AST_Call, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		    self.args = MAP(self.args, tw, /* allow_splicing */ false);
		});

		def_transform(AST_Sequence, function(self, tw) {
		    const result = MAP(self.expressions, tw);
		    self.expressions = result.length
		        ? result
		        : [new AST_Number({ value: 0 })];
		});

		def_transform(AST_PropAccess, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		});

		def_transform(AST_Sub, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		    self.property = self.property.transform(tw);
		});

		def_transform(AST_Chain, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		});

		def_transform(AST_Yield, function(self, tw) {
		    if (self.expression) self.expression = self.expression.transform(tw);
		});

		def_transform(AST_Await, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		});

		def_transform(AST_Unary, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		});

		def_transform(AST_Binary, function(self, tw) {
		    self.left = self.left.transform(tw);
		    self.right = self.right.transform(tw);
		});

		def_transform(AST_PrivateIn, function(self, tw) {
		    self.key = self.key.transform(tw);
		    self.value = self.value.transform(tw);
		});

		def_transform(AST_Conditional, function(self, tw) {
		    self.condition = self.condition.transform(tw);
		    self.consequent = self.consequent.transform(tw);
		    self.alternative = self.alternative.transform(tw);
		});

		def_transform(AST_Array, function(self, tw) {
		    self.elements = MAP(self.elements, tw);
		});

		def_transform(AST_Object, function(self, tw) {
		    self.properties = MAP(self.properties, tw);
		});

		def_transform(AST_ObjectProperty, function(self, tw) {
		    if (self.key instanceof AST_Node) {
		        self.key = self.key.transform(tw);
		    }
		    if (self.value) self.value = self.value.transform(tw);
		});

		def_transform(AST_Class, function(self, tw) {
		    if (self.name) self.name = self.name.transform(tw);
		    if (self.extends) self.extends = self.extends.transform(tw);
		    self.properties = MAP(self.properties, tw);
		});

		def_transform(AST_ClassStaticBlock, function(self, tw) {
		    self.body = MAP(self.body, tw);
		});

		def_transform(AST_Expansion, function(self, tw) {
		    self.expression = self.expression.transform(tw);
		});

		def_transform(AST_NameMapping, function(self, tw) {
		    self.foreign_name = self.foreign_name.transform(tw);
		    self.name = self.name.transform(tw);
		});

		def_transform(AST_Import, function(self, tw) {
		    if (self.imported_name) self.imported_name = self.imported_name.transform(tw);
		    if (self.imported_names) MAP(self.imported_names, tw);
		    self.module_name = self.module_name.transform(tw);
		});

		def_transform(AST_Export, function(self, tw) {
		    if (self.exported_definition) self.exported_definition = self.exported_definition.transform(tw);
		    if (self.exported_value) self.exported_value = self.exported_value.transform(tw);
		    if (self.exported_names) MAP(self.exported_names, tw);
		    if (self.module_name) self.module_name = self.module_name.transform(tw);
		});

		def_transform(AST_TemplateString, function(self, tw) {
		    self.segments = MAP(self.segments, tw);
		});

		def_transform(AST_PrefixedTemplateString, function(self, tw) {
		    self.prefix = self.prefix.transform(tw);
		    self.template_string = self.template_string.transform(tw);
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		(function() {

		    var normalize_directives = function(body) {
		        for (var i = 0; i < body.length; i++) {
		            if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {
		                body[i] = new AST_Directive({
		                    start: body[i].start,
		                    end: body[i].end,
		                    value: body[i].body.value
		                });
		            } else {
		                return body;
		            }
		        }

		        return body;
		    };

		    const assert_clause_from_moz = (assertions) => {
		        if (assertions && assertions.length > 0) {
		            return new AST_Object({
		                start: my_start_token(assertions),
		                end: my_end_token(assertions),
		                properties: assertions.map((assertion_kv) =>
		                    new AST_ObjectKeyVal({
		                        start: my_start_token(assertion_kv),
		                        end: my_end_token(assertion_kv),
		                        key: assertion_kv.key.name || assertion_kv.key.value,
		                        value: from_moz(assertion_kv.value)
		                    })
		                )
		            });
		        }
		        return null;
		    };

		    var MOZ_TO_ME = {
		        Program: function(M) {
		            return new AST_Toplevel({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                body: normalize_directives(M.body.map(from_moz))
		            });
		        },

		        ArrayPattern: function(M) {
		            return new AST_Destructuring({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                names: M.elements.map(function(elm) {
		                    if (elm === null) {
		                        return new AST_Hole();
		                    }
		                    return from_moz(elm);
		                }),
		                is_array: true
		            });
		        },

		        ObjectPattern: function(M) {
		            return new AST_Destructuring({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                names: M.properties.map(from_moz),
		                is_array: false
		            });
		        },

		        AssignmentPattern: function(M) {
		            return new AST_DefaultAssign({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                left: from_moz(M.left),
		                operator: "=",
		                right: from_moz(M.right)
		            });
		        },

		        SpreadElement: function(M) {
		            return new AST_Expansion({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.argument)
		            });
		        },

		        RestElement: function(M) {
		            return new AST_Expansion({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.argument)
		            });
		        },

		        TemplateElement: function(M) {
		            return new AST_TemplateSegment({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                value: M.value.cooked,
		                raw: M.value.raw
		            });
		        },

		        TemplateLiteral: function(M) {
		            var segments = [];
		            for (var i = 0; i < M.quasis.length; i++) {
		                segments.push(from_moz(M.quasis[i]));
		                if (M.expressions[i]) {
		                    segments.push(from_moz(M.expressions[i]));
		                }
		            }
		            return new AST_TemplateString({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                segments: segments
		            });
		        },

		        TaggedTemplateExpression: function(M) {
		            return new AST_PrefixedTemplateString({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                template_string: from_moz(M.quasi),
		                prefix: from_moz(M.tag)
		            });
		        },

		        FunctionDeclaration: function(M) {
		            return new AST_Defun({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                name: from_moz(M.id),
		                argnames: M.params.map(from_moz),
		                is_generator: M.generator,
		                async: M.async,
		                body: normalize_directives(from_moz(M.body).body)
		            });
		        },

		        FunctionExpression: function(M) {
		            return new AST_Function({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                name: from_moz(M.id),
		                argnames: M.params.map(from_moz),
		                is_generator: M.generator,
		                async: M.async,
		                body: normalize_directives(from_moz(M.body).body)
		            });
		        },

		        ArrowFunctionExpression: function(M) {
		            const body = M.body.type === "BlockStatement"
		                ? from_moz(M.body).body
		                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];
		            return new AST_Arrow({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                argnames: M.params.map(from_moz),
		                body,
		                async: M.async,
		            });
		        },

		        ExpressionStatement: function(M) {
		            return new AST_SimpleStatement({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                body: from_moz(M.expression)
		            });
		        },

		        TryStatement: function(M) {
		            var handlers = M.handlers || [M.handler];
		            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
		                throw new Error("Multiple catch clauses are not supported.");
		            }
		            return new AST_Try({
		                start    : my_start_token(M),
		                end      : my_end_token(M),
		                body     : new AST_TryBlock(from_moz(M.block)),
		                bcatch   : from_moz(handlers[0]),
		                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
		            });
		        },

		        Property: function(M) {
		            var key = M.key;
		            var args = {
		                start    : my_start_token(key || M.value),
		                end      : my_end_token(M.value),
		                key      : key.type == "Identifier" ? key.name : key.value,
		                value    : from_moz(M.value)
		            };
		            if (M.computed) {
		                args.key = from_moz(M.key);
		            }
		            if (M.method) {
		                args.is_generator = M.value.generator;
		                args.async = M.value.async;
		                if (!M.computed) {
		                    args.key = new AST_SymbolMethod({ name: args.key });
		                } else {
		                    args.key = from_moz(M.key);
		                }
		                return new AST_ConciseMethod(args);
		            }
		            if (M.kind == "init") {
		                if (key.type != "Identifier" && key.type != "Literal") {
		                    args.key = from_moz(key);
		                }
		                return new AST_ObjectKeyVal(args);
		            }
		            if (typeof args.key === "string" || typeof args.key === "number") {
		                args.key = new AST_SymbolMethod({
		                    name: args.key
		                });
		            }
		            args.value = new AST_Accessor(args.value);
		            if (M.kind == "get") return new AST_ObjectGetter(args);
		            if (M.kind == "set") return new AST_ObjectSetter(args);
		            if (M.kind == "method") {
		                args.async = M.value.async;
		                args.is_generator = M.value.generator;
		                args.quote = M.computed ? "\"" : null;
		                return new AST_ConciseMethod(args);
		            }
		        },

		        MethodDefinition: function(M) {
		            const is_private = M.key.type === "PrivateIdentifier";
		            const key = M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value });

		            var args = {
		                start    : my_start_token(M),
		                end      : my_end_token(M),
		                key,
		                value    : from_moz(M.value),
		                static   : M.static,
		            };
		            if (M.kind == "get") {
		                return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);
		            }
		            if (M.kind == "set") {
		                return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);
		            }
		            args.is_generator = M.value.generator;
		            args.async = M.value.async;
		            return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);
		        },

		        FieldDefinition: function(M) {
		            let key;
		            if (M.computed) {
		                key = from_moz(M.key);
		            } else {
		                if (M.key.type !== "Identifier") throw new Error("Non-Identifier key in FieldDefinition");
		                key = from_moz(M.key);
		            }
		            return new AST_ClassProperty({
		                start    : my_start_token(M),
		                end      : my_end_token(M),
		                key,
		                value    : from_moz(M.value),
		                static   : M.static,
		            });
		        },

		        PropertyDefinition: function(M) {
		            let key;
		            if (M.computed) {
		                key = from_moz(M.key);
		            } else if (M.key.type === "PrivateIdentifier") {
		                return new AST_ClassPrivateProperty({
		                    start    : my_start_token(M),
		                    end      : my_end_token(M),
		                    key      : from_moz(M.key),
		                    value    : from_moz(M.value),
		                    static   : M.static,
		                });
		            } else {
		                if (M.key.type !== "Identifier") {
		                    throw new Error("Non-Identifier key in PropertyDefinition");
		                }
		                key = from_moz(M.key);
		            }

		            return new AST_ClassProperty({
		                start    : my_start_token(M),
		                end      : my_end_token(M),
		                key,
		                value    : from_moz(M.value),
		                static   : M.static,
		            });
		        },

		        PrivateIdentifier: function (M) {
		            return new AST_SymbolPrivateProperty({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                name: M.name
		            });
		        },

		        StaticBlock: function(M) {
		            return new AST_ClassStaticBlock({
		                start : my_start_token(M),
		                end   : my_end_token(M),
		                body  : M.body.map(from_moz),
		            });
		        },

		        ArrayExpression: function(M) {
		            return new AST_Array({
		                start    : my_start_token(M),
		                end      : my_end_token(M),
		                elements : M.elements.map(function(elem) {
		                    return elem === null ? new AST_Hole() : from_moz(elem);
		                })
		            });
		        },

		        ObjectExpression: function(M) {
		            return new AST_Object({
		                start      : my_start_token(M),
		                end        : my_end_token(M),
		                properties : M.properties.map(function(prop) {
		                    if (prop.type === "SpreadElement") {
		                        return from_moz(prop);
		                    }
		                    prop.type = "Property";
		                    return from_moz(prop);
		                })
		            });
		        },

		        SequenceExpression: function(M) {
		            return new AST_Sequence({
		                start      : my_start_token(M),
		                end        : my_end_token(M),
		                expressions: M.expressions.map(from_moz)
		            });
		        },

		        MemberExpression: function(M) {
		            if (M.property.type === "PrivateIdentifier") {
		                return new AST_DotHash({
		                    start      : my_start_token(M),
		                    end        : my_end_token(M),
		                    property   : M.property.name,
		                    expression : from_moz(M.object),
		                    optional   : M.optional || false
		                });
		            }
		            return new (M.computed ? AST_Sub : AST_Dot)({
		                start      : my_start_token(M),
		                end        : my_end_token(M),
		                property   : M.computed ? from_moz(M.property) : M.property.name,
		                expression : from_moz(M.object),
		                optional   : M.optional || false
		            });
		        },

		        ChainExpression: function(M) {
		            return new AST_Chain({
		                start      : my_start_token(M),
		                end        : my_end_token(M),
		                expression : from_moz(M.expression)
		            });
		        },

		        SwitchCase: function(M) {
		            return new (M.test ? AST_Case : AST_Default)({
		                start      : my_start_token(M),
		                end        : my_end_token(M),
		                expression : from_moz(M.test),
		                body       : M.consequent.map(from_moz)
		            });
		        },

		        VariableDeclaration: function(M) {
		            return new (M.kind === "const" ? AST_Const :
		                        M.kind === "let" ? AST_Let : AST_Var)({
		                start       : my_start_token(M),
		                end         : my_end_token(M),
		                definitions : M.declarations.map(from_moz)
		            });
		        },

		        ImportDeclaration: function(M) {
		            var imported_name = null;
		            var imported_names = null;
		            M.specifiers.forEach(function (specifier) {
		                if (specifier.type === "ImportSpecifier" || specifier.type === "ImportNamespaceSpecifier") {
		                    if (!imported_names) { imported_names = []; }
		                    imported_names.push(from_moz(specifier));
		                } else if (specifier.type === "ImportDefaultSpecifier") {
		                    imported_name = from_moz(specifier);
		                }
		            });
		            return new AST_Import({
		                start       : my_start_token(M),
		                end         : my_end_token(M),
		                imported_name: imported_name,
		                imported_names : imported_names,
		                module_name : from_moz(M.source),
		                assert_clause: assert_clause_from_moz(M.assertions)
		            });
		        },

		        ImportSpecifier: function(M) {
		            return new AST_NameMapping({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                foreign_name: from_moz(M.imported),
		                name: from_moz(M.local)
		            });
		        },

		        ImportDefaultSpecifier: function(M) {
		            return from_moz(M.local);
		        },

		        ImportNamespaceSpecifier: function(M) {
		            return new AST_NameMapping({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                foreign_name: new AST_SymbolImportForeign({ name: "*" }),
		                name: from_moz(M.local)
		            });
		        },

		        ExportAllDeclaration: function(M) {
		            var foreign_name = M.exported == null ? 
		                new AST_SymbolExportForeign({ name: "*" }) :
		                from_moz(M.exported);
		            return new AST_Export({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                exported_names: [
		                    new AST_NameMapping({
		                        name: new AST_SymbolExportForeign({ name: "*" }),
		                        foreign_name: foreign_name
		                    })
		                ],
		                module_name: from_moz(M.source),
		                assert_clause: assert_clause_from_moz(M.assertions)
		            });
		        },

		        ExportNamedDeclaration: function(M) {
		            return new AST_Export({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                exported_definition: from_moz(M.declaration),
		                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {
		                    return from_moz(specifier);
		                }) : null,
		                module_name: from_moz(M.source),
		                assert_clause: assert_clause_from_moz(M.assertions)
		            });
		        },

		        ExportDefaultDeclaration: function(M) {
		            return new AST_Export({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                exported_value: from_moz(M.declaration),
		                is_default: true
		            });
		        },

		        ExportSpecifier: function(M) {
		            return new AST_NameMapping({
		                foreign_name: from_moz(M.exported),
		                name: from_moz(M.local)
		            });
		        },

		        Literal: function(M) {
		            var val = M.value, args = {
		                start  : my_start_token(M),
		                end    : my_end_token(M)
		            };
		            var rx = M.regex;
		            if (rx && rx.pattern) {
		                // RegExpLiteral as per ESTree AST spec
		                args.value = {
		                    source: rx.pattern,
		                    flags: rx.flags
		                };
		                return new AST_RegExp(args);
		            } else if (rx) {
		                // support legacy RegExp
		                const rx_source = M.raw || val;
		                const match = rx_source.match(/^\/(.*)\/(\w*)$/);
		                if (!match) throw new Error("Invalid regex source " + rx_source);
		                const [_, source, flags] = match;
		                args.value = { source, flags };
		                return new AST_RegExp(args);
		            }
		            if (val === null) return new AST_Null(args);
		            switch (typeof val) {
		              case "string":
		                args.quote = "\"";
		                var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
		                if (p.type == "ImportSpecifier") {
		                    args.name = val;
		                    return new AST_SymbolImportForeign(args);
		                } else if (p.type == "ExportSpecifier") {
		                    args.name = val;
		                    if (M == p.exported) {
		                        return new AST_SymbolExportForeign(args);
		                    } else {
		                        return new AST_SymbolExport(args);
		                    }
		                } else if (p.type == "ExportAllDeclaration" && M == p.exported) {
		                    args.name = val;
		                    return new AST_SymbolExportForeign(args);
		                }
		                args.value = val;
		                return new AST_String(args);
		              case "number":
		                args.value = val;
		                args.raw = M.raw || val.toString();
		                return new AST_Number(args);
		              case "boolean":
		                return new (val ? AST_True : AST_False)(args);
		            }
		        },

		        MetaProperty: function(M) {
		            if (M.meta.name === "new" && M.property.name === "target") {
		                return new AST_NewTarget({
		                    start: my_start_token(M),
		                    end: my_end_token(M)
		                });
		            } else if (M.meta.name === "import" && M.property.name === "meta") {
		                return new AST_ImportMeta({
		                    start: my_start_token(M),
		                    end: my_end_token(M)
		                });
		            }
		        },

		        Identifier: function(M) {
		            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
		            return new (  p.type == "LabeledStatement" ? AST_Label
		                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : p.kind == "let" ? AST_SymbolLet : AST_SymbolVar)
		                        : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)
		                        : p.type == "ExportSpecifier" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)
		                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
		                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
		                        : p.type == "ArrowFunctionExpression" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef
		                        : p.type == "ClassExpression" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)
		                        : p.type == "Property" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)
		                        : p.type == "PropertyDefinition" || p.type === "FieldDefinition" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)
		                        : p.type == "ClassDeclaration" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)
		                        : p.type == "MethodDefinition" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)
		                        : p.type == "CatchClause" ? AST_SymbolCatch
		                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
		                        : AST_SymbolRef)({
		                            start : my_start_token(M),
		                            end   : my_end_token(M),
		                            name  : M.name
		                        });
		        },

		        BigIntLiteral(M) {
		            return new AST_BigInt({
		                start : my_start_token(M),
		                end   : my_end_token(M),
		                value : M.value
		            });
		        },

		        EmptyStatement: function(M) {
		            return new AST_EmptyStatement({
		                start: my_start_token(M),
		                end: my_end_token(M)
		            });
		        },

		        BlockStatement: function(M) {
		            return new AST_BlockStatement({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                body: M.body.map(from_moz)
		            });
		        },

		        IfStatement: function(M) {
		            return new AST_If({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                condition: from_moz(M.test),
		                body: from_moz(M.consequent),
		                alternative: from_moz(M.alternate)
		            });
		        },

		        LabeledStatement: function(M) {
		            return new AST_LabeledStatement({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                label: from_moz(M.label),
		                body: from_moz(M.body)
		            });
		        },

		        BreakStatement: function(M) {
		            return new AST_Break({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                label: from_moz(M.label)
		            });
		        },

		        ContinueStatement: function(M) {
		            return new AST_Continue({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                label: from_moz(M.label)
		            });
		        },

		        WithStatement: function(M) {
		            return new AST_With({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.object),
		                body: from_moz(M.body)
		            });
		        },

		        SwitchStatement: function(M) {
		            return new AST_Switch({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.discriminant),
		                body: M.cases.map(from_moz)
		            });
		        },

		        ReturnStatement: function(M) {
		            return new AST_Return({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                value: from_moz(M.argument)
		            });
		        },

		        ThrowStatement: function(M) {
		            return new AST_Throw({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                value: from_moz(M.argument)
		            });
		        },

		        WhileStatement: function(M) {
		            return new AST_While({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                condition: from_moz(M.test),
		                body: from_moz(M.body)
		            });
		        },

		        DoWhileStatement: function(M) {
		            return new AST_Do({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                condition: from_moz(M.test),
		                body: from_moz(M.body)
		            });
		        },

		        ForStatement: function(M) {
		            return new AST_For({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                init: from_moz(M.init),
		                condition: from_moz(M.test),
		                step: from_moz(M.update),
		                body: from_moz(M.body)
		            });
		        },

		        ForInStatement: function(M) {
		            return new AST_ForIn({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                init: from_moz(M.left),
		                object: from_moz(M.right),
		                body: from_moz(M.body)
		            });
		        },

		        ForOfStatement: function(M) {
		            return new AST_ForOf({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                init: from_moz(M.left),
		                object: from_moz(M.right),
		                body: from_moz(M.body),
		                await: M.await
		            });
		        },

		        AwaitExpression: function(M) {
		            return new AST_Await({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.argument)
		            });
		        },

		        YieldExpression: function(M) {
		            return new AST_Yield({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.argument),
		                is_star: M.delegate
		            });
		        },

		        DebuggerStatement: function(M) {
		            return new AST_Debugger({
		                start: my_start_token(M),
		                end: my_end_token(M)
		            });
		        },

		        VariableDeclarator: function(M) {
		            return new AST_VarDef({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                name: from_moz(M.id),
		                value: from_moz(M.init)
		            });
		        },

		        CatchClause: function(M) {
		            return new AST_Catch({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                argname: from_moz(M.param),
		                body: from_moz(M.body).body
		            });
		        },

		        ThisExpression: function(M) {
		            return new AST_This({
		                start: my_start_token(M),
		                end: my_end_token(M)
		            });
		        },

		        Super: function(M) {
		            return new AST_Super({
		                start: my_start_token(M),
		                end: my_end_token(M)
		            });
		        },

		        BinaryExpression: function(M) {
		            if (M.left.type === "PrivateIdentifier") {
		                return new AST_PrivateIn({
		                    start: my_start_token(M),
		                    end: my_end_token(M),
		                    key: new AST_SymbolPrivateProperty({
		                        start: my_start_token(M.left),
		                        end: my_end_token(M.left),
		                        name: M.left.name
		                    }),
		                    value: from_moz(M.right),
		                });
		            }
		            return new AST_Binary({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                operator: M.operator,
		                left: from_moz(M.left),
		                right: from_moz(M.right)
		            });
		        },

		        LogicalExpression: function(M) {
		            return new AST_Binary({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                operator: M.operator,
		                left: from_moz(M.left),
		                right: from_moz(M.right)
		            });
		        },

		        AssignmentExpression: function(M) {
		            return new AST_Assign({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                operator: M.operator,
		                left: from_moz(M.left),
		                right: from_moz(M.right)
		            });
		        },

		        ConditionalExpression: function(M) {
		            return new AST_Conditional({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                condition: from_moz(M.test),
		                consequent: from_moz(M.consequent),
		                alternative: from_moz(M.alternate)
		            });
		        },

		        NewExpression: function(M) {
		            return new AST_New({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.callee),
		                args: M.arguments.map(from_moz)
		            });
		        },

		        CallExpression: function(M) {
		            return new AST_Call({
		                start: my_start_token(M),
		                end: my_end_token(M),
		                expression: from_moz(M.callee),
		                optional: M.optional,
		                args: M.arguments.map(from_moz)
		            });
		        }
		    };

		    MOZ_TO_ME.UpdateExpression =
		    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
		        var prefix = "prefix" in M ? M.prefix
		            : M.type == "UnaryExpression" ? true : false;
		        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
		            start      : my_start_token(M),
		            end        : my_end_token(M),
		            operator   : M.operator,
		            expression : from_moz(M.argument)
		        });
		    };

		    MOZ_TO_ME.ClassDeclaration =
		    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {
		        return new (M.type === "ClassDeclaration" ? AST_DefClass : AST_ClassExpression)({
		            start    : my_start_token(M),
		            end      : my_end_token(M),
		            name     : from_moz(M.id),
		            extends  : from_moz(M.superClass),
		            properties: M.body.body.map(from_moz)
		        });
		    };

		    def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {
		        return {
		            type: "EmptyStatement"
		        };
		    });
		    def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {
		        return {
		            type: "BlockStatement",
		            body: M.body.map(to_moz)
		        };
		    });
		    def_to_moz(AST_If, function To_Moz_IfStatement(M) {
		        return {
		            type: "IfStatement",
		            test: to_moz(M.condition),
		            consequent: to_moz(M.body),
		            alternate: to_moz(M.alternative)
		        };
		    });
		    def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {
		        return {
		            type: "LabeledStatement",
		            label: to_moz(M.label),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {
		        return {
		            type: "BreakStatement",
		            label: to_moz(M.label)
		        };
		    });
		    def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {
		        return {
		            type: "ContinueStatement",
		            label: to_moz(M.label)
		        };
		    });
		    def_to_moz(AST_With, function To_Moz_WithStatement(M) {
		        return {
		            type: "WithStatement",
		            object: to_moz(M.expression),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {
		        return {
		            type: "SwitchStatement",
		            discriminant: to_moz(M.expression),
		            cases: M.body.map(to_moz)
		        };
		    });
		    def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {
		        return {
		            type: "ReturnStatement",
		            argument: to_moz(M.value)
		        };
		    });
		    def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {
		        return {
		            type: "ThrowStatement",
		            argument: to_moz(M.value)
		        };
		    });
		    def_to_moz(AST_While, function To_Moz_WhileStatement(M) {
		        return {
		            type: "WhileStatement",
		            test: to_moz(M.condition),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {
		        return {
		            type: "DoWhileStatement",
		            test: to_moz(M.condition),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_For, function To_Moz_ForStatement(M) {
		        return {
		            type: "ForStatement",
		            init: to_moz(M.init),
		            test: to_moz(M.condition),
		            update: to_moz(M.step),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {
		        return {
		            type: "ForInStatement",
		            left: to_moz(M.init),
		            right: to_moz(M.object),
		            body: to_moz(M.body)
		        };
		    });
		    def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {
		        return {
		            type: "ForOfStatement",
		            left: to_moz(M.init),
		            right: to_moz(M.object),
		            body: to_moz(M.body),
		            await: M.await
		        };
		    });
		    def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {
		        return {
		            type: "AwaitExpression",
		            argument: to_moz(M.expression)
		        };
		    });
		    def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {
		        return {
		            type: "YieldExpression",
		            argument: to_moz(M.expression),
		            delegate: M.is_star
		        };
		    });
		    def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {
		        return {
		            type: "DebuggerStatement"
		        };
		    });
		    def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M) {
		        return {
		            type: "VariableDeclarator",
		            id: to_moz(M.name),
		            init: to_moz(M.value)
		        };
		    });
		    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
		        return {
		            type: "CatchClause",
		            param: to_moz(M.argname),
		            body: to_moz_block(M)
		        };
		    });

		    def_to_moz(AST_This, function To_Moz_ThisExpression() {
		        return {
		            type: "ThisExpression"
		        };
		    });
		    def_to_moz(AST_Super, function To_Moz_Super() {
		        return {
		            type: "Super"
		        };
		    });
		    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
		        return {
		            type: "BinaryExpression",
		            operator: M.operator,
		            left: to_moz(M.left),
		            right: to_moz(M.right)
		        };
		    });
		    def_to_moz(AST_Binary, function To_Moz_LogicalExpression(M) {
		        return {
		            type: "LogicalExpression",
		            operator: M.operator,
		            left: to_moz(M.left),
		            right: to_moz(M.right)
		        };
		    });
		    def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {
		        return {
		            type: "AssignmentExpression",
		            operator: M.operator,
		            left: to_moz(M.left),
		            right: to_moz(M.right)
		        };
		    });
		    def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {
		        return {
		            type: "ConditionalExpression",
		            test: to_moz(M.condition),
		            consequent: to_moz(M.consequent),
		            alternate: to_moz(M.alternative)
		        };
		    });
		    def_to_moz(AST_New, function To_Moz_NewExpression(M) {
		        return {
		            type: "NewExpression",
		            callee: to_moz(M.expression),
		            arguments: M.args.map(to_moz)
		        };
		    });
		    def_to_moz(AST_Call, function To_Moz_CallExpression(M) {
		        return {
		            type: "CallExpression",
		            callee: to_moz(M.expression),
		            optional: M.optional,
		            arguments: M.args.map(to_moz)
		        };
		    });

		    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
		        return to_moz_scope("Program", M);
		    });

		    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {
		        return {
		            type: to_moz_in_destructuring() ? "RestElement" : "SpreadElement",
		            argument: to_moz(M.expression)
		        };
		    });

		    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {
		        return {
		            type: "TaggedTemplateExpression",
		            tag: to_moz(M.prefix),
		            quasi: to_moz(M.template_string)
		        };
		    });

		    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {
		        var quasis = [];
		        var expressions = [];
		        for (var i = 0; i < M.segments.length; i++) {
		            if (i % 2 !== 0) {
		                expressions.push(to_moz(M.segments[i]));
		            } else {
		                quasis.push({
		                    type: "TemplateElement",
		                    value: {
		                        raw: M.segments[i].raw,
		                        cooked: M.segments[i].value
		                    },
		                    tail: i === M.segments.length - 1
		                });
		            }
		        }
		        return {
		            type: "TemplateLiteral",
		            quasis: quasis,
		            expressions: expressions
		        };
		    });

		    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {
		        return {
		            type: "FunctionDeclaration",
		            id: to_moz(M.name),
		            params: M.argnames.map(to_moz),
		            generator: M.is_generator,
		            async: M.async,
		            body: to_moz_scope("BlockStatement", M)
		        };
		    });

		    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {
		        var is_generator = parent.is_generator !== undefined ?
		            parent.is_generator : M.is_generator;
		        return {
		            type: "FunctionExpression",
		            id: to_moz(M.name),
		            params: M.argnames.map(to_moz),
		            generator: is_generator,
		            async: M.async,
		            body: to_moz_scope("BlockStatement", M)
		        };
		    });

		    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {
		        var body = {
		            type: "BlockStatement",
		            body: M.body.map(to_moz)
		        };
		        return {
		            type: "ArrowFunctionExpression",
		            params: M.argnames.map(to_moz),
		            async: M.async,
		            body: body
		        };
		    });

		    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {
		        if (M.is_array) {
		            return {
		                type: "ArrayPattern",
		                elements: M.names.map(to_moz)
		            };
		        }
		        return {
		            type: "ObjectPattern",
		            properties: M.names.map(to_moz)
		        };
		    });

		    def_to_moz(AST_Directive, function To_Moz_Directive(M) {
		        return {
		            type: "ExpressionStatement",
		            expression: {
		                type: "Literal",
		                value: M.value,
		                raw: M.print_to_string()
		            },
		            directive: M.value
		        };
		    });

		    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {
		        return {
		            type: "ExpressionStatement",
		            expression: to_moz(M.body)
		        };
		    });

		    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
		        return {
		            type: "SwitchCase",
		            test: to_moz(M.expression),
		            consequent: M.body.map(to_moz)
		        };
		    });

		    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
		        return {
		            type: "TryStatement",
		            block: to_moz_block(M.body),
		            handler: to_moz(M.bcatch),
		            guardedHandlers: [],
		            finalizer: to_moz(M.bfinally)
		        };
		    });

		    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
		        return {
		            type: "CatchClause",
		            param: to_moz(M.argname),
		            guard: null,
		            body: to_moz_block(M)
		        };
		    });

		    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
		        return {
		            type: "VariableDeclaration",
		            kind:
		                M instanceof AST_Const ? "const" :
		                M instanceof AST_Let ? "let" : "var",
		            declarations: M.definitions.map(to_moz)
		        };
		    });

		    const assert_clause_to_moz = assert_clause => {
		        const assertions = [];
		        if (assert_clause) {
		            for (const { key, value } of assert_clause.properties) {
		                const key_moz = is_basic_identifier_string(key)
		                    ? { type: "Identifier", name: key }
		                    : { type: "Literal", value: key, raw: JSON.stringify(key) };
		                assertions.push({
		                    type: "ImportAttribute",
		                    key: key_moz,
		                    value: to_moz(value)
		                });
		            }
		        }
		        return assertions;
		    };

		    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {
		        if (M.exported_names) {
		            var first_exported = M.exported_names[0];
		            var first_exported_name = first_exported.name;
		            if (first_exported_name.name === "*" && !first_exported_name.quote) {
		                var foreign_name = first_exported.foreign_name;
		                var exported = foreign_name.name === "*" && !foreign_name.quote
		                    ? null
		                    : to_moz(foreign_name);
		                return {
		                    type: "ExportAllDeclaration",
		                    source: to_moz(M.module_name),
		                    exported: exported,
		                    assertions: assert_clause_to_moz(M.assert_clause)
		                };
		            }
		            return {
		                type: "ExportNamedDeclaration",
		                specifiers: M.exported_names.map(function (name_mapping) {
		                    return {
		                        type: "ExportSpecifier",
		                        exported: to_moz(name_mapping.foreign_name),
		                        local: to_moz(name_mapping.name)
		                    };
		                }),
		                declaration: to_moz(M.exported_definition),
		                source: to_moz(M.module_name),
		                assertions: assert_clause_to_moz(M.assert_clause)
		            };
		        }
		        return {
		            type: M.is_default ? "ExportDefaultDeclaration" : "ExportNamedDeclaration",
		            declaration: to_moz(M.exported_value || M.exported_definition)
		        };
		    });

		    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {
		        var specifiers = [];
		        if (M.imported_name) {
		            specifiers.push({
		                type: "ImportDefaultSpecifier",
		                local: to_moz(M.imported_name)
		            });
		        }
		        if (M.imported_names) {
		            var first_imported_foreign_name = M.imported_names[0].foreign_name;
		            if (first_imported_foreign_name.name === "*" && !first_imported_foreign_name.quote) {
		                specifiers.push({
		                    type: "ImportNamespaceSpecifier",
		                    local: to_moz(M.imported_names[0].name)
		                });
		            } else {
		                M.imported_names.forEach(function(name_mapping) {
		                    specifiers.push({
		                        type: "ImportSpecifier",
		                        local: to_moz(name_mapping.name),
		                        imported: to_moz(name_mapping.foreign_name)
		                    });
		                });
		            }
		        }
		        return {
		            type: "ImportDeclaration",
		            specifiers: specifiers,
		            source: to_moz(M.module_name),
		            assertions: assert_clause_to_moz(M.assert_clause)
		        };
		    });

		    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {
		        return {
		            type: "MetaProperty",
		            meta: {
		                type: "Identifier",
		                name: "import"
		            },
		            property: {
		                type: "Identifier",
		                name: "meta"
		            }
		        };
		    });

		    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {
		        return {
		            type: "SequenceExpression",
		            expressions: M.expressions.map(to_moz)
		        };
		    });

		    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {
		        return {
		            type: "MemberExpression",
		            object: to_moz(M.expression),
		            computed: false,
		            property: {
		                type: "PrivateIdentifier",
		                name: M.property
		            },
		            optional: M.optional
		        };
		    });

		    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
		        var isComputed = M instanceof AST_Sub;
		        return {
		            type: "MemberExpression",
		            object: to_moz(M.expression),
		            computed: isComputed,
		            property: isComputed ? to_moz(M.property) : {type: "Identifier", name: M.property},
		            optional: M.optional
		        };
		    });

		    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {
		        return {
		            type: "ChainExpression",
		            expression: to_moz(M.expression)
		        };
		    });

		    def_to_moz(AST_Unary, function To_Moz_Unary(M) {
		        return {
		            type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
		            operator: M.operator,
		            prefix: M instanceof AST_UnaryPrefix,
		            argument: to_moz(M.expression)
		        };
		    });

		    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
		        if (M.operator == "=" && to_moz_in_destructuring()) {
		            return {
		                type: "AssignmentPattern",
		                left: to_moz(M.left),
		                right: to_moz(M.right)
		            };
		        }

		        const type = M.operator == "&&" || M.operator == "||" || M.operator === "??"
		            ? "LogicalExpression"
		            : "BinaryExpression";

		        return {
		            type,
		            left: to_moz(M.left),
		            operator: M.operator,
		            right: to_moz(M.right)
		        };
		    });

		    def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {
		        return {
		            type: "BinaryExpression",
		            left: { type: "PrivateIdentifier", name: M.key.name },
		            operator: "in",
		            right: to_moz(M.value),
		        };
		    });

		    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
		        return {
		            type: "ArrayExpression",
		            elements: M.elements.map(to_moz)
		        };
		    });

		    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {
		        return {
		            type: "ObjectExpression",
		            properties: M.properties.map(to_moz)
		        };
		    });

		    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {
		        var key = M.key instanceof AST_Node ? to_moz(M.key) : {
		            type: "Identifier",
		            value: M.key
		        };
		        if (typeof M.key === "number") {
		            key = {
		                type: "Literal",
		                value: Number(M.key)
		            };
		        }
		        if (typeof M.key === "string") {
		            key = {
		                type: "Identifier",
		                name: M.key
		            };
		        }
		        var kind;
		        var string_or_num = typeof M.key === "string" || typeof M.key === "number";
		        var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;
		        if (M instanceof AST_ObjectKeyVal) {
		            kind = "init";
		            computed = !string_or_num;
		        } else
		        if (M instanceof AST_ObjectGetter) {
		            kind = "get";
		        } else
		        if (M instanceof AST_ObjectSetter) {
		            kind = "set";
		        }
		        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {
		            const kind = M instanceof AST_PrivateGetter ? "get" : "set";
		            return {
		                type: "MethodDefinition",
		                computed: false,
		                kind: kind,
		                static: M.static,
		                key: {
		                    type: "PrivateIdentifier",
		                    name: M.key.name
		                },
		                value: to_moz(M.value)
		            };
		        }
		        if (M instanceof AST_ClassPrivateProperty) {
		            return {
		                type: "PropertyDefinition",
		                key: {
		                    type: "PrivateIdentifier",
		                    name: M.key.name
		                },
		                value: to_moz(M.value),
		                computed: false,
		                static: M.static
		            };
		        }
		        if (M instanceof AST_ClassProperty) {
		            return {
		                type: "PropertyDefinition",
		                key,
		                value: to_moz(M.value),
		                computed,
		                static: M.static
		            };
		        }
		        if (parent instanceof AST_Class) {
		            return {
		                type: "MethodDefinition",
		                computed: computed,
		                kind: kind,
		                static: M.static,
		                key: to_moz(M.key),
		                value: to_moz(M.value)
		            };
		        }
		        return {
		            type: "Property",
		            computed: computed,
		            kind: kind,
		            key: key,
		            value: to_moz(M.value)
		        };
		    });

		    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {
		        if (parent instanceof AST_Object) {
		            return {
		                type: "Property",
		                computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,
		                kind: "init",
		                method: true,
		                shorthand: false,
		                key: to_moz(M.key),
		                value: to_moz(M.value)
		            };
		        }

		        const key = M instanceof AST_PrivateMethod
		            ? {
		                type: "PrivateIdentifier",
		                name: M.key.name
		            }
		            : to_moz(M.key);

		        return {
		            type: "MethodDefinition",
		            kind: M.key === "constructor" ? "constructor" : "method",
		            key,
		            value: to_moz(M.value),
		            computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,
		            static: M.static,
		        };
		    });

		    def_to_moz(AST_Class, function To_Moz_Class(M) {
		        var type = M instanceof AST_ClassExpression ? "ClassExpression" : "ClassDeclaration";
		        return {
		            type: type,
		            superClass: to_moz(M.extends),
		            id: M.name ? to_moz(M.name) : null,
		            body: {
		                type: "ClassBody",
		                body: M.properties.map(to_moz)
		            }
		        };
		    });

		    def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {
		        return {
		            type: "StaticBlock",
		            body: M.body.map(to_moz),
		        };
		    });

		    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
		        return {
		            type: "MetaProperty",
		            meta: {
		                type: "Identifier",
		                name: "new"
		            },
		            property: {
		                type: "Identifier",
		                name: "target"
		            }
		        };
		    });

		    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {
		        if (
		            (M instanceof AST_SymbolMethod && parent.quote) ||
		            ((
		                M instanceof AST_SymbolImportForeign ||
		                M instanceof AST_SymbolExportForeign ||
		                M instanceof AST_SymbolExport
		                ) && M.quote)
		         ) {
		            return {
		                type: "Literal",
		                value: M.name
		            };
		        }
		        var def = M.definition();
		        return {
		            type: "Identifier",
		            name: def ? def.mangled_name || def.name : M.name
		        };
		    });

		    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
		        const pattern = M.value.source;
		        const flags = M.value.flags;
		        return {
		            type: "Literal",
		            value: null,
		            raw: M.print_to_string(),
		            regex: { pattern, flags }
		        };
		    });

		    def_to_moz(AST_Constant, function To_Moz_Literal(M) {
		        var value = M.value;
		        return {
		            type: "Literal",
		            value: value,
		            raw: M.raw || M.print_to_string()
		        };
		    });

		    def_to_moz(AST_Atom, function To_Moz_Atom(M) {
		        return {
		            type: "Identifier",
		            name: String(M.value)
		        };
		    });

		    def_to_moz(AST_BigInt, M => ({
		        type: "BigIntLiteral",
		        value: M.value
		    }));

		    AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
		    AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
		    AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() { return null; });

		    AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
		    AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);

		    /* -----[ tools ]----- */

		    function my_start_token(moznode) {
		        var loc = moznode.loc, start = loc && loc.start;
		        var range = moznode.range;
		        return new AST_Token(
		            "",
		            "",
		            start && start.line || 0,
		            start && start.column || 0,
		            range ? range [0] : moznode.start,
		            false,
		            [],
		            [],
		            loc && loc.source,
		        );
		    }

		    function my_end_token(moznode) {
		        var loc = moznode.loc, end = loc && loc.end;
		        var range = moznode.range;
		        return new AST_Token(
		            "",
		            "",
		            end && end.line || 0,
		            end && end.column || 0,
		            range ? range [0] : moznode.end,
		            false,
		            [],
		            [],
		            loc && loc.source,
		        );
		    }

		    var FROM_MOZ_STACK = null;

		    function from_moz(node) {
		        FROM_MOZ_STACK.push(node);
		        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
		        FROM_MOZ_STACK.pop();
		        return ret;
		    }

		    AST_Node.from_mozilla_ast = function(node) {
		        var save_stack = FROM_MOZ_STACK;
		        FROM_MOZ_STACK = [];
		        var ast = from_moz(node);
		        FROM_MOZ_STACK = save_stack;
		        return ast;
		    };

		    function set_moz_loc(mynode, moznode) {
		        var start = mynode.start;
		        var end = mynode.end;
		        if (!(start && end)) {
		            return moznode;
		        }
		        if (start.pos != null && end.endpos != null) {
		            moznode.range = [start.pos, end.endpos];
		        }
		        if (start.line) {
		            moznode.loc = {
		                start: {line: start.line, column: start.col},
		                end: end.endline ? {line: end.endline, column: end.endcol} : null
		            };
		            if (start.file) {
		                moznode.loc.source = start.file;
		            }
		        }
		        return moznode;
		    }

		    function def_to_moz(mytype, handler) {
		        mytype.DEFMETHOD("to_mozilla_ast", function(parent) {
		            return set_moz_loc(this, handler(this, parent));
		        });
		    }

		    var TO_MOZ_STACK = null;

		    function to_moz(node) {
		        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }
		        TO_MOZ_STACK.push(node);
		        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;
		        TO_MOZ_STACK.pop();
		        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }
		        return ast;
		    }

		    function to_moz_in_destructuring() {
		        var i = TO_MOZ_STACK.length;
		        while (i--) {
		            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {
		                return true;
		            }
		        }
		        return false;
		    }

		    function to_moz_block(node) {
		        return {
		            type: "BlockStatement",
		            body: node.body.map(to_moz)
		        };
		    }

		    function to_moz_scope(type, node) {
		        var body = node.body.map(to_moz);
		        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
		            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
		        }
		        return {
		            type: type,
		            body: body
		        };
		    }
		})();

		// return true if the node at the top of the stack (that means the
		// innermost node in the current output) is lexically the first in
		// a statement.
		function first_in_statement(stack) {
		    let node = stack.parent(-1);
		    for (let i = 0, p; p = stack.parent(i); i++) {
		        if (p instanceof AST_Statement && p.body === node)
		            return true;
		        if ((p instanceof AST_Sequence && p.expressions[0] === node) ||
		            (p.TYPE === "Call" && p.expression === node) ||
		            (p instanceof AST_PrefixedTemplateString && p.prefix === node) ||
		            (p instanceof AST_Dot && p.expression === node) ||
		            (p instanceof AST_Sub && p.expression === node) ||
		            (p instanceof AST_Chain && p.expression === node) ||
		            (p instanceof AST_Conditional && p.condition === node) ||
		            (p instanceof AST_Binary && p.left === node) ||
		            (p instanceof AST_UnaryPostfix && p.expression === node)
		        ) {
		            node = p;
		        } else {
		            return false;
		        }
		    }
		}

		// Returns whether the leftmost item in the expression is an object
		function left_is_object(node) {
		    if (node instanceof AST_Object) return true;
		    if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);
		    if (node.TYPE === "Call") return left_is_object(node.expression);
		    if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);
		    if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);
		    if (node instanceof AST_Chain) return left_is_object(node.expression);
		    if (node instanceof AST_Conditional) return left_is_object(node.condition);
		    if (node instanceof AST_Binary) return left_is_object(node.left);
		    if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);
		    return false;
		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		const EXPECT_DIRECTIVE = /^$|[;{][\s\n]*$/;
		const CODE_LINE_BREAK = 10;
		const CODE_SPACE = 32;

		const r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/g;

		function is_some_comments(comment) {
		    // multiline comment
		    return (
		        (comment.type === "comment2" || comment.type === "comment1")
		        && /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(comment.value)
		    );
		}

		class Rope {
		    constructor() {
		        this.committed = "";
		        this.current = "";
		    }

		    append(str) {
		        this.current += str;
		    }

		    insertAt(char, index) {
		        const { committed, current } = this;
		        if (index < committed.length) {
		            this.committed = committed.slice(0, index) + char + committed.slice(index);
		        } else if (index === committed.length) {
		            this.committed += char;
		        } else {
		            index -= committed.length;
		            this.committed += current.slice(0, index) + char;
		            this.current = current.slice(index);
		        }
		    }

		    charAt(index) {
		        const { committed } = this;
		        if (index < committed.length) return committed[index];
		        return this.current[index - committed.length];
		    }

		    curLength() {
		        return this.current.length;
		    }

		    length() {
		        return this.committed.length + this.current.length;
		    }

		    toString() {
		        return this.committed + this.current;
		    }
		}

		function OutputStream(options) {

		    var readonly = !options;
		    options = defaults(options, {
		        ascii_only           : false,
		        beautify             : false,
		        braces               : false,
		        comments             : "some",
		        ecma                 : 5,
		        ie8                  : false,
		        indent_level         : 4,
		        indent_start         : 0,
		        inline_script        : true,
		        keep_numbers         : false,
		        keep_quoted_props    : false,
		        max_line_len         : false,
		        preamble             : null,
		        preserve_annotations : false,
		        quote_keys           : false,
		        quote_style          : 0,
		        safari10             : false,
		        semicolons           : true,
		        shebang              : true,
		        shorthand            : undefined,
		        source_map           : null,
		        webkit               : false,
		        width                : 80,
		        wrap_iife            : false,
		        wrap_func_args       : true,

		        _destroy_ast         : false
		    }, true);

		    if (options.shorthand === undefined)
		        options.shorthand = options.ecma > 5;

		    // Convert comment option to RegExp if necessary and set up comments filter
		    var comment_filter = return_false; // Default case, throw all comments away
		    if (options.comments) {
		        let comments = options.comments;
		        if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
		            var regex_pos = options.comments.lastIndexOf("/");
		            comments = new RegExp(
		                options.comments.substr(1, regex_pos - 1),
		                options.comments.substr(regex_pos + 1)
		            );
		        }
		        if (comments instanceof RegExp) {
		            comment_filter = function(comment) {
		                return comment.type != "comment5" && comments.test(comment.value);
		            };
		        } else if (typeof comments === "function") {
		            comment_filter = function(comment) {
		                return comment.type != "comment5" && comments(this, comment);
		            };
		        } else if (comments === "some") {
		            comment_filter = is_some_comments;
		        } else { // NOTE includes "all" option
		            comment_filter = return_true;
		        }
		    }

		    var indentation = 0;
		    var current_col = 0;
		    var current_line = 1;
		    var current_pos = 0;
		    var OUTPUT = new Rope();
		    let printed_comments = new Set();

		    var to_utf8 = options.ascii_only ? function(str, identifier = false, regexp = false) {
		        if (options.ecma >= 2015 && !options.safari10 && !regexp) {
		            str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
		                var code = get_full_char_code(ch, 0).toString(16);
		                return "\\u{" + code + "}";
		            });
		        }
		        return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
		            var code = ch.charCodeAt(0).toString(16);
		            if (code.length <= 2 && !identifier) {
		                while (code.length < 2) code = "0" + code;
		                return "\\x" + code;
		            } else {
		                while (code.length < 4) code = "0" + code;
		                return "\\u" + code;
		            }
		        });
		    } : function(str) {
		        return str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(match, lone) {
		            if (lone) {
		                return "\\u" + lone.charCodeAt(0).toString(16);
		            }
		            return match;
		        });
		    };

		    function make_string(str, quote) {
		        var dq = 0, sq = 0;
		        str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
		          function(s, i) {
		            switch (s) {
		              case '"': ++dq; return '"';
		              case "'": ++sq; return "'";
		              case "\\": return "\\\\";
		              case "\n": return "\\n";
		              case "\r": return "\\r";
		              case "\t": return "\\t";
		              case "\b": return "\\b";
		              case "\f": return "\\f";
		              case "\x0B": return options.ie8 ? "\\x0B" : "\\v";
		              case "\u2028": return "\\u2028";
		              case "\u2029": return "\\u2029";
		              case "\ufeff": return "\\ufeff";
		              case "\0":
		                  return /[0-9]/.test(get_full_char(str, i+1)) ? "\\x00" : "\\0";
		            }
		            return s;
		        });
		        function quote_single() {
		            return "'" + str.replace(/\x27/g, "\\'") + "'";
		        }
		        function quote_double() {
		            return '"' + str.replace(/\x22/g, '\\"') + '"';
		        }
		        function quote_template() {
		            return "`" + str.replace(/`/g, "\\`") + "`";
		        }
		        str = to_utf8(str);
		        if (quote === "`") return quote_template();
		        switch (options.quote_style) {
		          case 1:
		            return quote_single();
		          case 2:
		            return quote_double();
		          case 3:
		            return quote == "'" ? quote_single() : quote_double();
		          default:
		            return dq > sq ? quote_single() : quote_double();
		        }
		    }

		    function encode_string(str, quote) {
		        var ret = make_string(str, quote);
		        if (options.inline_script) {
		            ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
		            ret = ret.replace(/\x3c!--/g, "\\x3c!--");
		            ret = ret.replace(/--\x3e/g, "--\\x3e");
		        }
		        return ret;
		    }

		    function make_name(name) {
		        name = name.toString();
		        name = to_utf8(name, true);
		        return name;
		    }

		    function make_indent(back) {
		        return " ".repeat(options.indent_start + indentation - back * options.indent_level);
		    }

		    /* -----[ beautification/minification ]----- */

		    var has_parens = false;
		    var might_need_space = false;
		    var might_need_semicolon = false;
		    var might_add_newline = 0;
		    var need_newline_indented = false;
		    var need_space = false;
		    var newline_insert = -1;
		    var last = "";
		    var mapping_token, mapping_name, mappings = options.source_map && [];

		    var do_add_mapping = mappings ? function() {
		        mappings.forEach(function(mapping) {
		            try {
		                let { name, token } = mapping;
		                if (name !== false) {
		                    if (token.type == "name" || token.type === "privatename") {
		                        name = token.value;
		                    } else if (name instanceof AST_Symbol) {
		                        name = token.type === "string" ? token.value : name.name;
		                    }
		                }
		                options.source_map.add(
		                    mapping.token.file,
		                    mapping.line, mapping.col,
		                    mapping.token.line, mapping.token.col,
		                    is_basic_identifier_string(name) ? name : undefined
		                );
		            } catch(ex) {
		                // Ignore bad mapping
		            }
		        });
		        mappings = [];
		    } : noop;

		    var ensure_line_len = options.max_line_len ? function() {
		        if (current_col > options.max_line_len) {
		            if (might_add_newline) {
		                OUTPUT.insertAt("\n", might_add_newline);
		                const curLength = OUTPUT.curLength();
		                if (mappings) {
		                    var delta = curLength - current_col;
		                    mappings.forEach(function(mapping) {
		                        mapping.line++;
		                        mapping.col += delta;
		                    });
		                }
		                current_line++;
		                current_pos++;
		                current_col = curLength;
		            }
		        }
		        if (might_add_newline) {
		            might_add_newline = 0;
		            do_add_mapping();
		        }
		    } : noop;

		    var requireSemicolonChars = makePredicate("( [ + * / - , . `");

		    function print(str) {
		        str = String(str);
		        var ch = get_full_char(str, 0);
		        if (need_newline_indented && ch) {
		            need_newline_indented = false;
		            if (ch !== "\n") {
		                print("\n");
		                indent();
		            }
		        }
		        if (need_space && ch) {
		            need_space = false;
		            if (!/[\s;})]/.test(ch)) {
		                space();
		            }
		        }
		        newline_insert = -1;
		        var prev = last.charAt(last.length - 1);
		        if (might_need_semicolon) {
		            might_need_semicolon = false;

		            if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
		                if (options.semicolons || requireSemicolonChars.has(ch)) {
		                    OUTPUT.append(";");
		                    current_col++;
		                    current_pos++;
		                } else {
		                    ensure_line_len();
		                    if (current_col > 0) {
		                        OUTPUT.append("\n");
		                        current_pos++;
		                        current_line++;
		                        current_col = 0;
		                    }

		                    if (/^\s+$/.test(str)) {
		                        // reset the semicolon flag, since we didn't print one
		                        // now and might still have to later
		                        might_need_semicolon = true;
		                    }
		                }

		                if (!options.beautify)
		                    might_need_space = false;
		            }
		        }

		        if (might_need_space) {
		            if ((is_identifier_char(prev)
		                    && (is_identifier_char(ch) || ch == "\\"))
		                || (ch == "/" && ch == prev)
		                || ((ch == "+" || ch == "-") && ch == last)
		            ) {
		                OUTPUT.append(" ");
		                current_col++;
		                current_pos++;
		            }
		            might_need_space = false;
		        }

		        if (mapping_token) {
		            mappings.push({
		                token: mapping_token,
		                name: mapping_name,
		                line: current_line,
		                col: current_col
		            });
		            mapping_token = false;
		            if (!might_add_newline) do_add_mapping();
		        }

		        OUTPUT.append(str);
		        has_parens = str[str.length - 1] == "(";
		        current_pos += str.length;
		        var a = str.split(/\r?\n/), n = a.length - 1;
		        current_line += n;
		        current_col += a[0].length;
		        if (n > 0) {
		            ensure_line_len();
		            current_col = a[n].length;
		        }
		        last = str;
		    }

		    var star = function() {
		        print("*");
		    };

		    var space = options.beautify ? function() {
		        print(" ");
		    } : function() {
		        might_need_space = true;
		    };

		    var indent = options.beautify ? function(half) {
		        if (options.beautify) {
		            print(make_indent(half ? 0.5 : 0));
		        }
		    } : noop;

		    var with_indent = options.beautify ? function(col, cont) {
		        if (col === true) col = next_indent();
		        var save_indentation = indentation;
		        indentation = col;
		        var ret = cont();
		        indentation = save_indentation;
		        return ret;
		    } : function(col, cont) { return cont(); };

		    var newline = options.beautify ? function() {
		        if (newline_insert < 0) return print("\n");
		        if (OUTPUT.charAt(newline_insert) != "\n") {
		            OUTPUT.insertAt("\n", newline_insert);
		            current_pos++;
		            current_line++;
		        }
		        newline_insert++;
		    } : options.max_line_len ? function() {
		        ensure_line_len();
		        might_add_newline = OUTPUT.length();
		    } : noop;

		    var semicolon = options.beautify ? function() {
		        print(";");
		    } : function() {
		        might_need_semicolon = true;
		    };

		    function force_semicolon() {
		        might_need_semicolon = false;
		        print(";");
		    }

		    function next_indent() {
		        return indentation + options.indent_level;
		    }

		    function with_block(cont) {
		        var ret;
		        print("{");
		        newline();
		        with_indent(next_indent(), function() {
		            ret = cont();
		        });
		        indent();
		        print("}");
		        return ret;
		    }

		    function with_parens(cont) {
		        print("(");
		        //XXX: still nice to have that for argument lists
		        //var ret = with_indent(current_col, cont);
		        var ret = cont();
		        print(")");
		        return ret;
		    }

		    function with_square(cont) {
		        print("[");
		        //var ret = with_indent(current_col, cont);
		        var ret = cont();
		        print("]");
		        return ret;
		    }

		    function comma() {
		        print(",");
		        space();
		    }

		    function colon() {
		        print(":");
		        space();
		    }

		    var add_mapping = mappings ? function(token, name) {
		        mapping_token = token;
		        mapping_name = name;
		    } : noop;

		    function get() {
		        if (might_add_newline) {
		            ensure_line_len();
		        }
		        return OUTPUT.toString();
		    }

		    function has_nlb() {
		        const output = OUTPUT.toString();
		        let n = output.length - 1;
		        while (n >= 0) {
		            const code = output.charCodeAt(n);
		            if (code === CODE_LINE_BREAK) {
		                return true;
		            }

		            if (code !== CODE_SPACE) {
		                return false;
		            }
		            n--;
		        }
		        return true;
		    }

		    function filter_comment(comment) {
		        if (!options.preserve_annotations) {
		            comment = comment.replace(r_annotation, " ");
		        }
		        if (/^\s*$/.test(comment)) {
		            return "";
		        }
		        return comment.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
		    }

		    function prepend_comments(node) {
		        var self = this;
		        var start = node.start;
		        if (!start) return;
		        var printed_comments = self.printed_comments;

		        // There cannot be a newline between return/yield and its value.
		        const keyword_with_value = 
		            node instanceof AST_Exit && node.value
		            || (node instanceof AST_Await || node instanceof AST_Yield)
		                && node.expression;

		        if (
		            start.comments_before
		            && printed_comments.has(start.comments_before)
		        ) {
		            if (keyword_with_value) {
		                start.comments_before = [];
		            } else {
		                return;
		            }
		        }

		        var comments = start.comments_before;
		        if (!comments) {
		            comments = start.comments_before = [];
		        }
		        printed_comments.add(comments);

		        if (keyword_with_value) {
		            var tw = new TreeWalker(function(node) {
		                var parent = tw.parent();
		                if (parent instanceof AST_Exit
		                    || parent instanceof AST_Await
		                    || parent instanceof AST_Yield
		                    || parent instanceof AST_Binary && parent.left === node
		                    || parent.TYPE == "Call" && parent.expression === node
		                    || parent instanceof AST_Conditional && parent.condition === node
		                    || parent instanceof AST_Dot && parent.expression === node
		                    || parent instanceof AST_Sequence && parent.expressions[0] === node
		                    || parent instanceof AST_Sub && parent.expression === node
		                    || parent instanceof AST_UnaryPostfix) {
		                    if (!node.start) return;
		                    var text = node.start.comments_before;
		                    if (text && !printed_comments.has(text)) {
		                        printed_comments.add(text);
		                        comments = comments.concat(text);
		                    }
		                } else {
		                    return true;
		                }
		            });
		            tw.push(node);
		            keyword_with_value.walk(tw);
		        }

		        if (current_pos == 0) {
		            if (comments.length > 0 && options.shebang && comments[0].type === "comment5"
		                && !printed_comments.has(comments[0])) {
		                print("#!" + comments.shift().value + "\n");
		                indent();
		            }
		            var preamble = options.preamble;
		            if (preamble) {
		                print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
		            }
		        }

		        comments = comments.filter(comment_filter, node).filter(c => !printed_comments.has(c));
		        if (comments.length == 0) return;
		        var last_nlb = has_nlb();
		        comments.forEach(function(c, i) {
		            printed_comments.add(c);
		            if (!last_nlb) {
		                if (c.nlb) {
		                    print("\n");
		                    indent();
		                    last_nlb = true;
		                } else if (i > 0) {
		                    space();
		                }
		            }

		            if (/comment[134]/.test(c.type)) {
		                var value = filter_comment(c.value);
		                if (value) {
		                    print("//" + value + "\n");
		                    indent();
		                }
		                last_nlb = true;
		            } else if (c.type == "comment2") {
		                var value = filter_comment(c.value);
		                if (value) {
		                    print("/*" + value + "*/");
		                }
		                last_nlb = false;
		            }
		        });
		        if (!last_nlb) {
		            if (start.nlb) {
		                print("\n");
		                indent();
		            } else {
		                space();
		            }
		        }
		    }

		    function append_comments(node, tail) {
		        var self = this;
		        var token = node.end;
		        if (!token) return;
		        var printed_comments = self.printed_comments;
		        var comments = token[tail ? "comments_before" : "comments_after"];
		        if (!comments || printed_comments.has(comments)) return;
		        if (!(node instanceof AST_Statement || comments.every((c) =>
		            !/comment[134]/.test(c.type)
		        ))) return;
		        printed_comments.add(comments);
		        var insert = OUTPUT.length();
		        comments.filter(comment_filter, node).forEach(function(c, i) {
		            if (printed_comments.has(c)) return;
		            printed_comments.add(c);
		            need_space = false;
		            if (need_newline_indented) {
		                print("\n");
		                indent();
		                need_newline_indented = false;
		            } else if (c.nlb && (i > 0 || !has_nlb())) {
		                print("\n");
		                indent();
		            } else if (i > 0 || !tail) {
		                space();
		            }
		            if (/comment[134]/.test(c.type)) {
		                const value = filter_comment(c.value);
		                if (value) {
		                    print("//" + value);
		                }
		                need_newline_indented = true;
		            } else if (c.type == "comment2") {
		                const value = filter_comment(c.value);
		                if (value) {
		                    print("/*" + value + "*/");
		                }
		                need_space = true;
		            }
		        });
		        if (OUTPUT.length() > insert) newline_insert = insert;
		    }

		    /**
		     * When output.option("_destroy_ast") is enabled, destroy the function.
		     * Call this after printing it.
		     */
		    const gc_scope =
		      options["_destroy_ast"]
		        ? function gc_scope(scope) {
		            scope.body.length = 0;
		            scope.argnames.length = 0;
		        }
		        : noop;

		    var stack = [];
		    return {
		        get             : get,
		        toString        : get,
		        indent          : indent,
		        in_directive    : false,
		        use_asm         : null,
		        active_scope    : null,
		        indentation     : function() { return indentation; },
		        current_width   : function() { return current_col - indentation; },
		        should_break    : function() { return options.width && this.current_width() >= options.width; },
		        has_parens      : function() { return has_parens; },
		        newline         : newline,
		        print           : print,
		        star            : star,
		        space           : space,
		        comma           : comma,
		        colon           : colon,
		        last            : function() { return last; },
		        semicolon       : semicolon,
		        force_semicolon : force_semicolon,
		        to_utf8         : to_utf8,
		        print_name      : function(name) { print(make_name(name)); },
		        print_string    : function(str, quote, escape_directive) {
		            var encoded = encode_string(str, quote);
		            if (escape_directive === true && !encoded.includes("\\")) {
		                // Insert semicolons to break directive prologue
		                if (!EXPECT_DIRECTIVE.test(OUTPUT.toString())) {
		                    force_semicolon();
		                }
		                force_semicolon();
		            }
		            print(encoded);
		        },
		        print_template_string_chars: function(str) {
		            var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
		            return print(encoded.substr(1, encoded.length - 2));
		        },
		        encode_string   : encode_string,
		        next_indent     : next_indent,
		        with_indent     : with_indent,
		        with_block      : with_block,
		        with_parens     : with_parens,
		        with_square     : with_square,
		        add_mapping     : add_mapping,
		        option          : function(opt) { return options[opt]; },
		        gc_scope,
		        printed_comments: printed_comments,
		        prepend_comments: readonly ? noop : prepend_comments,
		        append_comments : readonly || comment_filter === return_false ? noop : append_comments,
		        line            : function() { return current_line; },
		        col             : function() { return current_col; },
		        pos             : function() { return current_pos; },
		        push_node       : function(node) { stack.push(node); },
		        pop_node        : function() { return stack.pop(); },
		        parent          : function(n) {
		            return stack[stack.length - 2 - (n || 0)];
		        }
		    };

		}

		/* -----[ code generators ]----- */

		(function() {

		    /* -----[ utils ]----- */

		    function DEFPRINT(nodetype, generator) {
		        nodetype.DEFMETHOD("_codegen", generator);
		    }

		    AST_Node.DEFMETHOD("print", function(output, force_parens) {
		        var self = this, generator = self._codegen;
		        if (self instanceof AST_Scope) {
		            output.active_scope = self;
		        } else if (!output.use_asm && self instanceof AST_Directive && self.value == "use asm") {
		            output.use_asm = output.active_scope;
		        }
		        function doit() {
		            output.prepend_comments(self);
		            self.add_source_map(output);
		            generator(self, output);
		            output.append_comments(self);
		        }
		        output.push_node(self);
		        if (force_parens || self.needs_parens(output)) {
		            output.with_parens(doit);
		        } else {
		            doit();
		        }
		        output.pop_node();
		        if (self === output.use_asm) {
		            output.use_asm = null;
		        }
		    });
		    AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);

		    AST_Node.DEFMETHOD("print_to_string", function(options) {
		        var output = OutputStream(options);
		        this.print(output);
		        return output.get();
		    });

		    /* -----[ PARENTHESES ]----- */

		    function PARENS(nodetype, func) {
		        if (Array.isArray(nodetype)) {
		            nodetype.forEach(function(nodetype) {
		                PARENS(nodetype, func);
		            });
		        } else {
		            nodetype.DEFMETHOD("needs_parens", func);
		        }
		    }

		    PARENS(AST_Node, return_false);

		    // a function expression needs parens around it when it's provably
		    // the first token to appear in a statement.
		    PARENS(AST_Function, function(output) {
		        if (!output.has_parens() && first_in_statement(output)) {
		            return true;
		        }

		        if (output.option("webkit")) {
		            var p = output.parent();
		            if (p instanceof AST_PropAccess && p.expression === this) {
		                return true;
		            }
		        }

		        if (output.option("wrap_iife")) {
		            var p = output.parent();
		            if (p instanceof AST_Call && p.expression === this) {
		                return true;
		            }
		        }

		        if (output.option("wrap_func_args")) {
		            var p = output.parent();
		            if (p instanceof AST_Call && p.args.includes(this)) {
		                return true;
		            }
		        }

		        return false;
		    });

		    PARENS(AST_Arrow, function(output) {
		        var p = output.parent();

		        if (
		            output.option("wrap_func_args")
		            && p instanceof AST_Call
		            && p.args.includes(this)
		        ) {
		            return true;
		        }
		        return p instanceof AST_PropAccess && p.expression === this
		            || p instanceof AST_Conditional && p.condition === this;
		    });

		    // same goes for an object literal (as in AST_Function), because
		    // otherwise {...} would be interpreted as a block of code.
		    PARENS(AST_Object, function(output) {
		        return !output.has_parens() && first_in_statement(output);
		    });

		    PARENS(AST_ClassExpression, first_in_statement);

		    PARENS(AST_Unary, function(output) {
		        var p = output.parent();
		        return p instanceof AST_PropAccess && p.expression === this
		            || p instanceof AST_Call && p.expression === this
		            || p instanceof AST_Binary
		                && p.operator === "**"
		                && this instanceof AST_UnaryPrefix
		                && p.left === this
		                && this.operator !== "++"
		                && this.operator !== "--";
		    });

		    PARENS(AST_Await, function(output) {
		        var p = output.parent();
		        return p instanceof AST_PropAccess && p.expression === this
		            || p instanceof AST_Call && p.expression === this
		            || p instanceof AST_Binary && p.operator === "**" && p.left === this
		            || output.option("safari10") && p instanceof AST_UnaryPrefix;
		    });

		    PARENS(AST_Sequence, function(output) {
		        var p = output.parent();
		        return p instanceof AST_Call                          // (foo, bar)() or foo(1, (2, 3), 4)
		            || p instanceof AST_Unary                         // !(foo, bar, baz)
		            || p instanceof AST_Binary                        // 1 + (2, 3) + 4 ==> 8
		            || p instanceof AST_VarDef                        // var a = (1, 2), b = a + a; ==> b == 4
		            || p instanceof AST_PropAccess                    // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
		            || p instanceof AST_Array                         // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
		            || p instanceof AST_ObjectProperty                // { foo: (1, 2) }.foo ==> 2
		            || p instanceof AST_Conditional                   /* (false, true) ? (a = 10, b = 20) : (c = 30)
		                                                               * ==> 20 (side effect, set a := 10 and b := 20) */
		            || p instanceof AST_Arrow                         // x => (x, x)
		            || p instanceof AST_DefaultAssign                 // x => (x = (0, function(){}))
		            || p instanceof AST_Expansion                     // [...(a, b)]
		            || p instanceof AST_ForOf && this === p.object    // for (e of (foo, bar)) {}
		            || p instanceof AST_Yield                         // yield (foo, bar)
		            || p instanceof AST_Export                        // export default (foo, bar)
		        ;
		    });

		    PARENS(AST_Binary, function(output) {
		        var p = output.parent();
		        // (foo && bar)()
		        if (p instanceof AST_Call && p.expression === this)
		            return true;
		        // typeof (foo && bar)
		        if (p instanceof AST_Unary)
		            return true;
		        // (foo && bar)["prop"], (foo && bar).prop
		        if (p instanceof AST_PropAccess && p.expression === this)
		            return true;
		        // this deals with precedence: 3 * (2 + 1)
		        if (p instanceof AST_Binary) {
		            const po = p.operator;
		            const so = this.operator;

		            if (so === "??" && (po === "||" || po === "&&")) {
		                return true;
		            }

		            if (po === "??" && (so === "||" || so === "&&")) {
		                return true;
		            }

		            const pp = PRECEDENCE[po];
		            const sp = PRECEDENCE[so];
		            if (pp > sp
		                || (pp == sp
		                    && (this === p.right || po == "**"))) {
		                return true;
		            }
		        }
		    });

		    PARENS(AST_Yield, function(output) {
		        var p = output.parent();
		        // (yield 1) + (yield 2)
		        // a = yield 3
		        if (p instanceof AST_Binary && p.operator !== "=")
		            return true;
		        // (yield 1)()
		        // new (yield 1)()
		        if (p instanceof AST_Call && p.expression === this)
		            return true;
		        // (yield 1) ? yield 2 : yield 3
		        if (p instanceof AST_Conditional && p.condition === this)
		            return true;
		        // -(yield 4)
		        if (p instanceof AST_Unary)
		            return true;
		        // (yield x).foo
		        // (yield x)['foo']
		        if (p instanceof AST_PropAccess && p.expression === this)
		            return true;
		    });

		    PARENS(AST_Chain, function(output) {
		        var p = output.parent();
		        if (!(p instanceof AST_Call || p instanceof AST_PropAccess)) return false;
		        return p.expression === this;
		    });

		    PARENS(AST_PropAccess, function(output) {
		        var p = output.parent();
		        if (p instanceof AST_New && p.expression === this) {
		            // i.e. new (foo.bar().baz)
		            //
		            // if there's one call into this subtree, then we need
		            // parens around it too, otherwise the call will be
		            // interpreted as passing the arguments to the upper New
		            // expression.
		            return walk(this, node => {
		                if (node instanceof AST_Scope) return true;
		                if (node instanceof AST_Call) {
		                    return walk_abort;  // makes walk() return true.
		                }
		            });
		        }
		    });

		    PARENS(AST_Call, function(output) {
		        var p = output.parent(), p1;
		        if (p instanceof AST_New && p.expression === this
		            || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)
		            return true;

		        // workaround for Safari bug.
		        // https://bugs.webkit.org/show_bug.cgi?id=123506
		        return this.expression instanceof AST_Function
		            && p instanceof AST_PropAccess
		            && p.expression === this
		            && (p1 = output.parent(1)) instanceof AST_Assign
		            && p1.left === p;
		    });

		    PARENS(AST_New, function(output) {
		        var p = output.parent();
		        if (this.args.length === 0
		            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
		                || p instanceof AST_Call && p.expression === this
		                || p instanceof AST_PrefixedTemplateString && p.prefix === this)) // (new foo)(bar)
		            return true;
		    });

		    PARENS(AST_Number, function(output) {
		        var p = output.parent();
		        if (p instanceof AST_PropAccess && p.expression === this) {
		            var value = this.getValue();
		            if (value < 0 || /^0/.test(make_num(value))) {
		                return true;
		            }
		        }
		    });

		    PARENS(AST_BigInt, function(output) {
		        var p = output.parent();
		        if (p instanceof AST_PropAccess && p.expression === this) {
		            var value = this.getValue();
		            if (value.startsWith("-")) {
		                return true;
		            }
		        }
		    });

		    PARENS([ AST_Assign, AST_Conditional ], function(output) {
		        var p = output.parent();
		        // !(a = false) → true
		        if (p instanceof AST_Unary)
		            return true;
		        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
		        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
		            return true;
		        // (a = func)() —or— new (a = Object)()
		        if (p instanceof AST_Call && p.expression === this)
		            return true;
		        // (a = foo) ? bar : baz
		        if (p instanceof AST_Conditional && p.condition === this)
		            return true;
		        // (a = foo)["prop"] —or— (a = foo).prop
		        if (p instanceof AST_PropAccess && p.expression === this)
		            return true;
		        // ({a, b} = {a: 1, b: 2}), a destructuring assignment
		        if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)
		            return true;
		    });

		    /* -----[ PRINTERS ]----- */

		    DEFPRINT(AST_Directive, function(self, output) {
		        output.print_string(self.value, self.quote);
		        output.semicolon();
		    });

		    DEFPRINT(AST_Expansion, function (self, output) {
		        output.print("...");
		        self.expression.print(output);
		    });

		    DEFPRINT(AST_Destructuring, function (self, output) {
		        output.print(self.is_array ? "[" : "{");
		        var len = self.names.length;
		        self.names.forEach(function (name, i) {
		            if (i > 0) output.comma();
		            name.print(output);
		            // If the final element is a hole, we need to make sure it
		            // doesn't look like a trailing comma, by inserting an actual
		            // trailing comma.
		            if (i == len - 1 && name instanceof AST_Hole) output.comma();
		        });
		        output.print(self.is_array ? "]" : "}");
		    });

		    DEFPRINT(AST_Debugger, function(self, output) {
		        output.print("debugger");
		        output.semicolon();
		    });

		    /* -----[ statements ]----- */

		    function display_body(body, is_toplevel, output, allow_directives) {
		        var last = body.length - 1;
		        output.in_directive = allow_directives;
		        body.forEach(function(stmt, i) {
		            if (output.in_directive === true && !(stmt instanceof AST_Directive ||
		                stmt instanceof AST_EmptyStatement ||
		                (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)
		            )) {
		                output.in_directive = false;
		            }
		            if (!(stmt instanceof AST_EmptyStatement)) {
		                output.indent();
		                stmt.print(output);
		                if (!(i == last && is_toplevel)) {
		                    output.newline();
		                    if (is_toplevel) output.newline();
		                }
		            }
		            if (output.in_directive === true &&
		                stmt instanceof AST_SimpleStatement &&
		                stmt.body instanceof AST_String
		            ) {
		                output.in_directive = false;
		            }
		        });
		        output.in_directive = false;
		    }

		    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
		        print_maybe_braced_body(this.body, output);
		    });

		    DEFPRINT(AST_Statement, function(self, output) {
		        self.body.print(output);
		        output.semicolon();
		    });
		    DEFPRINT(AST_Toplevel, function(self, output) {
		        display_body(self.body, true, output, true);
		        output.print("");
		    });
		    DEFPRINT(AST_LabeledStatement, function(self, output) {
		        self.label.print(output);
		        output.colon();
		        self.body.print(output);
		    });
		    DEFPRINT(AST_SimpleStatement, function(self, output) {
		        self.body.print(output);
		        output.semicolon();
		    });
		    function print_braced_empty(self, output) {
		        output.print("{");
		        output.with_indent(output.next_indent(), function() {
		            output.append_comments(self, true);
		        });
		        output.add_mapping(self.end);
		        output.print("}");
		    }
		    function print_braced(self, output, allow_directives) {
		        if (self.body.length > 0) {
		            output.with_block(function() {
		                display_body(self.body, false, output, allow_directives);
		                output.add_mapping(self.end);
		            });
		        } else print_braced_empty(self, output);
		    }
		    DEFPRINT(AST_BlockStatement, function(self, output) {
		        print_braced(self, output);
		    });
		    DEFPRINT(AST_EmptyStatement, function(self, output) {
		        output.semicolon();
		    });
		    DEFPRINT(AST_Do, function(self, output) {
		        output.print("do");
		        output.space();
		        make_block(self.body, output);
		        output.space();
		        output.print("while");
		        output.space();
		        output.with_parens(function() {
		            self.condition.print(output);
		        });
		        output.semicolon();
		    });
		    DEFPRINT(AST_While, function(self, output) {
		        output.print("while");
		        output.space();
		        output.with_parens(function() {
		            self.condition.print(output);
		        });
		        output.space();
		        self._do_print_body(output);
		    });
		    DEFPRINT(AST_For, function(self, output) {
		        output.print("for");
		        output.space();
		        output.with_parens(function() {
		            if (self.init) {
		                if (self.init instanceof AST_Definitions) {
		                    self.init.print(output);
		                } else {
		                    parenthesize_for_noin(self.init, output, true);
		                }
		                output.print(";");
		                output.space();
		            } else {
		                output.print(";");
		            }
		            if (self.condition) {
		                self.condition.print(output);
		                output.print(";");
		                output.space();
		            } else {
		                output.print(";");
		            }
		            if (self.step) {
		                self.step.print(output);
		            }
		        });
		        output.space();
		        self._do_print_body(output);
		    });
		    DEFPRINT(AST_ForIn, function(self, output) {
		        output.print("for");
		        if (self.await) {
		            output.space();
		            output.print("await");
		        }
		        output.space();
		        output.with_parens(function() {
		            self.init.print(output);
		            output.space();
		            output.print(self instanceof AST_ForOf ? "of" : "in");
		            output.space();
		            self.object.print(output);
		        });
		        output.space();
		        self._do_print_body(output);
		    });
		    DEFPRINT(AST_With, function(self, output) {
		        output.print("with");
		        output.space();
		        output.with_parens(function() {
		            self.expression.print(output);
		        });
		        output.space();
		        self._do_print_body(output);
		    });

		    /* -----[ functions ]----- */
		    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
		        var self = this;
		        if (!nokeyword) {
		            if (self.async) {
		                output.print("async");
		                output.space();
		            }
		            output.print("function");
		            if (self.is_generator) {
		                output.star();
		            }
		            if (self.name) {
		                output.space();
		            }
		        }
		        if (self.name instanceof AST_Symbol) {
		            self.name.print(output);
		        } else if (nokeyword && self.name instanceof AST_Node) {
		            output.with_square(function() {
		                self.name.print(output); // Computed method name
		            });
		        }
		        output.with_parens(function() {
		            self.argnames.forEach(function(arg, i) {
		                if (i) output.comma();
		                arg.print(output);
		            });
		        });
		        output.space();
		        print_braced(self, output, true);
		    });
		    DEFPRINT(AST_Lambda, function(self, output) {
		        self._do_print(output);
		        output.gc_scope(self);
		    });

		    DEFPRINT(AST_PrefixedTemplateString, function(self, output) {
		        var tag = self.prefix;
		        var parenthesize_tag = tag instanceof AST_Lambda
		            || tag instanceof AST_Binary
		            || tag instanceof AST_Conditional
		            || tag instanceof AST_Sequence
		            || tag instanceof AST_Unary
		            || tag instanceof AST_Dot && tag.expression instanceof AST_Object;
		        if (parenthesize_tag) output.print("(");
		        self.prefix.print(output);
		        if (parenthesize_tag) output.print(")");
		        self.template_string.print(output);
		    });
		    DEFPRINT(AST_TemplateString, function(self, output) {
		        var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;

		        output.print("`");
		        for (var i = 0; i < self.segments.length; i++) {
		            if (!(self.segments[i] instanceof AST_TemplateSegment)) {
		                output.print("${");
		                self.segments[i].print(output);
		                output.print("}");
		            } else if (is_tagged) {
		                output.print(self.segments[i].raw);
		            } else {
		                output.print_template_string_chars(self.segments[i].value);
		            }
		        }
		        output.print("`");
		    });
		    DEFPRINT(AST_TemplateSegment, function(self, output) {
		        output.print_template_string_chars(self.value);
		    });

		    AST_Arrow.DEFMETHOD("_do_print", function(output) {
		        var self = this;
		        var parent = output.parent();
		        var needs_parens = (parent instanceof AST_Binary && !(parent instanceof AST_Assign)) ||
		            parent instanceof AST_Unary ||
		            (parent instanceof AST_Call && self === parent.expression);
		        if (needs_parens) { output.print("("); }
		        if (self.async) {
		            output.print("async");
		            output.space();
		        }
		        if (self.argnames.length === 1 && self.argnames[0] instanceof AST_Symbol) {
		            self.argnames[0].print(output);
		        } else {
		            output.with_parens(function() {
		                self.argnames.forEach(function(arg, i) {
		                    if (i) output.comma();
		                    arg.print(output);
		                });
		            });
		        }
		        output.space();
		        output.print("=>");
		        output.space();
		        const first_statement = self.body[0];
		        if (
		            self.body.length === 1
		            && first_statement instanceof AST_Return
		        ) {
		            const returned = first_statement.value;
		            if (!returned) {
		                output.print("{}");
		            } else if (left_is_object(returned)) {
		                output.print("(");
		                returned.print(output);
		                output.print(")");
		            } else {
		                returned.print(output);
		            }
		        } else {
		            print_braced(self, output);
		        }
		        if (needs_parens) { output.print(")"); }
		        output.gc_scope(self);
		    });

		    /* -----[ exits ]----- */
		    AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
		        output.print(kind);
		        if (this.value) {
		            output.space();
		            const comments = this.value.start.comments_before;
		            if (comments && comments.length && !output.printed_comments.has(comments)) {
		                output.print("(");
		                this.value.print(output);
		                output.print(")");
		            } else {
		                this.value.print(output);
		            }
		        }
		        output.semicolon();
		    });
		    DEFPRINT(AST_Return, function(self, output) {
		        self._do_print(output, "return");
		    });
		    DEFPRINT(AST_Throw, function(self, output) {
		        self._do_print(output, "throw");
		    });

		    /* -----[ yield ]----- */

		    DEFPRINT(AST_Yield, function(self, output) {
		        var star = self.is_star ? "*" : "";
		        output.print("yield" + star);
		        if (self.expression) {
		            output.space();
		            self.expression.print(output);
		        }
		    });

		    DEFPRINT(AST_Await, function(self, output) {
		        output.print("await");
		        output.space();
		        var e = self.expression;
		        var parens = !(
		               e instanceof AST_Call
		            || e instanceof AST_SymbolRef
		            || e instanceof AST_PropAccess
		            || e instanceof AST_Unary
		            || e instanceof AST_Constant
		            || e instanceof AST_Await
		            || e instanceof AST_Object
		        );
		        if (parens) output.print("(");
		        self.expression.print(output);
		        if (parens) output.print(")");
		    });

		    /* -----[ loop control ]----- */
		    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
		        output.print(kind);
		        if (this.label) {
		            output.space();
		            this.label.print(output);
		        }
		        output.semicolon();
		    });
		    DEFPRINT(AST_Break, function(self, output) {
		        self._do_print(output, "break");
		    });
		    DEFPRINT(AST_Continue, function(self, output) {
		        self._do_print(output, "continue");
		    });

		    /* -----[ if ]----- */
		    function make_then(self, output) {
		        var b = self.body;
		        if (output.option("braces")
		            || output.option("ie8") && b instanceof AST_Do)
		            return make_block(b, output);
		        // The squeezer replaces "block"-s that contain only a single
		        // statement with the statement itself; technically, the AST
		        // is correct, but this can create problems when we output an
		        // IF having an ELSE clause where the THEN clause ends in an
		        // IF *without* an ELSE block (then the outer ELSE would refer
		        // to the inner IF).  This function checks for this case and
		        // adds the block braces if needed.
		        if (!b) return output.force_semicolon();
		        while (true) {
		            if (b instanceof AST_If) {
		                if (!b.alternative) {
		                    make_block(self.body, output);
		                    return;
		                }
		                b = b.alternative;
		            } else if (b instanceof AST_StatementWithBody) {
		                b = b.body;
		            } else break;
		        }
		        print_maybe_braced_body(self.body, output);
		    }
		    DEFPRINT(AST_If, function(self, output) {
		        output.print("if");
		        output.space();
		        output.with_parens(function() {
		            self.condition.print(output);
		        });
		        output.space();
		        if (self.alternative) {
		            make_then(self, output);
		            output.space();
		            output.print("else");
		            output.space();
		            if (self.alternative instanceof AST_If)
		                self.alternative.print(output);
		            else
		                print_maybe_braced_body(self.alternative, output);
		        } else {
		            self._do_print_body(output);
		        }
		    });

		    /* -----[ switch ]----- */
		    DEFPRINT(AST_Switch, function(self, output) {
		        output.print("switch");
		        output.space();
		        output.with_parens(function() {
		            self.expression.print(output);
		        });
		        output.space();
		        var last = self.body.length - 1;
		        if (last < 0) print_braced_empty(self, output);
		        else output.with_block(function() {
		            self.body.forEach(function(branch, i) {
		                output.indent(true);
		                branch.print(output);
		                if (i < last && branch.body.length > 0)
		                    output.newline();
		            });
		        });
		    });
		    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
		        output.newline();
		        this.body.forEach(function(stmt) {
		            output.indent();
		            stmt.print(output);
		            output.newline();
		        });
		    });
		    DEFPRINT(AST_Default, function(self, output) {
		        output.print("default:");
		        self._do_print_body(output);
		    });
		    DEFPRINT(AST_Case, function(self, output) {
		        output.print("case");
		        output.space();
		        self.expression.print(output);
		        output.print(":");
		        self._do_print_body(output);
		    });

		    /* -----[ exceptions ]----- */
		    DEFPRINT(AST_Try, function(self, output) {
		        output.print("try");
		        output.space();
		        self.body.print(output);
		        if (self.bcatch) {
		            output.space();
		            self.bcatch.print(output);
		        }
		        if (self.bfinally) {
		            output.space();
		            self.bfinally.print(output);
		        }
		    });
		    DEFPRINT(AST_TryBlock, function(self, output) {
		        print_braced(self, output);
		    });
		    DEFPRINT(AST_Catch, function(self, output) {
		        output.print("catch");
		        if (self.argname) {
		            output.space();
		            output.with_parens(function() {
		                self.argname.print(output);
		            });
		        }
		        output.space();
		        print_braced(self, output);
		    });
		    DEFPRINT(AST_Finally, function(self, output) {
		        output.print("finally");
		        output.space();
		        print_braced(self, output);
		    });

		    /* -----[ var/const ]----- */
		    AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
		        output.print(kind);
		        output.space();
		        this.definitions.forEach(function(def, i) {
		            if (i) output.comma();
		            def.print(output);
		        });
		        var p = output.parent();
		        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
		        var output_semicolon = !in_for || p && p.init !== this;
		        if (output_semicolon)
		            output.semicolon();
		    });
		    DEFPRINT(AST_Let, function(self, output) {
		        self._do_print(output, "let");
		    });
		    DEFPRINT(AST_Var, function(self, output) {
		        self._do_print(output, "var");
		    });
		    DEFPRINT(AST_Const, function(self, output) {
		        self._do_print(output, "const");
		    });
		    DEFPRINT(AST_Import, function(self, output) {
		        output.print("import");
		        output.space();
		        if (self.imported_name) {
		            self.imported_name.print(output);
		        }
		        if (self.imported_name && self.imported_names) {
		            output.print(",");
		            output.space();
		        }
		        if (self.imported_names) {
		            if (self.imported_names.length === 1 &&
		                self.imported_names[0].foreign_name.name === "*" &&
		                !self.imported_names[0].foreign_name.quote) {
		                self.imported_names[0].print(output);
		            } else {
		                output.print("{");
		                self.imported_names.forEach(function (name_import, i) {
		                    output.space();
		                    name_import.print(output);
		                    if (i < self.imported_names.length - 1) {
		                        output.print(",");
		                    }
		                });
		                output.space();
		                output.print("}");
		            }
		        }
		        if (self.imported_name || self.imported_names) {
		            output.space();
		            output.print("from");
		            output.space();
		        }
		        self.module_name.print(output);
		        if (self.assert_clause) {
		            output.print("assert");
		            self.assert_clause.print(output);
		        }
		        output.semicolon();
		    });
		    DEFPRINT(AST_ImportMeta, function(self, output) {
		        output.print("import.meta");
		    });

		    DEFPRINT(AST_NameMapping, function(self, output) {
		        var is_import = output.parent() instanceof AST_Import;
		        var definition = self.name.definition();
		        var foreign_name = self.foreign_name;
		        var names_are_different =
		            (definition && definition.mangled_name || self.name.name) !==
		            foreign_name.name;
		        if (!names_are_different &&
		            foreign_name.name === "*" &&
		            foreign_name.quote != self.name.quote) {
		                // export * as "*"
		            names_are_different = true;
		        }
		        var foreign_name_is_name = foreign_name.quote == null;
		        if (names_are_different) {
		            if (is_import) {
		                if (foreign_name_is_name) {
		                    output.print(foreign_name.name);
		                } else {
		                    output.print_string(foreign_name.name, foreign_name.quote);
		                }
		            } else {
		                if (self.name.quote == null) {
		                    self.name.print(output);
		                } else {
		                    output.print_string(self.name.name, self.name.quote);
		                }
		                
		            }
		            output.space();
		            output.print("as");
		            output.space();
		            if (is_import) {
		                self.name.print(output);
		            } else {
		                if (foreign_name_is_name) {
		                    output.print(foreign_name.name);
		                } else {
		                    output.print_string(foreign_name.name, foreign_name.quote);
		                }
		            }
		        } else {
		            if (self.name.quote == null) {
		                self.name.print(output);
		            } else {
		                output.print_string(self.name.name, self.name.quote);
		            }
		        }
		    });

		    DEFPRINT(AST_Export, function(self, output) {
		        output.print("export");
		        output.space();
		        if (self.is_default) {
		            output.print("default");
		            output.space();
		        }
		        if (self.exported_names) {
		            if (self.exported_names.length === 1 &&
		                self.exported_names[0].name.name === "*" &&
		                !self.exported_names[0].name.quote) {
		                    self.exported_names[0].print(output);
		            } else {
		                output.print("{");
		                self.exported_names.forEach(function(name_export, i) {
		                    output.space();
		                    name_export.print(output);
		                    if (i < self.exported_names.length - 1) {
		                        output.print(",");
		                    }
		                });
		                output.space();
		                output.print("}");
		            }
		        } else if (self.exported_value) {
		            self.exported_value.print(output);
		        } else if (self.exported_definition) {
		            self.exported_definition.print(output);
		            if (self.exported_definition instanceof AST_Definitions) return;
		        }
		        if (self.module_name) {
		            output.space();
		            output.print("from");
		            output.space();
		            self.module_name.print(output);
		        }
		        if (self.assert_clause) {
		            output.print("assert");
		            self.assert_clause.print(output);
		        }
		        if (self.exported_value
		                && !(self.exported_value instanceof AST_Defun ||
		                    self.exported_value instanceof AST_Function ||
		                    self.exported_value instanceof AST_Class)
		            || self.module_name
		            || self.exported_names
		        ) {
		            output.semicolon();
		        }
		    });

		    function parenthesize_for_noin(node, output, noin) {
		        var parens = false;
		        // need to take some precautions here:
		        //    https://github.com/mishoo/UglifyJS2/issues/60
		        if (noin) {
		            parens = walk(node, node => {
		                // Don't go into scopes -- except arrow functions:
		                // https://github.com/terser/terser/issues/1019#issuecomment-877642607
		                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
		                    return true;
		                }
		                if (
		                    node instanceof AST_Binary && node.operator == "in"
		                    || node instanceof AST_PrivateIn
		                ) {
		                    return walk_abort;  // makes walk() return true
		                }
		            });
		        }
		        node.print(output, parens);
		    }

		    DEFPRINT(AST_VarDef, function(self, output) {
		        self.name.print(output);
		        if (self.value) {
		            output.space();
		            output.print("=");
		            output.space();
		            var p = output.parent(1);
		            var noin = p instanceof AST_For || p instanceof AST_ForIn;
		            parenthesize_for_noin(self.value, output, noin);
		        }
		    });

		    /* -----[ other expressions ]----- */
		    DEFPRINT(AST_Call, function(self, output) {
		        self.expression.print(output);
		        if (self instanceof AST_New && self.args.length === 0)
		            return;
		        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {
		            output.add_mapping(self.start);
		        }
		        if (self.optional) output.print("?.");
		        output.with_parens(function() {
		            self.args.forEach(function(expr, i) {
		                if (i) output.comma();
		                expr.print(output);
		            });
		        });
		    });
		    DEFPRINT(AST_New, function(self, output) {
		        output.print("new");
		        output.space();
		        AST_Call.prototype._codegen(self, output);
		    });

		    AST_Sequence.DEFMETHOD("_do_print", function(output) {
		        this.expressions.forEach(function(node, index) {
		            if (index > 0) {
		                output.comma();
		                if (output.should_break()) {
		                    output.newline();
		                    output.indent();
		                }
		            }
		            node.print(output);
		        });
		    });
		    DEFPRINT(AST_Sequence, function(self, output) {
		        self._do_print(output);
		        // var p = output.parent();
		        // if (p instanceof AST_Statement) {
		        //     output.with_indent(output.next_indent(), function(){
		        //         self._do_print(output);
		        //     });
		        // } else {
		        //     self._do_print(output);
		        // }
		    });
		    DEFPRINT(AST_Dot, function(self, output) {
		        var expr = self.expression;
		        expr.print(output);
		        var prop = self.property;
		        var print_computed = ALL_RESERVED_WORDS.has(prop)
		            ? output.option("ie8")
		            : !is_identifier_string(
		                prop,
		                output.option("ecma") >= 2015 && !output.option("safari10")
		            );

		        if (self.optional) output.print("?.");

		        if (print_computed) {
		            output.print("[");
		            output.add_mapping(self.end);
		            output.print_string(prop);
		            output.print("]");
		        } else {
		            if (expr instanceof AST_Number && expr.getValue() >= 0) {
		                if (!/[xa-f.)]/i.test(output.last())) {
		                    output.print(".");
		                }
		            }
		            if (!self.optional) output.print(".");
		            // the name after dot would be mapped about here.
		            output.add_mapping(self.end);
		            output.print_name(prop);
		        }
		    });
		    DEFPRINT(AST_DotHash, function(self, output) {
		        var expr = self.expression;
		        expr.print(output);
		        var prop = self.property;

		        if (self.optional) output.print("?");
		        output.print(".#");
		        output.add_mapping(self.end);
		        output.print_name(prop);
		    });
		    DEFPRINT(AST_Sub, function(self, output) {
		        self.expression.print(output);
		        if (self.optional) output.print("?.");
		        output.print("[");
		        self.property.print(output);
		        output.print("]");
		    });
		    DEFPRINT(AST_Chain, function(self, output) {
		        self.expression.print(output);
		    });
		    DEFPRINT(AST_UnaryPrefix, function(self, output) {
		        var op = self.operator;
		        if (op === "--" && output.last().endsWith("!")) {
		            // avoid printing "<!--"
		            output.print(" ");
		        }
		        output.print(op);
		        if (/^[a-z]/i.test(op)
		            || (/[+-]$/.test(op)
		                && self.expression instanceof AST_UnaryPrefix
		                && /^[+-]/.test(self.expression.operator))) {
		            output.space();
		        }
		        self.expression.print(output);
		    });
		    DEFPRINT(AST_UnaryPostfix, function(self, output) {
		        self.expression.print(output);
		        output.print(self.operator);
		    });
		    DEFPRINT(AST_Binary, function(self, output) {
		        var op = self.operator;
		        self.left.print(output);
		        if (op[0] == ">" /* ">>" ">>>" ">" ">=" */
		            && output.last().endsWith("--")) {
		            // space is mandatory to avoid outputting -->
		            output.print(" ");
		        } else {
		            // the space is optional depending on "beautify"
		            output.space();
		        }
		        output.print(op);
		        output.space();
		        self.right.print(output);
		    });
		    DEFPRINT(AST_Conditional, function(self, output) {
		        self.condition.print(output);
		        output.space();
		        output.print("?");
		        output.space();
		        self.consequent.print(output);
		        output.space();
		        output.colon();
		        self.alternative.print(output);
		    });

		    /* -----[ literals ]----- */
		    DEFPRINT(AST_Array, function(self, output) {
		        output.with_square(function() {
		            var a = self.elements, len = a.length;
		            if (len > 0) output.space();
		            a.forEach(function(exp, i) {
		                if (i) output.comma();
		                exp.print(output);
		                // If the final element is a hole, we need to make sure it
		                // doesn't look like a trailing comma, by inserting an actual
		                // trailing comma.
		                if (i === len - 1 && exp instanceof AST_Hole)
		                  output.comma();
		            });
		            if (len > 0) output.space();
		        });
		    });
		    DEFPRINT(AST_Object, function(self, output) {
		        if (self.properties.length > 0) output.with_block(function() {
		            self.properties.forEach(function(prop, i) {
		                if (i) {
		                    output.print(",");
		                    output.newline();
		                }
		                output.indent();
		                prop.print(output);
		            });
		            output.newline();
		        });
		        else print_braced_empty(self, output);
		    });
		    DEFPRINT(AST_Class, function(self, output) {
		        output.print("class");
		        output.space();
		        if (self.name) {
		            self.name.print(output);
		            output.space();
		        }
		        if (self.extends) {
		            var parens = (
		                   !(self.extends instanceof AST_SymbolRef)
		                && !(self.extends instanceof AST_PropAccess)
		                && !(self.extends instanceof AST_ClassExpression)
		                && !(self.extends instanceof AST_Function)
		            );
		            output.print("extends");
		            if (parens) {
		                output.print("(");
		            } else {
		                output.space();
		            }
		            self.extends.print(output);
		            if (parens) {
		                output.print(")");
		            } else {
		                output.space();
		            }
		        }
		        if (self.properties.length > 0) output.with_block(function() {
		            self.properties.forEach(function(prop, i) {
		                if (i) {
		                    output.newline();
		                }
		                output.indent();
		                prop.print(output);
		            });
		            output.newline();
		        });
		        else output.print("{}");
		    });
		    DEFPRINT(AST_NewTarget, function(self, output) {
		        output.print("new.target");
		    });

		    /** Prints a prop name. Returns whether it can be used as a shorthand. */
		    function print_property_name(key, quote, output) {
		        if (output.option("quote_keys")) {
		            output.print_string(key);
		            return false;
		        }
		        if ("" + +key == key && key >= 0) {
		            if (output.option("keep_numbers")) {
		                output.print(key);
		                return false;
		            }
		            output.print(make_num(key));
		            return false;
		        }
		        var print_string = ALL_RESERVED_WORDS.has(key)
		            ? output.option("ie8")
		            : (
		                output.option("ecma") < 2015 || output.option("safari10")
		                    ? !is_basic_identifier_string(key)
		                    : !is_identifier_string(key, true)
		            );
		        if (print_string || (quote && output.option("keep_quoted_props"))) {
		            output.print_string(key, quote);
		            return false;
		        }
		        output.print_name(key);
		        return true;
		    }

		    DEFPRINT(AST_ObjectKeyVal, function(self, output) {
		        function get_name(self) {
		            var def = self.definition();
		            return def ? def.mangled_name || def.name : self.name;
		        }

		        const try_shorthand = output.option("shorthand") && !(self.key instanceof AST_Node);
		        if (
		            try_shorthand
		            && self.value instanceof AST_Symbol
		            && get_name(self.value) === self.key
		            && !ALL_RESERVED_WORDS.has(self.key)
		        ) {
		            const was_shorthand = print_property_name(self.key, self.quote, output);
		            if (!was_shorthand) {
		                output.colon();
		                self.value.print(output);
		            }
		        } else if (
		            try_shorthand
		            && self.value instanceof AST_DefaultAssign
		            && self.value.left instanceof AST_Symbol
		            && get_name(self.value.left) === self.key
		        ) {
		            const was_shorthand = print_property_name(self.key, self.quote, output);
		            if (!was_shorthand) {
		                output.colon();
		                self.value.left.print(output);
		            }
		            output.space();
		            output.print("=");
		            output.space();
		            self.value.right.print(output);
		        } else {
		            if (!(self.key instanceof AST_Node)) {
		                print_property_name(self.key, self.quote, output);
		            } else {
		                output.with_square(function() {
		                    self.key.print(output);
		                });
		            }
		            output.colon();
		            self.value.print(output);
		        }
		    });
		    DEFPRINT(AST_ClassPrivateProperty, (self, output) => {
		        if (self.static) {
		            output.print("static");
		            output.space();
		        }

		        output.print("#");
		        
		        print_property_name(self.key.name, self.quote, output);

		        if (self.value) {
		            output.print("=");
		            self.value.print(output);
		        }

		        output.semicolon();
		    });
		    DEFPRINT(AST_ClassProperty, (self, output) => {
		        if (self.static) {
		            output.print("static");
		            output.space();
		        }

		        if (self.key instanceof AST_SymbolClassProperty) {
		            print_property_name(self.key.name, self.quote, output);
		        } else {
		            output.print("[");
		            self.key.print(output);
		            output.print("]");
		        }

		        if (self.value) {
		            output.print("=");
		            self.value.print(output);
		        }

		        output.semicolon();
		    });
		    AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, is_private, output) {
		        var self = this;
		        if (self.static) {
		            output.print("static");
		            output.space();
		        }
		        if (type) {
		            output.print(type);
		            output.space();
		        }
		        if (self.key instanceof AST_SymbolMethod) {
		            if (is_private) output.print("#");
		            print_property_name(self.key.name, self.quote, output);
		            self.key.add_source_map(output);
		        } else {
		            output.with_square(function() {
		                self.key.print(output);
		            });
		        }
		        self.value._do_print(output, true);
		    });
		    DEFPRINT(AST_ObjectSetter, function(self, output) {
		        self._print_getter_setter("set", false, output);
		    });
		    DEFPRINT(AST_ObjectGetter, function(self, output) {
		        self._print_getter_setter("get", false, output);
		    });
		    DEFPRINT(AST_PrivateSetter, function(self, output) {
		        self._print_getter_setter("set", true, output);
		    });
		    DEFPRINT(AST_PrivateGetter, function(self, output) {
		        self._print_getter_setter("get", true, output);
		    });
		    DEFPRINT(AST_PrivateMethod, function(self, output) {
		        var type;
		        if (self.is_generator && self.async) {
		            type = "async*";
		        } else if (self.is_generator) {
		            type = "*";
		        } else if (self.async) {
		            type = "async";
		        }
		        self._print_getter_setter(type, true, output);
		    });
		    DEFPRINT(AST_PrivateIn, function(self, output) {
		        self.key.print(output);
		        output.space();
		        output.print("in");
		        output.space();
		        self.value.print(output);
		    });
		    DEFPRINT(AST_SymbolPrivateProperty, function(self, output) {
		        output.print("#" + self.name);
		    });
		    DEFPRINT(AST_ConciseMethod, function(self, output) {
		        var type;
		        if (self.is_generator && self.async) {
		            type = "async*";
		        } else if (self.is_generator) {
		            type = "*";
		        } else if (self.async) {
		            type = "async";
		        }
		        self._print_getter_setter(type, false, output);
		    });
		    DEFPRINT(AST_ClassStaticBlock, function (self, output) {
		        output.print("static");
		        output.space();
		        print_braced(self, output);
		    });
		    AST_Symbol.DEFMETHOD("_do_print", function(output) {
		        var def = this.definition();
		        output.print_name(def ? def.mangled_name || def.name : this.name);
		    });
		    DEFPRINT(AST_Symbol, function (self, output) {
		        self._do_print(output);
		    });
		    DEFPRINT(AST_Hole, noop);
		    DEFPRINT(AST_This, function(self, output) {
		        output.print("this");
		    });
		    DEFPRINT(AST_Super, function(self, output) {
		        output.print("super");
		    });
		    DEFPRINT(AST_Constant, function(self, output) {
		        output.print(self.getValue());
		    });
		    DEFPRINT(AST_String, function(self, output) {
		        output.print_string(self.getValue(), self.quote, output.in_directive);
		    });
		    DEFPRINT(AST_Number, function(self, output) {
		        if ((output.option("keep_numbers") || output.use_asm) && self.raw) {
		            output.print(self.raw);
		        } else {
		            output.print(make_num(self.getValue()));
		        }
		    });
		    DEFPRINT(AST_BigInt, function(self, output) {
		        output.print(self.getValue() + "n");
		    });

		    const r_slash_script = /(<\s*\/\s*script)/i;
		    const r_starts_with_script = /^\s*script/i;
		    const slash_script_replace = (_, $1) => $1.replace("/", "\\/");
		    DEFPRINT(AST_RegExp, function(self, output) {
		        let { source, flags } = self.getValue();
		        source = regexp_source_fix(source);
		        flags = flags ? sort_regexp_flags(flags) : "";

		        // Avoid outputting end of script tag
		        source = source.replace(r_slash_script, slash_script_replace);
		        if (r_starts_with_script.test(source) && output.last().endsWith("<")) {
		            output.print(" ");
		        }

		        output.print(output.to_utf8(`/${source}/${flags}`, false, true));

		        const parent = output.parent();
		        if (
		            parent instanceof AST_Binary
		            && /^\w/.test(parent.operator)
		            && parent.left === self
		        ) {
		            output.print(" ");
		        }
		    });

		    /** if, for, while, may or may not have braces surrounding its body */
		    function print_maybe_braced_body(stat, output) {
		        if (output.option("braces")) {
		            make_block(stat, output);
		        } else {
		            if (!stat || stat instanceof AST_EmptyStatement)
		                output.force_semicolon();
		            else if (stat instanceof AST_Let || stat instanceof AST_Const || stat instanceof AST_Class)
		                make_block(stat, output);
		            else
		                stat.print(output);
		        }
		    }

		    function best_of(a) {
		        var best = a[0], len = best.length;
		        for (var i = 1; i < a.length; ++i) {
		            if (a[i].length < len) {
		                best = a[i];
		                len = best.length;
		            }
		        }
		        return best;
		    }

		    function make_num(num) {
		        var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
		        var candidates = [ str ];
		        if (Math.floor(num) === num) {
		            if (num < 0) {
		                candidates.push("-0x" + (-num).toString(16).toLowerCase());
		            } else {
		                candidates.push("0x" + num.toString(16).toLowerCase());
		            }
		        }
		        var match, len, digits;
		        if (match = /^\.0+/.exec(str)) {
		            len = match[0].length;
		            digits = str.slice(len);
		            candidates.push(digits + "e-" + (digits.length + len - 1));
		        } else if (match = /0+$/.exec(str)) {
		            len = match[0].length;
		            candidates.push(str.slice(0, -len) + "e" + len);
		        } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
		            candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
		        }
		        return best_of(candidates);
		    }

		    function make_block(stmt, output) {
		        if (!stmt || stmt instanceof AST_EmptyStatement)
		            output.print("{}");
		        else if (stmt instanceof AST_BlockStatement)
		            stmt.print(output);
		        else output.with_block(function() {
		            output.indent();
		            stmt.print(output);
		            output.newline();
		        });
		    }

		    /* -----[ source map generators ]----- */

		    function DEFMAP(nodetype, generator) {
		        nodetype.forEach(function(nodetype) {
		            nodetype.DEFMETHOD("add_source_map", generator);
		        });
		    }

		    DEFMAP([
		        // We could easily add info for ALL nodes, but it seems to me that
		        // would be quite wasteful, hence this noop in the base class.
		        AST_Node,
		        // since the label symbol will mark it
		        AST_LabeledStatement,
		        AST_Toplevel,
		    ], noop);

		    // XXX: I'm not exactly sure if we need it for all of these nodes,
		    // or if we should add even more.
		    DEFMAP([
		        AST_Array,
		        AST_BlockStatement,
		        AST_Catch,
		        AST_Class,
		        AST_Constant,
		        AST_Debugger,
		        AST_Definitions,
		        AST_Directive,
		        AST_Finally,
		        AST_Jump,
		        AST_Lambda,
		        AST_New,
		        AST_Object,
		        AST_StatementWithBody,
		        AST_Symbol,
		        AST_Switch,
		        AST_SwitchBranch,
		        AST_TemplateString,
		        AST_TemplateSegment,
		        AST_Try,
		    ], function(output) {
		        output.add_mapping(this.start);
		    });

		    DEFMAP([
		        AST_ObjectGetter,
		        AST_ObjectSetter,
		        AST_PrivateGetter,
		        AST_PrivateSetter,
		        AST_ConciseMethod,
		        AST_PrivateMethod,
		    ], function(output) {
		        output.add_mapping(this.start, false /*name handled below*/);
		    });

		    DEFMAP([
		        AST_SymbolMethod,
		        AST_SymbolPrivateProperty
		    ], function(output) {
		        const tok_type = this.end && this.end.type;
		        if (tok_type === "name" || tok_type === "privatename") {
		            output.add_mapping(this.end, this.name);
		        } else {
		            output.add_mapping(this.end);
		        }
		    });

		    DEFMAP([ AST_ObjectProperty ], function(output) {
		        output.add_mapping(this.start, this.key);
		    });
		})();

		const shallow_cmp = (node1, node2) => {
		    return (
		        node1 === null && node2 === null
		        || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2)
		    );
		};

		const equivalent_to = (tree1, tree2) => {
		    if (!shallow_cmp(tree1, tree2)) return false;
		    const walk_1_state = [tree1];
		    const walk_2_state = [tree2];

		    const walk_1_push = walk_1_state.push.bind(walk_1_state);
		    const walk_2_push = walk_2_state.push.bind(walk_2_state);

		    while (walk_1_state.length && walk_2_state.length) {
		        const node_1 = walk_1_state.pop();
		        const node_2 = walk_2_state.pop();

		        if (!shallow_cmp(node_1, node_2)) return false;

		        node_1._children_backwards(walk_1_push);
		        node_2._children_backwards(walk_2_push);

		        if (walk_1_state.length !== walk_2_state.length) {
		            // Different number of children
		            return false;
		        }
		    }

		    return walk_1_state.length == 0 && walk_2_state.length == 0;
		};

		const pass_through = () => true;

		AST_Node.prototype.shallow_cmp = function () {
		    throw new Error("did not find a shallow_cmp function for " + this.constructor.name);
		};

		AST_Debugger.prototype.shallow_cmp = pass_through;

		AST_Directive.prototype.shallow_cmp = function(other) {
		    return this.value === other.value;
		};

		AST_SimpleStatement.prototype.shallow_cmp = pass_through;

		AST_Block.prototype.shallow_cmp = pass_through;

		AST_EmptyStatement.prototype.shallow_cmp = pass_through;

		AST_LabeledStatement.prototype.shallow_cmp = function(other) {
		    return this.label.name === other.label.name;
		};

		AST_Do.prototype.shallow_cmp = pass_through;

		AST_While.prototype.shallow_cmp = pass_through;

		AST_For.prototype.shallow_cmp = function(other) {
		    return (this.init == null ? other.init == null : this.init === other.init) && (this.condition == null ? other.condition == null : this.condition === other.condition) && (this.step == null ? other.step == null : this.step === other.step);
		};

		AST_ForIn.prototype.shallow_cmp = pass_through;

		AST_ForOf.prototype.shallow_cmp = pass_through;

		AST_With.prototype.shallow_cmp = pass_through;

		AST_Toplevel.prototype.shallow_cmp = pass_through;

		AST_Expansion.prototype.shallow_cmp = pass_through;

		AST_Lambda.prototype.shallow_cmp = function(other) {
		    return this.is_generator === other.is_generator && this.async === other.async;
		};

		AST_Destructuring.prototype.shallow_cmp = function(other) {
		    return this.is_array === other.is_array;
		};

		AST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;

		AST_TemplateString.prototype.shallow_cmp = pass_through;

		AST_TemplateSegment.prototype.shallow_cmp = function(other) {
		    return this.value === other.value;
		};

		AST_Jump.prototype.shallow_cmp = pass_through;

		AST_LoopControl.prototype.shallow_cmp = pass_through;

		AST_Await.prototype.shallow_cmp = pass_through;

		AST_Yield.prototype.shallow_cmp = function(other) {
		    return this.is_star === other.is_star;
		};

		AST_If.prototype.shallow_cmp = function(other) {
		    return this.alternative == null ? other.alternative == null : this.alternative === other.alternative;
		};

		AST_Switch.prototype.shallow_cmp = pass_through;

		AST_SwitchBranch.prototype.shallow_cmp = pass_through;

		AST_Try.prototype.shallow_cmp = function(other) {
		    return (this.body === other.body) && (this.bcatch == null ? other.bcatch == null : this.bcatch === other.bcatch) && (this.bfinally == null ? other.bfinally == null : this.bfinally === other.bfinally);
		};

		AST_Catch.prototype.shallow_cmp = function(other) {
		    return this.argname == null ? other.argname == null : this.argname === other.argname;
		};

		AST_Finally.prototype.shallow_cmp = pass_through;

		AST_Definitions.prototype.shallow_cmp = pass_through;

		AST_VarDef.prototype.shallow_cmp = function(other) {
		    return this.value == null ? other.value == null : this.value === other.value;
		};

		AST_NameMapping.prototype.shallow_cmp = pass_through;

		AST_Import.prototype.shallow_cmp = function(other) {
		    return (this.imported_name == null ? other.imported_name == null : this.imported_name === other.imported_name) && (this.imported_names == null ? other.imported_names == null : this.imported_names === other.imported_names);
		};

		AST_ImportMeta.prototype.shallow_cmp = pass_through;

		AST_Export.prototype.shallow_cmp = function(other) {
		    return (this.exported_definition == null ? other.exported_definition == null : this.exported_definition === other.exported_definition) && (this.exported_value == null ? other.exported_value == null : this.exported_value === other.exported_value) && (this.exported_names == null ? other.exported_names == null : this.exported_names === other.exported_names) && this.module_name === other.module_name && this.is_default === other.is_default;
		};

		AST_Call.prototype.shallow_cmp = pass_through;

		AST_Sequence.prototype.shallow_cmp = pass_through;

		AST_PropAccess.prototype.shallow_cmp = pass_through;

		AST_Chain.prototype.shallow_cmp = pass_through;

		AST_Dot.prototype.shallow_cmp = function(other) {
		    return this.property === other.property;
		};

		AST_DotHash.prototype.shallow_cmp = function(other) {
		    return this.property === other.property;
		};

		AST_Unary.prototype.shallow_cmp = function(other) {
		    return this.operator === other.operator;
		};

		AST_Binary.prototype.shallow_cmp = function(other) {
		    return this.operator === other.operator;
		};

		AST_Conditional.prototype.shallow_cmp = pass_through;

		AST_Array.prototype.shallow_cmp = pass_through;

		AST_Object.prototype.shallow_cmp = pass_through;

		AST_ObjectProperty.prototype.shallow_cmp = pass_through;

		AST_ObjectKeyVal.prototype.shallow_cmp = function(other) {
		    return this.key === other.key;
		};

		AST_ObjectSetter.prototype.shallow_cmp = function(other) {
		    return this.static === other.static;
		};

		AST_ObjectGetter.prototype.shallow_cmp = function(other) {
		    return this.static === other.static;
		};

		AST_ConciseMethod.prototype.shallow_cmp = function(other) {
		    return this.static === other.static && this.is_generator === other.is_generator && this.async === other.async;
		};

		AST_Class.prototype.shallow_cmp = function(other) {
		    return (this.name == null ? other.name == null : this.name === other.name) && (this.extends == null ? other.extends == null : this.extends === other.extends);
		};

		AST_ClassProperty.prototype.shallow_cmp = function(other) {
		    return this.static === other.static;
		};

		AST_Symbol.prototype.shallow_cmp = function(other) {
		    return this.name === other.name;
		};

		AST_NewTarget.prototype.shallow_cmp = pass_through;

		AST_This.prototype.shallow_cmp = pass_through;

		AST_Super.prototype.shallow_cmp = pass_through;

		AST_String.prototype.shallow_cmp = function(other) {
		    return this.value === other.value;
		};

		AST_Number.prototype.shallow_cmp = function(other) {
		    return this.value === other.value;
		};

		AST_BigInt.prototype.shallow_cmp = function(other) {
		    return this.value === other.value;
		};

		AST_RegExp.prototype.shallow_cmp = function (other) {
		    return (
		        this.value.flags === other.value.flags
		        && this.value.source === other.value.source
		    );
		};

		AST_Atom.prototype.shallow_cmp = pass_through;

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		const MASK_EXPORT_DONT_MANGLE = 1 << 0;
		const MASK_EXPORT_WANT_MANGLE = 1 << 1;

		let function_defs = null;
		let unmangleable_names = null;
		/**
		 * When defined, there is a function declaration somewhere that's inside of a block.
		 * See https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics
		*/
		let scopes_with_block_defuns = null;

		class SymbolDef {
		    constructor(scope, orig, init) {
		        this.name = orig.name;
		        this.orig = [ orig ];
		        this.init = init;
		        this.eliminated = 0;
		        this.assignments = 0;
		        this.scope = scope;
		        this.replaced = 0;
		        this.global = false;
		        this.export = 0;
		        this.mangled_name = null;
		        this.undeclared = false;
		        this.id = SymbolDef.next_id++;
		        this.chained = false;
		        this.direct_access = false;
		        this.escaped = 0;
		        this.recursive_refs = 0;
		        this.references = [];
		        this.should_replace = undefined;
		        this.single_use = false;
		        this.fixed = false;
		        Object.seal(this);
		    }
		    fixed_value() {
		        if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;
		        return this.fixed();
		    }
		    unmangleable(options) {
		        if (!options) options = {};

		        if (
		            function_defs &&
		            function_defs.has(this.id) &&
		            keep_name(options.keep_fnames, this.orig[0].name)
		        ) return true;

		        return this.global && !options.toplevel
		            || (this.export & MASK_EXPORT_DONT_MANGLE)
		            || this.undeclared
		            || !options.eval && this.scope.pinned()
		            || (this.orig[0] instanceof AST_SymbolLambda
		                  || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name)
		            || this.orig[0] instanceof AST_SymbolMethod
		            || (this.orig[0] instanceof AST_SymbolClass
		                  || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);
		    }
		    mangle(options) {
		        const cache = options.cache && options.cache.props;
		        if (this.global && cache && cache.has(this.name)) {
		            this.mangled_name = cache.get(this.name);
		        } else if (!this.mangled_name && !this.unmangleable(options)) {
		            var s = this.scope;
		            var sym = this.orig[0];
		            if (options.ie8 && sym instanceof AST_SymbolLambda)
		                s = s.parent_scope;
		            const redefinition = redefined_catch_def(this);
		            this.mangled_name = redefinition
		                ? redefinition.mangled_name || redefinition.name
		                : s.next_mangled(options, this);
		            if (this.global && cache) {
		                cache.set(this.name, this.mangled_name);
		            }
		        }
		    }
		}

		SymbolDef.next_id = 1;

		function redefined_catch_def(def) {
		    if (def.orig[0] instanceof AST_SymbolCatch
		        && def.scope.is_block_scope()
		    ) {
		        return def.scope.get_defun_scope().variables.get(def.name);
		    }
		}

		AST_Scope.DEFMETHOD("figure_out_scope", function(options, { parent_scope = null, toplevel = this } = {}) {
		    options = defaults(options, {
		        cache: null,
		        ie8: false,
		        safari10: false,
		    });

		    if (!(toplevel instanceof AST_Toplevel)) {
		        throw new Error("Invalid toplevel scope");
		    }

		    // pass 1: setup scope chaining and handle definitions
		    var scope = this.parent_scope = parent_scope;
		    var labels = new Map();
		    var defun = null;
		    var in_destructuring = null;
		    var for_scopes = [];
		    var tw = new TreeWalker((node, descend) => {
		        if (node.is_block_scope()) {
		            const save_scope = scope;
		            node.block_scope = scope = new AST_Scope(node);
		            scope._block_scope = true;
		            scope.init_scope_vars(save_scope);
		            scope.uses_with = save_scope.uses_with;
		            scope.uses_eval = save_scope.uses_eval;

		            if (options.safari10) {
		                if (node instanceof AST_For || node instanceof AST_ForIn || node instanceof AST_ForOf) {
		                    for_scopes.push(scope);
		                }
		            }

		            if (node instanceof AST_Switch) {
		                // XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope
		                // AST_Switch has a scope within the body, but it itself "is a block scope"
		                // This means the switched expression has to belong to the outer scope
		                // while the body inside belongs to the switch itself.
		                // This is pretty nasty and warrants an AST change
		                const the_block_scope = scope;
		                scope = save_scope;
		                node.expression.walk(tw);
		                scope = the_block_scope;
		                for (let i = 0; i < node.body.length; i++) {
		                    node.body[i].walk(tw);
		                }
		            } else {
		                descend();
		            }
		            scope = save_scope;
		            return true;
		        }
		        if (node instanceof AST_Destructuring) {
		            const save_destructuring = in_destructuring;
		            in_destructuring = node;
		            descend();
		            in_destructuring = save_destructuring;
		            return true;
		        }
		        if (node instanceof AST_Scope) {
		            node.init_scope_vars(scope);
		            var save_scope = scope;
		            var save_defun = defun;
		            var save_labels = labels;
		            defun = scope = node;
		            labels = new Map();
		            descend();
		            scope = save_scope;
		            defun = save_defun;
		            labels = save_labels;
		            return true;        // don't descend again in TreeWalker
		        }
		        if (node instanceof AST_LabeledStatement) {
		            var l = node.label;
		            if (labels.has(l.name)) {
		                throw new Error(string_template("Label {name} defined twice", l));
		            }
		            labels.set(l.name, l);
		            descend();
		            labels.delete(l.name);
		            return true;        // no descend again
		        }
		        if (node instanceof AST_With) {
		            for (var s = scope; s; s = s.parent_scope)
		                s.uses_with = true;
		            return;
		        }
		        if (node instanceof AST_Symbol) {
		            node.scope = scope;
		        }
		        if (node instanceof AST_Label) {
		            node.thedef = node;
		            node.references = [];
		        }
		        if (node instanceof AST_SymbolLambda) {
		            defun.def_function(node, node.name == "arguments" ? undefined : defun);
		        } else if (node instanceof AST_SymbolDefun) {
		            // Careful here, the scope where this should be defined is
		            // the parent scope.  The reason is that we enter a new
		            // scope when we encounter the AST_Defun node (which is
		            // instanceof AST_Scope) but we get to the symbol a bit
		            // later.
		            const closest_scope = defun.parent_scope;

		            // In strict mode, function definitions are block-scoped
		            node.scope = tw.directives["use strict"]
		                ? closest_scope
		                : closest_scope.get_defun_scope();

		            mark_export(node.scope.def_function(node, defun), 1);
		        } else if (node instanceof AST_SymbolClass) {
		            mark_export(defun.def_variable(node, defun), 1);
		        } else if (node instanceof AST_SymbolImport) {
		            scope.def_variable(node);
		        } else if (node instanceof AST_SymbolDefClass) {
		            // This deals with the name of the class being available
		            // inside the class.
		            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);
		        } else if (
		            node instanceof AST_SymbolVar
		            || node instanceof AST_SymbolLet
		            || node instanceof AST_SymbolConst
		            || node instanceof AST_SymbolCatch
		        ) {
		            var def;
		            if (node instanceof AST_SymbolBlockDeclaration) {
		                def = scope.def_variable(node, null);
		            } else {
		                def = defun.def_variable(node, node.TYPE == "SymbolVar" ? null : undefined);
		            }
		            if (!def.orig.every((sym) => {
		                if (sym === node) return true;
		                if (node instanceof AST_SymbolBlockDeclaration) {
		                    return sym instanceof AST_SymbolLambda;
		                }
		                return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst);
		            })) {
		                js_error(
		                    `"${node.name}" is redeclared`,
		                    node.start.file,
		                    node.start.line,
		                    node.start.col,
		                    node.start.pos
		                );
		            }
		            if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);
		            if (defun !== scope) {
		                node.mark_enclosed();
		                var def = scope.find_variable(node);
		                if (node.thedef !== def) {
		                    node.thedef = def;
		                    node.reference();
		                }
		            }
		        } else if (node instanceof AST_LabelRef) {
		            var sym = labels.get(node.name);
		            if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
		                name: node.name,
		                line: node.start.line,
		                col: node.start.col
		            }));
		            node.thedef = sym;
		        }
		        if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {
		            js_error(
		                `"${node.TYPE}" statement may only appear at the top level`,
		                node.start.file,
		                node.start.line,
		                node.start.col,
		                node.start.pos
		            );
		        }
		    });
		    this.walk(tw);

		    function mark_export(def, level) {
		        if (in_destructuring) {
		            var i = 0;
		            do {
		                level++;
		            } while (tw.parent(i++) !== in_destructuring);
		        }
		        var node = tw.parent(level);
		        if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {
		            var exported = node.exported_definition;
		            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {
		                def.export = MASK_EXPORT_WANT_MANGLE;
		            }
		        }
		    }

		    // pass 2: find back references and eval
		    const is_toplevel = this instanceof AST_Toplevel;
		    if (is_toplevel) {
		        this.globals = new Map();
		    }

		    var tw = new TreeWalker(node => {
		        if (node instanceof AST_LoopControl && node.label) {
		            node.label.thedef.references.push(node);
		            return true;
		        }
		        if (node instanceof AST_SymbolRef) {
		            var name = node.name;
		            if (name == "eval" && tw.parent() instanceof AST_Call) {
		                for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
		                    s.uses_eval = true;
		                }
		            }
		            var sym;
		            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name
		                || !(sym = node.scope.find_variable(name))) {

		                sym = toplevel.def_global(node);
		                if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;
		            } else if (sym.scope instanceof AST_Lambda && name == "arguments") {
		                sym.scope.get_defun_scope().uses_arguments = true;
		            }
		            node.thedef = sym;
		            node.reference();
		            if (node.scope.is_block_scope()
		                && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {
		                node.scope = node.scope.get_defun_scope();
		            }
		            return true;
		        }
		        // ensure mangling works if catch reuses a scope variable
		        var def;
		        if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {
		            var s = node.scope;
		            while (s) {
		                push_uniq(s.enclosed, def);
		                if (s === def.scope) break;
		                s = s.parent_scope;
		            }
		        }
		    });
		    this.walk(tw);

		    // pass 3: work around IE8 and Safari catch scope bugs
		    if (options.ie8 || options.safari10) {
		        walk(this, node => {
		            if (node instanceof AST_SymbolCatch) {
		                var name = node.name;
		                var refs = node.thedef.references;
		                var scope = node.scope.get_defun_scope();
		                var def = scope.find_variable(name)
		                    || toplevel.globals.get(name)
		                    || scope.def_variable(node);
		                refs.forEach(function(ref) {
		                    ref.thedef = def;
		                    ref.reference();
		                });
		                node.thedef = def;
		                node.reference();
		                return true;
		            }
		        });
		    }

		    // pass 4: add symbol definitions to loop scopes
		    // Safari/Webkit bug workaround - loop init let variable shadowing argument.
		    // https://github.com/mishoo/UglifyJS2/issues/1753
		    // https://bugs.webkit.org/show_bug.cgi?id=171041
		    if (options.safari10) {
		        for (const scope of for_scopes) {
		            scope.parent_scope.variables.forEach(function(def) {
		                push_uniq(scope.enclosed, def);
		            });
		        }
		    }
		});

		AST_Toplevel.DEFMETHOD("def_global", function(node) {
		    var globals = this.globals, name = node.name;
		    if (globals.has(name)) {
		        return globals.get(name);
		    } else {
		        var g = new SymbolDef(this, node);
		        g.undeclared = true;
		        g.global = true;
		        globals.set(name, g);
		        return g;
		    }
		});

		AST_Scope.DEFMETHOD("init_scope_vars", function(parent_scope) {
		    this.variables = new Map();         // map name to AST_SymbolVar (variables defined in this scope; includes functions)
		    this.uses_with = false;             // will be set to true if this or some nested scope uses the `with` statement
		    this.uses_eval = false;             // will be set to true if this or nested scope uses the global `eval`
		    this.parent_scope = parent_scope;   // the parent scope
		    this.enclosed = [];                 // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
		    this.cname = -1;                    // the current index for mangling functions/variables
		});

		AST_Scope.DEFMETHOD("conflicting_def", function (name) {
		    return (
		        this.enclosed.find(def => def.name === name)
		        || this.variables.has(name)
		        || (this.parent_scope && this.parent_scope.conflicting_def(name))
		    );
		});

		AST_Scope.DEFMETHOD("conflicting_def_shallow", function (name) {
		    return (
		        this.enclosed.find(def => def.name === name)
		        || this.variables.has(name)
		    );
		});

		AST_Scope.DEFMETHOD("add_child_scope", function (scope) {
		    // `scope` is going to be moved into `this` right now.
		    // Update the required scopes' information

		    if (scope.parent_scope === this) return;

		    scope.parent_scope = this;

		    // Propagate to this.uses_arguments from arrow functions
		    if ((scope instanceof AST_Arrow) && !this.uses_arguments) {
		        this.uses_arguments = walk(scope, node => {
		            if (
		                node instanceof AST_SymbolRef
		                && node.scope instanceof AST_Lambda
		                && node.name === "arguments"
		            ) {
		                return walk_abort;
		            }

		            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
		                return true;
		            }
		        });
		    }

		    this.uses_with = this.uses_with || scope.uses_with;
		    this.uses_eval = this.uses_eval || scope.uses_eval;

		    const scope_ancestry = (() => {
		        const ancestry = [];
		        let cur = this;
		        do {
		            ancestry.push(cur);
		        } while ((cur = cur.parent_scope));
		        ancestry.reverse();
		        return ancestry;
		    })();

		    const new_scope_enclosed_set = new Set(scope.enclosed);
		    const to_enclose = [];
		    for (const scope_topdown of scope_ancestry) {
		        to_enclose.forEach(e => push_uniq(scope_topdown.enclosed, e));
		        for (const def of scope_topdown.variables.values()) {
		            if (new_scope_enclosed_set.has(def)) {
		                push_uniq(to_enclose, def);
		                push_uniq(scope_topdown.enclosed, def);
		            }
		        }
		    }
		});

		function find_scopes_visible_from(scopes) {
		    const found_scopes = new Set();

		    for (const scope of new Set(scopes)) {
		        (function bubble_up(scope) {
		            if (scope == null || found_scopes.has(scope)) return;

		            found_scopes.add(scope);

		            bubble_up(scope.parent_scope);
		        })(scope);
		    }

		    return [...found_scopes];
		}

		// Creates a symbol during compression
		AST_Scope.DEFMETHOD("create_symbol", function(SymClass, {
		    source,
		    tentative_name,
		    scope,
		    conflict_scopes = [scope],
		    init = null
		} = {}) {
		    let symbol_name;

		    conflict_scopes = find_scopes_visible_from(conflict_scopes);

		    if (tentative_name) {
		        // Implement hygiene (no new names are conflicting with existing names)
		        tentative_name =
		            symbol_name =
		            tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");

		        let i = 0;
		        while (conflict_scopes.find(s => s.conflicting_def_shallow(symbol_name))) {
		            symbol_name = tentative_name + "$" + i++;
		        }
		    }

		    if (!symbol_name) {
		        throw new Error("No symbol name could be generated in create_symbol()");
		    }

		    const symbol = make_node(SymClass, source, {
		        name: symbol_name,
		        scope
		    });

		    this.def_variable(symbol, init || null);

		    symbol.mark_enclosed();

		    return symbol;
		});


		AST_Node.DEFMETHOD("is_block_scope", return_false);
		AST_Class.DEFMETHOD("is_block_scope", return_false);
		AST_Lambda.DEFMETHOD("is_block_scope", return_false);
		AST_Toplevel.DEFMETHOD("is_block_scope", return_false);
		AST_SwitchBranch.DEFMETHOD("is_block_scope", return_false);
		AST_Block.DEFMETHOD("is_block_scope", return_true);
		AST_Scope.DEFMETHOD("is_block_scope", function () {
		    return this._block_scope || false;
		});
		AST_IterationStatement.DEFMETHOD("is_block_scope", return_true);

		AST_Lambda.DEFMETHOD("init_scope_vars", function() {
		    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
		    this.uses_arguments = false;
		    this.def_variable(new AST_SymbolFunarg({
		        name: "arguments",
		        start: this.start,
		        end: this.end
		    }));
		});

		AST_Arrow.DEFMETHOD("init_scope_vars", function() {
		    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
		    this.uses_arguments = false;
		});

		AST_Symbol.DEFMETHOD("mark_enclosed", function() {
		    var def = this.definition();
		    var s = this.scope;
		    while (s) {
		        push_uniq(s.enclosed, def);
		        if (s === def.scope) break;
		        s = s.parent_scope;
		    }
		});

		AST_Symbol.DEFMETHOD("reference", function() {
		    this.definition().references.push(this);
		    this.mark_enclosed();
		});

		AST_Scope.DEFMETHOD("find_variable", function(name) {
		    if (name instanceof AST_Symbol) name = name.name;
		    return this.variables.get(name)
		        || (this.parent_scope && this.parent_scope.find_variable(name));
		});

		AST_Scope.DEFMETHOD("def_function", function(symbol, init) {
		    var def = this.def_variable(symbol, init);
		    if (!def.init || def.init instanceof AST_Defun) def.init = init;
		    return def;
		});

		AST_Scope.DEFMETHOD("def_variable", function(symbol, init) {
		    var def = this.variables.get(symbol.name);
		    if (def) {
		        def.orig.push(symbol);
		        if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {
		            def.init = init;
		        }
		    } else {
		        def = new SymbolDef(this, symbol, init);
		        this.variables.set(symbol.name, def);
		        def.global = !this.parent_scope;
		    }
		    return symbol.thedef = def;
		});

		function next_mangled(scope, options) {
		    let defun_scope;
		    if (
		        scopes_with_block_defuns
		        && (defun_scope = scope.get_defun_scope())
		        && scopes_with_block_defuns.has(defun_scope)
		    ) {
		        scope = defun_scope;
		    }

		    var ext = scope.enclosed;
		    var nth_identifier = options.nth_identifier;
		    out: while (true) {
		        var m = nth_identifier.get(++scope.cname);
		        if (ALL_RESERVED_WORDS.has(m)) continue; // skip over "do"

		        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
		        // shadow a name reserved from mangling.
		        if (options.reserved.has(m)) continue;

		        // Functions with short names might collide with base54 output
		        // and therefore cause collisions when keep_fnames is true.
		        if (unmangleable_names && unmangleable_names.has(m)) continue out;

		        // we must ensure that the mangled name does not shadow a name
		        // from some parent scope that is referenced in this or in
		        // inner scopes.
		        for (let i = ext.length; --i >= 0;) {
		            const def = ext[i];
		            const name = def.mangled_name || (def.unmangleable(options) && def.name);
		            if (m == name) continue out;
		        }
		        return m;
		    }
		}

		AST_Scope.DEFMETHOD("next_mangled", function(options) {
		    return next_mangled(this, options);
		});

		AST_Toplevel.DEFMETHOD("next_mangled", function(options) {
		    let name;
		    const mangled_names = this.mangled_names;
		    do {
		        name = next_mangled(this, options);
		    } while (mangled_names.has(name));
		    return name;
		});

		AST_Function.DEFMETHOD("next_mangled", function(options, def) {
		    // #179, #326
		    // in Safari strict mode, something like (function x(x){...}) is a syntax error;
		    // a function expression's argument cannot shadow the function expression's name

		    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();

		    // the function's mangled_name is null when keep_fnames is true
		    var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;

		    while (true) {
		        var name = next_mangled(this, options);
		        if (!tricky_name || tricky_name != name)
		            return name;
		    }
		});

		AST_Symbol.DEFMETHOD("unmangleable", function(options) {
		    var def = this.definition();
		    return !def || def.unmangleable(options);
		});

		// labels are always mangleable
		AST_Label.DEFMETHOD("unmangleable", return_false);

		AST_Symbol.DEFMETHOD("unreferenced", function() {
		    return !this.definition().references.length && !this.scope.pinned();
		});

		AST_Symbol.DEFMETHOD("definition", function() {
		    return this.thedef;
		});

		AST_Symbol.DEFMETHOD("global", function() {
		    return this.thedef.global;
		});

		/**
		 * Format the mangler options (if any) into their appropriate types
		 */
		function format_mangler_options(options) {
		    options = defaults(options, {
		        eval        : false,
		        nth_identifier : base54,
		        ie8         : false,
		        keep_classnames: false,
		        keep_fnames : false,
		        module      : false,
		        reserved    : [],
		        toplevel    : false,
		    });
		    if (options.module) options.toplevel = true;
		    if (!Array.isArray(options.reserved)
		        && !(options.reserved instanceof Set)
		    ) {
		        options.reserved = [];
		    }
		    options.reserved = new Set(options.reserved);
		    // Never mangle arguments
		    options.reserved.add("arguments");
		    return options;
		}

		AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
		    options = format_mangler_options(options);
		    var nth_identifier = options.nth_identifier;

		    // We only need to mangle declaration nodes.  Special logic wired
		    // into the code generator will display the mangled name if it's
		    // present (and for AST_SymbolRef-s it'll use the mangled name of
		    // the AST_SymbolDeclaration that it points to).
		    var lname = -1;
		    var to_mangle = [];

		    if (options.keep_fnames) {
		        function_defs = new Set();
		    }

		    const mangled_names = this.mangled_names = new Set();
		    unmangleable_names = new Set();

		    if (options.cache) {
		        this.globals.forEach(collect);
		        if (options.cache.props) {
		            options.cache.props.forEach(function(mangled_name) {
		                mangled_names.add(mangled_name);
		            });
		        }
		    }

		    var tw = new TreeWalker(function(node, descend) {
		        if (node instanceof AST_LabeledStatement) {
		            // lname is incremented when we get to the AST_Label
		            var save_nesting = lname;
		            descend();
		            lname = save_nesting;
		            return true;        // don't descend again in TreeWalker
		        }
		        if (
		            node instanceof AST_Defun
		            && !(tw.parent() instanceof AST_Scope)
		        ) {
		            scopes_with_block_defuns = scopes_with_block_defuns || new Set();
		            scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());
		        }
		        if (node instanceof AST_Scope) {
		            node.variables.forEach(collect);
		            return;
		        }
		        if (node.is_block_scope()) {
		            node.block_scope.variables.forEach(collect);
		            return;
		        }
		        if (
		            function_defs
		            && node instanceof AST_VarDef
		            && node.value instanceof AST_Lambda
		            && !node.value.name
		            && keep_name(options.keep_fnames, node.name.name)
		        ) {
		            function_defs.add(node.name.definition().id);
		            return;
		        }
		        if (node instanceof AST_Label) {
		            let name;
		            do {
		                name = nth_identifier.get(++lname);
		            } while (ALL_RESERVED_WORDS.has(name));
		            node.mangled_name = name;
		            return true;
		        }
		        if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {
		            to_mangle.push(node.definition());
		            return;
		        }
		    });

		    this.walk(tw);

		    if (options.keep_fnames || options.keep_classnames) {
		        // Collect a set of short names which are unmangleable,
		        // for use in avoiding collisions in next_mangled.
		        to_mangle.forEach(def => {
		            if (def.name.length < 6 && def.unmangleable(options)) {
		                unmangleable_names.add(def.name);
		            }
		        });
		    }

		    to_mangle.forEach(def => { def.mangle(options); });

		    function_defs = null;
		    unmangleable_names = null;
		    scopes_with_block_defuns = null;

		    function collect(symbol) {
		        if (symbol.export & MASK_EXPORT_DONT_MANGLE) {
		            unmangleable_names.add(symbol.name);
		        } else if (!options.reserved.has(symbol.name)) {
		            to_mangle.push(symbol);
		        }
		    }
		});

		AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
		    const cache = options.cache && options.cache.props;
		    const avoid = new Set();
		    options.reserved.forEach(to_avoid);
		    this.globals.forEach(add_def);
		    this.walk(new TreeWalker(function(node) {
		        if (node instanceof AST_Scope) node.variables.forEach(add_def);
		        if (node instanceof AST_SymbolCatch) add_def(node.definition());
		    }));
		    return avoid;

		    function to_avoid(name) {
		        avoid.add(name);
		    }

		    function add_def(def) {
		        var name = def.name;
		        if (def.global && cache && cache.has(name)) name = cache.get(name);
		        else if (!def.unmangleable(options)) return;
		        to_avoid(name);
		    }
		});

		AST_Toplevel.DEFMETHOD("expand_names", function(options) {
		    options = format_mangler_options(options);
		    var nth_identifier = options.nth_identifier;
		    if (nth_identifier.reset && nth_identifier.sort) {
		        nth_identifier.reset();
		        nth_identifier.sort();
		    }
		    var avoid = this.find_colliding_names(options);
		    var cname = 0;
		    this.globals.forEach(rename);
		    this.walk(new TreeWalker(function(node) {
		        if (node instanceof AST_Scope) node.variables.forEach(rename);
		        if (node instanceof AST_SymbolCatch) rename(node.definition());
		    }));

		    function next_name() {
		        var name;
		        do {
		            name = nth_identifier.get(cname++);
		        } while (avoid.has(name) || ALL_RESERVED_WORDS.has(name));
		        return name;
		    }

		    function rename(def) {
		        if (def.global && options.cache) return;
		        if (def.unmangleable(options)) return;
		        if (options.reserved.has(def.name)) return;
		        const redefinition = redefined_catch_def(def);
		        const name = def.name = redefinition ? redefinition.name : next_name();
		        def.orig.forEach(function(sym) {
		            sym.name = name;
		        });
		        def.references.forEach(function(sym) {
		            sym.name = name;
		        });
		    }
		});

		AST_Node.DEFMETHOD("tail_node", return_this);
		AST_Sequence.DEFMETHOD("tail_node", function() {
		    return this.expressions[this.expressions.length - 1];
		});

		AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
		    options = format_mangler_options(options);
		    var nth_identifier = options.nth_identifier;
		    if (!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {
		        // If the identifier mangler is invariant, skip computing character frequency.
		        return;
		    }
		    nth_identifier.reset();

		    try {
		        AST_Node.prototype.print = function(stream, force_parens) {
		            this._print(stream, force_parens);
		            if (this instanceof AST_Symbol && !this.unmangleable(options)) {
		                nth_identifier.consider(this.name, -1);
		            } else if (options.properties) {
		                if (this instanceof AST_DotHash) {
		                    nth_identifier.consider("#" + this.property, -1);
		                } else if (this instanceof AST_Dot) {
		                    nth_identifier.consider(this.property, -1);
		                } else if (this instanceof AST_Sub) {
		                    skip_string(this.property);
		                }
		            }
		        };
		        nth_identifier.consider(this.print_to_string(), 1);
		    } finally {
		        AST_Node.prototype.print = AST_Node.prototype._print;
		    }
		    nth_identifier.sort();

		    function skip_string(node) {
		        if (node instanceof AST_String) {
		            nth_identifier.consider(node.value, -1);
		        } else if (node instanceof AST_Conditional) {
		            skip_string(node.consequent);
		            skip_string(node.alternative);
		        } else if (node instanceof AST_Sequence) {
		            skip_string(node.tail_node());
		        }
		    }
		});

		const base54 = (() => {
		    const leading = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split("");
		    const digits = "0123456789".split("");
		    let chars;
		    let frequency;
		    function reset() {
		        frequency = new Map();
		        leading.forEach(function(ch) {
		            frequency.set(ch, 0);
		        });
		        digits.forEach(function(ch) {
		            frequency.set(ch, 0);
		        });
		    }
		    function consider(str, delta) {
		        for (var i = str.length; --i >= 0;) {
		            frequency.set(str[i], frequency.get(str[i]) + delta);
		        }
		    }
		    function compare(a, b) {
		        return frequency.get(b) - frequency.get(a);
		    }
		    function sort() {
		        chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));
		    }
		    // Ensure this is in a usable initial state.
		    reset();
		    sort();
		    function base54(num) {
		        var ret = "", base = 54;
		        num++;
		        do {
		            num--;
		            ret += chars[num % base];
		            num = Math.floor(num / base);
		            base = 64;
		        } while (num > 0);
		        return ret;
		    }

		    return {
		        get: base54,
		        consider,
		        reset,
		        sort
		    };
		})();

		let mangle_options = undefined;
		AST_Node.prototype.size = function (compressor, stack) {
		    mangle_options = compressor && compressor.mangle_options;

		    let size = 0;
		    walk_parent(this, (node, info) => {
		        size += node._size(info);

		        // Braceless arrow functions have fake "return" statements
		        if (node instanceof AST_Arrow && node.is_braceless()) {
		            size += node.body[0].value._size(info);
		            return true;
		        }
		    }, stack || (compressor && compressor.stack));

		    // just to save a bit of memory
		    mangle_options = undefined;

		    return size;
		};

		AST_Node.prototype._size = () => 0;

		AST_Debugger.prototype._size = () => 8;

		AST_Directive.prototype._size = function () {
		    // TODO string encoding stuff
		    return 2 + this.value.length;
		};

		/** Count commas/semicolons necessary to show a list of expressions/statements */
		const list_overhead = (array) => array.length && array.length - 1;

		AST_Block.prototype._size = function () {
		    return 2 + list_overhead(this.body);
		};

		AST_Toplevel.prototype._size = function() {
		    return list_overhead(this.body);
		};

		AST_EmptyStatement.prototype._size = () => 1;

		AST_LabeledStatement.prototype._size = () => 2;  // x:

		AST_Do.prototype._size = () => 9;

		AST_While.prototype._size = () => 7;

		AST_For.prototype._size = () => 8;

		AST_ForIn.prototype._size = () => 8;
		// AST_ForOf inherits ^

		AST_With.prototype._size = () => 6;

		AST_Expansion.prototype._size = () => 3;

		const lambda_modifiers = func =>
		    (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);

		AST_Accessor.prototype._size = function () {
		    return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);
		};

		AST_Function.prototype._size = function (info) {
		    const first = !!first_in_statement(info);
		    return (first * 2) + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);
		};

		AST_Defun.prototype._size = function () {
		    return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);
		};

		AST_Arrow.prototype._size = function () {
		    let args_and_arrow = 2 + list_overhead(this.argnames);

		    if (
		        !(
		            this.argnames.length === 1
		            && this.argnames[0] instanceof AST_Symbol
		        )
		    ) {
		        args_and_arrow += 2; // parens around the args
		    }

		    const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;

		    return lambda_modifiers(this) + args_and_arrow + body_overhead;
		};

		AST_Destructuring.prototype._size = () => 2;

		AST_TemplateString.prototype._size = function () {
		    return 2 + (Math.floor(this.segments.length / 2) * 3);  /* "${}" */
		};

		AST_TemplateSegment.prototype._size = function () {
		    return this.value.length;
		};

		AST_Return.prototype._size = function () {
		    return this.value ? 7 : 6;
		};

		AST_Throw.prototype._size = () => 6;

		AST_Break.prototype._size = function () {
		    return this.label ? 6 : 5;
		};

		AST_Continue.prototype._size = function () {
		    return this.label ? 9 : 8;
		};

		AST_If.prototype._size = () => 4;

		AST_Switch.prototype._size = function () {
		    return 8 + list_overhead(this.body);
		};

		AST_Case.prototype._size = function () {
		    return 5 + list_overhead(this.body);
		};

		AST_Default.prototype._size = function () {
		    return 8 + list_overhead(this.body);
		};

		AST_Try.prototype._size = () => 3;

		AST_Catch.prototype._size = function () {
		    let size = 7 + list_overhead(this.body);
		    if (this.argname) {
		        size += 2;
		    }
		    return size;
		};

		AST_Finally.prototype._size = function () {
		    return 7 + list_overhead(this.body);
		};

		AST_Var.prototype._size = function () {
		    return 4 + list_overhead(this.definitions);
		};

		AST_Let.prototype._size = function () {
		    return 4 + list_overhead(this.definitions);
		};

		AST_Const.prototype._size = function () {
		    return 6 + list_overhead(this.definitions);
		};

		AST_VarDef.prototype._size = function () {
		    return this.value ? 1 : 0;
		};

		AST_NameMapping.prototype._size = function () {
		    // foreign name isn't mangled
		    return this.name ? 4 : 0;
		};

		AST_Import.prototype._size = function () {
		    // import
		    let size = 6;

		    if (this.imported_name) size += 1;

		    // from
		    if (this.imported_name || this.imported_names) size += 5;

		    // braces, and the commas
		    if (this.imported_names) {
		        size += 2 + list_overhead(this.imported_names);
		    }

		    return size;
		};

		AST_ImportMeta.prototype._size = () => 11;

		AST_Export.prototype._size = function () {
		    let size = 7 + (this.is_default ? 8 : 0);

		    if (this.exported_value) {
		        size += this.exported_value._size();
		    }

		    if (this.exported_names) {
		        // Braces and commas
		        size += 2 + list_overhead(this.exported_names);
		    }

		    if (this.module_name) {
		        // "from "
		        size += 5;
		    }

		    return size;
		};

		AST_Call.prototype._size = function () {
		    if (this.optional) {
		        return 4 + list_overhead(this.args);
		    }
		    return 2 + list_overhead(this.args);
		};

		AST_New.prototype._size = function () {
		    return 6 + list_overhead(this.args);
		};

		AST_Sequence.prototype._size = function () {
		    return list_overhead(this.expressions);
		};

		AST_Dot.prototype._size = function () {
		    if (this.optional) {
		        return this.property.length + 2;
		    }
		    return this.property.length + 1;
		};

		AST_DotHash.prototype._size = function () {
		    if (this.optional) {
		        return this.property.length + 3;
		    }
		    return this.property.length + 2;
		};

		AST_Sub.prototype._size = function () {
		    return this.optional ? 4 : 2;
		};

		AST_Unary.prototype._size = function () {
		    if (this.operator === "typeof") return 7;
		    if (this.operator === "void") return 5;
		    return this.operator.length;
		};

		AST_Binary.prototype._size = function (info) {
		    if (this.operator === "in") return 4;

		    let size = this.operator.length;

		    if (
		        (this.operator === "+" || this.operator === "-")
		        && this.right instanceof AST_Unary && this.right.operator === this.operator
		    ) {
		        // 1+ +a > needs space between the +
		        size += 1;
		    }

		    if (this.needs_parens(info)) {
		        size += 2;
		    }

		    return size;
		};

		AST_Conditional.prototype._size = () => 3;

		AST_Array.prototype._size = function () {
		    return 2 + list_overhead(this.elements);
		};

		AST_Object.prototype._size = function (info) {
		    let base = 2;
		    if (first_in_statement(info)) {
		        base += 2; // parens
		    }
		    return base + list_overhead(this.properties);
		};

		/*#__INLINE__*/
		const key_size = key =>
		    typeof key === "string" ? key.length : 0;

		AST_ObjectKeyVal.prototype._size = function () {
		    return key_size(this.key) + 1;
		};

		/*#__INLINE__*/
		const static_size = is_static => is_static ? 7 : 0;

		AST_ObjectGetter.prototype._size = function () {
		    return 5 + static_size(this.static) + key_size(this.key);
		};

		AST_ObjectSetter.prototype._size = function () {
		    return 5 + static_size(this.static) + key_size(this.key);
		};

		AST_ConciseMethod.prototype._size = function () {
		    return static_size(this.static) + key_size(this.key) + lambda_modifiers(this);
		};

		AST_PrivateMethod.prototype._size = function () {
		    return AST_ConciseMethod.prototype._size.call(this) + 1;
		};

		AST_PrivateGetter.prototype._size = AST_PrivateSetter.prototype._size = function () {
		    return AST_ConciseMethod.prototype._size.call(this) + 4;
		};

		AST_PrivateIn.prototype._size = function () {
		    return 5; // "#", and " in "
		};

		AST_Class.prototype._size = function () {
		    return (
		        (this.name ? 8 : 7)
		        + (this.extends ? 8 : 0)
		    );
		};

		AST_ClassStaticBlock.prototype._size = function () {
		    // "class{}" + semicolons
		    return 7 + list_overhead(this.body);
		};

		AST_ClassProperty.prototype._size = function () {
		    return (
		        static_size(this.static)
		        + (typeof this.key === "string" ? this.key.length + 2 : 0)
		        + (this.value ? 1 : 0)
		    );
		};

		AST_ClassPrivateProperty.prototype._size = function () {
		    return AST_ClassProperty.prototype._size.call(this) + 1;
		};

		AST_Symbol.prototype._size = function () {
		    if (!(mangle_options && this.thedef && !this.thedef.unmangleable(mangle_options))) {
		        return this.name.length;
		    } else {
		        return 1;
		    }
		};

		// TODO take propmangle into account
		AST_SymbolClassProperty.prototype._size = function () {
		    return this.name.length;
		};

		AST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function () {
		    if (this.name === "arguments") return 9;

		    return AST_Symbol.prototype._size.call(this);
		};

		AST_NewTarget.prototype._size = () => 10;

		AST_SymbolImportForeign.prototype._size = function () {
		    return this.name.length;
		};

		AST_SymbolExportForeign.prototype._size = function () {
		    return this.name.length;
		};

		AST_This.prototype._size = () => 4;

		AST_Super.prototype._size = () => 5;

		AST_String.prototype._size = function () {
		    return this.value.length + 2;
		};

		AST_Number.prototype._size = function () {
		    const { value } = this;
		    if (value === 0) return 1;
		    if (value > 0 && Math.floor(value) === value) {
		        return Math.floor(Math.log10(value) + 1);
		    }
		    return value.toString().length;
		};

		AST_BigInt.prototype._size = function () {
		    return this.value.length;
		};

		AST_RegExp.prototype._size = function () {
		    return this.value.toString().length;
		};

		AST_Null.prototype._size = () => 4;

		AST_NaN.prototype._size = () => 3;

		AST_Undefined.prototype._size = () => 6; // "void 0"

		AST_Hole.prototype._size = () => 0;  // comma is taken into account by list_overhead()

		AST_Infinity.prototype._size = () => 8;

		AST_True.prototype._size = () => 4;

		AST_False.prototype._size = () => 5;

		AST_Await.prototype._size = () => 6;

		AST_Yield.prototype._size = () => 6;

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// bitfield flags to be stored in node.flags.
		// These are set and unset during compression, and store information in the node without requiring multiple fields.
		const UNUSED = 0b00000001;
		const TRUTHY = 0b00000010;
		const FALSY = 0b00000100;
		const UNDEFINED = 0b00001000;
		const INLINED = 0b00010000;

		// Nodes to which values are ever written. Used when keep_assign is part of the unused option string.
		const WRITE_ONLY = 0b00100000;

		// information specific to a single compression pass
		const SQUEEZED = 0b0000000100000000;
		const OPTIMIZED = 0b0000001000000000;
		const TOP = 0b0000010000000000;
		const CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;

		const has_flag = (node, flag) => node.flags & flag;
		const set_flag = (node, flag) => { node.flags |= flag; };
		const clear_flag = (node, flag) => { node.flags &= ~flag; };

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function merge_sequence(array, node) {
		    if (node instanceof AST_Sequence) {
		        array.push(...node.expressions);
		    } else {
		        array.push(node);
		    }
		    return array;
		}

		function make_sequence(orig, expressions) {
		    if (expressions.length == 1) return expressions[0];
		    if (expressions.length == 0) throw new Error("trying to create a sequence with length zero!");
		    return make_node(AST_Sequence, orig, {
		        expressions: expressions.reduce(merge_sequence, [])
		    });
		}

		function make_node_from_constant(val, orig) {
		    switch (typeof val) {
		      case "string":
		        return make_node(AST_String, orig, {
		            value: val
		        });
		      case "number":
		        if (isNaN(val)) return make_node(AST_NaN, orig);
		        if (isFinite(val)) {
		            return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
		                operator: "-",
		                expression: make_node(AST_Number, orig, { value: -val })
		            }) : make_node(AST_Number, orig, { value: val });
		        }
		        return val < 0 ? make_node(AST_UnaryPrefix, orig, {
		            operator: "-",
		            expression: make_node(AST_Infinity, orig)
		        }) : make_node(AST_Infinity, orig);
		      case "boolean":
		        return make_node(val ? AST_True : AST_False, orig);
		      case "undefined":
		        return make_node(AST_Undefined, orig);
		      default:
		        if (val === null) {
		            return make_node(AST_Null, orig, { value: null });
		        }
		        if (val instanceof RegExp) {
		            return make_node(AST_RegExp, orig, {
		                value: {
		                    source: regexp_source_fix(val.source),
		                    flags: val.flags
		                }
		            });
		        }
		        throw new Error(string_template("Can't handle constant of type: {type}", {
		            type: typeof val
		        }));
		    }
		}

		function best_of_expression(ast1, ast2) {
		    return ast1.size() > ast2.size() ? ast2 : ast1;
		}

		function best_of_statement(ast1, ast2) {
		    return best_of_expression(
		        make_node(AST_SimpleStatement, ast1, {
		            body: ast1
		        }),
		        make_node(AST_SimpleStatement, ast2, {
		            body: ast2
		        })
		    ).body;
		}

		/** Find which node is smaller, and return that */
		function best_of(compressor, ast1, ast2) {
		    if (first_in_statement(compressor)) {
		        return best_of_statement(ast1, ast2);
		    } else {
		        return best_of_expression(ast1, ast2);
		    }
		}

		/** Simplify an object property's key, if possible */
		function get_simple_key(key) {
		    if (key instanceof AST_Constant) {
		        return key.getValue();
		    }
		    if (key instanceof AST_UnaryPrefix
		        && key.operator == "void"
		        && key.expression instanceof AST_Constant) {
		        return;
		    }
		    return key;
		}

		function read_property(obj, key) {
		    key = get_simple_key(key);
		    if (key instanceof AST_Node) return;

		    var value;
		    if (obj instanceof AST_Array) {
		        var elements = obj.elements;
		        if (key == "length") return make_node_from_constant(elements.length, obj);
		        if (typeof key == "number" && key in elements) value = elements[key];
		    } else if (obj instanceof AST_Object) {
		        key = "" + key;
		        var props = obj.properties;
		        for (var i = props.length; --i >= 0;) {
		            var prop = props[i];
		            if (!(prop instanceof AST_ObjectKeyVal)) return;
		            if (!value && props[i].key === key) value = props[i].value;
		        }
		    }

		    return value instanceof AST_SymbolRef && value.fixed_value() || value;
		}

		function has_break_or_continue(loop, parent) {
		    var found = false;
		    var tw = new TreeWalker(function(node) {
		        if (found || node instanceof AST_Scope) return true;
		        if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop) {
		            return found = true;
		        }
		    });
		    if (parent instanceof AST_LabeledStatement) tw.push(parent);
		    tw.push(loop);
		    loop.body.walk(tw);
		    return found;
		}

		// we shouldn't compress (1,func)(something) to
		// func(something) because that changes the meaning of
		// the func (becomes lexical instead of global).
		function maintain_this_binding(parent, orig, val) {
		    if (
		        parent instanceof AST_UnaryPrefix && parent.operator == "delete"
		        || parent instanceof AST_Call && parent.expression === orig
		            && (
		                val instanceof AST_Chain
		                || val instanceof AST_PropAccess
		                || val instanceof AST_SymbolRef && val.name == "eval"
		            )
		    ) {
		        const zero = make_node(AST_Number, orig, { value: 0 });
		        return make_sequence(orig, [ zero, val ]);
		    } else {
		        return val;
		    }
		}

		function is_func_expr(node) {
		    return node instanceof AST_Arrow || node instanceof AST_Function;
		}

		/**
		 * Used to determine whether the node can benefit from negation.
		 * Not the case with arrow functions (you need an extra set of parens). */
		function is_iife_call(node) {
		    if (node.TYPE != "Call") return false;
		    return node.expression instanceof AST_Function || is_iife_call(node.expression);
		}

		function is_empty(thing) {
		    if (thing === null) return true;
		    if (thing instanceof AST_EmptyStatement) return true;
		    if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
		    return false;
		}

		const identifier_atom = makePredicate("Infinity NaN undefined");
		function is_identifier_atom(node) {
		    return node instanceof AST_Infinity
		        || node instanceof AST_NaN
		        || node instanceof AST_Undefined;
		}

		/** Check if this is a SymbolRef node which has one def of a certain AST type */
		function is_ref_of(ref, type) {
		    if (!(ref instanceof AST_SymbolRef)) return false;
		    var orig = ref.definition().orig;
		    for (var i = orig.length; --i >= 0;) {
		        if (orig[i] instanceof type) return true;
		    }
		}

		/**Can we turn { block contents... } into just the block contents ?
		 * Not if one of these is inside.
		 **/
		function can_be_evicted_from_block(node) {
		    return !(
		        node instanceof AST_DefClass ||
		        node instanceof AST_Defun ||
		        node instanceof AST_Let ||
		        node instanceof AST_Const ||
		        node instanceof AST_Export ||
		        node instanceof AST_Import
		    );
		}

		function as_statement_array(thing) {
		    if (thing === null) return [];
		    if (thing instanceof AST_BlockStatement) return thing.body;
		    if (thing instanceof AST_EmptyStatement) return [];
		    if (thing instanceof AST_Statement) return [ thing ];
		    throw new Error("Can't convert thing to statement array");
		}

		function is_reachable(scope_node, defs) {
		    const find_ref = node => {
		        if (node instanceof AST_SymbolRef && defs.includes(node.definition())) {
		            return walk_abort;
		        }
		    };

		    return walk_parent(scope_node, (node, info) => {
		        if (node instanceof AST_Scope && node !== scope_node) {
		            var parent = info.parent();

		            if (
		                parent instanceof AST_Call
		                && parent.expression === node
		                // Async/Generators aren't guaranteed to sync evaluate all of
		                // their body steps, so it's possible they close over the variable.
		                && !(node.async || node.is_generator)
		            ) {
		                return;
		            }

		            if (walk(node, find_ref)) return walk_abort;

		            return true;
		        }
		    });
		}

		/** Check if a ref refers to the name of a function/class it's defined within */
		function is_recursive_ref(compressor, def) {
		    var node;
		    for (var i = 0; node = compressor.parent(i); i++) {
		        if (node instanceof AST_Lambda || node instanceof AST_Class) {
		            var name = node.name;
		            if (name && name.definition() === def) {
		                return true;
		            }
		        }
		    }
		    return false;
		}

		// TODO this only works with AST_Defun, shouldn't it work for other ways of defining functions?
		function retain_top_func(fn, compressor) {
		    return compressor.top_retain
		        && fn instanceof AST_Defun
		        && has_flag(fn, TOP)
		        && fn.name
		        && compressor.top_retain(fn.name.definition());
		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// Lists of native methods, useful for `unsafe` option which assumes they exist.
		// Note: Lots of methods and functions are missing here, in case they aren't pure
		// or not available in all JS environments.

		function make_nested_lookup(obj) {
		    const out = new Map();
		    for (var key of Object.keys(obj)) {
		        out.set(key, makePredicate(obj[key]));
		    }

		    const does_have = (global_name, fname) => {
		        const inner_map = out.get(global_name);
		        return inner_map != null && inner_map.has(fname);
		    };
		    return does_have;
		}

		// Objects which are safe to access without throwing or causing a side effect.
		// Usually we'd check the `unsafe` option first but these are way too common for that
		const pure_prop_access_globals = new Set([
		    "Number",
		    "String",
		    "Array",
		    "Object",
		    "Function",
		    "Promise",
		]);

		const object_methods = [
		    "constructor",
		    "toString",
		    "valueOf",
		];

		const is_pure_native_method = make_nested_lookup({
		    Array: [
		        "at",
		        "flat",
		        "includes",
		        "indexOf",
		        "join",
		        "lastIndexOf",
		        "slice",
		        ...object_methods,
		    ],
		    Boolean: object_methods,
		    Function: object_methods,
		    Number: [
		        "toExponential",
		        "toFixed",
		        "toPrecision",
		        ...object_methods,
		    ],
		    Object: object_methods,
		    RegExp: [
		        "test",
		        ...object_methods,
		    ],
		    String: [
		        "at",
		        "charAt",
		        "charCodeAt",
		        "charPointAt",
		        "concat",
		        "endsWith",
		        "fromCharCode",
		        "fromCodePoint",
		        "includes",
		        "indexOf",
		        "italics",
		        "lastIndexOf",
		        "localeCompare",
		        "match",
		        "matchAll",
		        "normalize",
		        "padStart",
		        "padEnd",
		        "repeat",
		        "replace",
		        "replaceAll",
		        "search",
		        "slice",
		        "split",
		        "startsWith",
		        "substr",
		        "substring",
		        "repeat",
		        "toLocaleLowerCase",
		        "toLocaleUpperCase",
		        "toLowerCase",
		        "toUpperCase",
		        "trim",
		        "trimEnd",
		        "trimStart",
		        ...object_methods,
		    ],
		});

		const is_pure_native_fn = make_nested_lookup({
		    Array: [
		        "isArray",
		    ],
		    Math: [
		        "abs",
		        "acos",
		        "asin",
		        "atan",
		        "ceil",
		        "cos",
		        "exp",
		        "floor",
		        "log",
		        "round",
		        "sin",
		        "sqrt",
		        "tan",
		        "atan2",
		        "pow",
		        "max",
		        "min",
		    ],
		    Number: [
		        "isFinite",
		        "isNaN",
		    ],
		    Object: [
		        "create",
		        "getOwnPropertyDescriptor",
		        "getOwnPropertyNames",
		        "getPrototypeOf",
		        "isExtensible",
		        "isFrozen",
		        "isSealed",
		        "hasOwn",
		        "keys",
		    ],
		    String: [
		        "fromCharCode",
		    ],
		});

		// Known numeric values which come with JS environments
		const is_pure_native_value = make_nested_lookup({
		    Math: [
		        "E",
		        "LN10",
		        "LN2",
		        "LOG2E",
		        "LOG10E",
		        "PI",
		        "SQRT1_2",
		        "SQRT2",
		    ],
		    Number: [
		        "MAX_VALUE",
		        "MIN_VALUE",
		        "NaN",
		        "NEGATIVE_INFINITY",
		        "POSITIVE_INFINITY",
		    ],
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// Functions and methods to infer certain facts about expressions
		// It's not always possible to be 100% sure about something just by static analysis,
		// so `true` means yes, and `false` means maybe

		const is_undeclared_ref = (node) =>
		    node instanceof AST_SymbolRef && node.definition().undeclared;

		const lazy_op = makePredicate("&& || ??");
		const unary_side_effects = makePredicate("delete ++ --");

		// methods to determine whether an expression has a boolean result type
		(function(def_is_boolean) {
		    const unary_bool = makePredicate("! delete");
		    const binary_bool = makePredicate("in instanceof == != === !== < <= >= >");
		    def_is_boolean(AST_Node, return_false);
		    def_is_boolean(AST_UnaryPrefix, function() {
		        return unary_bool.has(this.operator);
		    });
		    def_is_boolean(AST_Binary, function() {
		        return binary_bool.has(this.operator)
		            || lazy_op.has(this.operator)
		                && this.left.is_boolean()
		                && this.right.is_boolean();
		    });
		    def_is_boolean(AST_Conditional, function() {
		        return this.consequent.is_boolean() && this.alternative.is_boolean();
		    });
		    def_is_boolean(AST_Assign, function() {
		        return this.operator == "=" && this.right.is_boolean();
		    });
		    def_is_boolean(AST_Sequence, function() {
		        return this.tail_node().is_boolean();
		    });
		    def_is_boolean(AST_True, return_true);
		    def_is_boolean(AST_False, return_true);
		})(function(node, func) {
		    node.DEFMETHOD("is_boolean", func);
		});

		// methods to determine if an expression has a numeric result type
		(function(def_is_number) {
		    def_is_number(AST_Node, return_false);
		    def_is_number(AST_Number, return_true);
		    const unary = makePredicate("+ - ~ ++ --");
		    def_is_number(AST_Unary, function() {
		        return unary.has(this.operator) && !(this.expression instanceof AST_BigInt);
		    });
		    const numeric_ops = makePredicate("- * / % & | ^ << >> >>>");
		    def_is_number(AST_Binary, function(compressor) {
		        return numeric_ops.has(this.operator) || this.operator == "+"
		            && this.left.is_number(compressor)
		            && this.right.is_number(compressor);
		    });
		    def_is_number(AST_Assign, function(compressor) {
		        return numeric_ops.has(this.operator.slice(0, -1))
		            || this.operator == "=" && this.right.is_number(compressor);
		    });
		    def_is_number(AST_Sequence, function(compressor) {
		        return this.tail_node().is_number(compressor);
		    });
		    def_is_number(AST_Conditional, function(compressor) {
		        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("is_number", func);
		});

		// methods to determine if an expression has a string result type
		(function(def_is_string) {
		    def_is_string(AST_Node, return_false);
		    def_is_string(AST_String, return_true);
		    def_is_string(AST_TemplateString, return_true);
		    def_is_string(AST_UnaryPrefix, function() {
		        return this.operator == "typeof";
		    });
		    def_is_string(AST_Binary, function(compressor) {
		        return this.operator == "+" &&
		            (this.left.is_string(compressor) || this.right.is_string(compressor));
		    });
		    def_is_string(AST_Assign, function(compressor) {
		        return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
		    });
		    def_is_string(AST_Sequence, function(compressor) {
		        return this.tail_node().is_string(compressor);
		    });
		    def_is_string(AST_Conditional, function(compressor) {
		        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("is_string", func);
		});

		function is_undefined(node, compressor) {
		    return (
		        has_flag(node, UNDEFINED)
		        || node instanceof AST_Undefined
		        || node instanceof AST_UnaryPrefix
		            && node.operator == "void"
		            && !node.expression.has_side_effects(compressor)
		    );
		}

		// Is the node explicitly null or undefined.
		function is_null_or_undefined(node, compressor) {
		    let fixed;
		    return (
		        node instanceof AST_Null
		        || is_undefined(node, compressor)
		        || (
		            node instanceof AST_SymbolRef
		            && (fixed = node.definition().fixed) instanceof AST_Node
		            && is_nullish(fixed, compressor)
		        )
		    );
		}

		// Find out if this expression is optionally chained from a base-point that we
		// can statically analyze as null or undefined.
		function is_nullish_shortcircuited(node, compressor) {
		    if (node instanceof AST_PropAccess || node instanceof AST_Call) {
		        return (
		            (node.optional && is_null_or_undefined(node.expression, compressor))
		            || is_nullish_shortcircuited(node.expression, compressor)
		        );
		    }
		    if (node instanceof AST_Chain) return is_nullish_shortcircuited(node.expression, compressor);
		    return false;
		}

		// Find out if something is == null, or can short circuit into nullish.
		// Used to optimize ?. and ??
		function is_nullish(node, compressor) {
		    if (is_null_or_undefined(node, compressor)) return true;
		    return is_nullish_shortcircuited(node, compressor);
		}

		// Determine if expression might cause side effects
		// If there's a possibility that a node may change something when it's executed, this returns true
		(function(def_has_side_effects) {
		    def_has_side_effects(AST_Node, return_true);

		    def_has_side_effects(AST_EmptyStatement, return_false);
		    def_has_side_effects(AST_Constant, return_false);
		    def_has_side_effects(AST_This, return_false);

		    function any(list, compressor) {
		        for (var i = list.length; --i >= 0;)
		            if (list[i].has_side_effects(compressor))
		                return true;
		        return false;
		    }

		    def_has_side_effects(AST_Block, function(compressor) {
		        return any(this.body, compressor);
		    });
		    def_has_side_effects(AST_Call, function(compressor) {
		        if (
		            !this.is_callee_pure(compressor)
		            && (!this.expression.is_call_pure(compressor)
		                || this.expression.has_side_effects(compressor))
		        ) {
		            return true;
		        }
		        return any(this.args, compressor);
		    });
		    def_has_side_effects(AST_Switch, function(compressor) {
		        return this.expression.has_side_effects(compressor)
		            || any(this.body, compressor);
		    });
		    def_has_side_effects(AST_Case, function(compressor) {
		        return this.expression.has_side_effects(compressor)
		            || any(this.body, compressor);
		    });
		    def_has_side_effects(AST_Try, function(compressor) {
		        return this.body.has_side_effects(compressor)
		            || this.bcatch && this.bcatch.has_side_effects(compressor)
		            || this.bfinally && this.bfinally.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_If, function(compressor) {
		        return this.condition.has_side_effects(compressor)
		            || this.body && this.body.has_side_effects(compressor)
		            || this.alternative && this.alternative.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_ImportMeta, return_false);
		    def_has_side_effects(AST_LabeledStatement, function(compressor) {
		        return this.body.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_SimpleStatement, function(compressor) {
		        return this.body.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Lambda, return_false);
		    def_has_side_effects(AST_Class, function (compressor) {
		        if (this.extends && this.extends.has_side_effects(compressor)) {
		            return true;
		        }
		        return any(this.properties, compressor);
		    });
		    def_has_side_effects(AST_ClassStaticBlock, function(compressor) {
		        return any(this.body, compressor);
		    });
		    def_has_side_effects(AST_Binary, function(compressor) {
		        return this.left.has_side_effects(compressor)
		            || this.right.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Assign, return_true);
		    def_has_side_effects(AST_Conditional, function(compressor) {
		        return this.condition.has_side_effects(compressor)
		            || this.consequent.has_side_effects(compressor)
		            || this.alternative.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Unary, function(compressor) {
		        return unary_side_effects.has(this.operator)
		            || this.expression.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_SymbolRef, function(compressor) {
		        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
		    });
		    def_has_side_effects(AST_SymbolClassProperty, return_false);
		    def_has_side_effects(AST_SymbolDeclaration, return_false);
		    def_has_side_effects(AST_Object, function(compressor) {
		        return any(this.properties, compressor);
		    });
		    def_has_side_effects(AST_ObjectProperty, function(compressor) {
		        return (
		            this.computed_key() && this.key.has_side_effects(compressor)
		            || this.value && this.value.has_side_effects(compressor)
		        );
		    });
		    def_has_side_effects(AST_ClassProperty, function(compressor) {
		        return (
		            this.computed_key() && this.key.has_side_effects(compressor)
		            || this.static && this.value && this.value.has_side_effects(compressor)
		        );
		    });
		    def_has_side_effects(AST_ConciseMethod, function(compressor) {
		        return this.computed_key() && this.key.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_ObjectGetter, function(compressor) {
		        return this.computed_key() && this.key.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_ObjectSetter, function(compressor) {
		        return this.computed_key() && this.key.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Array, function(compressor) {
		        return any(this.elements, compressor);
		    });
		    def_has_side_effects(AST_Dot, function(compressor) {
		        if (is_nullish(this, compressor)) {
		            return this.expression.has_side_effects(compressor);
		        }
		        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
		            return true;
		        }

		        return this.expression.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Sub, function(compressor) {
		        if (is_nullish(this, compressor)) {
		            return this.expression.has_side_effects(compressor);
		        }
		        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
		            return true;
		        }

		        var property = this.property.has_side_effects(compressor);
		        if (property && this.optional) return true; // "?." is a condition

		        return property || this.expression.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Chain, function (compressor) {
		        return this.expression.has_side_effects(compressor);
		    });
		    def_has_side_effects(AST_Sequence, function(compressor) {
		        return any(this.expressions, compressor);
		    });
		    def_has_side_effects(AST_Definitions, function(compressor) {
		        return any(this.definitions, compressor);
		    });
		    def_has_side_effects(AST_VarDef, function() {
		        return this.value;
		    });
		    def_has_side_effects(AST_TemplateSegment, return_false);
		    def_has_side_effects(AST_TemplateString, function(compressor) {
		        return any(this.segments, compressor);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("has_side_effects", func);
		});

		// determine if expression may throw
		(function(def_may_throw) {
		    def_may_throw(AST_Node, return_true);

		    def_may_throw(AST_Constant, return_false);
		    def_may_throw(AST_EmptyStatement, return_false);
		    def_may_throw(AST_Lambda, return_false);
		    def_may_throw(AST_SymbolDeclaration, return_false);
		    def_may_throw(AST_This, return_false);
		    def_may_throw(AST_ImportMeta, return_false);

		    function any(list, compressor) {
		        for (var i = list.length; --i >= 0;)
		            if (list[i].may_throw(compressor))
		                return true;
		        return false;
		    }

		    def_may_throw(AST_Class, function(compressor) {
		        if (this.extends && this.extends.may_throw(compressor)) return true;
		        return any(this.properties, compressor);
		    });
		    def_may_throw(AST_ClassStaticBlock, function (compressor) {
		        return any(this.body, compressor);
		    });

		    def_may_throw(AST_Array, function(compressor) {
		        return any(this.elements, compressor);
		    });
		    def_may_throw(AST_Assign, function(compressor) {
		        if (this.right.may_throw(compressor)) return true;
		        if (!compressor.has_directive("use strict")
		            && this.operator == "="
		            && this.left instanceof AST_SymbolRef) {
		            return false;
		        }
		        return this.left.may_throw(compressor);
		    });
		    def_may_throw(AST_Binary, function(compressor) {
		        return this.left.may_throw(compressor)
		            || this.right.may_throw(compressor);
		    });
		    def_may_throw(AST_Block, function(compressor) {
		        return any(this.body, compressor);
		    });
		    def_may_throw(AST_Call, function(compressor) {
		        if (is_nullish(this, compressor)) return false;
		        if (any(this.args, compressor)) return true;
		        if (this.is_callee_pure(compressor)) return false;
		        if (this.expression.may_throw(compressor)) return true;
		        return !(this.expression instanceof AST_Lambda)
		            || any(this.expression.body, compressor);
		    });
		    def_may_throw(AST_Case, function(compressor) {
		        return this.expression.may_throw(compressor)
		            || any(this.body, compressor);
		    });
		    def_may_throw(AST_Conditional, function(compressor) {
		        return this.condition.may_throw(compressor)
		            || this.consequent.may_throw(compressor)
		            || this.alternative.may_throw(compressor);
		    });
		    def_may_throw(AST_Definitions, function(compressor) {
		        return any(this.definitions, compressor);
		    });
		    def_may_throw(AST_If, function(compressor) {
		        return this.condition.may_throw(compressor)
		            || this.body && this.body.may_throw(compressor)
		            || this.alternative && this.alternative.may_throw(compressor);
		    });
		    def_may_throw(AST_LabeledStatement, function(compressor) {
		        return this.body.may_throw(compressor);
		    });
		    def_may_throw(AST_Object, function(compressor) {
		        return any(this.properties, compressor);
		    });
		    def_may_throw(AST_ObjectProperty, function(compressor) {
		        // TODO key may throw too
		        return this.value ? this.value.may_throw(compressor) : false;
		    });
		    def_may_throw(AST_ClassProperty, function(compressor) {
		        return (
		            this.computed_key() && this.key.may_throw(compressor)
		            || this.static && this.value && this.value.may_throw(compressor)
		        );
		    });
		    def_may_throw(AST_ConciseMethod, function(compressor) {
		        return this.computed_key() && this.key.may_throw(compressor);
		    });
		    def_may_throw(AST_ObjectGetter, function(compressor) {
		        return this.computed_key() && this.key.may_throw(compressor);
		    });
		    def_may_throw(AST_ObjectSetter, function(compressor) {
		        return this.computed_key() && this.key.may_throw(compressor);
		    });
		    def_may_throw(AST_Return, function(compressor) {
		        return this.value && this.value.may_throw(compressor);
		    });
		    def_may_throw(AST_Sequence, function(compressor) {
		        return any(this.expressions, compressor);
		    });
		    def_may_throw(AST_SimpleStatement, function(compressor) {
		        return this.body.may_throw(compressor);
		    });
		    def_may_throw(AST_Dot, function(compressor) {
		        if (is_nullish(this, compressor)) return false;
		        return !this.optional && this.expression.may_throw_on_access(compressor)
		            || this.expression.may_throw(compressor);
		    });
		    def_may_throw(AST_Sub, function(compressor) {
		        if (is_nullish(this, compressor)) return false;
		        return !this.optional && this.expression.may_throw_on_access(compressor)
		            || this.expression.may_throw(compressor)
		            || this.property.may_throw(compressor);
		    });
		    def_may_throw(AST_Chain, function(compressor) {
		        return this.expression.may_throw(compressor);
		    });
		    def_may_throw(AST_Switch, function(compressor) {
		        return this.expression.may_throw(compressor)
		            || any(this.body, compressor);
		    });
		    def_may_throw(AST_SymbolRef, function(compressor) {
		        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
		    });
		    def_may_throw(AST_SymbolClassProperty, return_false);
		    def_may_throw(AST_Try, function(compressor) {
		        return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor)
		            || this.bfinally && this.bfinally.may_throw(compressor);
		    });
		    def_may_throw(AST_Unary, function(compressor) {
		        if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
		            return false;
		        return this.expression.may_throw(compressor);
		    });
		    def_may_throw(AST_VarDef, function(compressor) {
		        if (!this.value) return false;
		        return this.value.may_throw(compressor);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("may_throw", func);
		});

		// determine if expression is constant
		(function(def_is_constant_expression) {
		    function all_refs_local(scope) {
		        let result = true;
		        walk(this, node => {
		            if (node instanceof AST_SymbolRef) {
		                if (has_flag(this, INLINED)) {
		                    result = false;
		                    return walk_abort;
		                }
		                var def = node.definition();
		                if (
		                    member(def, this.enclosed)
		                    && !this.variables.has(def.name)
		                ) {
		                    if (scope) {
		                        var scope_def = scope.find_variable(node);
		                        if (def.undeclared ? !scope_def : scope_def === def) {
		                            result = "f";
		                            return true;
		                        }
		                    }
		                    result = false;
		                    return walk_abort;
		                }
		                return true;
		            }
		            if (node instanceof AST_This && this instanceof AST_Arrow) {
		                result = false;
		                return walk_abort;
		            }
		        });
		        return result;
		    }

		    def_is_constant_expression(AST_Node, return_false);
		    def_is_constant_expression(AST_Constant, return_true);
		    def_is_constant_expression(AST_Class, function(scope) {
		        if (this.extends && !this.extends.is_constant_expression(scope)) {
		            return false;
		        }

		        for (const prop of this.properties) {
		            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {
		                return false;
		            }
		            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {
		                return false;
		            }
		            if (prop instanceof AST_ClassStaticBlock) {
		                return false;
		            }
		        }

		        return all_refs_local.call(this, scope);
		    });
		    def_is_constant_expression(AST_Lambda, all_refs_local);
		    def_is_constant_expression(AST_Unary, function() {
		        return this.expression.is_constant_expression();
		    });
		    def_is_constant_expression(AST_Binary, function() {
		        return this.left.is_constant_expression()
		            && this.right.is_constant_expression();
		    });
		    def_is_constant_expression(AST_Array, function() {
		        return this.elements.every((l) => l.is_constant_expression());
		    });
		    def_is_constant_expression(AST_Object, function() {
		        return this.properties.every((l) => l.is_constant_expression());
		    });
		    def_is_constant_expression(AST_ObjectProperty, function() {
		        return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());
		    });
		})(function(node, func) {
		    node.DEFMETHOD("is_constant_expression", func);
		});


		// may_throw_on_access()
		// returns true if this node may be null, undefined or contain `AST_Accessor`
		(function(def_may_throw_on_access) {
		    AST_Node.DEFMETHOD("may_throw_on_access", function(compressor) {
		        return !compressor.option("pure_getters")
		            || this._dot_throw(compressor);
		    });

		    function is_strict(compressor) {
		        return /strict/.test(compressor.option("pure_getters"));
		    }

		    def_may_throw_on_access(AST_Node, is_strict);
		    def_may_throw_on_access(AST_Null, return_true);
		    def_may_throw_on_access(AST_Undefined, return_true);
		    def_may_throw_on_access(AST_Constant, return_false);
		    def_may_throw_on_access(AST_Array, return_false);
		    def_may_throw_on_access(AST_Object, function(compressor) {
		        if (!is_strict(compressor)) return false;
		        for (var i = this.properties.length; --i >=0;)
		            if (this.properties[i]._dot_throw(compressor)) return true;
		        return false;
		    });
		    // Do not be as strict with classes as we are with objects.
		    // Hopefully the community is not going to abuse static getters and setters.
		    // https://github.com/terser/terser/issues/724#issuecomment-643655656
		    def_may_throw_on_access(AST_Class, return_false);
		    def_may_throw_on_access(AST_ObjectProperty, return_false);
		    def_may_throw_on_access(AST_ObjectGetter, return_true);
		    def_may_throw_on_access(AST_Expansion, function(compressor) {
		        return this.expression._dot_throw(compressor);
		    });
		    def_may_throw_on_access(AST_Function, return_false);
		    def_may_throw_on_access(AST_Arrow, return_false);
		    def_may_throw_on_access(AST_UnaryPostfix, return_false);
		    def_may_throw_on_access(AST_UnaryPrefix, function() {
		        return this.operator == "void";
		    });
		    def_may_throw_on_access(AST_Binary, function(compressor) {
		        return (this.operator == "&&" || this.operator == "||" || this.operator == "??")
		            && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
		    });
		    def_may_throw_on_access(AST_Assign, function(compressor) {
		        if (this.logical) return true;

		        return this.operator == "="
		            && this.right._dot_throw(compressor);
		    });
		    def_may_throw_on_access(AST_Conditional, function(compressor) {
		        return this.consequent._dot_throw(compressor)
		            || this.alternative._dot_throw(compressor);
		    });
		    def_may_throw_on_access(AST_Dot, function(compressor) {
		        if (!is_strict(compressor)) return false;

		        if (this.property == "prototype") {
		            return !(
		                this.expression instanceof AST_Function
		                || this.expression instanceof AST_Class
		            );
		        }
		        return true;
		    });
		    def_may_throw_on_access(AST_Chain, function(compressor) {
		        return this.expression._dot_throw(compressor);
		    });
		    def_may_throw_on_access(AST_Sequence, function(compressor) {
		        return this.tail_node()._dot_throw(compressor);
		    });
		    def_may_throw_on_access(AST_SymbolRef, function(compressor) {
		        if (this.name === "arguments" && this.scope instanceof AST_Lambda) return false;
		        if (has_flag(this, UNDEFINED)) return true;
		        if (!is_strict(compressor)) return false;
		        if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;
		        if (this.is_immutable()) return false;
		        var fixed = this.fixed_value();
		        return !fixed || fixed._dot_throw(compressor);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("_dot_throw", func);
		});

		function is_lhs(node, parent) {
		    if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;
		    if (parent instanceof AST_Assign && parent.left === node) return node;
		    if (parent instanceof AST_ForIn && parent.init === node) return node;
		}

		// method to negate an expression
		(function(def_negate) {
		    function basic_negation(exp) {
		        return make_node(AST_UnaryPrefix, exp, {
		            operator: "!",
		            expression: exp
		        });
		    }
		    function best(orig, alt, first_in_statement) {
		        var negated = basic_negation(orig);
		        if (first_in_statement) {
		            var stat = make_node(AST_SimpleStatement, alt, {
		                body: alt
		            });
		            return best_of_expression(negated, stat) === stat ? alt : negated;
		        }
		        return best_of_expression(negated, alt);
		    }
		    def_negate(AST_Node, function() {
		        return basic_negation(this);
		    });
		    def_negate(AST_Statement, function() {
		        throw new Error("Cannot negate a statement");
		    });
		    def_negate(AST_Function, function() {
		        return basic_negation(this);
		    });
		    def_negate(AST_Class, function() {
		        return basic_negation(this);
		    });
		    def_negate(AST_Arrow, function() {
		        return basic_negation(this);
		    });
		    def_negate(AST_UnaryPrefix, function() {
		        if (this.operator == "!")
		            return this.expression;
		        return basic_negation(this);
		    });
		    def_negate(AST_Sequence, function(compressor) {
		        var expressions = this.expressions.slice();
		        expressions.push(expressions.pop().negate(compressor));
		        return make_sequence(this, expressions);
		    });
		    def_negate(AST_Conditional, function(compressor, first_in_statement) {
		        var self = this.clone();
		        self.consequent = self.consequent.negate(compressor);
		        self.alternative = self.alternative.negate(compressor);
		        return best(this, self, first_in_statement);
		    });
		    def_negate(AST_Binary, function(compressor, first_in_statement) {
		        var self = this.clone(), op = this.operator;
		        if (compressor.option("unsafe_comps")) {
		            switch (op) {
		              case "<=" : self.operator = ">"  ; return self;
		              case "<"  : self.operator = ">=" ; return self;
		              case ">=" : self.operator = "<"  ; return self;
		              case ">"  : self.operator = "<=" ; return self;
		            }
		        }
		        switch (op) {
		          case "==" : self.operator = "!="; return self;
		          case "!=" : self.operator = "=="; return self;
		          case "===": self.operator = "!=="; return self;
		          case "!==": self.operator = "==="; return self;
		          case "&&":
		            self.operator = "||";
		            self.left = self.left.negate(compressor, first_in_statement);
		            self.right = self.right.negate(compressor);
		            return best(this, self, first_in_statement);
		          case "||":
		            self.operator = "&&";
		            self.left = self.left.negate(compressor, first_in_statement);
		            self.right = self.right.negate(compressor);
		            return best(this, self, first_in_statement);
		        }
		        return basic_negation(this);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("negate", function(compressor, first_in_statement) {
		        return func.call(this, compressor, first_in_statement);
		    });
		});

		// Is the callee of this function pure?
		var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
		AST_Call.DEFMETHOD("is_callee_pure", function(compressor) {
		    if (compressor.option("unsafe")) {
		        var expr = this.expression;
		        var first_arg = (this.args && this.args[0] && this.args[0].evaluate(compressor));
		        if (
		            expr.expression && expr.expression.name === "hasOwnProperty" &&
		            (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)
		        ) {
		            return false;
		        }
		        if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;
		        if (
		            expr instanceof AST_Dot
		            && is_undeclared_ref(expr.expression)
		            && is_pure_native_fn(expr.expression.name, expr.property)
		        ) {
		            return true;
		        }
		    }
		    return !!has_annotation(this, _PURE) || !compressor.pure_funcs(this);
		});

		// If I call this, is it a pure function?
		AST_Node.DEFMETHOD("is_call_pure", return_false);
		AST_Dot.DEFMETHOD("is_call_pure", function(compressor) {
		    if (!compressor.option("unsafe")) return;
		    const expr = this.expression;

		    let native_obj;
		    if (expr instanceof AST_Array) {
		        native_obj = "Array";
		    } else if (expr.is_boolean()) {
		        native_obj = "Boolean";
		    } else if (expr.is_number(compressor)) {
		        native_obj = "Number";
		    } else if (expr instanceof AST_RegExp) {
		        native_obj = "RegExp";
		    } else if (expr.is_string(compressor)) {
		        native_obj = "String";
		    } else if (!this.may_throw_on_access(compressor)) {
		        native_obj = "Object";
		    }
		    return native_obj != null && is_pure_native_method(native_obj, this.property);
		});

		// tell me if a statement aborts
		const aborts = (thing) => thing && thing.aborts();

		(function(def_aborts) {
		    def_aborts(AST_Statement, return_null);
		    def_aborts(AST_Jump, return_this);
		    function block_aborts() {
		        for (var i = 0; i < this.body.length; i++) {
		            if (aborts(this.body[i])) {
		                return this.body[i];
		            }
		        }
		        return null;
		    }
		    def_aborts(AST_Import, return_null);
		    def_aborts(AST_BlockStatement, block_aborts);
		    def_aborts(AST_SwitchBranch, block_aborts);
		    def_aborts(AST_DefClass, function () {
		        for (const prop of this.properties) {
		            if (prop instanceof AST_ClassStaticBlock) {
		                if (prop.aborts()) return prop;
		            }
		        }
		        return null;
		    });
		    def_aborts(AST_ClassStaticBlock, block_aborts);
		    def_aborts(AST_If, function() {
		        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
		    });
		})(function(node, func) {
		    node.DEFMETHOD("aborts", func);
		});

		AST_Node.DEFMETHOD("contains_this", function() {
		    return walk(this, node => {
		        if (node instanceof AST_This) return walk_abort;
		        if (
		            node !== this
		            && node instanceof AST_Scope
		            && !(node instanceof AST_Arrow)
		        ) {
		            return true;
		        }
		    });
		});

		function is_modified(compressor, tw, node, value, level, immutable) {
		    var parent = tw.parent(level);
		    var lhs = is_lhs(node, parent);
		    if (lhs) return lhs;
		    if (!immutable
		        && parent instanceof AST_Call
		        && parent.expression === node
		        && !(value instanceof AST_Arrow)
		        && !(value instanceof AST_Class)
		        && !parent.is_callee_pure(compressor)
		        && (!(value instanceof AST_Function)
		            || !(parent instanceof AST_New) && value.contains_this())) {
		        return true;
		    }
		    if (parent instanceof AST_Array) {
		        return is_modified(compressor, tw, parent, parent, level + 1);
		    }
		    if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
		        var obj = tw.parent(level + 1);
		        return is_modified(compressor, tw, obj, obj, level + 2);
		    }
		    if (parent instanceof AST_PropAccess && parent.expression === node) {
		        var prop = read_property(value, parent.property);
		        return !immutable && is_modified(compressor, tw, parent, prop, level + 1);
		    }
		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// methods to evaluate a constant expression

		function def_eval(node, func) {
		    node.DEFMETHOD("_eval", func);
		}

		// Used to propagate a nullish short-circuit signal upwards through the chain.
		const nullish = Symbol("This AST_Chain is nullish");

		// If the node has been successfully reduced to a constant,
		// then its value is returned; otherwise the element itself
		// is returned.
		// They can be distinguished as constant value is never a
		// descendant of AST_Node.
		AST_Node.DEFMETHOD("evaluate", function (compressor) {
		    if (!compressor.option("evaluate"))
		        return this;
		    var val = this._eval(compressor, 1);
		    if (!val || val instanceof RegExp)
		        return val;
		    if (typeof val == "function" || typeof val == "object" || val == nullish)
		        return this;

		    // Evaluated strings can be larger than the original expression
		    if (typeof val === "string") {
		        const unevaluated_size = this.size(compressor);
		        if (val.length + 2 > unevaluated_size) return this;
		    }

		    return val;
		});

		var unaryPrefix = makePredicate("! ~ - + void");
		AST_Node.DEFMETHOD("is_constant", function () {
		    // Accomodate when compress option evaluate=false
		    // as well as the common constant expressions !0 and -1
		    if (this instanceof AST_Constant) {
		        return !(this instanceof AST_RegExp);
		    } else {
		        return this instanceof AST_UnaryPrefix
		            && this.expression instanceof AST_Constant
		            && unaryPrefix.has(this.operator);
		    }
		});

		def_eval(AST_Statement, function () {
		    throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
		});

		def_eval(AST_Lambda, return_this);
		def_eval(AST_Class, return_this);
		def_eval(AST_Node, return_this);
		def_eval(AST_Constant, function () {
		    return this.getValue();
		});

		def_eval(AST_BigInt, return_this);

		def_eval(AST_RegExp, function (compressor) {
		    let evaluated = compressor.evaluated_regexps.get(this.value);
		    if (evaluated === undefined && regexp_is_safe(this.value.source)) {
		        try {
		            const { source, flags } = this.value;
		            evaluated = new RegExp(source, flags);
		        } catch (e) {
		            evaluated = null;
		        }
		        compressor.evaluated_regexps.set(this.value, evaluated);
		    }
		    return evaluated || this;
		});

		def_eval(AST_TemplateString, function () {
		    if (this.segments.length !== 1) return this;
		    return this.segments[0].value;
		});

		def_eval(AST_Function, function (compressor) {
		    if (compressor.option("unsafe")) {
		        var fn = function () { };
		        fn.node = this;
		        fn.toString = () => this.print_to_string();
		        return fn;
		    }
		    return this;
		});

		def_eval(AST_Array, function (compressor, depth) {
		    if (compressor.option("unsafe")) {
		        var elements = [];
		        for (var i = 0, len = this.elements.length; i < len; i++) {
		            var element = this.elements[i];
		            var value = element._eval(compressor, depth);
		            if (element === value)
		                return this;
		            elements.push(value);
		        }
		        return elements;
		    }
		    return this;
		});

		def_eval(AST_Object, function (compressor, depth) {
		    if (compressor.option("unsafe")) {
		        var val = {};
		        for (var i = 0, len = this.properties.length; i < len; i++) {
		            var prop = this.properties[i];
		            if (prop instanceof AST_Expansion)
		                return this;
		            var key = prop.key;
		            if (key instanceof AST_Symbol) {
		                key = key.name;
		            } else if (key instanceof AST_Node) {
		                key = key._eval(compressor, depth);
		                if (key === prop.key)
		                    return this;
		            }
		            if (typeof Object.prototype[key] === "function") {
		                return this;
		            }
		            if (prop.value instanceof AST_Function)
		                continue;
		            val[key] = prop.value._eval(compressor, depth);
		            if (val[key] === prop.value)
		                return this;
		        }
		        return val;
		    }
		    return this;
		});

		var non_converting_unary = makePredicate("! typeof void");
		def_eval(AST_UnaryPrefix, function (compressor, depth) {
		    var e = this.expression;
		    // Function would be evaluated to an array and so typeof would
		    // incorrectly return 'object'. Hence making is a special case.
		    if (compressor.option("typeofs")
		        && this.operator == "typeof"
		        && (e instanceof AST_Lambda
		            || e instanceof AST_SymbolRef
		            && e.fixed_value() instanceof AST_Lambda)) {
		        return typeof function () { };
		    }
		    if (!non_converting_unary.has(this.operator))
		        depth++;
		    e = e._eval(compressor, depth);
		    if (e === this.expression)
		        return this;
		    switch (this.operator) {
		        case "!": return !e;
		        case "typeof":
		            // typeof <RegExp> returns "object" or "function" on different platforms
		            // so cannot evaluate reliably
		            if (e instanceof RegExp)
		                return this;
		            return typeof e;
		        case "void": return void e;
		        case "~": return ~e;
		        case "-": return -e;
		        case "+": return +e;
		    }
		    return this;
		});

		var non_converting_binary = makePredicate("&& || ?? === !==");
		const identity_comparison = makePredicate("== != === !==");
		const has_identity = value => typeof value === "object"
		    || typeof value === "function"
		    || typeof value === "symbol";

		def_eval(AST_Binary, function (compressor, depth) {
		    if (!non_converting_binary.has(this.operator))
		        depth++;

		    var left = this.left._eval(compressor, depth);
		    if (left === this.left)
		        return this;
		    var right = this.right._eval(compressor, depth);
		    if (right === this.right)
		        return this;
		    var result;

		    if (left != null
		        && right != null
		        && identity_comparison.has(this.operator)
		        && has_identity(left)
		        && has_identity(right)
		        && typeof left === typeof right) {
		        // Do not compare by reference
		        return this;
		    }

		    switch (this.operator) {
		        case "&&": result = left && right; break;
		        case "||": result = left || right; break;
		        case "??": result = left != null ? left : right; break;
		        case "|": result = left | right; break;
		        case "&": result = left & right; break;
		        case "^": result = left ^ right; break;
		        case "+": result = left + right; break;
		        case "*": result = left * right; break;
		        case "**": result = Math.pow(left, right); break;
		        case "/": result = left / right; break;
		        case "%": result = left % right; break;
		        case "-": result = left - right; break;
		        case "<<": result = left << right; break;
		        case ">>": result = left >> right; break;
		        case ">>>": result = left >>> right; break;
		        case "==": result = left == right; break;
		        case "===": result = left === right; break;
		        case "!=": result = left != right; break;
		        case "!==": result = left !== right; break;
		        case "<": result = left < right; break;
		        case "<=": result = left <= right; break;
		        case ">": result = left > right; break;
		        case ">=": result = left >= right; break;
		        default:
		            return this;
		    }
		    if (isNaN(result) && compressor.find_parent(AST_With)) {
		        // leave original expression as is
		        return this;
		    }
		    return result;
		});

		def_eval(AST_Conditional, function (compressor, depth) {
		    var condition = this.condition._eval(compressor, depth);
		    if (condition === this.condition)
		        return this;
		    var node = condition ? this.consequent : this.alternative;
		    var value = node._eval(compressor, depth);
		    return value === node ? this : value;
		});

		// Set of AST_SymbolRef which are currently being evaluated.
		// Avoids infinite recursion of ._eval()
		const reentrant_ref_eval = new Set();
		def_eval(AST_SymbolRef, function (compressor, depth) {
		    if (reentrant_ref_eval.has(this))
		        return this;

		    var fixed = this.fixed_value();
		    if (!fixed)
		        return this;

		    reentrant_ref_eval.add(this);
		    const value = fixed._eval(compressor, depth);
		    reentrant_ref_eval.delete(this);

		    if (value === fixed)
		        return this;

		    if (value && typeof value == "object") {
		        var escaped = this.definition().escaped;
		        if (escaped && depth > escaped)
		            return this;
		    }
		    return value;
		});

		const global_objs = { Array, Math, Number, Object, String };

		const regexp_flags = new Set([
		    "dotAll",
		    "global",
		    "ignoreCase",
		    "multiline",
		    "sticky",
		    "unicode",
		]);

		def_eval(AST_PropAccess, function (compressor, depth) {
		    let obj = this.expression._eval(compressor, depth + 1);
		    if (obj === nullish || (this.optional && obj == null)) return nullish;

		    // `.length` of strings and arrays is always safe
		    if (this.property === "length") {
		        if (typeof obj === "string") {
		            return obj.length;
		        }

		        const is_spreadless_array =
		            obj instanceof AST_Array
		            && obj.elements.every(el => !(el instanceof AST_Expansion));

		        if (
		            is_spreadless_array
		            && obj.elements.every(el => !el.has_side_effects(compressor))
		        ) {
		            return obj.elements.length;
		        }
		    }

		    if (compressor.option("unsafe")) {
		        var key = this.property;
		        if (key instanceof AST_Node) {
		            key = key._eval(compressor, depth);
		            if (key === this.property)
		                return this;
		        }

		        var exp = this.expression;
		        if (is_undeclared_ref(exp)) {
		            var aa;
		            var first_arg = exp.name === "hasOwnProperty"
		                && key === "call"
		                && (aa = compressor.parent() && compressor.parent().args)
		                && (aa && aa[0]
		                    && aa[0].evaluate(compressor));

		            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;

		            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
		                return this.clone();
		            }
		            if (!is_pure_native_value(exp.name, key))
		                return this;
		            obj = global_objs[exp.name];
		        } else {
		            if (obj instanceof RegExp) {
		                if (key == "source") {
		                    return regexp_source_fix(obj.source);
		                } else if (key == "flags" || regexp_flags.has(key)) {
		                    return obj[key];
		                }
		            }
		            if (!obj || obj === exp || !HOP(obj, key))
		                return this;

		            if (typeof obj == "function")
		                switch (key) {
		                    case "name":
		                        return obj.node.name ? obj.node.name.name : "";
		                    case "length":
		                        return obj.node.length_property();
		                    default:
		                        return this;
		                }
		        }
		        return obj[key];
		    }
		    return this;
		});

		def_eval(AST_Chain, function (compressor, depth) {
		    const evaluated = this.expression._eval(compressor, depth);
		    return evaluated === nullish
		        ? undefined
		        : evaluated === this.expression
		          ? this
		          : evaluated;
		});

		def_eval(AST_Call, function (compressor, depth) {
		    var exp = this.expression;

		    const callee = exp._eval(compressor, depth);
		    if (callee === nullish || (this.optional && callee == null)) return nullish;

		    if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
		        var key = exp.property;
		        if (key instanceof AST_Node) {
		            key = key._eval(compressor, depth);
		            if (key === exp.property)
		                return this;
		        }
		        var val;
		        var e = exp.expression;
		        if (is_undeclared_ref(e)) {
		            var first_arg = e.name === "hasOwnProperty" &&
		                key === "call" &&
		                (this.args[0] && this.args[0].evaluate(compressor));

		            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;

		            if ((first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {
		                return this.clone();
		            }
		            if (!is_pure_native_fn(e.name, key)) return this;
		            val = global_objs[e.name];
		        } else {
		            val = e._eval(compressor, depth + 1);
		            if (val === e || !val)
		                return this;
		            if (!is_pure_native_method(val.constructor.name, key))
		                return this;
		        }
		        var args = [];
		        for (var i = 0, len = this.args.length; i < len; i++) {
		            var arg = this.args[i];
		            var value = arg._eval(compressor, depth);
		            if (arg === value)
		                return this;
		            if (arg instanceof AST_Lambda)
		                return this;
		            args.push(value);
		        }
		        try {
		            return val[key].apply(val, args);
		        } catch (ex) {
		            // We don't really care
		        }
		    }
		    return this;
		});

		// Also a subclass of AST_Call
		def_eval(AST_New, return_this);

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// AST_Node#drop_side_effect_free() gets called when we don't care about the value,
		// only about side effects. We'll be defining this method for each node type in this module
		//
		// Examples:
		// foo++ -> foo++
		// 1 + func() -> func()
		// 10 -> (nothing)
		// knownPureFunc(foo++) -> foo++

		function def_drop_side_effect_free(node, func) {
		    node.DEFMETHOD("drop_side_effect_free", func);
		}

		// Drop side-effect-free elements from an array of expressions.
		// Returns an array of expressions with side-effects or null
		// if all elements were dropped. Note: original array may be
		// returned if nothing changed.
		function trim(nodes, compressor, first_in_statement) {
		    var len = nodes.length;
		    if (!len)  return null;

		    var ret = [], changed = false;
		    for (var i = 0; i < len; i++) {
		        var node = nodes[i].drop_side_effect_free(compressor, first_in_statement);
		        changed |= node !== nodes[i];
		        if (node) {
		            ret.push(node);
		            first_in_statement = false;
		        }
		    }
		    return changed ? ret.length ? ret : null : nodes;
		}

		def_drop_side_effect_free(AST_Node, return_this);
		def_drop_side_effect_free(AST_Constant, return_null);
		def_drop_side_effect_free(AST_This, return_null);

		def_drop_side_effect_free(AST_Call, function (compressor, first_in_statement) {
		    if (is_nullish_shortcircuited(this, compressor)) {
		        return this.expression.drop_side_effect_free(compressor, first_in_statement);
		    }

		    if (!this.is_callee_pure(compressor)) {
		        if (this.expression.is_call_pure(compressor)) {
		            var exprs = this.args.slice();
		            exprs.unshift(this.expression.expression);
		            exprs = trim(exprs, compressor, first_in_statement);
		            return exprs && make_sequence(this, exprs);
		        }
		        if (is_func_expr(this.expression)
		            && (!this.expression.name || !this.expression.name.definition().references.length)) {
		            var node = this.clone();
		            node.expression.process_expression(false, compressor);
		            return node;
		        }
		        return this;
		    }

		    var args = trim(this.args, compressor, first_in_statement);
		    return args && make_sequence(this, args);
		});

		def_drop_side_effect_free(AST_Accessor, return_null);

		def_drop_side_effect_free(AST_Function, return_null);

		def_drop_side_effect_free(AST_Arrow, return_null);

		def_drop_side_effect_free(AST_Class, function (compressor) {
		    const with_effects = [];
		    const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);
		    if (trimmed_extends)
		        with_effects.push(trimmed_extends);

		    for (const prop of this.properties) {
		        if (prop instanceof AST_ClassStaticBlock) {
		            if (prop.has_side_effects(compressor)) {
		                return this; // Be cautious about these
		            }
		        } else {
		            const trimmed_prop = prop.drop_side_effect_free(compressor);
		            if (trimmed_prop) {
		                if (trimmed_prop.contains_this()) return this;

		                with_effects.push(trimmed_prop);
		            }
		        }
		    }

		    if (!with_effects.length)
		        return null;

		    const exprs = make_sequence(this, with_effects);
		    if (this instanceof AST_DefClass) {
		        // We want a statement
		        return make_node(AST_SimpleStatement, this, { body: exprs });
		    } else {
		        return exprs;
		    }
		});

		def_drop_side_effect_free(AST_ClassProperty, function (compressor) {
		    const key = this.computed_key() && this.key.drop_side_effect_free(compressor);

		    const value = this.static && this.value
		        && this.value.drop_side_effect_free(compressor);

		    if (key && value)
		        return make_sequence(this, [key, value]);
		    return key || value || null;
		});

		def_drop_side_effect_free(AST_Binary, function (compressor, first_in_statement) {
		    var right = this.right.drop_side_effect_free(compressor);
		    if (!right)
		        return this.left.drop_side_effect_free(compressor, first_in_statement);
		    if (lazy_op.has(this.operator)) {
		        if (right === this.right)
		            return this;
		        var node = this.clone();
		        node.right = right;
		        return node;
		    } else {
		        var left = this.left.drop_side_effect_free(compressor, first_in_statement);
		        if (!left)
		            return this.right.drop_side_effect_free(compressor, first_in_statement);
		        return make_sequence(this, [left, right]);
		    }
		});

		def_drop_side_effect_free(AST_Assign, function (compressor) {
		    if (this.logical)
		        return this;

		    var left = this.left;
		    if (left.has_side_effects(compressor)
		        || compressor.has_directive("use strict")
		        && left instanceof AST_PropAccess
		        && left.expression.is_constant()) {
		        return this;
		    }
		    set_flag(this, WRITE_ONLY);
		    while (left instanceof AST_PropAccess) {
		        left = left.expression;
		    }
		    if (left.is_constant_expression(compressor.find_parent(AST_Scope))) {
		        return this.right.drop_side_effect_free(compressor);
		    }
		    return this;
		});

		def_drop_side_effect_free(AST_Conditional, function (compressor) {
		    var consequent = this.consequent.drop_side_effect_free(compressor);
		    var alternative = this.alternative.drop_side_effect_free(compressor);
		    if (consequent === this.consequent && alternative === this.alternative)
		        return this;
		    if (!consequent)
		        return alternative ? make_node(AST_Binary, this, {
		            operator: "||",
		            left: this.condition,
		            right: alternative
		        }) : this.condition.drop_side_effect_free(compressor);
		    if (!alternative)
		        return make_node(AST_Binary, this, {
		            operator: "&&",
		            left: this.condition,
		            right: consequent
		        });
		    var node = this.clone();
		    node.consequent = consequent;
		    node.alternative = alternative;
		    return node;
		});

		def_drop_side_effect_free(AST_Unary, function (compressor, first_in_statement) {
		    if (unary_side_effects.has(this.operator)) {
		        if (!this.expression.has_side_effects(compressor)) {
		            set_flag(this, WRITE_ONLY);
		        } else {
		            clear_flag(this, WRITE_ONLY);
		        }
		        return this;
		    }
		    if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
		        return null;
		    var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);
		    if (first_in_statement && expression && is_iife_call(expression)) {
		        if (expression === this.expression && this.operator == "!")
		            return this;
		        return expression.negate(compressor, first_in_statement);
		    }
		    return expression;
		});

		def_drop_side_effect_free(AST_SymbolRef, function (compressor) {
		    const safe_access = this.is_declared(compressor)
		        || pure_prop_access_globals.has(this.name);
		    return safe_access ? null : this;
		});

		def_drop_side_effect_free(AST_Object, function (compressor, first_in_statement) {
		    var values = trim(this.properties, compressor, first_in_statement);
		    return values && make_sequence(this, values);
		});

		def_drop_side_effect_free(AST_ObjectProperty, function (compressor, first_in_statement) {
		    const computed_key = this instanceof AST_ObjectKeyVal && this.key instanceof AST_Node;
		    const key = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement);
		    const value = this.value && this.value.drop_side_effect_free(compressor, first_in_statement);
		    if (key && value) {
		        return make_sequence(this, [key, value]);
		    }
		    return key || value;
		});

		def_drop_side_effect_free(AST_ConciseMethod, function () {
		    return this.computed_key() ? this.key : null;
		});

		def_drop_side_effect_free(AST_ObjectGetter, function () {
		    return this.computed_key() ? this.key : null;
		});

		def_drop_side_effect_free(AST_ObjectSetter, function () {
		    return this.computed_key() ? this.key : null;
		});

		def_drop_side_effect_free(AST_Array, function (compressor, first_in_statement) {
		    var values = trim(this.elements, compressor, first_in_statement);
		    return values && make_sequence(this, values);
		});

		def_drop_side_effect_free(AST_Dot, function (compressor, first_in_statement) {
		    if (is_nullish_shortcircuited(this, compressor)) {
		        return this.expression.drop_side_effect_free(compressor, first_in_statement);
		    }
		    if (!this.optional && this.expression.may_throw_on_access(compressor)) {
		        return this;
		    }

		    return this.expression.drop_side_effect_free(compressor, first_in_statement);
		});

		def_drop_side_effect_free(AST_Sub, function (compressor, first_in_statement) {
		    if (is_nullish_shortcircuited(this, compressor)) {
		        return this.expression.drop_side_effect_free(compressor, first_in_statement);
		    }
		    if (!this.optional && this.expression.may_throw_on_access(compressor)) {
		        return this;
		    }

		    var property = this.property.drop_side_effect_free(compressor);
		    if (property && this.optional) return this;

		    var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);

		    if (expression && property) return make_sequence(this, [expression, property]);
		    return expression || property;
		});

		def_drop_side_effect_free(AST_Chain, function (compressor, first_in_statement) {
		    return this.expression.drop_side_effect_free(compressor, first_in_statement);
		});

		def_drop_side_effect_free(AST_Sequence, function (compressor) {
		    var last = this.tail_node();
		    var expr = last.drop_side_effect_free(compressor);
		    if (expr === last)
		        return this;
		    var expressions = this.expressions.slice(0, -1);
		    if (expr)
		        expressions.push(expr);
		    if (!expressions.length) {
		        return make_node(AST_Number, this, { value: 0 });
		    }
		    return make_sequence(this, expressions);
		});

		def_drop_side_effect_free(AST_Expansion, function (compressor, first_in_statement) {
		    return this.expression.drop_side_effect_free(compressor, first_in_statement);
		});

		def_drop_side_effect_free(AST_TemplateSegment, return_null);

		def_drop_side_effect_free(AST_TemplateString, function (compressor) {
		    var values = trim(this.segments, compressor, first_in_statement);
		    return values && make_sequence(this, values);
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		const r_keep_assign = /keep_assign/;

		/** Drop unused variables from this scope */
		AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
		    if (!compressor.option("unused")) return;
		    if (compressor.has_directive("use asm")) return;
		    var self = this;
		    if (self.pinned()) return;
		    var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;
		    var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;
		    const assign_as_unused = r_keep_assign.test(compressor.option("unused")) ? return_false : function(node) {
		        if (node instanceof AST_Assign
		            && !node.logical
		            && (has_flag(node, WRITE_ONLY) || node.operator == "=")
		        ) {
		            return node.left;
		        }
		        if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {
		            return node.expression;
		        }
		    };
		    var in_use_ids = new Map();
		    var fixed_ids = new Map();
		    if (self instanceof AST_Toplevel && compressor.top_retain) {
		        self.variables.forEach(function(def) {
		            if (compressor.top_retain(def)) {
		                in_use_ids.set(def.id, def);
		            }
		        });
		    }
		    var var_defs_by_id = new Map();
		    var initializations = new Map();
		    // pass 1: find out which symbols are directly used in
		    // this scope (not in nested scopes).
		    var scope = this;
		    var tw = new TreeWalker(function(node, descend) {
		        if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
		            node.argnames.forEach(function(argname) {
		                if (!(argname instanceof AST_SymbolDeclaration)) return;
		                var def = argname.definition();
		                in_use_ids.set(def.id, def);
		            });
		        }
		        if (node === self) return;
		        if (node instanceof AST_Class) {
		            if (node.has_side_effects(compressor)) {
		                node.visit_nondeferred_class_parts(tw);
		            }
		        }
		        if (node instanceof AST_Defun || node instanceof AST_DefClass) {
		            var node_def = node.name.definition();
		            const in_export = tw.parent() instanceof AST_Export;
		            if (in_export || !drop_funcs && scope === self) {
		                if (node_def.global) {
		                    in_use_ids.set(node_def.id, node_def);
		                }
		            }

		            map_add(initializations, node_def.id, node);
		            return true; // don't go in nested scopes
		        }
		        // In the root scope, we drop things. In inner scopes, we just check for uses.
		        const in_root_scope = scope === self;
		        if (node instanceof AST_SymbolFunarg && in_root_scope) {
		            map_add(var_defs_by_id, node.definition().id, node);
		        }
		        if (node instanceof AST_Definitions && in_root_scope) {
		            const in_export = tw.parent() instanceof AST_Export;
		            node.definitions.forEach(function(def) {
		                if (def.name instanceof AST_SymbolVar) {
		                    map_add(var_defs_by_id, def.name.definition().id, def);
		                }
		                if (in_export || !drop_vars) {
		                    walk(def.name, node => {
		                        if (node instanceof AST_SymbolDeclaration) {
		                            const def = node.definition();
		                            if (def.global) {
		                                in_use_ids.set(def.id, def);
		                            }
		                        }
		                    });
		                }
		                if (def.name instanceof AST_Destructuring) {
		                    def.walk(tw);
		                }
		                if (def.name instanceof AST_SymbolDeclaration && def.value) {
		                    var node_def = def.name.definition();
		                    map_add(initializations, node_def.id, def.value);
		                    if (!node_def.chained && def.name.fixed_value() === def.value) {
		                        fixed_ids.set(node_def.id, def);
		                    }
		                    if (def.value.has_side_effects(compressor)) {
		                        def.value.walk(tw);
		                    }
		                }
		            });
		            return true;
		        }
		        return scan_ref_scoped(node, descend);
		    });
		    self.walk(tw);
		    // pass 2: for every used symbol we need to walk its
		    // initialization code to figure out if it uses other
		    // symbols (that may not be in_use).
		    tw = new TreeWalker(scan_ref_scoped);
		    in_use_ids.forEach(function (def) {
		        var init = initializations.get(def.id);
		        if (init) init.forEach(function(init) {
		            init.walk(tw);
		        });
		    });
		    // pass 3: we should drop declarations not in_use
		    var tt = new TreeTransformer(
		        function before(node, descend, in_list) {
		            var parent = tt.parent();
		            if (drop_vars) {
		                const sym = assign_as_unused(node);
		                if (sym instanceof AST_SymbolRef) {
		                    var def = sym.definition();
		                    var in_use = in_use_ids.has(def.id);
		                    if (node instanceof AST_Assign) {
		                        if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {
		                            return maintain_this_binding(parent, node, node.right.transform(tt));
		                        }
		                    } else if (!in_use) {
		                        return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
		                    }
		                }
		            }
		            if (scope !== self) return;
		            var def;
		            if (node.name
		                && (node instanceof AST_ClassExpression
		                    && !keep_name(compressor.option("keep_classnames"), (def = node.name.definition()).name)
		                || node instanceof AST_Function
		                    && !keep_name(compressor.option("keep_fnames"), (def = node.name.definition()).name))) {
		                // any declarations with same name will overshadow
		                // name of this anonymous function and can therefore
		                // never be used anywhere
		                if (!in_use_ids.has(def.id) || def.orig.length > 1) node.name = null;
		            }
		            if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
		                var trim = !compressor.option("keep_fargs");
		                for (var a = node.argnames, i = a.length; --i >= 0;) {
		                    var sym = a[i];
		                    if (sym instanceof AST_Expansion) {
		                        sym = sym.expression;
		                    }
		                    if (sym instanceof AST_DefaultAssign) {
		                        sym = sym.left;
		                    }
		                    // Do not drop destructuring arguments.
		                    // They constitute a type assertion of sorts
		                    if (
		                        !(sym instanceof AST_Destructuring)
		                        && !in_use_ids.has(sym.definition().id)
		                    ) {
		                        set_flag(sym, UNUSED);
		                        if (trim) {
		                            a.pop();
		                        }
		                    } else {
		                        trim = false;
		                    }
		                }
		            }
		            if (node instanceof AST_DefClass && node !== self) {
		                const def = node.name.definition();
		                descend(node, this);
		                const keep_class = def.global && !drop_funcs || in_use_ids.has(def.id);
		                if (!keep_class) {
		                    const kept = node.drop_side_effect_free(compressor);
		                    if (kept == null) {
		                        def.eliminated++;
		                        return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
		                    }
		                    return kept;
		                }
		                return node;
		            }
		            if (node instanceof AST_Defun && node !== self) {
		                const def = node.name.definition();
		                const keep = def.global && !drop_funcs || in_use_ids.has(def.id);
		                if (!keep) {
		                    def.eliminated++;
		                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
		                }
		            }
		            if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {
		                var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);
		                // place uninitialized names at the start
		                var body = [], head = [], tail = [];
		                // for unused names whose initialization has
		                // side effects, we can cascade the init. code
		                // into the next one, or next statement.
		                var side_effects = [];
		                node.definitions.forEach(function(def) {
		                    if (def.value) def.value = def.value.transform(tt);
		                    var is_destructure = def.name instanceof AST_Destructuring;
		                    var sym = is_destructure
		                        ? new SymbolDef(null, { name: "<destructure>" }) /* fake SymbolDef */
		                        : def.name.definition();
		                    if (drop_block && sym.global) return tail.push(def);
		                    if (!(drop_vars || drop_block)
		                        || is_destructure
		                            && (def.name.names.length
		                                || def.name.is_array
		                                || compressor.option("pure_getters") != true)
		                        || in_use_ids.has(sym.id)
		                    ) {
		                        if (def.value && fixed_ids.has(sym.id) && fixed_ids.get(sym.id) !== def) {
		                            def.value = def.value.drop_side_effect_free(compressor);
		                        }
		                        if (def.name instanceof AST_SymbolVar) {
		                            var var_defs = var_defs_by_id.get(sym.id);
		                            if (var_defs.length > 1 && (!def.value || sym.orig.indexOf(def.name) > sym.eliminated)) {
		                                if (def.value) {
		                                    var ref = make_node(AST_SymbolRef, def.name, def.name);
		                                    sym.references.push(ref);
		                                    var assign = make_node(AST_Assign, def, {
		                                        operator: "=",
		                                        logical: false,
		                                        left: ref,
		                                        right: def.value
		                                    });
		                                    if (fixed_ids.get(sym.id) === def) {
		                                        fixed_ids.set(sym.id, assign);
		                                    }
		                                    side_effects.push(assign.transform(tt));
		                                }
		                                remove(var_defs, def);
		                                sym.eliminated++;
		                                return;
		                            }
		                        }
		                        if (def.value) {
		                            if (side_effects.length > 0) {
		                                if (tail.length > 0) {
		                                    side_effects.push(def.value);
		                                    def.value = make_sequence(def.value, side_effects);
		                                } else {
		                                    body.push(make_node(AST_SimpleStatement, node, {
		                                        body: make_sequence(node, side_effects)
		                                    }));
		                                }
		                                side_effects = [];
		                            }
		                            tail.push(def);
		                        } else {
		                            head.push(def);
		                        }
		                    } else if (sym.orig[0] instanceof AST_SymbolCatch) {
		                        var value = def.value && def.value.drop_side_effect_free(compressor);
		                        if (value) side_effects.push(value);
		                        def.value = null;
		                        head.push(def);
		                    } else {
		                        var value = def.value && def.value.drop_side_effect_free(compressor);
		                        if (value) {
		                            side_effects.push(value);
		                        }
		                        sym.eliminated++;
		                    }
		                });
		                if (head.length > 0 || tail.length > 0) {
		                    node.definitions = head.concat(tail);
		                    body.push(node);
		                }
		                if (side_effects.length > 0) {
		                    body.push(make_node(AST_SimpleStatement, node, {
		                        body: make_sequence(node, side_effects)
		                    }));
		                }
		                switch (body.length) {
		                  case 0:
		                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
		                  case 1:
		                    return body[0];
		                  default:
		                    return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });
		                }
		            }
		            // certain combination of unused name + side effect leads to:
		            //    https://github.com/mishoo/UglifyJS2/issues/44
		            //    https://github.com/mishoo/UglifyJS2/issues/1830
		            //    https://github.com/mishoo/UglifyJS2/issues/1838
		            // that's an invalid AST.
		            // We fix it at this stage by moving the `var` outside the `for`.
		            if (node instanceof AST_For) {
		                descend(node, this);
		                var block;
		                if (node.init instanceof AST_BlockStatement) {
		                    block = node.init;
		                    node.init = block.body.pop();
		                    block.body.push(node);
		                }
		                if (node.init instanceof AST_SimpleStatement) {
		                    node.init = node.init.body;
		                } else if (is_empty(node.init)) {
		                    node.init = null;
		                }
		                return !block ? node : in_list ? MAP.splice(block.body) : block;
		            }
		            if (node instanceof AST_LabeledStatement
		                && node.body instanceof AST_For
		            ) {
		                descend(node, this);
		                if (node.body instanceof AST_BlockStatement) {
		                    var block = node.body;
		                    node.body = block.body.pop();
		                    block.body.push(node);
		                    return in_list ? MAP.splice(block.body) : block;
		                }
		                return node;
		            }
		            if (node instanceof AST_BlockStatement) {
		                descend(node, this);
		                if (in_list && node.body.every(can_be_evicted_from_block)) {
		                    return MAP.splice(node.body);
		                }
		                return node;
		            }
		            if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
		                const save_scope = scope;
		                scope = node;
		                descend(node, this);
		                scope = save_scope;
		                return node;
		            }
		        }
		    );

		    self.transform(tt);

		    function scan_ref_scoped(node, descend) {
		        var node_def;
		        const sym = assign_as_unused(node);
		        if (sym instanceof AST_SymbolRef
		            && !is_ref_of(node.left, AST_SymbolBlockDeclaration)
		            && self.variables.get(sym.name) === (node_def = sym.definition())
		        ) {
		            if (node instanceof AST_Assign) {
		                node.right.walk(tw);
		                if (!node_def.chained && node.left.fixed_value() === node.right) {
		                    fixed_ids.set(node_def.id, node);
		                }
		            }
		            return true;
		        }
		        if (node instanceof AST_SymbolRef) {
		            node_def = node.definition();
		            if (!in_use_ids.has(node_def.id)) {
		                in_use_ids.set(node_def.id, node_def);
		                if (node_def.orig[0] instanceof AST_SymbolCatch) {
		                    const redef = node_def.scope.is_block_scope()
		                        && node_def.scope.get_defun_scope().variables.get(node_def.name);
		                    if (redef) in_use_ids.set(redef.id, redef);
		                }
		            }
		            return true;
		        }
		        if (node instanceof AST_Class) {
		            descend();
		            return true;
		        }
		        if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
		            var save_scope = scope;
		            scope = node;
		            descend();
		            scope = save_scope;
		            return true;
		        }
		    }
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		/**
		 * Define the method AST_Node#reduce_vars, which goes through the AST in
		 * execution order to perform basic flow analysis
		 */
		function def_reduce_vars(node, func) {
		    node.DEFMETHOD("reduce_vars", func);
		}

		def_reduce_vars(AST_Node, noop);

		/** Clear definition properties */
		function reset_def(compressor, def) {
		    def.assignments = 0;
		    def.chained = false;
		    def.direct_access = false;
		    def.escaped = 0;
		    def.recursive_refs = 0;
		    def.references = [];
		    def.single_use = undefined;
		    if (
		        def.scope.pinned()
		        || (def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments)
		    ) {
		        def.fixed = false;
		    } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {
		        def.fixed = def.init;
		    } else {
		        def.fixed = false;
		    }
		}

		function reset_variables(tw, compressor, node) {
		    node.variables.forEach(function(def) {
		        reset_def(compressor, def);
		        if (def.fixed === null) {
		            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);
		            mark(tw, def, true);
		        } else if (def.fixed) {
		            tw.loop_ids.set(def.id, tw.in_loop);
		            mark(tw, def, true);
		        }
		    });
		}

		function reset_block_variables(compressor, node) {
		    if (node.block_scope) node.block_scope.variables.forEach((def) => {
		        reset_def(compressor, def);
		    });
		}

		function push(tw) {
		    tw.safe_ids = Object.create(tw.safe_ids);
		}

		function pop(tw) {
		    tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
		}

		function mark(tw, def, safe) {
		    tw.safe_ids[def.id] = safe;
		}

		function safe_to_read(tw, def) {
		    if (def.single_use == "m") return false;
		    if (tw.safe_ids[def.id]) {
		        if (def.fixed == null) {
		            var orig = def.orig[0];
		            if (orig instanceof AST_SymbolFunarg || orig.name == "arguments") return false;
		            def.fixed = make_node(AST_Undefined, orig);
		        }
		        return true;
		    }
		    return def.fixed instanceof AST_Defun;
		}

		function safe_to_assign(tw, def, scope, value) {
		    if (def.fixed === undefined) return true;
		    let def_safe_ids;
		    if (def.fixed === null
		        && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))
		    ) {
		        def_safe_ids[def.id] = false;
		        tw.defs_to_safe_ids.delete(def.id);
		        return true;
		    }
		    if (!HOP(tw.safe_ids, def.id)) return false;
		    if (!safe_to_read(tw, def)) return false;
		    if (def.fixed === false) return false;
		    if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;
		    if (def.fixed instanceof AST_Defun) {
		        return value instanceof AST_Node && def.fixed.parent_scope === scope;
		    }
		    return def.orig.every((sym) => {
		        return !(sym instanceof AST_SymbolConst
		            || sym instanceof AST_SymbolDefun
		            || sym instanceof AST_SymbolLambda);
		    });
		}

		function ref_once(tw, compressor, def) {
		    return compressor.option("unused")
		        && !def.scope.pinned()
		        && def.references.length - def.recursive_refs == 1
		        && tw.loop_ids.get(def.id) === tw.in_loop;
		}

		function is_immutable(value) {
		    if (!value) return false;
		    return value.is_constant()
		        || value instanceof AST_Lambda
		        || value instanceof AST_This;
		}

		// A definition "escapes" when its value can leave the point of use.
		// Example: `a = b || c`
		// In this example, "b" and "c" are escaping, because they're going into "a"
		//
		// def.escaped is != 0 when it escapes.
		//
		// When greater than 1, it means that N chained properties will be read off
		// of that def before an escape occurs. This is useful for evaluating
		// property accesses, where you need to know when to stop.
		function mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {
		    var parent = tw.parent(level);
		    if (value) {
		        if (value.is_constant()) return;
		        if (value instanceof AST_ClassExpression) return;
		    }

		    if (
		        parent instanceof AST_Assign && (parent.operator === "=" || parent.logical) && node === parent.right
		        || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New)
		        || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope
		        || parent instanceof AST_VarDef && node === parent.value
		        || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope
		    ) {
		        if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;
		        if (!d.escaped || d.escaped > depth) d.escaped = depth;
		        return;
		    } else if (
		        parent instanceof AST_Array
		        || parent instanceof AST_Await
		        || parent instanceof AST_Binary && lazy_op.has(parent.operator)
		        || parent instanceof AST_Conditional && node !== parent.condition
		        || parent instanceof AST_Expansion
		        || parent instanceof AST_Sequence && node === parent.tail_node()
		    ) {
		        mark_escaped(tw, d, scope, parent, parent, level + 1, depth);
		    } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
		        var obj = tw.parent(level + 1);

		        mark_escaped(tw, d, scope, obj, obj, level + 2, depth);
		    } else if (parent instanceof AST_PropAccess && node === parent.expression) {
		        value = read_property(value, parent.property);

		        mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);
		        if (value) return;
		    }

		    if (level > 0) return;
		    if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;
		    if (parent instanceof AST_SimpleStatement) return;

		    d.direct_access = true;
		}

		const suppress = node => walk(node, node => {
		    if (!(node instanceof AST_Symbol)) return;
		    var d = node.definition();
		    if (!d) return;
		    if (node instanceof AST_SymbolRef) d.references.push(node);
		    d.fixed = false;
		});

		def_reduce_vars(AST_Accessor, function(tw, descend, compressor) {
		    push(tw);
		    reset_variables(tw, compressor, this);
		    descend();
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_Assign, function(tw, descend, compressor) {
		    var node = this;
		    if (node.left instanceof AST_Destructuring) {
		        suppress(node.left);
		        return;
		    }

		    const finish_walk = () => {
		        if (node.logical) {
		            node.left.walk(tw);

		            push(tw);
		            node.right.walk(tw);
		            pop(tw);

		            return true;
		        }
		    };

		    var sym = node.left;
		    if (!(sym instanceof AST_SymbolRef)) return finish_walk();

		    var def = sym.definition();
		    var safe = safe_to_assign(tw, def, sym.scope, node.right);
		    def.assignments++;
		    if (!safe) return finish_walk();

		    var fixed = def.fixed;
		    if (!fixed && node.operator != "=" && !node.logical) return finish_walk();

		    var eq = node.operator == "=";
		    var value = eq ? node.right : node;
		    if (is_modified(compressor, tw, node, value, 0)) return finish_walk();

		    def.references.push(sym);

		    if (!node.logical) {
		        if (!eq) def.chained = true;

		        def.fixed = eq ? function() {
		            return node.right;
		        } : function() {
		            return make_node(AST_Binary, node, {
		                operator: node.operator.slice(0, -1),
		                left: fixed instanceof AST_Node ? fixed : fixed(),
		                right: node.right
		            });
		        };
		    }

		    if (node.logical) {
		        mark(tw, def, false);
		        push(tw);
		        node.right.walk(tw);
		        pop(tw);
		        return true;
		    }

		    mark(tw, def, false);
		    node.right.walk(tw);
		    mark(tw, def, true);

		    mark_escaped(tw, def, sym.scope, node, value, 0, 1);

		    return true;
		});

		def_reduce_vars(AST_Binary, function(tw) {
		    if (!lazy_op.has(this.operator)) return;
		    this.left.walk(tw);
		    push(tw);
		    this.right.walk(tw);
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_Block, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		});

		def_reduce_vars(AST_Case, function(tw) {
		    push(tw);
		    this.expression.walk(tw);
		    pop(tw);
		    push(tw);
		    walk_body(this, tw);
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_Class, function(tw, descend) {
		    clear_flag(this, INLINED);
		    push(tw);
		    descend();
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		});

		def_reduce_vars(AST_Conditional, function(tw) {
		    this.condition.walk(tw);
		    push(tw);
		    this.consequent.walk(tw);
		    pop(tw);
		    push(tw);
		    this.alternative.walk(tw);
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_Chain, function(tw, descend) {
		    // Chains' conditions apply left-to-right, cumulatively.
		    // If we walk normally we don't go in that order because we would pop before pushing again
		    // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.
		    // Then we pop everything when they are done being walked.
		    const safe_ids = tw.safe_ids;

		    descend();

		    // Unroll back to start
		    tw.safe_ids = safe_ids;
		    return true;
		});

		def_reduce_vars(AST_Call, function (tw) {
		    this.expression.walk(tw);

		    if (this.optional) {
		        // Never pop -- it's popped at AST_Chain above
		        push(tw);
		    }

		    for (const arg of this.args) arg.walk(tw);

		    return true;
		});

		def_reduce_vars(AST_PropAccess, function (tw) {
		    if (!this.optional) return;

		    this.expression.walk(tw);

		    // Never pop -- it's popped at AST_Chain above
		    push(tw);

		    if (this.property instanceof AST_Node) this.property.walk(tw);

		    return true;
		});

		def_reduce_vars(AST_Default, function(tw, descend) {
		    push(tw);
		    descend();
		    pop(tw);
		    return true;
		});

		function mark_lambda(tw, descend, compressor) {
		    clear_flag(this, INLINED);
		    push(tw);
		    reset_variables(tw, compressor, this);

		    var iife;
		    if (!this.name
		        && !this.uses_arguments
		        && !this.pinned()
		        && (iife = tw.parent()) instanceof AST_Call
		        && iife.expression === this
		        && !iife.args.some(arg => arg instanceof AST_Expansion)
		        && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)
		    ) {
		        // Virtually turn IIFE parameters into variable definitions:
		        //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()
		        // So existing transformation rules can work on them.
		        this.argnames.forEach((arg, i) => {
		            if (!arg.definition) return;
		            var d = arg.definition();
		            // Avoid setting fixed when there's more than one origin for a variable value
		            if (d.orig.length > 1) return;
		            if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive("use strict"))) {
		                d.fixed = function() {
		                    return iife.args[i] || make_node(AST_Undefined, iife);
		                };
		                tw.loop_ids.set(d.id, tw.in_loop);
		                mark(tw, d, true);
		            } else {
		                d.fixed = false;
		            }
		        });
		    }

		    descend();
		    pop(tw);

		    handle_defined_after_hoist(this);

		    return true;
		}

		/**
		 * It's possible for a hoisted function to use something that's not defined yet. Example:
		 *
		 * hoisted();
		 * var defined_after = true;
		 * function hoisted() {
		 *   // use defined_after
		 * }
		 *
		 * This function is called on the parent to handle this issue.
		 */
		function handle_defined_after_hoist(parent) {
		    const defuns = [];
		    walk(parent, node => {
		        if (node === parent) return;
		        if (node instanceof AST_Defun) defuns.push(node);
		        if (
		            node instanceof AST_Scope
		            || node instanceof AST_SimpleStatement
		        ) return true;
		    });

		    const symbols_of_interest = new Set();
		    const defuns_of_interest = new Set();
		    const potential_conflicts = [];

		    for (const defun of defuns) {
		        const fname_def = defun.name.definition();
		        const found_self_ref_in_other_defuns = defuns.some(
		            d => d !== defun && d.enclosed.indexOf(fname_def) !== -1
		        );

		        for (const def of defun.enclosed) {
		            if (
		                def.fixed === false
		                || def === fname_def
		                || def.scope.get_defun_scope() !== parent
		            ) {
		                continue;
		            }

		            // defun is hoisted, so always safe
		            if (
		                def.assignments === 0
		                && def.orig.length === 1
		                && def.orig[0] instanceof AST_SymbolDefun
		            ) {
		                continue;
		            }

		            if (found_self_ref_in_other_defuns) {
		                def.fixed = false;
		                continue;
		            }

		            // for the slower checks below this loop
		            potential_conflicts.push({ defun, def, fname_def });
		            symbols_of_interest.add(def.id);
		            symbols_of_interest.add(fname_def.id);
		            defuns_of_interest.add(defun);
		        }
		    }

		    // linearize all symbols, and locate defs that are read after the defun
		    if (potential_conflicts.length) {
		        // All "symbols of interest", that is, defuns or defs, that we found.
		        // These are placed in order so we can check which is after which.
		        const found_symbols = [];
		        // Indices of `found_symbols` which are writes
		        const found_symbol_writes = new Set();
		        // Defun ranges are recorded because we don't care if a function uses the def internally
		        const defun_ranges = new Map();

		        let tw;
		        parent.walk((tw = new TreeWalker((node, descend) => {
		            if (node instanceof AST_Defun && defuns_of_interest.has(node)) {
		                const start = found_symbols.length;
		                descend();
		                const end = found_symbols.length;

		                defun_ranges.set(node, { start, end });
		                return true;
		            }
		            // if we found a defun on the list, mark IN_DEFUN=id and descend

		            if (node instanceof AST_Symbol && node.thedef) {
		                const id = node.definition().id;
		                if (symbols_of_interest.has(id)) {
		                    if (node instanceof AST_SymbolDeclaration || is_lhs(node, tw)) {
		                        found_symbol_writes.add(found_symbols.length);
		                    }
		                    found_symbols.push(id);
		                }
		            }
		        })));

		        for (const { def, defun, fname_def } of potential_conflicts) {
		            const defun_range = defun_ranges.get(defun);

		            // find the index in `found_symbols`, with some special rules:
		            const find = (sym_id, starting_at = 0, must_be_write = false) => {
		                let index = starting_at;

		                for (;;) {
		                    index = found_symbols.indexOf(sym_id, index);

		                    if (index === -1) {
		                        break;
		                    } else if (index >= defun_range.start && index < defun_range.end) {
		                        index = defun_range.end;
		                        continue;
		                    } else if (must_be_write && !found_symbol_writes.has(index)) {
		                        index++;
		                        continue;
		                    } else {
		                        break;
		                    }
		                }

		                return index;
		            };

		            const read_defun_at = find(fname_def.id);
		            const wrote_def_at = find(def.id, read_defun_at + 1, true);

		            const wrote_def_after_reading_defun = read_defun_at != -1 && wrote_def_at != -1 && wrote_def_at > read_defun_at;

		            if (wrote_def_after_reading_defun) {
		                def.fixed = false;
		            }
		        }
		    }
		}

		def_reduce_vars(AST_Lambda, mark_lambda);

		def_reduce_vars(AST_Do, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		    const saved_loop = tw.in_loop;
		    tw.in_loop = this;
		    push(tw);
		    this.body.walk(tw);
		    if (has_break_or_continue(this)) {
		        pop(tw);
		        push(tw);
		    }
		    this.condition.walk(tw);
		    pop(tw);
		    tw.in_loop = saved_loop;
		    return true;
		});

		def_reduce_vars(AST_For, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		    if (this.init) this.init.walk(tw);
		    const saved_loop = tw.in_loop;
		    tw.in_loop = this;
		    push(tw);
		    if (this.condition) this.condition.walk(tw);
		    this.body.walk(tw);
		    if (this.step) {
		        if (has_break_or_continue(this)) {
		            pop(tw);
		            push(tw);
		        }
		        this.step.walk(tw);
		    }
		    pop(tw);
		    tw.in_loop = saved_loop;
		    return true;
		});

		def_reduce_vars(AST_ForIn, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		    suppress(this.init);
		    this.object.walk(tw);
		    const saved_loop = tw.in_loop;
		    tw.in_loop = this;
		    push(tw);
		    this.body.walk(tw);
		    pop(tw);
		    tw.in_loop = saved_loop;
		    return true;
		});

		def_reduce_vars(AST_If, function(tw) {
		    this.condition.walk(tw);
		    push(tw);
		    this.body.walk(tw);
		    pop(tw);
		    if (this.alternative) {
		        push(tw);
		        this.alternative.walk(tw);
		        pop(tw);
		    }
		    return true;
		});

		def_reduce_vars(AST_LabeledStatement, function(tw) {
		    push(tw);
		    this.body.walk(tw);
		    pop(tw);
		    return true;
		});

		def_reduce_vars(AST_SymbolCatch, function() {
		    this.definition().fixed = false;
		});

		def_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {
		    var d = this.definition();
		    d.references.push(this);
		    if (d.references.length == 1
		        && !d.fixed
		        && d.orig[0] instanceof AST_SymbolDefun) {
		        tw.loop_ids.set(d.id, tw.in_loop);
		    }
		    var fixed_value;
		    if (d.fixed === undefined || !safe_to_read(tw, d)) {
		        d.fixed = false;
		    } else if (d.fixed) {
		        fixed_value = this.fixed_value();
		        if (
		            fixed_value instanceof AST_Lambda
		            && is_recursive_ref(tw, d)
		        ) {
		            d.recursive_refs++;
		        } else if (fixed_value
		            && !compressor.exposed(d)
		            && ref_once(tw, compressor, d)
		        ) {
		            d.single_use =
		                fixed_value instanceof AST_Lambda && !fixed_value.pinned()
		                || fixed_value instanceof AST_Class
		                || d.scope === this.scope && fixed_value.is_constant_expression();
		        } else {
		            d.single_use = false;
		        }
		        if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {
		            if (d.single_use) {
		                d.single_use = "m";
		            } else {
		                d.fixed = false;
		            }
		        }
		    }
		    mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);
		});

		def_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {
		    this.globals.forEach(function(def) {
		        reset_def(compressor, def);
		    });
		    reset_variables(tw, compressor, this);
		    descend();
		    handle_defined_after_hoist(this);
		    return true;
		});

		def_reduce_vars(AST_Try, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		    push(tw);
		    this.body.walk(tw);
		    pop(tw);
		    if (this.bcatch) {
		        push(tw);
		        this.bcatch.walk(tw);
		        pop(tw);
		    }
		    if (this.bfinally) this.bfinally.walk(tw);
		    return true;
		});

		def_reduce_vars(AST_Unary, function(tw) {
		    var node = this;
		    if (node.operator !== "++" && node.operator !== "--") return;
		    var exp = node.expression;
		    if (!(exp instanceof AST_SymbolRef)) return;
		    var def = exp.definition();
		    var safe = safe_to_assign(tw, def, exp.scope, true);
		    def.assignments++;
		    if (!safe) return;
		    var fixed = def.fixed;
		    if (!fixed) return;
		    def.references.push(exp);
		    def.chained = true;
		    def.fixed = function() {
		        return make_node(AST_Binary, node, {
		            operator: node.operator.slice(0, -1),
		            left: make_node(AST_UnaryPrefix, node, {
		                operator: "+",
		                expression: fixed instanceof AST_Node ? fixed : fixed()
		            }),
		            right: make_node(AST_Number, node, {
		                value: 1
		            })
		        });
		    };
		    mark(tw, def, true);
		    return true;
		});

		def_reduce_vars(AST_VarDef, function(tw, descend) {
		    var node = this;
		    if (node.name instanceof AST_Destructuring) {
		        suppress(node.name);
		        return;
		    }
		    var d = node.name.definition();
		    if (node.value) {
		        if (safe_to_assign(tw, d, node.name.scope, node.value)) {
		            d.fixed = function() {
		                return node.value;
		            };
		            tw.loop_ids.set(d.id, tw.in_loop);
		            mark(tw, d, false);
		            descend();
		            mark(tw, d, true);
		            return true;
		        } else {
		            d.fixed = false;
		        }
		    }
		});

		def_reduce_vars(AST_While, function(tw, descend, compressor) {
		    reset_block_variables(compressor, this);
		    const saved_loop = tw.in_loop;
		    tw.in_loop = this;
		    push(tw);
		    descend();
		    pop(tw);
		    tw.in_loop = saved_loop;
		    return true;
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function loop_body(x) {
		    if (x instanceof AST_IterationStatement) {
		        return x.body instanceof AST_BlockStatement ? x.body : x;
		    }
		    return x;
		}

		function is_lhs_read_only(lhs) {
		    if (lhs instanceof AST_This) return true;
		    if (lhs instanceof AST_SymbolRef) return lhs.definition().orig[0] instanceof AST_SymbolLambda;
		    if (lhs instanceof AST_PropAccess) {
		        lhs = lhs.expression;
		        if (lhs instanceof AST_SymbolRef) {
		            if (lhs.is_immutable()) return false;
		            lhs = lhs.fixed_value();
		        }
		        if (!lhs) return true;
		        if (lhs instanceof AST_RegExp) return false;
		        if (lhs instanceof AST_Constant) return true;
		        return is_lhs_read_only(lhs);
		    }
		    return false;
		}

		/** var a = 1 --> var a*/
		function remove_initializers(var_statement) {
		    var decls = [];
		    var_statement.definitions.forEach(function(def) {
		        if (def.name instanceof AST_SymbolDeclaration) {
		            def.value = null;
		            decls.push(def);
		        } else {
		            def.declarations_as_names().forEach(name => {
		                decls.push(make_node(AST_VarDef, def, {
		                    name,
		                    value: null
		                }));
		            });
		        }
		    });
		    return decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : null;
		}

		/** Called on code which we know is unreachable, to keep elements that affect outside of it. */
		function trim_unreachable_code(compressor, stat, target) {
		    walk(stat, node => {
		        if (node instanceof AST_Var) {
		            const no_initializers = remove_initializers(node);
		            if (no_initializers) target.push(no_initializers);
		            return true;
		        }
		        if (
		            node instanceof AST_Defun
		            && (node === stat || !compressor.has_directive("use strict"))
		        ) {
		            target.push(node === stat ? node : make_node(AST_Var, node, {
		                definitions: [
		                    make_node(AST_VarDef, node, {
		                        name: make_node(AST_SymbolVar, node.name, node.name),
		                        value: null
		                    })
		                ]
		            }));
		            return true;
		        }
		        if (node instanceof AST_Export || node instanceof AST_Import) {
		            target.push(node);
		            return true;
		        }
		        if (node instanceof AST_Scope) {
		            return true;
		        }
		    });
		}

		/** Tighten a bunch of statements together, and perform statement-level optimization. */
		function tighten_body(statements, compressor) {
		    const nearest_scope = compressor.find_scope();
		    const defun_scope = nearest_scope.get_defun_scope();
		    const { in_loop, in_try } = find_loop_scope_try();

		    var CHANGED, max_iter = 10;
		    do {
		        CHANGED = false;
		        eliminate_spurious_blocks(statements);
		        if (compressor.option("dead_code")) {
		            eliminate_dead_code(statements, compressor);
		        }
		        if (compressor.option("if_return")) {
		            handle_if_return(statements, compressor);
		        }
		        if (compressor.sequences_limit > 0) {
		            sequencesize(statements, compressor);
		            sequencesize_2(statements, compressor);
		        }
		        if (compressor.option("join_vars")) {
		            join_consecutive_vars(statements);
		        }
		        if (compressor.option("collapse_vars")) {
		            collapse(statements, compressor);
		        }
		    } while (CHANGED && max_iter-- > 0);

		    function find_loop_scope_try() {
		        var node = compressor.self(), level = 0, in_loop = false, in_try = false;
		        do {
		            if (node instanceof AST_IterationStatement) {
		                in_loop = true;
		            } else if (node instanceof AST_Scope) {
		                break;
		            } else if (node instanceof AST_TryBlock) {
		                in_try = true;
		            }
		        } while (node = compressor.parent(level++));

		        return { in_loop, in_try };
		    }

		    // Search from right to left for assignment-like expressions:
		    // - `var a = x;`
		    // - `a = x;`
		    // - `++a`
		    // For each candidate, scan from left to right for first usage, then try
		    // to fold assignment into the site for compression.
		    // Will not attempt to collapse assignments into or past code blocks
		    // which are not sequentially executed, e.g. loops and conditionals.
		    function collapse(statements, compressor) {
		        if (nearest_scope.pinned() || defun_scope.pinned())
		            return statements;
		        var args;
		        var candidates = [];
		        var stat_index = statements.length;
		        var scanner = new TreeTransformer(function (node) {
		            if (abort)
		                return node;
		            // Skip nodes before `candidate` as quickly as possible
		            if (!hit) {
		                if (node !== hit_stack[hit_index])
		                    return node;
		                hit_index++;
		                if (hit_index < hit_stack.length)
		                    return handle_custom_scan_order(node);
		                hit = true;
		                stop_after = find_stop(node, 0);
		                if (stop_after === node)
		                    abort = true;
		                return node;
		            }
		            // Stop immediately if these node types are encountered
		            var parent = scanner.parent();
		            if (node instanceof AST_Assign
		                    && (node.logical || node.operator != "=" && lhs.equivalent_to(node.left))
		                || node instanceof AST_Await
		                || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression)
		                ||
		                    (node instanceof AST_Call || node instanceof AST_PropAccess)
		                    && node.optional
		                || node instanceof AST_Debugger
		                || node instanceof AST_Destructuring
		                || node instanceof AST_Expansion
		                    && node.expression instanceof AST_Symbol
		                    && (
		                        node.expression instanceof AST_This
		                        || node.expression.definition().references.length > 1
		                    )
		                || node instanceof AST_IterationStatement && !(node instanceof AST_For)
		                || node instanceof AST_LoopControl
		                || node instanceof AST_Try
		                || node instanceof AST_With
		                || node instanceof AST_Yield
		                || node instanceof AST_Export
		                || node instanceof AST_Class
		                || parent instanceof AST_For && node !== parent.init
		                || !replace_all
		                    && (
		                        node instanceof AST_SymbolRef
		                        && !node.is_declared(compressor)
		                        && !pure_prop_access_globals.has(node)
		                    )
		                || node instanceof AST_SymbolRef
		                    && parent instanceof AST_Call
		                    && has_annotation(parent, _NOINLINE)
		            ) {
		                abort = true;
		                return node;
		            }
		            // Stop only if candidate is found within conditional branches
		            if (!stop_if_hit && (!lhs_local || !replace_all)
		                && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node
		                    || parent instanceof AST_Conditional && parent.condition !== node
		                    || parent instanceof AST_If && parent.condition !== node)) {
		                stop_if_hit = parent;
		            }
		            // Replace variable with assignment when found
		            if (
		                can_replace
		                && !(node instanceof AST_SymbolDeclaration)
		                && lhs.equivalent_to(node)
		                && !shadows(scanner.find_scope() || nearest_scope, lvalues)
		            ) {
		                if (stop_if_hit) {
		                    abort = true;
		                    return node;
		                }
		                if (is_lhs(node, parent)) {
		                    if (value_def)
		                        replaced++;
		                    return node;
		                } else {
		                    replaced++;
		                    if (value_def && candidate instanceof AST_VarDef)
		                        return node;
		                }
		                CHANGED = abort = true;
		                if (candidate instanceof AST_UnaryPostfix) {
		                    return make_node(AST_UnaryPrefix, candidate, candidate);
		                }
		                if (candidate instanceof AST_VarDef) {
		                    var def = candidate.name.definition();
		                    var value = candidate.value;
		                    if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {
		                        def.replaced++;
		                        if (funarg && is_identifier_atom(value)) {
		                            return value.transform(compressor);
		                        } else {
		                            return maintain_this_binding(parent, node, value);
		                        }
		                    }
		                    return make_node(AST_Assign, candidate, {
		                        operator: "=",
		                        logical: false,
		                        left: make_node(AST_SymbolRef, candidate.name, candidate.name),
		                        right: value
		                    });
		                }
		                clear_flag(candidate, WRITE_ONLY);
		                return candidate;
		            }
		            // These node types have child nodes that execute sequentially,
		            // but are otherwise not safe to scan into or beyond them.
		            var sym;
		            if (node instanceof AST_Call
		                || node instanceof AST_Exit
		                && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs))
		                || node instanceof AST_PropAccess
		                && (side_effects || node.expression.may_throw_on_access(compressor))
		                || node instanceof AST_SymbolRef
		                && ((lvalues.has(node.name) && lvalues.get(node.name).modified) || side_effects && may_modify(node))
		                || node instanceof AST_VarDef && node.value
		                && (lvalues.has(node.name.name) || side_effects && may_modify(node.name))
		                || (sym = is_lhs(node.left, node))
		                && (sym instanceof AST_PropAccess || lvalues.has(sym.name))
		                || may_throw
		                && (in_try ? node.has_side_effects(compressor) : side_effects_external(node))) {
		                stop_after = node;
		                if (node instanceof AST_Scope)
		                    abort = true;
		            }
		            return handle_custom_scan_order(node);
		        }, function (node) {
		            if (abort)
		                return;
		            if (stop_after === node)
		                abort = true;
		            if (stop_if_hit === node)
		                stop_if_hit = null;
		        });

		        var multi_replacer = new TreeTransformer(function (node) {
		            if (abort)
		                return node;
		            // Skip nodes before `candidate` as quickly as possible
		            if (!hit) {
		                if (node !== hit_stack[hit_index])
		                    return node;
		                hit_index++;
		                if (hit_index < hit_stack.length)
		                    return;
		                hit = true;
		                return node;
		            }
		            // Replace variable when found
		            if (node instanceof AST_SymbolRef
		                && node.name == def.name) {
		                if (!--replaced)
		                    abort = true;
		                if (is_lhs(node, multi_replacer.parent()))
		                    return node;
		                def.replaced++;
		                value_def.replaced--;
		                return candidate.value;
		            }
		            // Skip (non-executed) functions and (leading) default case in switch statements
		            if (node instanceof AST_Default || node instanceof AST_Scope)
		                return node;
		        });

		        while (--stat_index >= 0) {
		            // Treat parameters as collapsible in IIFE, i.e.
		            //   function(a, b){ ... }(x());
		            // would be translated into equivalent assignments:
		            //   var a = x(), b = undefined;
		            if (stat_index == 0 && compressor.option("unused"))
		                extract_args();
		            // Find collapsible assignments
		            var hit_stack = [];
		            extract_candidates(statements[stat_index]);
		            while (candidates.length > 0) {
		                hit_stack = candidates.pop();
		                var hit_index = 0;
		                var candidate = hit_stack[hit_stack.length - 1];
		                var value_def = null;
		                var stop_after = null;
		                var stop_if_hit = null;
		                var lhs = get_lhs(candidate);
		                if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor))
		                    continue;
		                // Locate symbols which may execute code outside of scanning range
		                var lvalues = get_lvalues(candidate);
		                var lhs_local = is_lhs_local(lhs);
		                if (lhs instanceof AST_SymbolRef) {
		                    lvalues.set(lhs.name, { def: lhs.definition(), modified: false });
		                }
		                var side_effects = value_has_side_effects(candidate);
		                var replace_all = replace_all_symbols();
		                var may_throw = candidate.may_throw(compressor);
		                var funarg = candidate.name instanceof AST_SymbolFunarg;
		                var hit = funarg;
		                var abort = false, replaced = 0, can_replace = !args || !hit;
		                if (!can_replace) {
		                    for (
		                        let j = compressor.self().argnames.lastIndexOf(candidate.name) + 1;
		                        !abort && j < args.length;
		                        j++
		                    ) {
		                        args[j].transform(scanner);
		                    }
		                    can_replace = true;
		                }
		                for (var i = stat_index; !abort && i < statements.length; i++) {
		                    statements[i].transform(scanner);
		                }
		                if (value_def) {
		                    var def = candidate.name.definition();
		                    if (abort && def.references.length - def.replaced > replaced)
		                        replaced = false;
		                    else {
		                        abort = false;
		                        hit_index = 0;
		                        hit = funarg;
		                        for (var i = stat_index; !abort && i < statements.length; i++) {
		                            statements[i].transform(multi_replacer);
		                        }
		                        value_def.single_use = false;
		                    }
		                }
		                if (replaced && !remove_candidate(candidate))
		                    statements.splice(stat_index, 1);
		            }
		        }

		        function handle_custom_scan_order(node) {
		            // Skip (non-executed) functions
		            if (node instanceof AST_Scope)
		                return node;

		            // Scan case expressions first in a switch statement
		            if (node instanceof AST_Switch) {
		                node.expression = node.expression.transform(scanner);
		                for (var i = 0, len = node.body.length; !abort && i < len; i++) {
		                    var branch = node.body[i];
		                    if (branch instanceof AST_Case) {
		                        if (!hit) {
		                            if (branch !== hit_stack[hit_index])
		                                continue;
		                            hit_index++;
		                        }
		                        branch.expression = branch.expression.transform(scanner);
		                        if (!replace_all)
		                            break;
		                    }
		                }
		                abort = true;
		                return node;
		            }
		        }

		        function redefined_within_scope(def, scope) {
		            if (def.global)
		                return false;
		            let cur_scope = def.scope;
		            while (cur_scope && cur_scope !== scope) {
		                if (cur_scope.variables.has(def.name)) {
		                    return true;
		                }
		                cur_scope = cur_scope.parent_scope;
		            }
		            return false;
		        }

		        function has_overlapping_symbol(fn, arg, fn_strict) {
		            var found = false, scan_this = !(fn instanceof AST_Arrow);
		            arg.walk(new TreeWalker(function (node, descend) {
		                if (found)
		                    return true;
		                if (node instanceof AST_SymbolRef && (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {
		                    var s = node.definition().scope;
		                    if (s !== defun_scope)
		                        while (s = s.parent_scope) {
		                            if (s === defun_scope)
		                                return true;
		                        }
		                    return found = true;
		                }
		                if ((fn_strict || scan_this) && node instanceof AST_This) {
		                    return found = true;
		                }
		                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
		                    var prev = scan_this;
		                    scan_this = false;
		                    descend();
		                    scan_this = prev;
		                    return true;
		                }
		            }));
		            return found;
		        }

		        function extract_args() {
		            var iife, fn = compressor.self();
		            if (is_func_expr(fn)
		                && !fn.name
		                && !fn.uses_arguments
		                && !fn.pinned()
		                && (iife = compressor.parent()) instanceof AST_Call
		                && iife.expression === fn
		                && iife.args.every((arg) => !(arg instanceof AST_Expansion))) {
		                var fn_strict = compressor.has_directive("use strict");
		                if (fn_strict && !member(fn_strict, fn.body))
		                    fn_strict = false;
		                var len = fn.argnames.length;
		                args = iife.args.slice(len);
		                var names = new Set();
		                for (var i = len; --i >= 0;) {
		                    var sym = fn.argnames[i];
		                    var arg = iife.args[i];
		                    // The following two line fix is a duplicate of the fix at
		                    // https://github.com/terser/terser/commit/011d3eb08cefe6922c7d1bdfa113fc4aeaca1b75
		                    // This might mean that these two pieces of code (one here in collapse_vars and another in reduce_vars
		                    // Might be doing the exact same thing.
		                    const def = sym.definition && sym.definition();
		                    const is_reassigned = def && def.orig.length > 1;
		                    if (is_reassigned)
		                        continue;
		                    args.unshift(make_node(AST_VarDef, sym, {
		                        name: sym,
		                        value: arg
		                    }));
		                    if (names.has(sym.name))
		                        continue;
		                    names.add(sym.name);
		                    if (sym instanceof AST_Expansion) {
		                        var elements = iife.args.slice(i);
		                        if (elements.every((arg) => !has_overlapping_symbol(fn, arg, fn_strict)
		                        )) {
		                            candidates.unshift([make_node(AST_VarDef, sym, {
		                                name: sym.expression,
		                                value: make_node(AST_Array, iife, {
		                                    elements: elements
		                                })
		                            })]);
		                        }
		                    } else {
		                        if (!arg) {
		                            arg = make_node(AST_Undefined, sym).transform(compressor);
		                        } else if (arg instanceof AST_Lambda && arg.pinned()
		                            || has_overlapping_symbol(fn, arg, fn_strict)) {
		                            arg = null;
		                        }
		                        if (arg)
		                            candidates.unshift([make_node(AST_VarDef, sym, {
		                                name: sym,
		                                value: arg
		                            })]);
		                    }
		                }
		            }
		        }

		        function extract_candidates(expr) {
		            hit_stack.push(expr);
		            if (expr instanceof AST_Assign) {
		                if (!expr.left.has_side_effects(compressor)
		                    && !(expr.right instanceof AST_Chain)) {
		                    candidates.push(hit_stack.slice());
		                }
		                extract_candidates(expr.right);
		            } else if (expr instanceof AST_Binary) {
		                extract_candidates(expr.left);
		                extract_candidates(expr.right);
		            } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {
		                extract_candidates(expr.expression);
		                expr.args.forEach(extract_candidates);
		            } else if (expr instanceof AST_Case) {
		                extract_candidates(expr.expression);
		            } else if (expr instanceof AST_Conditional) {
		                extract_candidates(expr.condition);
		                extract_candidates(expr.consequent);
		                extract_candidates(expr.alternative);
		            } else if (expr instanceof AST_Definitions) {
		                var len = expr.definitions.length;
		                // limit number of trailing variable definitions for consideration
		                var i = len - 200;
		                if (i < 0)
		                    i = 0;
		                for (; i < len; i++) {
		                    extract_candidates(expr.definitions[i]);
		                }
		            } else if (expr instanceof AST_DWLoop) {
		                extract_candidates(expr.condition);
		                if (!(expr.body instanceof AST_Block)) {
		                    extract_candidates(expr.body);
		                }
		            } else if (expr instanceof AST_Exit) {
		                if (expr.value)
		                    extract_candidates(expr.value);
		            } else if (expr instanceof AST_For) {
		                if (expr.init)
		                    extract_candidates(expr.init);
		                if (expr.condition)
		                    extract_candidates(expr.condition);
		                if (expr.step)
		                    extract_candidates(expr.step);
		                if (!(expr.body instanceof AST_Block)) {
		                    extract_candidates(expr.body);
		                }
		            } else if (expr instanceof AST_ForIn) {
		                extract_candidates(expr.object);
		                if (!(expr.body instanceof AST_Block)) {
		                    extract_candidates(expr.body);
		                }
		            } else if (expr instanceof AST_If) {
		                extract_candidates(expr.condition);
		                if (!(expr.body instanceof AST_Block)) {
		                    extract_candidates(expr.body);
		                }
		                if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
		                    extract_candidates(expr.alternative);
		                }
		            } else if (expr instanceof AST_Sequence) {
		                expr.expressions.forEach(extract_candidates);
		            } else if (expr instanceof AST_SimpleStatement) {
		                extract_candidates(expr.body);
		            } else if (expr instanceof AST_Switch) {
		                extract_candidates(expr.expression);
		                expr.body.forEach(extract_candidates);
		            } else if (expr instanceof AST_Unary) {
		                if (expr.operator == "++" || expr.operator == "--") {
		                    candidates.push(hit_stack.slice());
		                }
		            } else if (expr instanceof AST_VarDef) {
		                if (expr.value && !(expr.value instanceof AST_Chain)) {
		                    candidates.push(hit_stack.slice());
		                    extract_candidates(expr.value);
		                }
		            }
		            hit_stack.pop();
		        }

		        function find_stop(node, level, write_only) {
		            var parent = scanner.parent(level);
		            if (parent instanceof AST_Assign) {
		                if (write_only
		                    && !parent.logical
		                    && !(parent.left instanceof AST_PropAccess
		                        || lvalues.has(parent.left.name))) {
		                    return find_stop(parent, level + 1, write_only);
		                }
		                return node;
		            }
		            if (parent instanceof AST_Binary) {
		                if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {
		                    return find_stop(parent, level + 1, write_only);
		                }
		                return node;
		            }
		            if (parent instanceof AST_Call)
		                return node;
		            if (parent instanceof AST_Case)
		                return node;
		            if (parent instanceof AST_Conditional) {
		                if (write_only && parent.condition === node) {
		                    return find_stop(parent, level + 1, write_only);
		                }
		                return node;
		            }
		            if (parent instanceof AST_Definitions) {
		                return find_stop(parent, level + 1, true);
		            }
		            if (parent instanceof AST_Exit) {
		                return write_only ? find_stop(parent, level + 1, write_only) : node;
		            }
		            if (parent instanceof AST_If) {
		                if (write_only && parent.condition === node) {
		                    return find_stop(parent, level + 1, write_only);
		                }
		                return node;
		            }
		            if (parent instanceof AST_IterationStatement)
		                return node;
		            if (parent instanceof AST_Sequence) {
		                return find_stop(parent, level + 1, parent.tail_node() !== node);
		            }
		            if (parent instanceof AST_SimpleStatement) {
		                return find_stop(parent, level + 1, true);
		            }
		            if (parent instanceof AST_Switch)
		                return node;
		            if (parent instanceof AST_VarDef)
		                return node;
		            return null;
		        }

		        function mangleable_var(var_def) {
		            var value = var_def.value;
		            if (!(value instanceof AST_SymbolRef))
		                return;
		            if (value.name == "arguments")
		                return;
		            var def = value.definition();
		            if (def.undeclared)
		                return;
		            return value_def = def;
		        }

		        function get_lhs(expr) {
		            if (expr instanceof AST_Assign && expr.logical) {
		                return false;
		            } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {
		                var def = expr.name.definition();
		                if (!member(expr.name, def.orig))
		                    return;
		                var referenced = def.references.length - def.replaced;
		                if (!referenced)
		                    return;
		                var declared = def.orig.length - def.eliminated;
		                if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg)
		                    || (referenced > 1 ? mangleable_var(expr) : !compressor.exposed(def))) {
		                    return make_node(AST_SymbolRef, expr.name, expr.name);
		                }
		            } else {
		                const lhs = expr instanceof AST_Assign
		                    ? expr.left
		                    : expr.expression;
		                return !is_ref_of(lhs, AST_SymbolConst)
		                    && !is_ref_of(lhs, AST_SymbolLet) && lhs;
		            }
		        }

		        function get_rvalue(expr) {
		            if (expr instanceof AST_Assign) {
		                return expr.right;
		            } else {
		                return expr.value;
		            }
		        }

		        function get_lvalues(expr) {
		            var lvalues = new Map();
		            if (expr instanceof AST_Unary)
		                return lvalues;
		            var tw = new TreeWalker(function (node) {
		                var sym = node;
		                while (sym instanceof AST_PropAccess)
		                    sym = sym.expression;
		                if (sym instanceof AST_SymbolRef) {
		                    const prev = lvalues.get(sym.name);
		                    if (!prev || !prev.modified) {
		                        lvalues.set(sym.name, {
		                            def: sym.definition(),
		                            modified: is_modified(compressor, tw, node, node, 0)
		                        });
		                    }
		                }
		            });
		            get_rvalue(expr).walk(tw);
		            return lvalues;
		        }

		        function remove_candidate(expr) {
		            if (expr.name instanceof AST_SymbolFunarg) {
		                var iife = compressor.parent(), argnames = compressor.self().argnames;
		                var index = argnames.indexOf(expr.name);
		                if (index < 0) {
		                    iife.args.length = Math.min(iife.args.length, argnames.length - 1);
		                } else {
		                    var args = iife.args;
		                    if (args[index])
		                        args[index] = make_node(AST_Number, args[index], {
		                            value: 0
		                        });
		                }
		                return true;
		            }
		            var found = false;
		            return statements[stat_index].transform(new TreeTransformer(function (node, descend, in_list) {
		                if (found)
		                    return node;
		                if (node === expr || node.body === expr) {
		                    found = true;
		                    if (node instanceof AST_VarDef) {
		                        node.value = node.name instanceof AST_SymbolConst
		                            ? make_node(AST_Undefined, node.value) // `const` always needs value.
		                            : null;
		                        return node;
		                    }
		                    return in_list ? MAP.skip : null;
		                }
		            }, function (node) {
		                if (node instanceof AST_Sequence)
		                    switch (node.expressions.length) {
		                        case 0: return null;
		                        case 1: return node.expressions[0];
		                    }
		            }));
		        }

		        function is_lhs_local(lhs) {
		            while (lhs instanceof AST_PropAccess)
		                lhs = lhs.expression;
		            return lhs instanceof AST_SymbolRef
		                && lhs.definition().scope.get_defun_scope() === defun_scope
		                && !(in_loop
		                    && (lvalues.has(lhs.name)
		                        || candidate instanceof AST_Unary
		                        || (candidate instanceof AST_Assign
		                            && !candidate.logical
		                            && candidate.operator != "=")));
		        }

		        function value_has_side_effects(expr) {
		            if (expr instanceof AST_Unary)
		                return unary_side_effects.has(expr.operator);
		            return get_rvalue(expr).has_side_effects(compressor);
		        }

		        function replace_all_symbols() {
		            if (side_effects)
		                return false;
		            if (value_def)
		                return true;
		            if (lhs instanceof AST_SymbolRef) {
		                var def = lhs.definition();
		                if (def.references.length - def.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {
		                    return true;
		                }
		            }
		            return false;
		        }

		        function may_modify(sym) {
		            if (!sym.definition)
		                return true; // AST_Destructuring
		            var def = sym.definition();
		            if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun)
		                return false;
		            if (def.scope.get_defun_scope() !== defun_scope)
		                return true;
		            return def.references.some((ref) =>
		                ref.scope.get_defun_scope() !== defun_scope
		            );
		        }

		        function side_effects_external(node, lhs) {
		            if (node instanceof AST_Assign)
		                return side_effects_external(node.left, true);
		            if (node instanceof AST_Unary)
		                return side_effects_external(node.expression, true);
		            if (node instanceof AST_VarDef)
		                return node.value && side_effects_external(node.value);
		            if (lhs) {
		                if (node instanceof AST_Dot)
		                    return side_effects_external(node.expression, true);
		                if (node instanceof AST_Sub)
		                    return side_effects_external(node.expression, true);
		                if (node instanceof AST_SymbolRef)
		                    return node.definition().scope.get_defun_scope() !== defun_scope;
		            }
		            return false;
		        }

		        /**
		         * Will any of the pulled-in lvalues shadow a variable in newScope or parents?
		         * similar to scope_encloses_variables_in_this_scope */
		        function shadows(my_scope, lvalues) {
		            for (const { def } of lvalues.values()) {
		                const looked_up = my_scope.find_variable(def.name);
		                if (looked_up) {
		                    if (looked_up === def) continue;
		                    return true;
		                }
		            }
		            return false;
		        }
		    }

		    function eliminate_spurious_blocks(statements) {
		        var seen_dirs = [];
		        for (var i = 0; i < statements.length;) {
		            var stat = statements[i];
		            if (stat instanceof AST_BlockStatement && stat.body.every(can_be_evicted_from_block)) {
		                CHANGED = true;
		                eliminate_spurious_blocks(stat.body);
		                statements.splice(i, 1, ...stat.body);
		                i += stat.body.length;
		            } else if (stat instanceof AST_EmptyStatement) {
		                CHANGED = true;
		                statements.splice(i, 1);
		            } else if (stat instanceof AST_Directive) {
		                if (seen_dirs.indexOf(stat.value) < 0) {
		                    i++;
		                    seen_dirs.push(stat.value);
		                } else {
		                    CHANGED = true;
		                    statements.splice(i, 1);
		                }
		            } else
		                i++;
		        }
		    }

		    function handle_if_return(statements, compressor) {
		        var self = compressor.self();
		        var multiple_if_returns = has_multiple_if_returns(statements);
		        var in_lambda = self instanceof AST_Lambda;
		        // Prevent extremely deep nesting
		        // https://github.com/terser/terser/issues/1432
		        // https://github.com/webpack/webpack/issues/17548
		        const iteration_start = Math.min(statements.length, 500);
		        for (var i = iteration_start; --i >= 0;) {
		            var stat = statements[i];
		            var j = next_index(i);
		            var next = statements[j];

		            if (in_lambda && !next && stat instanceof AST_Return) {
		                if (!stat.value) {
		                    CHANGED = true;
		                    statements.splice(i, 1);
		                    continue;
		                }
		                if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == "void") {
		                    CHANGED = true;
		                    statements[i] = make_node(AST_SimpleStatement, stat, {
		                        body: stat.value.expression
		                    });
		                    continue;
		                }
		            }

		            if (stat instanceof AST_If) {
		                let ab, new_else;

		                ab = aborts(stat.body);
		                if (
		                    can_merge_flow(ab)
		                    && (new_else = as_statement_array_with_return(stat.body, ab))
		                ) {
		                    if (ab.label) {
		                        remove(ab.label.thedef.references, ab);
		                    }
		                    CHANGED = true;
		                    stat = stat.clone();
		                    stat.condition = stat.condition.negate(compressor);
		                    stat.body = make_node(AST_BlockStatement, stat, {
		                        body: as_statement_array(stat.alternative).concat(extract_functions())
		                    });
		                    stat.alternative = make_node(AST_BlockStatement, stat, {
		                        body: new_else
		                    });
		                    statements[i] = stat.transform(compressor);
		                    continue;
		                }

		                ab = aborts(stat.alternative);
		                if (
		                    can_merge_flow(ab)
		                    && (new_else = as_statement_array_with_return(stat.alternative, ab))
		                ) {
		                    if (ab.label) {
		                        remove(ab.label.thedef.references, ab);
		                    }
		                    CHANGED = true;
		                    stat = stat.clone();
		                    stat.body = make_node(AST_BlockStatement, stat.body, {
		                        body: as_statement_array(stat.body).concat(extract_functions())
		                    });
		                    stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
		                        body: new_else
		                    });
		                    statements[i] = stat.transform(compressor);
		                    continue;
		                }
		            }

		            if (stat instanceof AST_If && stat.body instanceof AST_Return) {
		                var value = stat.body.value;
		                //---
		                // pretty silly case, but:
		                // if (foo()) return; return; ==> foo(); return;
		                if (!value && !stat.alternative
		                    && (in_lambda && !next || next instanceof AST_Return && !next.value)) {
		                    CHANGED = true;
		                    statements[i] = make_node(AST_SimpleStatement, stat.condition, {
		                        body: stat.condition
		                    });
		                    continue;
		                }
		                //---
		                // if (foo()) return x; return y; ==> return foo() ? x : y;
		                if (value && !stat.alternative && next instanceof AST_Return && next.value) {
		                    CHANGED = true;
		                    stat = stat.clone();
		                    stat.alternative = next;
		                    statements[i] = stat.transform(compressor);
		                    statements.splice(j, 1);
		                    continue;
		                }
		                //---
		                // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
		                if (value && !stat.alternative
		                    && (!next && in_lambda && multiple_if_returns
		                        || next instanceof AST_Return)) {
		                    CHANGED = true;
		                    stat = stat.clone();
		                    stat.alternative = next || make_node(AST_Return, stat, {
		                        value: null
		                    });
		                    statements[i] = stat.transform(compressor);
		                    if (next)
		                        statements.splice(j, 1);
		                    continue;
		                }
		                //---
		                // if (a) return b; if (c) return d; e; ==> return a ? b : c ? d : void e;
		                //
		                // if sequences is not enabled, this can lead to an endless loop (issue #866).
		                // however, with sequences on this helps producing slightly better output for
		                // the example code.
		                var prev = statements[prev_index(i)];
		                if (compressor.option("sequences") && in_lambda && !stat.alternative
		                    && prev instanceof AST_If && prev.body instanceof AST_Return
		                    && next_index(j) == statements.length && next instanceof AST_SimpleStatement) {
		                    CHANGED = true;
		                    stat = stat.clone();
		                    stat.alternative = make_node(AST_BlockStatement, next, {
		                        body: [
		                            next,
		                            make_node(AST_Return, next, {
		                                value: null
		                            })
		                        ]
		                    });
		                    statements[i] = stat.transform(compressor);
		                    statements.splice(j, 1);
		                    continue;
		                }
		            }
		        }

		        function has_multiple_if_returns(statements) {
		            var n = 0;
		            for (var i = statements.length; --i >= 0;) {
		                var stat = statements[i];
		                if (stat instanceof AST_If && stat.body instanceof AST_Return) {
		                    if (++n > 1)
		                        return true;
		                }
		            }
		            return false;
		        }

		        function is_return_void(value) {
		            return !value || value instanceof AST_UnaryPrefix && value.operator == "void";
		        }

		        function can_merge_flow(ab) {
		            if (!ab)
		                return false;
		            for (var j = i + 1, len = statements.length; j < len; j++) {
		                var stat = statements[j];
		                if (stat instanceof AST_Const || stat instanceof AST_Let)
		                    return false;
		            }
		            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab) : null;
		            return ab instanceof AST_Return && in_lambda && is_return_void(ab.value)
		                || ab instanceof AST_Continue && self === loop_body(lct)
		                || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct;
		        }

		        function extract_functions() {
		            var tail = statements.slice(i + 1);
		            statements.length = i + 1;
		            return tail.filter(function (stat) {
		                if (stat instanceof AST_Defun) {
		                    statements.push(stat);
		                    return false;
		                }
		                return true;
		            });
		        }

		        function as_statement_array_with_return(node, ab) {
		            var body = as_statement_array(node);
		            if (ab !== body[body.length - 1]) {
		                return undefined;
		            }
		            body = body.slice(0, -1);
		            if (ab.value) {
		                body.push(make_node(AST_SimpleStatement, ab.value, {
		                    body: ab.value.expression
		                }));
		            }
		            return body;
		        }

		        function next_index(i) {
		            for (var j = i + 1, len = statements.length; j < len; j++) {
		                var stat = statements[j];
		                if (!(stat instanceof AST_Var && declarations_only(stat))) {
		                    break;
		                }
		            }
		            return j;
		        }

		        function prev_index(i) {
		            for (var j = i; --j >= 0;) {
		                var stat = statements[j];
		                if (!(stat instanceof AST_Var && declarations_only(stat))) {
		                    break;
		                }
		            }
		            return j;
		        }
		    }

		    function eliminate_dead_code(statements, compressor) {
		        var has_quit;
		        var self = compressor.self();
		        for (var i = 0, n = 0, len = statements.length; i < len; i++) {
		            var stat = statements[i];
		            if (stat instanceof AST_LoopControl) {
		                var lct = compressor.loopcontrol_target(stat);
		                if (stat instanceof AST_Break
		                    && !(lct instanceof AST_IterationStatement)
		                    && loop_body(lct) === self
		                    || stat instanceof AST_Continue
		                    && loop_body(lct) === self) {
		                    if (stat.label) {
		                        remove(stat.label.thedef.references, stat);
		                    }
		                } else {
		                    statements[n++] = stat;
		                }
		            } else {
		                statements[n++] = stat;
		            }
		            if (aborts(stat)) {
		                has_quit = statements.slice(i + 1);
		                break;
		            }
		        }
		        statements.length = n;
		        CHANGED = n != len;
		        if (has_quit)
		            has_quit.forEach(function (stat) {
		                trim_unreachable_code(compressor, stat, statements);
		            });
		    }

		    function declarations_only(node) {
		        return node.definitions.every((var_def) => !var_def.value);
		    }

		    function sequencesize(statements, compressor) {
		        if (statements.length < 2)
		            return;
		        var seq = [], n = 0;
		        function push_seq() {
		            if (!seq.length)
		                return;
		            var body = make_sequence(seq[0], seq);
		            statements[n++] = make_node(AST_SimpleStatement, body, { body: body });
		            seq = [];
		        }
		        for (var i = 0, len = statements.length; i < len; i++) {
		            var stat = statements[i];
		            if (stat instanceof AST_SimpleStatement) {
		                if (seq.length >= compressor.sequences_limit)
		                    push_seq();
		                var body = stat.body;
		                if (seq.length > 0)
		                    body = body.drop_side_effect_free(compressor);
		                if (body)
		                    merge_sequence(seq, body);
		            } else if (stat instanceof AST_Definitions && declarations_only(stat)
		                || stat instanceof AST_Defun) {
		                statements[n++] = stat;
		            } else {
		                push_seq();
		                statements[n++] = stat;
		            }
		        }
		        push_seq();
		        statements.length = n;
		        if (n != len)
		            CHANGED = true;
		    }

		    function to_simple_statement(block, decls) {
		        if (!(block instanceof AST_BlockStatement))
		            return block;
		        var stat = null;
		        for (var i = 0, len = block.body.length; i < len; i++) {
		            var line = block.body[i];
		            if (line instanceof AST_Var && declarations_only(line)) {
		                decls.push(line);
		            } else if (stat || line instanceof AST_Const || line instanceof AST_Let) {
		                return false;
		            } else {
		                stat = line;
		            }
		        }
		        return stat;
		    }

		    function sequencesize_2(statements, compressor) {
		        function cons_seq(right) {
		            n--;
		            CHANGED = true;
		            var left = prev.body;
		            return make_sequence(left, [left, right]).transform(compressor);
		        }
		        var n = 0, prev;
		        for (var i = 0; i < statements.length; i++) {
		            var stat = statements[i];
		            if (prev) {
		                if (stat instanceof AST_Exit) {
		                    stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));
		                } else if (stat instanceof AST_For) {
		                    if (!(stat.init instanceof AST_Definitions)) {
		                        const abort = walk(prev.body, node => {
		                            if (node instanceof AST_Scope)
		                                return true;
		                            if (node instanceof AST_Binary
		                                && node.operator === "in") {
		                                return walk_abort;
		                            }
		                        });
		                        if (!abort) {
		                            if (stat.init)
		                                stat.init = cons_seq(stat.init);
		                            else {
		                                stat.init = prev.body;
		                                n--;
		                                CHANGED = true;
		                            }
		                        }
		                    }
		                } else if (stat instanceof AST_ForIn) {
		                    if (!(stat.init instanceof AST_Const) && !(stat.init instanceof AST_Let)) {
		                        stat.object = cons_seq(stat.object);
		                    }
		                } else if (stat instanceof AST_If) {
		                    stat.condition = cons_seq(stat.condition);
		                } else if (stat instanceof AST_Switch) {
		                    stat.expression = cons_seq(stat.expression);
		                } else if (stat instanceof AST_With) {
		                    stat.expression = cons_seq(stat.expression);
		                }
		            }
		            if (compressor.option("conditionals") && stat instanceof AST_If) {
		                var decls = [];
		                var body = to_simple_statement(stat.body, decls);
		                var alt = to_simple_statement(stat.alternative, decls);
		                if (body !== false && alt !== false && decls.length > 0) {
		                    var len = decls.length;
		                    decls.push(make_node(AST_If, stat, {
		                        condition: stat.condition,
		                        body: body || make_node(AST_EmptyStatement, stat.body),
		                        alternative: alt
		                    }));
		                    decls.unshift(n, 1);
		                    [].splice.apply(statements, decls);
		                    i += len;
		                    n += len + 1;
		                    prev = null;
		                    CHANGED = true;
		                    continue;
		                }
		            }
		            statements[n++] = stat;
		            prev = stat instanceof AST_SimpleStatement ? stat : null;
		        }
		        statements.length = n;
		    }

		    function join_object_assignments(defn, body) {
		        if (!(defn instanceof AST_Definitions))
		            return;
		        var def = defn.definitions[defn.definitions.length - 1];
		        if (!(def.value instanceof AST_Object))
		            return;
		        var exprs;
		        if (body instanceof AST_Assign && !body.logical) {
		            exprs = [body];
		        } else if (body instanceof AST_Sequence) {
		            exprs = body.expressions.slice();
		        }
		        if (!exprs)
		            return;
		        var trimmed = false;
		        do {
		            var node = exprs[0];
		            if (!(node instanceof AST_Assign))
		                break;
		            if (node.operator != "=")
		                break;
		            if (!(node.left instanceof AST_PropAccess))
		                break;
		            var sym = node.left.expression;
		            if (!(sym instanceof AST_SymbolRef))
		                break;
		            if (def.name.name != sym.name)
		                break;
		            if (!node.right.is_constant_expression(nearest_scope))
		                break;
		            var prop = node.left.property;
		            if (prop instanceof AST_Node) {
		                prop = prop.evaluate(compressor);
		            }
		            if (prop instanceof AST_Node)
		                break;
		            prop = "" + prop;
		            var diff = compressor.option("ecma") < 2015
		                && compressor.has_directive("use strict") ? function (node) {
		                    return node.key != prop && (node.key && node.key.name != prop);
		                } : function (node) {
		                    return node.key && node.key.name != prop;
		                };
		            if (!def.value.properties.every(diff))
		                break;
		            var p = def.value.properties.filter(function (p) { return p.key === prop; })[0];
		            if (!p) {
		                def.value.properties.push(make_node(AST_ObjectKeyVal, node, {
		                    key: prop,
		                    value: node.right
		                }));
		            } else {
		                p.value = new AST_Sequence({
		                    start: p.start,
		                    expressions: [p.value.clone(), node.right.clone()],
		                    end: p.end
		                });
		            }
		            exprs.shift();
		            trimmed = true;
		        } while (exprs.length);
		        return trimmed && exprs;
		    }

		    function join_consecutive_vars(statements) {
		        var defs;
		        for (var i = 0, j = -1, len = statements.length; i < len; i++) {
		            var stat = statements[i];
		            var prev = statements[j];
		            if (stat instanceof AST_Definitions) {
		                if (prev && prev.TYPE == stat.TYPE) {
		                    prev.definitions = prev.definitions.concat(stat.definitions);
		                    CHANGED = true;
		                } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {
		                    defs.definitions = defs.definitions.concat(stat.definitions);
		                    CHANGED = true;
		                } else {
		                    statements[++j] = stat;
		                    defs = stat;
		                }
		            } else if (stat instanceof AST_Exit) {
		                stat.value = extract_object_assignments(stat.value);
		            } else if (stat instanceof AST_For) {
		                var exprs = join_object_assignments(prev, stat.init);
		                if (exprs) {
		                    CHANGED = true;
		                    stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;
		                    statements[++j] = stat;
		                } else if (
		                    prev instanceof AST_Var
		                    && (!stat.init || stat.init.TYPE == prev.TYPE)
		                ) {
		                    if (stat.init) {
		                        prev.definitions = prev.definitions.concat(stat.init.definitions);
		                    }
		                    stat.init = prev;
		                    statements[j] = stat;
		                    CHANGED = true;
		                } else if (
		                    defs instanceof AST_Var
		                    && stat.init instanceof AST_Var
		                    && declarations_only(stat.init)
		                ) {
		                    defs.definitions = defs.definitions.concat(stat.init.definitions);
		                    stat.init = null;
		                    statements[++j] = stat;
		                    CHANGED = true;
		                } else {
		                    statements[++j] = stat;
		                }
		            } else if (stat instanceof AST_ForIn) {
		                stat.object = extract_object_assignments(stat.object);
		            } else if (stat instanceof AST_If) {
		                stat.condition = extract_object_assignments(stat.condition);
		            } else if (stat instanceof AST_SimpleStatement) {
		                var exprs = join_object_assignments(prev, stat.body);
		                if (exprs) {
		                    CHANGED = true;
		                    if (!exprs.length)
		                        continue;
		                    stat.body = make_sequence(stat.body, exprs);
		                }
		                statements[++j] = stat;
		            } else if (stat instanceof AST_Switch) {
		                stat.expression = extract_object_assignments(stat.expression);
		            } else if (stat instanceof AST_With) {
		                stat.expression = extract_object_assignments(stat.expression);
		            } else {
		                statements[++j] = stat;
		            }
		        }
		        statements.length = j + 1;

		        function extract_object_assignments(value) {
		            statements[++j] = stat;
		            var exprs = join_object_assignments(prev, value);
		            if (exprs) {
		                CHANGED = true;
		                if (exprs.length) {
		                    return make_sequence(value, exprs);
		                } else if (value instanceof AST_Sequence) {
		                    return value.tail_node().left;
		                } else {
		                    return value.left;
		                }
		            }
		            return value;
		        }
		    }
		}

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		/**
		 * Module that contains the inlining logic.
		 *
		 * @module
		 *
		 * The stars of the show are `inline_into_symbolref` and `inline_into_call`.
		 */

		function within_array_or_object_literal(compressor) {
		    var node, level = 0;
		    while (node = compressor.parent(level++)) {
		        if (node instanceof AST_Statement) return false;
		        if (node instanceof AST_Array
		            || node instanceof AST_ObjectKeyVal
		            || node instanceof AST_Object) {
		            return true;
		        }
		    }
		    return false;
		}

		function scope_encloses_variables_in_this_scope(scope, pulled_scope) {
		    for (const enclosed of pulled_scope.enclosed) {
		        if (pulled_scope.variables.has(enclosed.name)) {
		            continue;
		        }
		        const looked_up = scope.find_variable(enclosed.name);
		        if (looked_up) {
		            if (looked_up === enclosed) continue;
		            return true;
		        }
		    }
		    return false;
		}

		function inline_into_symbolref(self, compressor) {
		    const parent = compressor.parent();

		    const def = self.definition();
		    const nearest_scope = compressor.find_scope();
		    if (compressor.top_retain && def.global && compressor.top_retain(def)) {
		        def.fixed = false;
		        def.single_use = false;
		        return self;
		    }

		    let fixed = self.fixed_value();
		    let single_use = def.single_use
		        && !(parent instanceof AST_Call
		            && (parent.is_callee_pure(compressor))
		                || has_annotation(parent, _NOINLINE))
		        && !(parent instanceof AST_Export
		            && fixed instanceof AST_Lambda
		            && fixed.name);

		    if (single_use && fixed instanceof AST_Node) {
		        single_use =
		            !fixed.has_side_effects(compressor)
		            && !fixed.may_throw(compressor);
		    }

		    if (fixed instanceof AST_Class && def.scope !== self.scope) {
		        return self;
		    }

		    if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
		        if (retain_top_func(fixed, compressor)) {
		            single_use = false;
		        } else if (def.scope !== self.scope
		            && (def.escaped == 1
		                || has_flag(fixed, INLINED)
		                || within_array_or_object_literal(compressor)
		                || !compressor.option("reduce_funcs"))) {
		            single_use = false;
		        } else if (is_recursive_ref(compressor, def)) {
		            single_use = false;
		        } else if (def.scope !== self.scope || def.orig[0] instanceof AST_SymbolFunarg) {
		            single_use = fixed.is_constant_expression(self.scope);
		            if (single_use == "f") {
		                var scope = self.scope;
		                do {
		                    if (scope instanceof AST_Defun || is_func_expr(scope)) {
		                        set_flag(scope, INLINED);
		                    }
		                } while (scope = scope.parent_scope);
		            }
		        }
		    }

		    if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
		        single_use =
		            def.scope === self.scope
		                && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)
		            || parent instanceof AST_Call
		                && parent.expression === self
		                && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)
		                && !(fixed.name && fixed.name.definition().recursive_refs > 0);
		    }

		    if (single_use && fixed) {
		        if (fixed instanceof AST_DefClass) {
		            set_flag(fixed, SQUEEZED);
		            fixed = make_node(AST_ClassExpression, fixed, fixed);
		        }
		        if (fixed instanceof AST_Defun) {
		            set_flag(fixed, SQUEEZED);
		            fixed = make_node(AST_Function, fixed, fixed);
		        }
		        if (def.recursive_refs > 0 && fixed.name instanceof AST_SymbolDefun) {
		            const defun_def = fixed.name.definition();
		            let lambda_def = fixed.variables.get(fixed.name.name);
		            let name = lambda_def && lambda_def.orig[0];
		            if (!(name instanceof AST_SymbolLambda)) {
		                name = make_node(AST_SymbolLambda, fixed.name, fixed.name);
		                name.scope = fixed;
		                fixed.name = name;
		                lambda_def = fixed.def_function(name);
		            }
		            walk(fixed, node => {
		                if (node instanceof AST_SymbolRef && node.definition() === defun_def) {
		                    node.thedef = lambda_def;
		                    lambda_def.references.push(node);
		                }
		            });
		        }
		        if (
		            (fixed instanceof AST_Lambda || fixed instanceof AST_Class)
		            && fixed.parent_scope !== nearest_scope
		        ) {
		            fixed = fixed.clone(true, compressor.get_toplevel());

		            nearest_scope.add_child_scope(fixed);
		        }
		        return fixed.optimize(compressor);
		    }

		    // multiple uses
		    if (fixed) {
		        let replace;

		        if (fixed instanceof AST_This) {
		            if (!(def.orig[0] instanceof AST_SymbolFunarg)
		                && def.references.every((ref) =>
		                    def.scope === ref.scope
		                )) {
		                replace = fixed;
		            }
		        } else {
		            var ev = fixed.evaluate(compressor);
		            if (
		                ev !== fixed
		                && (compressor.option("unsafe_regexp") || !(ev instanceof RegExp))
		            ) {
		                replace = make_node_from_constant(ev, fixed);
		            }
		        }

		        if (replace) {
		            const name_length = self.size(compressor);
		            const replace_size = replace.size(compressor);

		            let overhead = 0;
		            if (compressor.option("unused") && !compressor.exposed(def)) {
		                overhead =
		                    (name_length + 2 + replace_size) /
		                    (def.references.length - def.assignments);
		            }

		            if (replace_size <= name_length + overhead) {
		                return replace;
		            }
		        }
		    }

		    return self;
		}

		function inline_into_call(self, compressor) {
		    var exp = self.expression;
		    var fn = exp;
		    var simple_args = self.args.every((arg) => !(arg instanceof AST_Expansion));

		    if (compressor.option("reduce_vars")
		        && fn instanceof AST_SymbolRef
		        && !has_annotation(self, _NOINLINE)
		    ) {
		        const fixed = fn.fixed_value();

		        if (
		            retain_top_func(fixed, compressor)
		            || !compressor.toplevel.funcs && exp.definition().global
		        ) {
		            return self;
		        }

		        fn = fixed;
		    }

		    var is_func = fn instanceof AST_Lambda;

		    var stat = is_func && fn.body[0];
		    var is_regular_func = is_func && !fn.is_generator && !fn.async;
		    var can_inline = is_regular_func && compressor.option("inline") && !self.is_callee_pure(compressor);
		    if (can_inline && stat instanceof AST_Return) {
		        let returned = stat.value;
		        if (!returned || returned.is_constant_expression()) {
		            if (returned) {
		                returned = returned.clone(true);
		            } else {
		                returned = make_node(AST_Undefined, self);
		            }
		            const args = self.args.concat(returned);
		            return make_sequence(self, args).optimize(compressor);
		        }

		        // optimize identity function
		        if (
		            fn.argnames.length === 1
		            && (fn.argnames[0] instanceof AST_SymbolFunarg)
		            && self.args.length < 2
		            && !(self.args[0] instanceof AST_Expansion)
		            && returned instanceof AST_SymbolRef
		            && returned.name === fn.argnames[0].name
		        ) {
		            const replacement =
		                (self.args[0] || make_node(AST_Undefined)).optimize(compressor);

		            let parent;
		            if (
		                replacement instanceof AST_PropAccess
		                && (parent = compressor.parent()) instanceof AST_Call
		                && parent.expression === self
		            ) {
		                // identity function was being used to remove `this`, like in
		                //
		                // id(bag.no_this)(...)
		                //
		                // Replace with a larger but more effish (0, bag.no_this) wrapper.

		                return make_sequence(self, [
		                    make_node(AST_Number, self, { value: 0 }),
		                    replacement
		                ]);
		            }
		            // replace call with first argument or undefined if none passed
		            return replacement;
		        }
		    }

		    if (can_inline) {
		        var scope, in_loop, level = -1;
		        let def;
		        let returned_value;
		        let nearest_scope;
		        if (simple_args
		            && !fn.uses_arguments
		            && !(compressor.parent() instanceof AST_Class)
		            && !(fn.name && fn instanceof AST_Function)
		            && (returned_value = can_flatten_body(stat))
		            && (exp === fn
		                || has_annotation(self, _INLINE)
		                || compressor.option("unused")
		                    && (def = exp.definition()).references.length == 1
		                    && !is_recursive_ref(compressor, def)
		                    && fn.is_constant_expression(exp.scope))
		            && !has_annotation(self, _PURE | _NOINLINE)
		            && !fn.contains_this()
		            && can_inject_symbols()
		            && (nearest_scope = compressor.find_scope())
		            && !scope_encloses_variables_in_this_scope(nearest_scope, fn)
		            && !(function in_default_assign() {
		                    // Due to the fact function parameters have their own scope
		                    // which can't use `var something` in the function body within,
		                    // we simply don't inline into DefaultAssign.
		                    let i = 0;
		                    let p;
		                    while ((p = compressor.parent(i++))) {
		                        if (p instanceof AST_DefaultAssign) return true;
		                        if (p instanceof AST_Block) break;
		                    }
		                    return false;
		                })()
		            && !(scope instanceof AST_Class)
		        ) {
		            set_flag(fn, SQUEEZED);
		            nearest_scope.add_child_scope(fn);
		            return make_sequence(self, flatten_fn(returned_value)).optimize(compressor);
		        }
		    }

		    if (can_inline && has_annotation(self, _INLINE)) {
		        set_flag(fn, SQUEEZED);
		        fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);
		        fn = fn.clone(true);
		        fn.figure_out_scope({}, {
		            parent_scope: compressor.find_scope(),
		            toplevel: compressor.get_toplevel()
		        });

		        return make_node(AST_Call, self, {
		            expression: fn,
		            args: self.args,
		        }).optimize(compressor);
		    }

		    const can_drop_this_call = is_regular_func && compressor.option("side_effects") && fn.body.every(is_empty);
		    if (can_drop_this_call) {
		        var args = self.args.concat(make_node(AST_Undefined, self));
		        return make_sequence(self, args).optimize(compressor);
		    }

		    if (compressor.option("negate_iife")
		        && compressor.parent() instanceof AST_SimpleStatement
		        && is_iife_call(self)) {
		        return self.negate(compressor, true);
		    }

		    var ev = self.evaluate(compressor);
		    if (ev !== self) {
		        ev = make_node_from_constant(ev, self).optimize(compressor);
		        return best_of(compressor, ev, self);
		    }

		    return self;

		    function return_value(stat) {
		        if (!stat) return make_node(AST_Undefined, self);
		        if (stat instanceof AST_Return) {
		            if (!stat.value) return make_node(AST_Undefined, self);
		            return stat.value.clone(true);
		        }
		        if (stat instanceof AST_SimpleStatement) {
		            return make_node(AST_UnaryPrefix, stat, {
		                operator: "void",
		                expression: stat.body.clone(true)
		            });
		        }
		    }

		    function can_flatten_body(stat) {
		        var body = fn.body;
		        var len = body.length;
		        if (compressor.option("inline") < 3) {
		            return len == 1 && return_value(stat);
		        }
		        stat = null;
		        for (var i = 0; i < len; i++) {
		            var line = body[i];
		            if (line instanceof AST_Var) {
		                if (stat && !line.definitions.every((var_def) =>
		                    !var_def.value
		                )) {
		                    return false;
		                }
		            } else if (stat) {
		                return false;
		            } else if (!(line instanceof AST_EmptyStatement)) {
		                stat = line;
		            }
		        }
		        return return_value(stat);
		    }

		    function can_inject_args(block_scoped, safe_to_inject) {
		        for (var i = 0, len = fn.argnames.length; i < len; i++) {
		            var arg = fn.argnames[i];
		            if (arg instanceof AST_DefaultAssign) {
		                if (has_flag(arg.left, UNUSED)) continue;
		                return false;
		            }
		            if (arg instanceof AST_Destructuring) return false;
		            if (arg instanceof AST_Expansion) {
		                if (has_flag(arg.expression, UNUSED)) continue;
		                return false;
		            }
		            if (has_flag(arg, UNUSED)) continue;
		            if (!safe_to_inject
		                || block_scoped.has(arg.name)
		                || identifier_atom.has(arg.name)
		                || scope.conflicting_def(arg.name)) {
		                return false;
		            }
		            if (in_loop) in_loop.push(arg.definition());
		        }
		        return true;
		    }

		    function can_inject_vars(block_scoped, safe_to_inject) {
		        var len = fn.body.length;
		        for (var i = 0; i < len; i++) {
		            var stat = fn.body[i];
		            if (!(stat instanceof AST_Var)) continue;
		            if (!safe_to_inject) return false;
		            for (var j = stat.definitions.length; --j >= 0;) {
		                var name = stat.definitions[j].name;
		                if (name instanceof AST_Destructuring
		                    || block_scoped.has(name.name)
		                    || identifier_atom.has(name.name)
		                    || scope.conflicting_def(name.name)) {
		                    return false;
		                }
		                if (in_loop) in_loop.push(name.definition());
		            }
		        }
		        return true;
		    }

		    function can_inject_symbols() {
		        var block_scoped = new Set();
		        do {
		            scope = compressor.parent(++level);
		            if (scope.is_block_scope() && scope.block_scope) {
		                // TODO this is sometimes undefined during compression.
		                // But it should always have a value!
		                scope.block_scope.variables.forEach(function (variable) {
		                    block_scoped.add(variable.name);
		                });
		            }
		            if (scope instanceof AST_Catch) {
		                // TODO can we delete? AST_Catch is a block scope.
		                if (scope.argname) {
		                    block_scoped.add(scope.argname.name);
		                }
		            } else if (scope instanceof AST_IterationStatement) {
		                in_loop = [];
		            } else if (scope instanceof AST_SymbolRef) {
		                if (scope.fixed_value() instanceof AST_Scope) return false;
		            }
		        } while (!(scope instanceof AST_Scope));

		        var safe_to_inject = !(scope instanceof AST_Toplevel) || compressor.toplevel.vars;
		        var inline = compressor.option("inline");
		        if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject)) return false;
		        if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject)) return false;
		        return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);
		    }

		    function append_var(decls, expressions, name, value) {
		        var def = name.definition();

		        // Name already exists, only when a function argument had the same name
		        const already_appended = scope.variables.has(name.name);
		        if (!already_appended) {
		            scope.variables.set(name.name, def);
		            scope.enclosed.push(def);
		            decls.push(make_node(AST_VarDef, name, {
		                name: name,
		                value: null
		            }));
		        }

		        var sym = make_node(AST_SymbolRef, name, name);
		        def.references.push(sym);
		        if (value) expressions.push(make_node(AST_Assign, self, {
		            operator: "=",
		            logical: false,
		            left: sym,
		            right: value.clone()
		        }));
		    }

		    function flatten_args(decls, expressions) {
		        var len = fn.argnames.length;
		        for (var i = self.args.length; --i >= len;) {
		            expressions.push(self.args[i]);
		        }
		        for (i = len; --i >= 0;) {
		            var name = fn.argnames[i];
		            var value = self.args[i];
		            if (has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {
		                if (value) expressions.push(value);
		            } else {
		                var symbol = make_node(AST_SymbolVar, name, name);
		                name.definition().orig.push(symbol);
		                if (!value && in_loop) value = make_node(AST_Undefined, self);
		                append_var(decls, expressions, symbol, value);
		            }
		        }
		        decls.reverse();
		        expressions.reverse();
		    }

		    function flatten_vars(decls, expressions) {
		        var pos = expressions.length;
		        for (var i = 0, lines = fn.body.length; i < lines; i++) {
		            var stat = fn.body[i];
		            if (!(stat instanceof AST_Var)) continue;
		            for (var j = 0, defs = stat.definitions.length; j < defs; j++) {
		                var var_def = stat.definitions[j];
		                var name = var_def.name;
		                append_var(decls, expressions, name, var_def.value);
		                if (in_loop && fn.argnames.every((argname) =>
		                    argname.name != name.name
		                )) {
		                    var def = fn.variables.get(name.name);
		                    var sym = make_node(AST_SymbolRef, name, name);
		                    def.references.push(sym);
		                    expressions.splice(pos++, 0, make_node(AST_Assign, var_def, {
		                        operator: "=",
		                        logical: false,
		                        left: sym,
		                        right: make_node(AST_Undefined, name)
		                    }));
		                }
		            }
		        }
		    }

		    function flatten_fn(returned_value) {
		        var decls = [];
		        var expressions = [];
		        flatten_args(decls, expressions);
		        flatten_vars(decls, expressions);
		        expressions.push(returned_value);

		        if (decls.length) {
		            const i = scope.body.indexOf(compressor.parent(level - 1)) + 1;
		            scope.body.splice(i, 0, make_node(AST_Var, fn, {
		                definitions: decls
		            }));
		        }

		        return expressions.map(exp => exp.clone(true));
		    }
		}

		(function(def_find_defs) {
		    function to_node(value, orig) {
		        if (value instanceof AST_Node) {
		            if (!(value instanceof AST_Constant)) {
		                // Value may be a function, an array including functions and even a complex assign / block expression,
		                // so it should never be shared in different places.
		                // Otherwise wrong information may be used in the compression phase
		                value = value.clone(true);
		            }
		            return make_node(value.CTOR, orig, value);
		        }
		        if (Array.isArray(value)) return make_node(AST_Array, orig, {
		            elements: value.map(function(value) {
		                return to_node(value, orig);
		            })
		        });
		        if (value && typeof value == "object") {
		            var props = [];
		            for (var key in value) if (HOP(value, key)) {
		                props.push(make_node(AST_ObjectKeyVal, orig, {
		                    key: key,
		                    value: to_node(value[key], orig)
		                }));
		            }
		            return make_node(AST_Object, orig, {
		                properties: props
		            });
		        }
		        return make_node_from_constant(value, orig);
		    }

		    AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
		        if (!compressor.option("global_defs")) return this;
		        this.figure_out_scope({ ie8: compressor.option("ie8") });
		        return this.transform(new TreeTransformer(function(node) {
		            var def = node._find_defs(compressor, "");
		            if (!def) return;
		            var level = 0, child = node, parent;
		            while (parent = this.parent(level++)) {
		                if (!(parent instanceof AST_PropAccess)) break;
		                if (parent.expression !== child) break;
		                child = parent;
		            }
		            if (is_lhs(child, parent)) {
		                return;
		            }
		            return def;
		        }));
		    });
		    def_find_defs(AST_Node, noop);
		    def_find_defs(AST_Chain, function(compressor, suffix) {
		        return this.expression._find_defs(compressor, suffix);
		    });
		    def_find_defs(AST_Dot, function(compressor, suffix) {
		        return this.expression._find_defs(compressor, "." + this.property + suffix);
		    });
		    def_find_defs(AST_SymbolDeclaration, function() {
		        if (!this.global()) return;
		    });
		    def_find_defs(AST_SymbolRef, function(compressor, suffix) {
		        if (!this.global()) return;
		        var defines = compressor.option("global_defs");
		        var name = this.name + suffix;
		        if (HOP(defines, name)) return to_node(defines[name], this);
		    });
		    def_find_defs(AST_ImportMeta, function(compressor, suffix) {
		        var defines = compressor.option("global_defs");
		        var name = "import.meta" + suffix;
		        if (HOP(defines, name)) return to_node(defines[name], this);
		    });
		})(function(node, func) {
		    node.DEFMETHOD("_find_defs", func);
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		class Compressor extends TreeWalker {
		    constructor(options, { false_by_default = false, mangle_options = false }) {
		        super();
		        if (options.defaults !== undefined && !options.defaults) false_by_default = true;
		        this.options = defaults(options, {
		            arguments     : false,
		            arrows        : !false_by_default,
		            booleans      : !false_by_default,
		            booleans_as_integers : false,
		            collapse_vars : !false_by_default,
		            comparisons   : !false_by_default,
		            computed_props: !false_by_default,
		            conditionals  : !false_by_default,
		            dead_code     : !false_by_default,
		            defaults      : true,
		            directives    : !false_by_default,
		            drop_console  : false,
		            drop_debugger : !false_by_default,
		            ecma          : 5,
		            evaluate      : !false_by_default,
		            expression    : false,
		            global_defs   : false,
		            hoist_funs    : false,
		            hoist_props   : !false_by_default,
		            hoist_vars    : false,
		            ie8           : false,
		            if_return     : !false_by_default,
		            inline        : !false_by_default,
		            join_vars     : !false_by_default,
		            keep_classnames: false,
		            keep_fargs    : true,
		            keep_fnames   : false,
		            keep_infinity : false,
		            lhs_constants : !false_by_default,
		            loops         : !false_by_default,
		            module        : false,
		            negate_iife   : !false_by_default,
		            passes        : 1,
		            properties    : !false_by_default,
		            pure_getters  : !false_by_default && "strict",
		            pure_funcs    : null,
		            reduce_funcs  : !false_by_default,
		            reduce_vars   : !false_by_default,
		            sequences     : !false_by_default,
		            side_effects  : !false_by_default,
		            switches      : !false_by_default,
		            top_retain    : null,
		            toplevel      : !!(options && options["top_retain"]),
		            typeofs       : !false_by_default,
		            unsafe        : false,
		            unsafe_arrows : false,
		            unsafe_comps  : false,
		            unsafe_Function: false,
		            unsafe_math   : false,
		            unsafe_symbols: false,
		            unsafe_methods: false,
		            unsafe_proto  : false,
		            unsafe_regexp : false,
		            unsafe_undefined: false,
		            unused        : !false_by_default,
		            warnings      : false  // legacy
		        }, true);
		        var global_defs = this.options["global_defs"];
		        if (typeof global_defs == "object") for (var key in global_defs) {
		            if (key[0] === "@" && HOP(global_defs, key)) {
		                global_defs[key.slice(1)] = parse(global_defs[key], {
		                    expression: true
		                });
		            }
		        }
		        if (this.options["inline"] === true) this.options["inline"] = 3;
		        var pure_funcs = this.options["pure_funcs"];
		        if (typeof pure_funcs == "function") {
		            this.pure_funcs = pure_funcs;
		        } else {
		            this.pure_funcs = pure_funcs ? function(node) {
		                return !pure_funcs.includes(node.expression.print_to_string());
		            } : return_true;
		        }
		        var top_retain = this.options["top_retain"];
		        if (top_retain instanceof RegExp) {
		            this.top_retain = function(def) {
		                return top_retain.test(def.name);
		            };
		        } else if (typeof top_retain == "function") {
		            this.top_retain = top_retain;
		        } else if (top_retain) {
		            if (typeof top_retain == "string") {
		                top_retain = top_retain.split(/,/);
		            }
		            this.top_retain = function(def) {
		                return top_retain.includes(def.name);
		            };
		        }
		        if (this.options["module"]) {
		            this.directives["use strict"] = true;
		            this.options["toplevel"] = true;
		        }
		        var toplevel = this.options["toplevel"];
		        this.toplevel = typeof toplevel == "string" ? {
		            funcs: /funcs/.test(toplevel),
		            vars: /vars/.test(toplevel)
		        } : {
		            funcs: toplevel,
		            vars: toplevel
		        };
		        var sequences = this.options["sequences"];
		        this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
		        this.evaluated_regexps = new Map();
		        this._toplevel = undefined;
		        this.mangle_options = mangle_options
		            ? format_mangler_options(mangle_options)
		            : mangle_options;
		    }

		    option(key) {
		        return this.options[key];
		    }

		    exposed(def) {
		        if (def.export) return true;
		        if (def.global) for (var i = 0, len = def.orig.length; i < len; i++)
		            if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? "funcs" : "vars"])
		                return true;
		        return false;
		    }

		    in_boolean_context() {
		        if (!this.option("booleans")) return false;
		        var self = this.self();
		        for (var i = 0, p; p = this.parent(i); i++) {
		            if (p instanceof AST_SimpleStatement
		                || p instanceof AST_Conditional && p.condition === self
		                || p instanceof AST_DWLoop && p.condition === self
		                || p instanceof AST_For && p.condition === self
		                || p instanceof AST_If && p.condition === self
		                || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self) {
		                return true;
		            }
		            if (
		                p instanceof AST_Binary
		                    && (
		                        p.operator == "&&"
		                        || p.operator == "||"
		                        || p.operator == "??"
		                    )
		                || p instanceof AST_Conditional
		                || p.tail_node() === self
		            ) {
		                self = p;
		            } else {
		                return false;
		            }
		        }
		    }

		    get_toplevel() {
		        return this._toplevel;
		    }

		    compress(toplevel) {
		        toplevel = toplevel.resolve_defines(this);
		        this._toplevel = toplevel;
		        if (this.option("expression")) {
		            this._toplevel.process_expression(true);
		        }
		        var passes = +this.options.passes || 1;
		        var min_count = 1 / 0;
		        var stopping = false;
		        var nth_identifier = this.mangle_options && this.mangle_options.nth_identifier || base54;
		        var mangle = { ie8: this.option("ie8"), nth_identifier: nth_identifier };
		        for (var pass = 0; pass < passes; pass++) {
		            this._toplevel.figure_out_scope(mangle);
		            if (pass === 0 && this.option("drop_console")) {
		                // must be run before reduce_vars and compress pass
		                this._toplevel = this._toplevel.drop_console(this.option("drop_console"));
		            }
		            if (pass > 0 || this.option("reduce_vars")) {
		                this._toplevel.reset_opt_flags(this);
		            }
		            this._toplevel = this._toplevel.transform(this);
		            if (passes > 1) {
		                let count = 0;
		                walk(this._toplevel, () => { count++; });
		                if (count < min_count) {
		                    min_count = count;
		                    stopping = false;
		                } else if (stopping) {
		                    break;
		                } else {
		                    stopping = true;
		                }
		            }
		        }
		        if (this.option("expression")) {
		            this._toplevel.process_expression(false);
		        }
		        toplevel = this._toplevel;
		        this._toplevel = undefined;
		        return toplevel;
		    }

		    before(node, descend) {
		        if (has_flag(node, SQUEEZED)) return node;
		        var was_scope = false;
		        if (node instanceof AST_Scope) {
		            node = node.hoist_properties(this);
		            node = node.hoist_declarations(this);
		            was_scope = true;
		        }
		        // Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()
		        // would call AST_Node.transform() if a different instance of AST_Node is
		        // produced after def_optimize().
		        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.
		        // Migrate and defer all children's AST_Node.transform() to below, which
		        // will now happen after this parent AST_Node has been properly substituted
		        // thus gives a consistent AST snapshot.
		        descend(node, this);
		        // Existing code relies on how AST_Node.optimize() worked, and omitting the
		        // following replacement call would result in degraded efficiency of both
		        // output and performance.
		        descend(node, this);
		        var opt = node.optimize(this);
		        if (was_scope && opt instanceof AST_Scope) {
		            opt.drop_unused(this);
		            descend(opt, this);
		        }
		        if (opt === node) set_flag(opt, SQUEEZED);
		        return opt;
		    }

		    /** Alternative to plain is_lhs() which doesn't work within .optimize() */
		    is_lhs() {
		        const self = this.stack[this.stack.length - 1];
		        const parent = this.stack[this.stack.length - 2];
		        return is_lhs(self, parent);
		    }
		}

		function def_optimize(node, optimizer) {
		    node.DEFMETHOD("optimize", function(compressor) {
		        var self = this;
		        if (has_flag(self, OPTIMIZED)) return self;
		        if (compressor.has_directive("use asm")) return self;
		        var opt = optimizer(self, compressor);
		        set_flag(opt, OPTIMIZED);
		        return opt;
		    });
		}

		def_optimize(AST_Node, function(self) {
		    return self;
		});

		AST_Toplevel.DEFMETHOD("drop_console", function(options) {
		    var isArray = Array.isArray(options);

		    return this.transform(new TreeTransformer(function(self) {
		        if (self.TYPE !== "Call") {
		            return;
		        }

		        var exp = self.expression;

		        if (!(exp instanceof AST_PropAccess)) {
		            return;
		        }

		        if (isArray && options.indexOf(exp.property) === -1) {
		            return;
		        }

		        var name = exp.expression;
		        while (name.expression) {
		            name = name.expression;
		        }
		        if (is_undeclared_ref(name) && name.name == "console") {
		            return make_node(AST_Undefined, self);
		        }
		    }));
		});

		AST_Node.DEFMETHOD("equivalent_to", function(node) {
		    return equivalent_to(this, node);
		});

		AST_Scope.DEFMETHOD("process_expression", function(insert, compressor) {
		    var self = this;
		    var tt = new TreeTransformer(function(node) {
		        if (insert && node instanceof AST_SimpleStatement) {
		            return make_node(AST_Return, node, {
		                value: node.body
		            });
		        }
		        if (!insert && node instanceof AST_Return) {
		            if (compressor) {
		                var value = node.value && node.value.drop_side_effect_free(compressor, true);
		                return value
		                    ? make_node(AST_SimpleStatement, node, { body: value })
		                    : make_node(AST_EmptyStatement, node);
		            }
		            return make_node(AST_SimpleStatement, node, {
		                body: node.value || make_node(AST_UnaryPrefix, node, {
		                    operator: "void",
		                    expression: make_node(AST_Number, node, {
		                        value: 0
		                    })
		                })
		            });
		        }
		        if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self) {
		            return node;
		        }
		        if (node instanceof AST_Block) {
		            var index = node.body.length - 1;
		            if (index >= 0) {
		                node.body[index] = node.body[index].transform(tt);
		            }
		        } else if (node instanceof AST_If) {
		            node.body = node.body.transform(tt);
		            if (node.alternative) {
		                node.alternative = node.alternative.transform(tt);
		            }
		        } else if (node instanceof AST_With) {
		            node.body = node.body.transform(tt);
		        }
		        return node;
		    });
		    self.transform(tt);
		});

		AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
		    const self = this;
		    const reduce_vars = compressor.option("reduce_vars");

		    const preparation = new TreeWalker(function(node, descend) {
		        clear_flag(node, CLEAR_BETWEEN_PASSES);
		        if (reduce_vars) {
		            if (compressor.top_retain
		                && node instanceof AST_Defun  // Only functions are retained
		                && preparation.parent() === self
		            ) {
		                set_flag(node, TOP);
		            }
		            return node.reduce_vars(preparation, descend, compressor);
		        }
		    });
		    // Stack of look-up tables to keep track of whether a `SymbolDef` has been
		    // properly assigned before use:
		    // - `push()` & `pop()` when visiting conditional branches
		    preparation.safe_ids = Object.create(null);
		    preparation.in_loop = null;
		    preparation.loop_ids = new Map();
		    preparation.defs_to_safe_ids = new Map();
		    self.walk(preparation);
		});

		AST_Symbol.DEFMETHOD("fixed_value", function() {
		    var fixed = this.thedef.fixed;
		    if (!fixed || fixed instanceof AST_Node) return fixed;
		    return fixed();
		});

		AST_SymbolRef.DEFMETHOD("is_immutable", function() {
		    var orig = this.definition().orig;
		    return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;
		});

		function find_variable(compressor, name) {
		    var scope, i = 0;
		    while (scope = compressor.parent(i++)) {
		        if (scope instanceof AST_Scope) break;
		        if (scope instanceof AST_Catch && scope.argname) {
		            scope = scope.argname.definition().scope;
		            break;
		        }
		    }
		    return scope.find_variable(name);
		}

		var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");
		AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
		    return !this.definition().undeclared
		        || compressor.option("unsafe") && global_names.has(this.name);
		});

		/* -----[ optimizers ]----- */

		var directives = new Set(["use asm", "use strict"]);
		def_optimize(AST_Directive, function(self, compressor) {
		    if (compressor.option("directives")
		        && (!directives.has(self.value) || compressor.has_directive(self.value) !== self)) {
		        return make_node(AST_EmptyStatement, self);
		    }
		    return self;
		});

		def_optimize(AST_Debugger, function(self, compressor) {
		    if (compressor.option("drop_debugger"))
		        return make_node(AST_EmptyStatement, self);
		    return self;
		});

		def_optimize(AST_LabeledStatement, function(self, compressor) {
		    if (self.body instanceof AST_Break
		        && compressor.loopcontrol_target(self.body) === self.body) {
		        return make_node(AST_EmptyStatement, self);
		    }
		    return self.label.references.length == 0 ? self.body : self;
		});

		def_optimize(AST_Block, function(self, compressor) {
		    tighten_body(self.body, compressor);
		    return self;
		});

		function can_be_extracted_from_if_block(node) {
		    return !(
		        node instanceof AST_Const
		        || node instanceof AST_Let
		        || node instanceof AST_Class
		    );
		}

		def_optimize(AST_BlockStatement, function(self, compressor) {
		    tighten_body(self.body, compressor);
		    switch (self.body.length) {
		      case 1:
		        if (!compressor.has_directive("use strict")
		            && compressor.parent() instanceof AST_If
		            && can_be_extracted_from_if_block(self.body[0])
		            || can_be_evicted_from_block(self.body[0])) {
		            return self.body[0];
		        }
		        break;
		      case 0: return make_node(AST_EmptyStatement, self);
		    }
		    return self;
		});

		function opt_AST_Lambda(self, compressor) {
		    tighten_body(self.body, compressor);
		    if (compressor.option("side_effects")
		        && self.body.length == 1
		        && self.body[0] === compressor.has_directive("use strict")) {
		        self.body.length = 0;
		    }
		    return self;
		}
		def_optimize(AST_Lambda, opt_AST_Lambda);

		AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
		    var self = this;
		    if (compressor.has_directive("use asm")) return self;

		    var hoist_funs = compressor.option("hoist_funs");
		    var hoist_vars = compressor.option("hoist_vars");

		    if (hoist_funs || hoist_vars) {
		        var dirs = [];
		        var hoisted = [];
		        var vars = new Map(), vars_found = 0, var_decl = 0;
		        // let's count var_decl first, we seem to waste a lot of
		        // space if we hoist `var` when there's only one.
		        walk(self, node => {
		            if (node instanceof AST_Scope && node !== self)
		                return true;
		            if (node instanceof AST_Var) {
		                ++var_decl;
		                return true;
		            }
		        });
		        hoist_vars = hoist_vars && var_decl > 1;
		        var tt = new TreeTransformer(
		            function before(node) {
		                if (node !== self) {
		                    if (node instanceof AST_Directive) {
		                        dirs.push(node);
		                        return make_node(AST_EmptyStatement, node);
		                    }
		                    if (hoist_funs && node instanceof AST_Defun
		                        && !(tt.parent() instanceof AST_Export)
		                        && tt.parent() === self) {
		                        hoisted.push(node);
		                        return make_node(AST_EmptyStatement, node);
		                    }
		                    if (
		                        hoist_vars
		                        && node instanceof AST_Var
		                        && !node.definitions.some(def => def.name instanceof AST_Destructuring)
		                    ) {
		                        node.definitions.forEach(function(def) {
		                            vars.set(def.name.name, def);
		                            ++vars_found;
		                        });
		                        var seq = node.to_assignments(compressor);
		                        var p = tt.parent();
		                        if (p instanceof AST_ForIn && p.init === node) {
		                            if (seq == null) {
		                                var def = node.definitions[0].name;
		                                return make_node(AST_SymbolRef, def, def);
		                            }
		                            return seq;
		                        }
		                        if (p instanceof AST_For && p.init === node) {
		                            return seq;
		                        }
		                        if (!seq) return make_node(AST_EmptyStatement, node);
		                        return make_node(AST_SimpleStatement, node, {
		                            body: seq
		                        });
		                    }
		                    if (node instanceof AST_Scope)
		                        return node; // to avoid descending in nested scopes
		                }
		            }
		        );
		        self = self.transform(tt);
		        if (vars_found > 0) {
		            // collect only vars which don't show up in self's arguments list
		            var defs = [];
		            const is_lambda = self instanceof AST_Lambda;
		            const args_as_names = is_lambda ? self.args_as_names() : null;
		            vars.forEach((def, name) => {
		                if (is_lambda && args_as_names.some((x) => x.name === def.name.name)) {
		                    vars.delete(name);
		                } else {
		                    def = def.clone();
		                    def.value = null;
		                    defs.push(def);
		                    vars.set(name, def);
		                }
		            });
		            if (defs.length > 0) {
		                // try to merge in assignments
		                for (var i = 0; i < self.body.length;) {
		                    if (self.body[i] instanceof AST_SimpleStatement) {
		                        var expr = self.body[i].body, sym, assign;
		                        if (expr instanceof AST_Assign
		                            && expr.operator == "="
		                            && (sym = expr.left) instanceof AST_Symbol
		                            && vars.has(sym.name)
		                        ) {
		                            var def = vars.get(sym.name);
		                            if (def.value) break;
		                            def.value = expr.right;
		                            remove(defs, def);
		                            defs.push(def);
		                            self.body.splice(i, 1);
		                            continue;
		                        }
		                        if (expr instanceof AST_Sequence
		                            && (assign = expr.expressions[0]) instanceof AST_Assign
		                            && assign.operator == "="
		                            && (sym = assign.left) instanceof AST_Symbol
		                            && vars.has(sym.name)
		                        ) {
		                            var def = vars.get(sym.name);
		                            if (def.value) break;
		                            def.value = assign.right;
		                            remove(defs, def);
		                            defs.push(def);
		                            self.body[i].body = make_sequence(expr, expr.expressions.slice(1));
		                            continue;
		                        }
		                    }
		                    if (self.body[i] instanceof AST_EmptyStatement) {
		                        self.body.splice(i, 1);
		                        continue;
		                    }
		                    if (self.body[i] instanceof AST_BlockStatement) {
		                        self.body.splice(i, 1, ...self.body[i].body);
		                        continue;
		                    }
		                    break;
		                }
		                defs = make_node(AST_Var, self, {
		                    definitions: defs
		                });
		                hoisted.push(defs);
		            }
		        }
		        self.body = dirs.concat(hoisted, self.body);
		    }
		    return self;
		});

		AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
		    var self = this;
		    if (!compressor.option("hoist_props") || compressor.has_directive("use asm")) return self;
		    var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;
		    var defs_by_id = new Map();
		    var hoister = new TreeTransformer(function(node, descend) {
		        if (node instanceof AST_VarDef) {
		            const sym = node.name;
		            let def;
		            let value;
		            if (sym.scope === self
		                && (def = sym.definition()).escaped != 1
		                && !def.assignments
		                && !def.direct_access
		                && !def.single_use
		                && !compressor.exposed(def)
		                && !top_retain(def)
		                && (value = sym.fixed_value()) === node.value
		                && value instanceof AST_Object
		                && !value.properties.some(prop =>
		                    prop instanceof AST_Expansion || prop.computed_key()
		                )
		            ) {
		                descend(node, this);
		                const defs = new Map();
		                const assignments = [];
		                value.properties.forEach(({ key, value }) => {
		                    const scope = hoister.find_scope();
		                    const symbol = self.create_symbol(sym.CTOR, {
		                        source: sym,
		                        scope,
		                        conflict_scopes: new Set([
		                            scope,
		                            ...sym.definition().references.map(ref => ref.scope)
		                        ]),
		                        tentative_name: sym.name + "_" + key
		                    });

		                    defs.set(String(key), symbol.definition());

		                    assignments.push(make_node(AST_VarDef, node, {
		                        name: symbol,
		                        value
		                    }));
		                });
		                defs_by_id.set(def.id, defs);
		                return MAP.splice(assignments);
		            }
		        } else if (node instanceof AST_PropAccess
		            && node.expression instanceof AST_SymbolRef
		        ) {
		            const defs = defs_by_id.get(node.expression.definition().id);
		            if (defs) {
		                const def = defs.get(String(get_simple_key(node.property)));
		                const sym = make_node(AST_SymbolRef, node, {
		                    name: def.name,
		                    scope: node.expression.scope,
		                    thedef: def
		                });
		                sym.reference({});
		                return sym;
		            }
		        }
		    });
		    return self.transform(hoister);
		});

		def_optimize(AST_SimpleStatement, function(self, compressor) {
		    if (compressor.option("side_effects")) {
		        var body = self.body;
		        var node = body.drop_side_effect_free(compressor, true);
		        if (!node) {
		            return make_node(AST_EmptyStatement, self);
		        }
		        if (node !== body) {
		            return make_node(AST_SimpleStatement, self, { body: node });
		        }
		    }
		    return self;
		});

		def_optimize(AST_While, function(self, compressor) {
		    return compressor.option("loops") ? make_node(AST_For, self, self).optimize(compressor) : self;
		});

		def_optimize(AST_Do, function(self, compressor) {
		    if (!compressor.option("loops")) return self;
		    var cond = self.condition.tail_node().evaluate(compressor);
		    if (!(cond instanceof AST_Node)) {
		        if (cond) return make_node(AST_For, self, {
		            body: make_node(AST_BlockStatement, self.body, {
		                body: [
		                    self.body,
		                    make_node(AST_SimpleStatement, self.condition, {
		                        body: self.condition
		                    })
		                ]
		            })
		        }).optimize(compressor);
		        if (!has_break_or_continue(self, compressor.parent())) {
		            return make_node(AST_BlockStatement, self.body, {
		                body: [
		                    self.body,
		                    make_node(AST_SimpleStatement, self.condition, {
		                        body: self.condition
		                    })
		                ]
		            }).optimize(compressor);
		        }
		    }
		    return self;
		});

		function if_break_in_loop(self, compressor) {
		    var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
		    if (compressor.option("dead_code") && is_break(first)) {
		        var body = [];
		        if (self.init instanceof AST_Statement) {
		            body.push(self.init);
		        } else if (self.init) {
		            body.push(make_node(AST_SimpleStatement, self.init, {
		                body: self.init
		            }));
		        }
		        if (self.condition) {
		            body.push(make_node(AST_SimpleStatement, self.condition, {
		                body: self.condition
		            }));
		        }
		        trim_unreachable_code(compressor, self.body, body);
		        return make_node(AST_BlockStatement, self, {
		            body: body
		        });
		    }
		    if (first instanceof AST_If) {
		        if (is_break(first.body)) {
		            if (self.condition) {
		                self.condition = make_node(AST_Binary, self.condition, {
		                    left: self.condition,
		                    operator: "&&",
		                    right: first.condition.negate(compressor),
		                });
		            } else {
		                self.condition = first.condition.negate(compressor);
		            }
		            drop_it(first.alternative);
		        } else if (is_break(first.alternative)) {
		            if (self.condition) {
		                self.condition = make_node(AST_Binary, self.condition, {
		                    left: self.condition,
		                    operator: "&&",
		                    right: first.condition,
		                });
		            } else {
		                self.condition = first.condition;
		            }
		            drop_it(first.body);
		        }
		    }
		    return self;

		    function is_break(node) {
		        return node instanceof AST_Break
		            && compressor.loopcontrol_target(node) === compressor.self();
		    }

		    function drop_it(rest) {
		        rest = as_statement_array(rest);
		        if (self.body instanceof AST_BlockStatement) {
		            self.body = self.body.clone();
		            self.body.body = rest.concat(self.body.body.slice(1));
		            self.body = self.body.transform(compressor);
		        } else {
		            self.body = make_node(AST_BlockStatement, self.body, {
		                body: rest
		            }).transform(compressor);
		        }
		        self = if_break_in_loop(self, compressor);
		    }
		}

		def_optimize(AST_For, function(self, compressor) {
		    if (!compressor.option("loops")) return self;
		    if (compressor.option("side_effects") && self.init) {
		        self.init = self.init.drop_side_effect_free(compressor);
		    }
		    if (self.condition) {
		        var cond = self.condition.evaluate(compressor);
		        if (!(cond instanceof AST_Node)) {
		            if (cond) self.condition = null;
		            else if (!compressor.option("dead_code")) {
		                var orig = self.condition;
		                self.condition = make_node_from_constant(cond, self.condition);
		                self.condition = best_of_expression(self.condition.transform(compressor), orig);
		            }
		        }
		        if (compressor.option("dead_code")) {
		            if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);
		            if (!cond) {
		                var body = [];
		                trim_unreachable_code(compressor, self.body, body);
		                if (self.init instanceof AST_Statement) {
		                    body.push(self.init);
		                } else if (self.init) {
		                    body.push(make_node(AST_SimpleStatement, self.init, {
		                        body: self.init
		                    }));
		                }
		                body.push(make_node(AST_SimpleStatement, self.condition, {
		                    body: self.condition
		                }));
		                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);
		            }
		        }
		    }
		    return if_break_in_loop(self, compressor);
		});

		def_optimize(AST_If, function(self, compressor) {
		    if (is_empty(self.alternative)) self.alternative = null;

		    if (!compressor.option("conditionals")) return self;
		    // if condition can be statically determined, drop
		    // one of the blocks.  note, statically determined implies
		    // “has no side effects”; also it doesn't work for cases like
		    // `x && true`, though it probably should.
		    var cond = self.condition.evaluate(compressor);
		    if (!compressor.option("dead_code") && !(cond instanceof AST_Node)) {
		        var orig = self.condition;
		        self.condition = make_node_from_constant(cond, orig);
		        self.condition = best_of_expression(self.condition.transform(compressor), orig);
		    }
		    if (compressor.option("dead_code")) {
		        if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);
		        if (!cond) {
		            var body = [];
		            trim_unreachable_code(compressor, self.body, body);
		            body.push(make_node(AST_SimpleStatement, self.condition, {
		                body: self.condition
		            }));
		            if (self.alternative) body.push(self.alternative);
		            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);
		        } else if (!(cond instanceof AST_Node)) {
		            var body = [];
		            body.push(make_node(AST_SimpleStatement, self.condition, {
		                body: self.condition
		            }));
		            body.push(self.body);
		            if (self.alternative) {
		                trim_unreachable_code(compressor, self.alternative, body);
		            }
		            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);
		        }
		    }
		    var negated = self.condition.negate(compressor);
		    var self_condition_length = self.condition.size();
		    var negated_length = negated.size();
		    var negated_is_best = negated_length < self_condition_length;
		    if (self.alternative && negated_is_best) {
		        negated_is_best = false; // because we already do the switch here.
		        // no need to swap values of self_condition_length and negated_length
		        // here because they are only used in an equality comparison later on.
		        self.condition = negated;
		        var tmp = self.body;
		        self.body = self.alternative || make_node(AST_EmptyStatement, self);
		        self.alternative = tmp;
		    }
		    if (is_empty(self.body) && is_empty(self.alternative)) {
		        return make_node(AST_SimpleStatement, self.condition, {
		            body: self.condition.clone()
		        }).optimize(compressor);
		    }
		    if (self.body instanceof AST_SimpleStatement
		        && self.alternative instanceof AST_SimpleStatement) {
		        return make_node(AST_SimpleStatement, self, {
		            body: make_node(AST_Conditional, self, {
		                condition   : self.condition,
		                consequent  : self.body.body,
		                alternative : self.alternative.body
		            })
		        }).optimize(compressor);
		    }
		    if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
		        if (self_condition_length === negated_length && !negated_is_best
		            && self.condition instanceof AST_Binary && self.condition.operator == "||") {
		            // although the code length of self.condition and negated are the same,
		            // negated does not require additional surrounding parentheses.
		            // see https://github.com/mishoo/UglifyJS2/issues/979
		            negated_is_best = true;
		        }
		        if (negated_is_best) return make_node(AST_SimpleStatement, self, {
		            body: make_node(AST_Binary, self, {
		                operator : "||",
		                left     : negated,
		                right    : self.body.body
		            })
		        }).optimize(compressor);
		        return make_node(AST_SimpleStatement, self, {
		            body: make_node(AST_Binary, self, {
		                operator : "&&",
		                left     : self.condition,
		                right    : self.body.body
		            })
		        }).optimize(compressor);
		    }
		    if (self.body instanceof AST_EmptyStatement
		        && self.alternative instanceof AST_SimpleStatement) {
		        return make_node(AST_SimpleStatement, self, {
		            body: make_node(AST_Binary, self, {
		                operator : "||",
		                left     : self.condition,
		                right    : self.alternative.body
		            })
		        }).optimize(compressor);
		    }
		    if (self.body instanceof AST_Exit
		        && self.alternative instanceof AST_Exit
		        && self.body.TYPE == self.alternative.TYPE) {
		        return make_node(self.body.CTOR, self, {
		            value: make_node(AST_Conditional, self, {
		                condition   : self.condition,
		                consequent  : self.body.value || make_node(AST_Undefined, self.body),
		                alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)
		            }).transform(compressor)
		        }).optimize(compressor);
		    }
		    if (self.body instanceof AST_If
		        && !self.body.alternative
		        && !self.alternative) {
		        self = make_node(AST_If, self, {
		            condition: make_node(AST_Binary, self.condition, {
		                operator: "&&",
		                left: self.condition,
		                right: self.body.condition
		            }),
		            body: self.body.body,
		            alternative: null
		        });
		    }
		    if (aborts(self.body)) {
		        if (self.alternative) {
		            var alt = self.alternative;
		            self.alternative = null;
		            return make_node(AST_BlockStatement, self, {
		                body: [ self, alt ]
		            }).optimize(compressor);
		        }
		    }
		    if (aborts(self.alternative)) {
		        var body = self.body;
		        self.body = self.alternative;
		        self.condition = negated_is_best ? negated : self.condition.negate(compressor);
		        self.alternative = null;
		        return make_node(AST_BlockStatement, self, {
		            body: [ self, body ]
		        }).optimize(compressor);
		    }
		    return self;
		});

		def_optimize(AST_Switch, function(self, compressor) {
		    if (!compressor.option("switches")) return self;
		    var branch;
		    var value = self.expression.evaluate(compressor);
		    if (!(value instanceof AST_Node)) {
		        var orig = self.expression;
		        self.expression = make_node_from_constant(value, orig);
		        self.expression = best_of_expression(self.expression.transform(compressor), orig);
		    }
		    if (!compressor.option("dead_code")) return self;
		    if (value instanceof AST_Node) {
		        value = self.expression.tail_node().evaluate(compressor);
		    }
		    var decl = [];
		    var body = [];
		    var default_branch;
		    var exact_match;
		    for (var i = 0, len = self.body.length; i < len && !exact_match; i++) {
		        branch = self.body[i];
		        if (branch instanceof AST_Default) {
		            if (!default_branch) {
		                default_branch = branch;
		            } else {
		                eliminate_branch(branch, body[body.length - 1]);
		            }
		        } else if (!(value instanceof AST_Node)) {
		            var exp = branch.expression.evaluate(compressor);
		            if (!(exp instanceof AST_Node) && exp !== value) {
		                eliminate_branch(branch, body[body.length - 1]);
		                continue;
		            }
		            if (exp instanceof AST_Node) exp = branch.expression.tail_node().evaluate(compressor);
		            if (exp === value) {
		                exact_match = branch;
		                if (default_branch) {
		                    var default_index = body.indexOf(default_branch);
		                    body.splice(default_index, 1);
		                    eliminate_branch(default_branch, body[default_index - 1]);
		                    default_branch = null;
		                }
		            }
		        }
		        body.push(branch);
		    }
		    while (i < len) eliminate_branch(self.body[i++], body[body.length - 1]);
		    self.body = body;

		    let default_or_exact = default_branch || exact_match;
		    default_branch = null;
		    exact_match = null;

		    // group equivalent branches so they will be located next to each other,
		    // that way the next micro-optimization will merge them.
		    // ** bail micro-optimization if not a simple switch case with breaks
		    if (body.every((branch, i) =>
		        (branch === default_or_exact || branch.expression instanceof AST_Constant)
		        && (branch.body.length === 0 || aborts(branch) || body.length - 1 === i))
		    ) {
		        for (let i = 0; i < body.length; i++) {
		            const branch = body[i];
		            for (let j = i + 1; j < body.length; j++) {
		                const next = body[j];
		                if (next.body.length === 0) continue;
		                const last_branch = j === (body.length - 1);
		                const equivalentBranch = branches_equivalent(next, branch, false);
		                if (equivalentBranch || (last_branch && branches_equivalent(next, branch, true))) {
		                    if (!equivalentBranch && last_branch) {
		                        next.body.push(make_node(AST_Break));
		                    }

		                    // let's find previous siblings with inert fallthrough...
		                    let x = j - 1;
		                    let fallthroughDepth = 0;
		                    while (x > i) {
		                        if (is_inert_body(body[x--])) {
		                            fallthroughDepth++;
		                        } else {
		                            break;
		                        }
		                    }

		                    const plucked = body.splice(j - fallthroughDepth, 1 + fallthroughDepth);
		                    body.splice(i + 1, 0, ...plucked);
		                    i += plucked.length;
		                }
		            }
		        }
		    }

		    // merge equivalent branches in a row
		    for (let i = 0; i < body.length; i++) {
		        let branch = body[i];
		        if (branch.body.length === 0) continue;
		        if (!aborts(branch)) continue;

		        for (let j = i + 1; j < body.length; i++, j++) {
		            let next = body[j];
		            if (next.body.length === 0) continue;
		            if (
		                branches_equivalent(next, branch, false)
		                || (j === body.length - 1 && branches_equivalent(next, branch, true))
		            ) {
		                branch.body = [];
		                branch = next;
		                continue;
		            }
		            break;
		        }
		    }

		    // Prune any empty branches at the end of the switch statement.
		    {
		        let i = body.length - 1;
		        for (; i >= 0; i--) {
		            let bbody = body[i].body;
		            if (is_break(bbody[bbody.length - 1], compressor)) bbody.pop();
		            if (!is_inert_body(body[i])) break;
		        }
		        // i now points to the index of a branch that contains a body. By incrementing, it's
		        // pointing to the first branch that's empty.
		        i++;
		        if (!default_or_exact || body.indexOf(default_or_exact) >= i) {
		            // The default behavior is to do nothing. We can take advantage of that to
		            // remove all case expressions that are side-effect free that also do
		            // nothing, since they'll default to doing nothing. But we can't remove any
		            // case expressions before one that would side-effect, since they may cause
		            // the side-effect to be skipped.
		            for (let j = body.length - 1; j >= i; j--) {
		                let branch = body[j];
		                if (branch === default_or_exact) {
		                    default_or_exact = null;
		                    body.pop();
		                } else if (!branch.expression.has_side_effects(compressor)) {
		                    body.pop();
		                } else {
		                    break;
		                }
		            }
		        }
		    }


		    // Prune side-effect free branches that fall into default.
		    DEFAULT: if (default_or_exact) {
		        let default_index = body.indexOf(default_or_exact);
		        let default_body_index = default_index;
		        for (; default_body_index < body.length - 1; default_body_index++) {
		            if (!is_inert_body(body[default_body_index])) break;
		        }
		        if (default_body_index < body.length - 1) {
		            break DEFAULT;
		        }

		        let side_effect_index = body.length - 1;
		        for (; side_effect_index >= 0; side_effect_index--) {
		            let branch = body[side_effect_index];
		            if (branch === default_or_exact) continue;
		            if (branch.expression.has_side_effects(compressor)) break;
		        }
		        // If the default behavior comes after any side-effect case expressions,
		        // then we can fold all side-effect free cases into the default branch.
		        // If the side-effect case is after the default, then any side-effect
		        // free cases could prevent the side-effect from occurring.
		        if (default_body_index > side_effect_index) {
		            let prev_body_index = default_index - 1;
		            for (; prev_body_index >= 0; prev_body_index--) {
		                if (!is_inert_body(body[prev_body_index])) break;
		            }
		            let before = Math.max(side_effect_index, prev_body_index) + 1;
		            let after = default_index;
		            if (side_effect_index > default_index) {
		                // If the default falls into the same body as a side-effect
		                // case, then we need preserve that case and only prune the
		                // cases after it.
		                after = side_effect_index;
		                body[side_effect_index].body = body[default_body_index].body;
		            } else {
		                // The default will be the last branch.
		                default_or_exact.body = body[default_body_index].body;
		            }

		            // Prune everything after the default (or last side-effect case)
		            // until the next case with a body.
		            body.splice(after + 1, default_body_index - after);
		            // Prune everything before the default that falls into it.
		            body.splice(before, default_index - before);
		        }
		    }

		    // See if we can remove the switch entirely if all cases (the default) fall into the same case body.
		    DEFAULT: if (default_or_exact) {
		        let i = body.findIndex(branch => !is_inert_body(branch));
		        let caseBody;
		        // `i` is equal to one of the following:
		        // - `-1`, there is no body in the switch statement.
		        // - `body.length - 1`, all cases fall into the same body.
		        // - anything else, there are multiple bodies in the switch.
		        if (i === body.length - 1) {
		            // All cases fall into the case body.
		            let branch = body[i];
		            if (has_nested_break(self)) break DEFAULT;

		            // This is the last case body, and we've already pruned any breaks, so it's
		            // safe to hoist.
		            caseBody = make_node(AST_BlockStatement, branch, {
		                body: branch.body
		            });
		            branch.body = [];
		        } else if (i !== -1) {
		            // If there are multiple bodies, then we cannot optimize anything.
		            break DEFAULT;
		        }

		        let sideEffect = body.find(branch => {
		            return (
		                branch !== default_or_exact
		                && branch.expression.has_side_effects(compressor)
		            );
		        });
		        // If no cases cause a side-effect, we can eliminate the switch entirely.
		        if (!sideEffect) {
		            return make_node(AST_BlockStatement, self, {
		                body: decl.concat(
		                    statement(self.expression),
		                    default_or_exact.expression ? statement(default_or_exact.expression) : [],
		                    caseBody || []
		                )
		            }).optimize(compressor);
		        }

		        // If we're this far, either there was no body or all cases fell into the same body.
		        // If there was no body, then we don't need a default branch (because the default is
		        // do nothing). If there was a body, we'll extract it to after the switch, so the
		        // switch's new default is to do nothing and we can still prune it.
		        const default_index = body.indexOf(default_or_exact);
		        body.splice(default_index, 1);
		        default_or_exact = null;

		        if (caseBody) {
		            // Recurse into switch statement one more time so that we can append the case body
		            // outside of the switch. This recursion will only happen once since we've pruned
		            // the default case.
		            return make_node(AST_BlockStatement, self, {
		                body: decl.concat(self, caseBody)
		            }).optimize(compressor);
		        }
		        // If we fall here, there is a default branch somewhere, there are no case bodies,
		        // and there's a side-effect somewhere. Just let the below paths take care of it.
		    }

		    if (body.length > 0) {
		        body[0].body = decl.concat(body[0].body);
		    }

		    if (body.length == 0) {
		        return make_node(AST_BlockStatement, self, {
		            body: decl.concat(statement(self.expression))
		        }).optimize(compressor);
		    }
		    if (body.length == 1 && !has_nested_break(self)) {
		        // This is the last case body, and we've already pruned any breaks, so it's
		        // safe to hoist.
		        let branch = body[0];
		        return make_node(AST_If, self, {
		            condition: make_node(AST_Binary, self, {
		                operator: "===",
		                left: self.expression,
		                right: branch.expression,
		            }),
		            body: make_node(AST_BlockStatement, branch, {
		                body: branch.body
		            }),
		            alternative: null
		        }).optimize(compressor);
		    }
		    if (body.length === 2 && default_or_exact && !has_nested_break(self)) {
		        let branch = body[0] === default_or_exact ? body[1] : body[0];
		        let exact_exp = default_or_exact.expression && statement(default_or_exact.expression);
		        if (aborts(body[0])) {
		            // Only the first branch body could have a break (at the last statement)
		            let first = body[0];
		            if (is_break(first.body[first.body.length - 1], compressor)) {
		                first.body.pop();
		            }
		            return make_node(AST_If, self, {
		                condition: make_node(AST_Binary, self, {
		                    operator: "===",
		                    left: self.expression,
		                    right: branch.expression,
		                }),
		                body: make_node(AST_BlockStatement, branch, {
		                    body: branch.body
		                }),
		                alternative: make_node(AST_BlockStatement, default_or_exact, {
		                    body: [].concat(
		                        exact_exp || [],
		                        default_or_exact.body
		                    )
		                })
		            }).optimize(compressor);
		        }
		        let operator = "===";
		        let consequent = make_node(AST_BlockStatement, branch, {
		            body: branch.body,
		        });
		        let always = make_node(AST_BlockStatement, default_or_exact, {
		            body: [].concat(
		                exact_exp || [],
		                default_or_exact.body
		            )
		        });
		        if (body[0] === default_or_exact) {
		            operator = "!==";
		            let tmp = always;
		            always = consequent;
		            consequent = tmp;
		        }
		        return make_node(AST_BlockStatement, self, {
		            body: [
		                make_node(AST_If, self, {
		                    condition: make_node(AST_Binary, self, {
		                        operator: operator,
		                        left: self.expression,
		                        right: branch.expression,
		                    }),
		                    body: consequent,
		                    alternative: null
		                })
		            ].concat(always)
		        }).optimize(compressor);
		    }
		    return self;

		    function eliminate_branch(branch, prev) {
		        if (prev && !aborts(prev)) {
		            prev.body = prev.body.concat(branch.body);
		        } else {
		            trim_unreachable_code(compressor, branch, decl);
		        }
		    }
		    function branches_equivalent(branch, prev, insertBreak) {
		        let bbody = branch.body;
		        let pbody = prev.body;
		        if (insertBreak) {
		            bbody = bbody.concat(make_node(AST_Break));
		        }
		        if (bbody.length !== pbody.length) return false;
		        let bblock = make_node(AST_BlockStatement, branch, { body: bbody });
		        let pblock = make_node(AST_BlockStatement, prev, { body: pbody });
		        return bblock.equivalent_to(pblock);
		    }
		    function statement(expression) {
		        return make_node(AST_SimpleStatement, expression, {
		            body: expression
		        });
		    }
		    function has_nested_break(root) {
		        let has_break = false;
		        let tw = new TreeWalker(node => {
		            if (has_break) return true;
		            if (node instanceof AST_Lambda) return true;
		            if (node instanceof AST_SimpleStatement) return true;
		            if (!is_break(node, tw)) return;
		            let parent = tw.parent();
		            if (
		                parent instanceof AST_SwitchBranch
		                && parent.body[parent.body.length - 1] === node
		            ) {
		                return;
		            }
		            has_break = true;
		        });
		        root.walk(tw);
		        return has_break;
		    }
		    function is_break(node, stack) {
		        return node instanceof AST_Break
		            && stack.loopcontrol_target(node) === self;
		    }
		    function is_inert_body(branch) {
		        return !aborts(branch) && !make_node(AST_BlockStatement, branch, {
		            body: branch.body
		        }).has_side_effects(compressor);
		    }
		});

		def_optimize(AST_Try, function(self, compressor) {
		    if (self.bcatch && self.bfinally && self.bfinally.body.every(is_empty)) self.bfinally = null;

		    if (compressor.option("dead_code") && self.body.body.every(is_empty)) {
		        var body = [];
		        if (self.bcatch) {
		            trim_unreachable_code(compressor, self.bcatch, body);
		        }
		        if (self.bfinally) body.push(...self.bfinally.body);
		        return make_node(AST_BlockStatement, self, {
		            body: body
		        }).optimize(compressor);
		    }
		    return self;
		});

		AST_Definitions.DEFMETHOD("to_assignments", function(compressor) {
		    var reduce_vars = compressor.option("reduce_vars");
		    var assignments = [];

		    for (const def of this.definitions) {
		        if (def.value) {
		            var name = make_node(AST_SymbolRef, def.name, def.name);
		            assignments.push(make_node(AST_Assign, def, {
		                operator : "=",
		                logical: false,
		                left     : name,
		                right    : def.value
		            }));
		            if (reduce_vars) name.definition().fixed = false;
		        }
		        const thedef = def.name.definition();
		        thedef.eliminated++;
		        thedef.replaced--;
		    }

		    if (assignments.length == 0) return null;
		    return make_sequence(this, assignments);
		});

		def_optimize(AST_Definitions, function(self) {
		    if (self.definitions.length == 0) {
		        return make_node(AST_EmptyStatement, self);
		    }
		    return self;
		});

		def_optimize(AST_VarDef, function(self, compressor) {
		    if (
		        self.name instanceof AST_SymbolLet
		        && self.value != null
		        && is_undefined(self.value, compressor)
		    ) {
		        self.value = null;
		    }
		    return self;
		});

		def_optimize(AST_Import, function(self) {
		    return self;
		});

		def_optimize(AST_Call, function(self, compressor) {
		    var exp = self.expression;
		    var fn = exp;
		    inline_array_like_spread(self.args);
		    var simple_args = self.args.every((arg) => !(arg instanceof AST_Expansion));

		    if (compressor.option("reduce_vars") && fn instanceof AST_SymbolRef) {
		        fn = fn.fixed_value();
		    }

		    var is_func = fn instanceof AST_Lambda;

		    if (is_func && fn.pinned()) return self;

		    if (compressor.option("unused")
		        && simple_args
		        && is_func
		        && !fn.uses_arguments) {
		        var pos = 0, last = 0;
		        for (var i = 0, len = self.args.length; i < len; i++) {
		            if (fn.argnames[i] instanceof AST_Expansion) {
		                if (has_flag(fn.argnames[i].expression, UNUSED)) while (i < len) {
		                    var node = self.args[i++].drop_side_effect_free(compressor);
		                    if (node) {
		                        self.args[pos++] = node;
		                    }
		                } else while (i < len) {
		                    self.args[pos++] = self.args[i++];
		                }
		                last = pos;
		                break;
		            }
		            var trim = i >= fn.argnames.length;
		            if (trim || has_flag(fn.argnames[i], UNUSED)) {
		                var node = self.args[i].drop_side_effect_free(compressor);
		                if (node) {
		                    self.args[pos++] = node;
		                } else if (!trim) {
		                    self.args[pos++] = make_node(AST_Number, self.args[i], {
		                        value: 0
		                    });
		                    continue;
		                }
		            } else {
		                self.args[pos++] = self.args[i];
		            }
		            last = pos;
		        }
		        self.args.length = last;
		    }

		    if (compressor.option("unsafe")) {
		        if (exp instanceof AST_Dot && exp.start.value === "Array" && exp.property === "from" && self.args.length === 1) {
		            const [argument] = self.args;
		            if (argument instanceof AST_Array) {
		                return make_node(AST_Array, argument, {
		                    elements: argument.elements
		                }).optimize(compressor);
		            }
		        }
		        if (is_undeclared_ref(exp)) switch (exp.name) {
		          case "Array":
		            if (self.args.length != 1) {
		                return make_node(AST_Array, self, {
		                    elements: self.args
		                }).optimize(compressor);
		            } else if (self.args[0] instanceof AST_Number && self.args[0].value <= 11) {
		                const elements = [];
		                for (let i = 0; i < self.args[0].value; i++) elements.push(new AST_Hole);
		                return new AST_Array({ elements });
		            }
		            break;
		          case "Object":
		            if (self.args.length == 0) {
		                return make_node(AST_Object, self, {
		                    properties: []
		                });
		            }
		            break;
		          case "String":
		            if (self.args.length == 0) return make_node(AST_String, self, {
		                value: ""
		            });
		            if (self.args.length <= 1) return make_node(AST_Binary, self, {
		                left: self.args[0],
		                operator: "+",
		                right: make_node(AST_String, self, { value: "" })
		            }).optimize(compressor);
		            break;
		          case "Number":
		            if (self.args.length == 0) return make_node(AST_Number, self, {
		                value: 0
		            });
		            if (self.args.length == 1 && compressor.option("unsafe_math")) {
		                return make_node(AST_UnaryPrefix, self, {
		                    expression: self.args[0],
		                    operator: "+"
		                }).optimize(compressor);
		            }
		            break;
		          case "Symbol":
		            if (self.args.length == 1 && self.args[0] instanceof AST_String && compressor.option("unsafe_symbols"))
		                self.args.length = 0;
		                break;
		          case "Boolean":
		            if (self.args.length == 0) return make_node(AST_False, self);
		            if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
		                expression: make_node(AST_UnaryPrefix, self, {
		                    expression: self.args[0],
		                    operator: "!"
		                }),
		                operator: "!"
		            }).optimize(compressor);
		            break;
		          case "RegExp":
		            var params = [];
		            if (self.args.length >= 1
		                && self.args.length <= 2
		                && self.args.every((arg) => {
		                    var value = arg.evaluate(compressor);
		                    params.push(value);
		                    return arg !== value;
		                })
		                && regexp_is_safe(params[0])
		            ) {
		                let [ source, flags ] = params;
		                source = regexp_source_fix(new RegExp(source).source);
		                const rx = make_node(AST_RegExp, self, {
		                    value: { source, flags }
		                });
		                if (rx._eval(compressor) !== rx) {
		                    return rx;
		                }
		            }
		            break;
		        } else if (exp instanceof AST_Dot) switch(exp.property) {
		          case "toString":
		            if (self.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {
		                return make_node(AST_Binary, self, {
		                    left: make_node(AST_String, self, { value: "" }),
		                    operator: "+",
		                    right: exp.expression
		                }).optimize(compressor);
		            }
		            break;
		          case "join":
		            if (exp.expression instanceof AST_Array) EXIT: {
		                var separator;
		                if (self.args.length > 0) {
		                    separator = self.args[0].evaluate(compressor);
		                    if (separator === self.args[0]) break EXIT; // not a constant
		                }
		                var elements = [];
		                var consts = [];
		                for (var i = 0, len = exp.expression.elements.length; i < len; i++) {
		                    var el = exp.expression.elements[i];
		                    if (el instanceof AST_Expansion) break EXIT;
		                    var value = el.evaluate(compressor);
		                    if (value !== el) {
		                        consts.push(value);
		                    } else {
		                        if (consts.length > 0) {
		                            elements.push(make_node(AST_String, self, {
		                                value: consts.join(separator)
		                            }));
		                            consts.length = 0;
		                        }
		                        elements.push(el);
		                    }
		                }
		                if (consts.length > 0) {
		                    elements.push(make_node(AST_String, self, {
		                        value: consts.join(separator)
		                    }));
		                }
		                if (elements.length == 0) return make_node(AST_String, self, { value: "" });
		                if (elements.length == 1) {
		                    if (elements[0].is_string(compressor)) {
		                        return elements[0];
		                    }
		                    return make_node(AST_Binary, elements[0], {
		                        operator : "+",
		                        left     : make_node(AST_String, self, { value: "" }),
		                        right    : elements[0]
		                    });
		                }
		                if (separator == "") {
		                    var first;
		                    if (elements[0].is_string(compressor)
		                        || elements[1].is_string(compressor)) {
		                        first = elements.shift();
		                    } else {
		                        first = make_node(AST_String, self, { value: "" });
		                    }
		                    return elements.reduce(function(prev, el) {
		                        return make_node(AST_Binary, el, {
		                            operator : "+",
		                            left     : prev,
		                            right    : el
		                        });
		                    }, first).optimize(compressor);
		                }
		                // need this awkward cloning to not affect original element
		                // best_of will decide which one to get through.
		                var node = self.clone();
		                node.expression = node.expression.clone();
		                node.expression.expression = node.expression.expression.clone();
		                node.expression.expression.elements = elements;
		                return best_of(compressor, self, node);
		            }
		            break;
		          case "charAt":
		            if (exp.expression.is_string(compressor)) {
		                var arg = self.args[0];
		                var index = arg ? arg.evaluate(compressor) : 0;
		                if (index !== arg) {
		                    return make_node(AST_Sub, exp, {
		                        expression: exp.expression,
		                        property: make_node_from_constant(index | 0, arg || exp)
		                    }).optimize(compressor);
		                }
		            }
		            break;
		          case "apply":
		            if (self.args.length == 2 && self.args[1] instanceof AST_Array) {
		                var args = self.args[1].elements.slice();
		                args.unshift(self.args[0]);
		                return make_node(AST_Call, self, {
		                    expression: make_node(AST_Dot, exp, {
		                        expression: exp.expression,
		                        optional: false,
		                        property: "call"
		                    }),
		                    args: args
		                }).optimize(compressor);
		            }
		            break;
		          case "call":
		            var func = exp.expression;
		            if (func instanceof AST_SymbolRef) {
		                func = func.fixed_value();
		            }
		            if (func instanceof AST_Lambda && !func.contains_this()) {
		                return (self.args.length ? make_sequence(this, [
		                    self.args[0],
		                    make_node(AST_Call, self, {
		                        expression: exp.expression,
		                        args: self.args.slice(1)
		                    })
		                ]) : make_node(AST_Call, self, {
		                    expression: exp.expression,
		                    args: []
		                })).optimize(compressor);
		            }
		            break;
		        }
		    }

		    if (compressor.option("unsafe_Function")
		        && is_undeclared_ref(exp)
		        && exp.name == "Function") {
		        // new Function() => function(){}
		        if (self.args.length == 0) return make_node(AST_Function, self, {
		            argnames: [],
		            body: []
		        }).optimize(compressor);
		        var nth_identifier = compressor.mangle_options && compressor.mangle_options.nth_identifier || base54;
		        if (self.args.every((x) => x instanceof AST_String)) {
		            // quite a corner-case, but we can handle it:
		            //   https://github.com/mishoo/UglifyJS2/issues/203
		            // if the code argument is a constant, then we can minify it.
		            try {
		                var code = "n(function(" + self.args.slice(0, -1).map(function(arg) {
		                    return arg.value;
		                }).join(",") + "){" + self.args[self.args.length - 1].value + "})";
		                var ast = parse(code);
		                var mangle = { ie8: compressor.option("ie8"), nth_identifier: nth_identifier };
		                ast.figure_out_scope(mangle);
		                var comp = new Compressor(compressor.options, {
		                    mangle_options: compressor.mangle_options
		                });
		                ast = ast.transform(comp);
		                ast.figure_out_scope(mangle);
		                ast.compute_char_frequency(mangle);
		                ast.mangle_names(mangle);
		                var fun;
		                walk(ast, node => {
		                    if (is_func_expr(node)) {
		                        fun = node;
		                        return walk_abort;
		                    }
		                });
		                var code = OutputStream();
		                AST_BlockStatement.prototype._codegen.call(fun, fun, code);
		                self.args = [
		                    make_node(AST_String, self, {
		                        value: fun.argnames.map(function(arg) {
		                            return arg.print_to_string();
		                        }).join(",")
		                    }),
		                    make_node(AST_String, self.args[self.args.length - 1], {
		                        value: code.get().replace(/^{|}$/g, "")
		                    })
		                ];
		                return self;
		            } catch (ex) {
		                if (!(ex instanceof JS_Parse_Error)) {
		                    throw ex;
		                }

		                // Otherwise, it crashes at runtime. Or maybe it's nonstandard syntax.
		            }
		        }
		    }

		    return inline_into_call(self, compressor);
		});

		def_optimize(AST_New, function(self, compressor) {
		    if (
		        compressor.option("unsafe") &&
		        is_undeclared_ref(self.expression) &&
		        ["Object", "RegExp", "Function", "Error", "Array"].includes(self.expression.name)
		    ) return make_node(AST_Call, self, self).transform(compressor);
		    return self;
		});

		def_optimize(AST_Sequence, function(self, compressor) {
		    if (!compressor.option("side_effects")) return self;
		    var expressions = [];
		    filter_for_side_effects();
		    var end = expressions.length - 1;
		    trim_right_for_undefined();
		    if (end == 0) {
		        self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);
		        if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);
		        return self;
		    }
		    self.expressions = expressions;
		    return self;

		    function filter_for_side_effects() {
		        var first = first_in_statement(compressor);
		        var last = self.expressions.length - 1;
		        self.expressions.forEach(function(expr, index) {
		            if (index < last) expr = expr.drop_side_effect_free(compressor, first);
		            if (expr) {
		                merge_sequence(expressions, expr);
		                first = false;
		            }
		        });
		    }

		    function trim_right_for_undefined() {
		        while (end > 0 && is_undefined(expressions[end], compressor)) end--;
		        if (end < expressions.length - 1) {
		            expressions[end] = make_node(AST_UnaryPrefix, self, {
		                operator   : "void",
		                expression : expressions[end]
		            });
		            expressions.length = end + 1;
		        }
		    }
		});

		AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
		    if (compressor.option("sequences")) {
		        if (this.expression instanceof AST_Sequence) {
		            var x = this.expression.expressions.slice();
		            var e = this.clone();
		            e.expression = x.pop();
		            x.push(e);
		            return make_sequence(this, x).optimize(compressor);
		        }
		    }
		    return this;
		});

		def_optimize(AST_UnaryPostfix, function(self, compressor) {
		    return self.lift_sequences(compressor);
		});

		def_optimize(AST_UnaryPrefix, function(self, compressor) {
		    var e = self.expression;
		    if (
		        self.operator == "delete" &&
		        !(
		            e instanceof AST_SymbolRef ||
		            e instanceof AST_PropAccess ||
		            e instanceof AST_Chain ||
		            is_identifier_atom(e)
		        )
		    ) {
		        return make_sequence(self, [e, make_node(AST_True, self)]).optimize(compressor);
		    }
		    var seq = self.lift_sequences(compressor);
		    if (seq !== self) {
		        return seq;
		    }
		    if (compressor.option("side_effects") && self.operator == "void") {
		        e = e.drop_side_effect_free(compressor);
		        if (e) {
		            self.expression = e;
		            return self;
		        } else {
		            return make_node(AST_Undefined, self).optimize(compressor);
		        }
		    }
		    if (compressor.in_boolean_context()) {
		        switch (self.operator) {
		          case "!":
		            if (e instanceof AST_UnaryPrefix && e.operator == "!") {
		                // !!foo ==> foo, if we're in boolean context
		                return e.expression;
		            }
		            if (e instanceof AST_Binary) {
		                self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));
		            }
		            break;
		          case "typeof":
		            // typeof always returns a non-empty string, thus it's
		            // always true in booleans
		            // And we don't need to check if it's undeclared, because in typeof, that's OK
		            return (e instanceof AST_SymbolRef ? make_node(AST_True, self) : make_sequence(self, [
		                e,
		                make_node(AST_True, self)
		            ])).optimize(compressor);
		        }
		    }
		    if (self.operator == "-" && e instanceof AST_Infinity) {
		        e = e.transform(compressor);
		    }
		    if (e instanceof AST_Binary
		        && (self.operator == "+" || self.operator == "-")
		        && (e.operator == "*" || e.operator == "/" || e.operator == "%")) {
		        return make_node(AST_Binary, self, {
		            operator: e.operator,
		            left: make_node(AST_UnaryPrefix, e.left, {
		                operator: self.operator,
		                expression: e.left
		            }),
		            right: e.right
		        });
		    }
		    // avoids infinite recursion of numerals
		    if (self.operator != "-"
		        || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)) {
		        var ev = self.evaluate(compressor);
		        if (ev !== self) {
		            ev = make_node_from_constant(ev, self).optimize(compressor);
		            return best_of(compressor, ev, self);
		        }
		    }
		    return self;
		});

		AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
		    if (compressor.option("sequences")) {
		        if (this.left instanceof AST_Sequence) {
		            var x = this.left.expressions.slice();
		            var e = this.clone();
		            e.left = x.pop();
		            x.push(e);
		            return make_sequence(this, x).optimize(compressor);
		        }
		        if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {
		            var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
		            var x = this.right.expressions;
		            var last = x.length - 1;
		            for (var i = 0; i < last; i++) {
		                if (!assign && x[i].has_side_effects(compressor)) break;
		            }
		            if (i == last) {
		                x = x.slice();
		                var e = this.clone();
		                e.right = x.pop();
		                x.push(e);
		                return make_sequence(this, x).optimize(compressor);
		            } else if (i > 0) {
		                var e = this.clone();
		                e.right = make_sequence(this.right, x.slice(i));
		                x = x.slice(0, i);
		                x.push(e);
		                return make_sequence(this, x).optimize(compressor);
		            }
		        }
		    }
		    return this;
		});

		var commutativeOperators = makePredicate("== === != !== * & | ^");
		function is_object(node) {
		    return node instanceof AST_Array
		        || node instanceof AST_Lambda
		        || node instanceof AST_Object
		        || node instanceof AST_Class;
		}

		def_optimize(AST_Binary, function(self, compressor) {
		    function reversible() {
		        return self.left.is_constant()
		            || self.right.is_constant()
		            || !self.left.has_side_effects(compressor)
		                && !self.right.has_side_effects(compressor);
		    }
		    function reverse(op) {
		        if (reversible()) {
		            if (op) self.operator = op;
		            var tmp = self.left;
		            self.left = self.right;
		            self.right = tmp;
		        }
		    }
		    if (compressor.option("lhs_constants") && commutativeOperators.has(self.operator)) {
		        if (self.right.is_constant()
		            && !self.left.is_constant()) {
		            // if right is a constant, whatever side effects the
		            // left side might have could not influence the
		            // result.  hence, force switch.

		            if (!(self.left instanceof AST_Binary
		                  && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
		                reverse();
		            }
		        }
		    }
		    self = self.lift_sequences(compressor);
		    if (compressor.option("comparisons")) switch (self.operator) {
		      case "===":
		      case "!==":
		        var is_strict_comparison = true;
		        if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
		            (self.left.is_number(compressor) && self.right.is_number(compressor)) ||
		            (self.left.is_boolean() && self.right.is_boolean()) ||
		            self.left.equivalent_to(self.right)) {
		            self.operator = self.operator.substr(0, 2);
		        }
		        // XXX: intentionally falling down to the next case
		      case "==":
		      case "!=":
		        // void 0 == x => null == x
		        if (!is_strict_comparison && is_undefined(self.left, compressor)) {
		            self.left = make_node(AST_Null, self.left);
		        // x == void 0 => x == null
		        } else if (!is_strict_comparison && is_undefined(self.right, compressor)) {
		            self.right = make_node(AST_Null, self.right);
		        } else if (compressor.option("typeofs")
		            // "undefined" == typeof x => undefined === x
		            && self.left instanceof AST_String
		            && self.left.value == "undefined"
		            && self.right instanceof AST_UnaryPrefix
		            && self.right.operator == "typeof") {
		            var expr = self.right.expression;
		            if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)
		                : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
		                self.right = expr;
		                self.left = make_node(AST_Undefined, self.left).optimize(compressor);
		                if (self.operator.length == 2) self.operator += "=";
		            }
		        } else if (compressor.option("typeofs")
		            // typeof x === "undefined" => x === undefined
		            && self.left instanceof AST_UnaryPrefix
		            && self.left.operator == "typeof"
		            && self.right instanceof AST_String
		            && self.right.value == "undefined") {
		            var expr = self.left.expression;
		            if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)
		                : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
		                self.left = expr;
		                self.right = make_node(AST_Undefined, self.right).optimize(compressor);
		                if (self.operator.length == 2) self.operator += "=";
		            }
		        } else if (self.left instanceof AST_SymbolRef
		            // obj !== obj => false
		            && self.right instanceof AST_SymbolRef
		            && self.left.definition() === self.right.definition()
		            && is_object(self.left.fixed_value())) {
		            return make_node(self.operator[0] == "=" ? AST_True : AST_False, self);
		        }
		        break;
		      case "&&":
		      case "||":
		        var lhs = self.left;
		        if (lhs.operator == self.operator) {
		            lhs = lhs.right;
		        }
		        if (lhs instanceof AST_Binary
		            && lhs.operator == (self.operator == "&&" ? "!==" : "===")
		            && self.right instanceof AST_Binary
		            && lhs.operator == self.right.operator
		            && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null
		                || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor))
		            && !lhs.right.has_side_effects(compressor)
		            && lhs.right.equivalent_to(self.right.right)) {
		            var combined = make_node(AST_Binary, self, {
		                operator: lhs.operator.slice(0, -1),
		                left: make_node(AST_Null, self),
		                right: lhs.right
		            });
		            if (lhs !== self.left) {
		                combined = make_node(AST_Binary, self, {
		                    operator: self.operator,
		                    left: self.left.left,
		                    right: combined
		                });
		            }
		            return combined;
		        }
		        break;
		    }
		    if (self.operator == "+" && compressor.in_boolean_context()) {
		        var ll = self.left.evaluate(compressor);
		        var rr = self.right.evaluate(compressor);
		        if (ll && typeof ll == "string") {
		            return make_sequence(self, [
		                self.right,
		                make_node(AST_True, self)
		            ]).optimize(compressor);
		        }
		        if (rr && typeof rr == "string") {
		            return make_sequence(self, [
		                self.left,
		                make_node(AST_True, self)
		            ]).optimize(compressor);
		        }
		    }
		    if (compressor.option("comparisons") && self.is_boolean()) {
		        if (!(compressor.parent() instanceof AST_Binary)
		            || compressor.parent() instanceof AST_Assign) {
		            var negated = make_node(AST_UnaryPrefix, self, {
		                operator: "!",
		                expression: self.negate(compressor, first_in_statement(compressor))
		            });
		            self = best_of(compressor, self, negated);
		        }
		        if (compressor.option("unsafe_comps")) {
		            switch (self.operator) {
		              case "<": reverse(">"); break;
		              case "<=": reverse(">="); break;
		            }
		        }
		    }
		    if (self.operator == "+") {
		        if (self.right instanceof AST_String
		            && self.right.getValue() == ""
		            && self.left.is_string(compressor)) {
		            return self.left;
		        }
		        if (self.left instanceof AST_String
		            && self.left.getValue() == ""
		            && self.right.is_string(compressor)) {
		            return self.right;
		        }
		        if (self.left instanceof AST_Binary
		            && self.left.operator == "+"
		            && self.left.left instanceof AST_String
		            && self.left.left.getValue() == ""
		            && self.right.is_string(compressor)) {
		            self.left = self.left.right;
		            return self;
		        }
		    }
		    if (compressor.option("evaluate")) {
		        switch (self.operator) {
		          case "&&":
		            var ll = has_flag(self.left, TRUTHY)
		                ? true
		                : has_flag(self.left, FALSY)
		                    ? false
		                    : self.left.evaluate(compressor);
		            if (!ll) {
		                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);
		            } else if (!(ll instanceof AST_Node)) {
		                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);
		            }
		            var rr = self.right.evaluate(compressor);
		            if (!rr) {
		                if (compressor.in_boolean_context()) {
		                    return make_sequence(self, [
		                        self.left,
		                        make_node(AST_False, self)
		                    ]).optimize(compressor);
		                } else {
		                    set_flag(self, FALSY);
		                }
		            } else if (!(rr instanceof AST_Node)) {
		                var parent = compressor.parent();
		                if (parent.operator == "&&" && parent.left === compressor.self() || compressor.in_boolean_context()) {
		                    return self.left.optimize(compressor);
		                }
		            }
		            // x || false && y ---> x ? y : false
		            if (self.left.operator == "||") {
		                var lr = self.left.right.evaluate(compressor);
		                if (!lr) return make_node(AST_Conditional, self, {
		                    condition: self.left.left,
		                    consequent: self.right,
		                    alternative: self.left.right
		                }).optimize(compressor);
		            }
		            break;
		          case "||":
		            var ll = has_flag(self.left, TRUTHY)
		              ? true
		              : has_flag(self.left, FALSY)
		                ? false
		                : self.left.evaluate(compressor);
		            if (!ll) {
		                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);
		            } else if (!(ll instanceof AST_Node)) {
		                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);
		            }
		            var rr = self.right.evaluate(compressor);
		            if (!rr) {
		                var parent = compressor.parent();
		                if (parent.operator == "||" && parent.left === compressor.self() || compressor.in_boolean_context()) {
		                    return self.left.optimize(compressor);
		                }
		            } else if (!(rr instanceof AST_Node)) {
		                if (compressor.in_boolean_context()) {
		                    return make_sequence(self, [
		                        self.left,
		                        make_node(AST_True, self)
		                    ]).optimize(compressor);
		                } else {
		                    set_flag(self, TRUTHY);
		                }
		            }
		            if (self.left.operator == "&&") {
		                var lr = self.left.right.evaluate(compressor);
		                if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {
		                    condition: self.left.left,
		                    consequent: self.left.right,
		                    alternative: self.right
		                }).optimize(compressor);
		            }
		            break;
		          case "??":
		            if (is_nullish(self.left, compressor)) {
		                return self.right;
		            }

		            var ll = self.left.evaluate(compressor);
		            if (!(ll instanceof AST_Node)) {
		                // if we know the value for sure we can simply compute right away.
		                return ll == null ? self.right : self.left;
		            }

		            if (compressor.in_boolean_context()) {
		                const rr = self.right.evaluate(compressor);
		                if (!(rr instanceof AST_Node) && !rr) {
		                    return self.left;
		                }
		            }
		        }
		        var associative = true;
		        switch (self.operator) {
		          case "+":
		            // (x + "foo") + "bar" => x + "foobar"
		            if (self.right instanceof AST_Constant
		                && self.left instanceof AST_Binary
		                && self.left.operator == "+"
		                && self.left.is_string(compressor)) {
		                var binary = make_node(AST_Binary, self, {
		                    operator: "+",
		                    left: self.left.right,
		                    right: self.right,
		                });
		                var r = binary.optimize(compressor);
		                if (binary !== r) {
		                    self = make_node(AST_Binary, self, {
		                        operator: "+",
		                        left: self.left.left,
		                        right: r
		                    });
		                }
		            }
		            // (x + "foo") + ("bar" + y) => (x + "foobar") + y
		            if (self.left instanceof AST_Binary
		                && self.left.operator == "+"
		                && self.left.is_string(compressor)
		                && self.right instanceof AST_Binary
		                && self.right.operator == "+"
		                && self.right.is_string(compressor)) {
		                var binary = make_node(AST_Binary, self, {
		                    operator: "+",
		                    left: self.left.right,
		                    right: self.right.left,
		                });
		                var m = binary.optimize(compressor);
		                if (binary !== m) {
		                    self = make_node(AST_Binary, self, {
		                        operator: "+",
		                        left: make_node(AST_Binary, self.left, {
		                            operator: "+",
		                            left: self.left.left,
		                            right: m
		                        }),
		                        right: self.right.right
		                    });
		                }
		            }
		            // a + -b => a - b
		            if (self.right instanceof AST_UnaryPrefix
		                && self.right.operator == "-"
		                && self.left.is_number(compressor)) {
		                self = make_node(AST_Binary, self, {
		                    operator: "-",
		                    left: self.left,
		                    right: self.right.expression
		                });
		                break;
		            }
		            // -a + b => b - a
		            if (self.left instanceof AST_UnaryPrefix
		                && self.left.operator == "-"
		                && reversible()
		                && self.right.is_number(compressor)) {
		                self = make_node(AST_Binary, self, {
		                    operator: "-",
		                    left: self.right,
		                    right: self.left.expression
		                });
		                break;
		            }
		            // `foo${bar}baz` + 1 => `foo${bar}baz1`
		            if (self.left instanceof AST_TemplateString) {
		                var l = self.left;
		                var r = self.right.evaluate(compressor);
		                if (r != self.right) {
		                    l.segments[l.segments.length - 1].value += String(r);
		                    return l;
		                }
		            }
		            // 1 + `foo${bar}baz` => `1foo${bar}baz`
		            if (self.right instanceof AST_TemplateString) {
		                var r = self.right;
		                var l = self.left.evaluate(compressor);
		                if (l != self.left) {
		                    r.segments[0].value = String(l) + r.segments[0].value;
		                    return r;
		                }
		            }
		            // `1${bar}2` + `foo${bar}baz` => `1${bar}2foo${bar}baz`
		            if (self.left instanceof AST_TemplateString
		                && self.right instanceof AST_TemplateString) {
		                var l = self.left;
		                var segments = l.segments;
		                var r = self.right;
		                segments[segments.length - 1].value += r.segments[0].value;
		                for (var i = 1; i < r.segments.length; i++) {
		                    segments.push(r.segments[i]);
		                }
		                return l;
		            }
		          case "*":
		            associative = compressor.option("unsafe_math");
		          case "&":
		          case "|":
		          case "^":
		            // a + +b => +b + a
		            if (self.left.is_number(compressor)
		                && self.right.is_number(compressor)
		                && reversible()
		                && !(self.left instanceof AST_Binary
		                    && self.left.operator != self.operator
		                    && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
		                var reversed = make_node(AST_Binary, self, {
		                    operator: self.operator,
		                    left: self.right,
		                    right: self.left
		                });
		                if (self.right instanceof AST_Constant
		                    && !(self.left instanceof AST_Constant)) {
		                    self = best_of(compressor, reversed, self);
		                } else {
		                    self = best_of(compressor, self, reversed);
		                }
		            }
		            if (associative && self.is_number(compressor)) {
		                // a + (b + c) => (a + b) + c
		                if (self.right instanceof AST_Binary
		                    && self.right.operator == self.operator) {
		                    self = make_node(AST_Binary, self, {
		                        operator: self.operator,
		                        left: make_node(AST_Binary, self.left, {
		                            operator: self.operator,
		                            left: self.left,
		                            right: self.right.left,
		                            start: self.left.start,
		                            end: self.right.left.end
		                        }),
		                        right: self.right.right
		                    });
		                }
		                // (n + 2) + 3 => 5 + n
		                // (2 * n) * 3 => 6 + n
		                if (self.right instanceof AST_Constant
		                    && self.left instanceof AST_Binary
		                    && self.left.operator == self.operator) {
		                    if (self.left.left instanceof AST_Constant) {
		                        self = make_node(AST_Binary, self, {
		                            operator: self.operator,
		                            left: make_node(AST_Binary, self.left, {
		                                operator: self.operator,
		                                left: self.left.left,
		                                right: self.right,
		                                start: self.left.left.start,
		                                end: self.right.end
		                            }),
		                            right: self.left.right
		                        });
		                    } else if (self.left.right instanceof AST_Constant) {
		                        self = make_node(AST_Binary, self, {
		                            operator: self.operator,
		                            left: make_node(AST_Binary, self.left, {
		                                operator: self.operator,
		                                left: self.left.right,
		                                right: self.right,
		                                start: self.left.right.start,
		                                end: self.right.end
		                            }),
		                            right: self.left.left
		                        });
		                    }
		                }
		                // (a | 1) | (2 | d) => (3 | a) | b
		                if (self.left instanceof AST_Binary
		                    && self.left.operator == self.operator
		                    && self.left.right instanceof AST_Constant
		                    && self.right instanceof AST_Binary
		                    && self.right.operator == self.operator
		                    && self.right.left instanceof AST_Constant) {
		                    self = make_node(AST_Binary, self, {
		                        operator: self.operator,
		                        left: make_node(AST_Binary, self.left, {
		                            operator: self.operator,
		                            left: make_node(AST_Binary, self.left.left, {
		                                operator: self.operator,
		                                left: self.left.right,
		                                right: self.right.left,
		                                start: self.left.right.start,
		                                end: self.right.left.end
		                            }),
		                            right: self.left.left
		                        }),
		                        right: self.right.right
		                    });
		                }
		            }
		        }
		    }
		    // x && (y && z)  ==>  x && y && z
		    // x || (y || z)  ==>  x || y || z
		    // x + ("y" + z)  ==>  x + "y" + z
		    // "x" + (y + "z")==>  "x" + y + "z"
		    if (self.right instanceof AST_Binary
		        && self.right.operator == self.operator
		        && (lazy_op.has(self.operator)
		            || (self.operator == "+"
		                && (self.right.left.is_string(compressor)
		                    || (self.left.is_string(compressor)
		                        && self.right.right.is_string(compressor)))))
		    ) {
		        self.left = make_node(AST_Binary, self.left, {
		            operator : self.operator,
		            left     : self.left.transform(compressor),
		            right    : self.right.left.transform(compressor)
		        });
		        self.right = self.right.right.transform(compressor);
		        return self.transform(compressor);
		    }
		    var ev = self.evaluate(compressor);
		    if (ev !== self) {
		        ev = make_node_from_constant(ev, self).optimize(compressor);
		        return best_of(compressor, ev, self);
		    }
		    return self;
		});

		def_optimize(AST_SymbolExport, function(self) {
		    return self;
		});

		def_optimize(AST_SymbolRef, function(self, compressor) {
		    if (
		        !compressor.option("ie8")
		        && is_undeclared_ref(self)
		        && !compressor.find_parent(AST_With)
		    ) {
		        switch (self.name) {
		          case "undefined":
		            return make_node(AST_Undefined, self).optimize(compressor);
		          case "NaN":
		            return make_node(AST_NaN, self).optimize(compressor);
		          case "Infinity":
		            return make_node(AST_Infinity, self).optimize(compressor);
		        }
		    }

		    if (compressor.option("reduce_vars") && !compressor.is_lhs()) {
		        return inline_into_symbolref(self, compressor);
		    } else {
		        return self;
		    }
		});

		function is_atomic(lhs, self) {
		    return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;
		}

		def_optimize(AST_Undefined, function(self, compressor) {
		    if (compressor.option("unsafe_undefined")) {
		        var undef = find_variable(compressor, "undefined");
		        if (undef) {
		            var ref = make_node(AST_SymbolRef, self, {
		                name   : "undefined",
		                scope  : undef.scope,
		                thedef : undef
		            });
		            set_flag(ref, UNDEFINED);
		            return ref;
		        }
		    }
		    var lhs = compressor.is_lhs();
		    if (lhs && is_atomic(lhs, self)) return self;
		    return make_node(AST_UnaryPrefix, self, {
		        operator: "void",
		        expression: make_node(AST_Number, self, {
		            value: 0
		        })
		    });
		});

		def_optimize(AST_Infinity, function(self, compressor) {
		    var lhs = compressor.is_lhs();
		    if (lhs && is_atomic(lhs, self)) return self;
		    if (
		        compressor.option("keep_infinity")
		        && !(lhs && !is_atomic(lhs, self))
		        && !find_variable(compressor, "Infinity")
		    ) {
		        return self;
		    }
		    return make_node(AST_Binary, self, {
		        operator: "/",
		        left: make_node(AST_Number, self, {
		            value: 1
		        }),
		        right: make_node(AST_Number, self, {
		            value: 0
		        })
		    });
		});

		def_optimize(AST_NaN, function(self, compressor) {
		    var lhs = compressor.is_lhs();
		    if (lhs && !is_atomic(lhs, self)
		        || find_variable(compressor, "NaN")) {
		        return make_node(AST_Binary, self, {
		            operator: "/",
		            left: make_node(AST_Number, self, {
		                value: 0
		            }),
		            right: make_node(AST_Number, self, {
		                value: 0
		            })
		        });
		    }
		    return self;
		});

		const ASSIGN_OPS = makePredicate("+ - / * % >> << >>> | ^ &");
		const ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
		def_optimize(AST_Assign, function(self, compressor) {
		    if (self.logical) {
		        return self.lift_sequences(compressor);
		    }

		    var def;
		    // x = x ---> x
		    if (
		        self.operator === "="
		        && self.left instanceof AST_SymbolRef
		        && self.left.name !== "arguments"
		        && !(def = self.left.definition()).undeclared
		        && self.right.equivalent_to(self.left)
		    ) {
		        return self.right;
		    }

		    if (compressor.option("dead_code")
		        && self.left instanceof AST_SymbolRef
		        && (def = self.left.definition()).scope === compressor.find_parent(AST_Lambda)) {
		        var level = 0, node, parent = self;
		        do {
		            node = parent;
		            parent = compressor.parent(level++);
		            if (parent instanceof AST_Exit) {
		                if (in_try(level, parent)) break;
		                if (is_reachable(def.scope, [ def ])) break;
		                if (self.operator == "=") return self.right;
		                def.fixed = false;
		                return make_node(AST_Binary, self, {
		                    operator: self.operator.slice(0, -1),
		                    left: self.left,
		                    right: self.right
		                }).optimize(compressor);
		            }
		        } while (parent instanceof AST_Binary && parent.right === node
		            || parent instanceof AST_Sequence && parent.tail_node() === node);
		    }
		    self = self.lift_sequences(compressor);

		    if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {
		        // x = expr1 OP expr2
		        if (self.right.left instanceof AST_SymbolRef
		            && self.right.left.name == self.left.name
		            && ASSIGN_OPS.has(self.right.operator)) {
		            // x = x - 2  --->  x -= 2
		            self.operator = self.right.operator + "=";
		            self.right = self.right.right;
		        } else if (self.right.right instanceof AST_SymbolRef
		            && self.right.right.name == self.left.name
		            && ASSIGN_OPS_COMMUTATIVE.has(self.right.operator)
		            && !self.right.left.has_side_effects(compressor)) {
		            // x = 2 & x  --->  x &= 2
		            self.operator = self.right.operator + "=";
		            self.right = self.right.left;
		        }
		    }
		    return self;

		    function in_try(level, node) {
		        function may_assignment_throw() {
		            const right = self.right;
		            self.right = make_node(AST_Null, right);
		            const may_throw = node.may_throw(compressor);
		            self.right = right;

		            return may_throw;
		        }

		        var stop_at = self.left.definition().scope.get_defun_scope();
		        var parent;
		        while ((parent = compressor.parent(level++)) !== stop_at) {
		            if (parent instanceof AST_Try) {
		                if (parent.bfinally) return true;
		                if (parent.bcatch && may_assignment_throw()) return true;
		            }
		        }
		    }
		});

		def_optimize(AST_DefaultAssign, function(self, compressor) {
		    if (!compressor.option("evaluate")) {
		        return self;
		    }
		    var evaluateRight = self.right.evaluate(compressor);

		    // `[x = undefined] = foo` ---> `[x] = foo`
		    // `(arg = undefined) => ...` ---> `(arg) => ...` (unless `keep_fargs`)
		    // `((arg = undefined) => ...)()` ---> `((arg) => ...)()`
		    let lambda, iife;
		    if (evaluateRight === undefined) {
		        if (
		            (lambda = compressor.parent()) instanceof AST_Lambda
		                ? (
		                    compressor.option("keep_fargs") === false
		                    || (iife = compressor.parent(1)).TYPE === "Call"
		                        && iife.expression === lambda
		                )
		                : true
		        ) {
		            self = self.left;
		        }
		    } else if (evaluateRight !== self.right) {
		        evaluateRight = make_node_from_constant(evaluateRight, self.right);
		        self.right = best_of_expression(evaluateRight, self.right);
		    }

		    return self;
		});

		function is_nullish_check(check, check_subject, compressor) {
		    if (check_subject.may_throw(compressor)) return false;

		    let nullish_side;

		    // foo == null
		    if (
		        check instanceof AST_Binary
		        && check.operator === "=="
		        // which side is nullish?
		        && (
		            (nullish_side = is_nullish(check.left, compressor) && check.left)
		            || (nullish_side = is_nullish(check.right, compressor) && check.right)
		        )
		        // is the other side the same as the check_subject
		        && (
		            nullish_side === check.left
		                ? check.right
		                : check.left
		        ).equivalent_to(check_subject)
		    ) {
		        return true;
		    }

		    // foo === null || foo === undefined
		    if (check instanceof AST_Binary && check.operator === "||") {
		        let null_cmp;
		        let undefined_cmp;

		        const find_comparison = cmp => {
		            if (!(
		                cmp instanceof AST_Binary
		                && (cmp.operator === "===" || cmp.operator === "==")
		            )) {
		                return false;
		            }

		            let found = 0;
		            let defined_side;

		            if (cmp.left instanceof AST_Null) {
		                found++;
		                null_cmp = cmp;
		                defined_side = cmp.right;
		            }
		            if (cmp.right instanceof AST_Null) {
		                found++;
		                null_cmp = cmp;
		                defined_side = cmp.left;
		            }
		            if (is_undefined(cmp.left, compressor)) {
		                found++;
		                undefined_cmp = cmp;
		                defined_side = cmp.right;
		            }
		            if (is_undefined(cmp.right, compressor)) {
		                found++;
		                undefined_cmp = cmp;
		                defined_side = cmp.left;
		            }

		            if (found !== 1) {
		                return false;
		            }

		            if (!defined_side.equivalent_to(check_subject)) {
		                return false;
		            }

		            return true;
		        };

		        if (!find_comparison(check.left)) return false;
		        if (!find_comparison(check.right)) return false;

		        if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {
		            return true;
		        }
		    }

		    return false;
		}

		def_optimize(AST_Conditional, function(self, compressor) {
		    if (!compressor.option("conditionals")) return self;
		    // This looks like lift_sequences(), should probably be under "sequences"
		    if (self.condition instanceof AST_Sequence) {
		        var expressions = self.condition.expressions.slice();
		        self.condition = expressions.pop();
		        expressions.push(self);
		        return make_sequence(self, expressions);
		    }
		    var cond = self.condition.evaluate(compressor);
		    if (cond !== self.condition) {
		        if (cond) {
		            return maintain_this_binding(compressor.parent(), compressor.self(), self.consequent);
		        } else {
		            return maintain_this_binding(compressor.parent(), compressor.self(), self.alternative);
		        }
		    }
		    var negated = cond.negate(compressor, first_in_statement(compressor));
		    if (best_of(compressor, cond, negated) === negated) {
		        self = make_node(AST_Conditional, self, {
		            condition: negated,
		            consequent: self.alternative,
		            alternative: self.consequent
		        });
		    }
		    var condition = self.condition;
		    var consequent = self.consequent;
		    var alternative = self.alternative;
		    // x?x:y --> x||y
		    if (condition instanceof AST_SymbolRef
		        && consequent instanceof AST_SymbolRef
		        && condition.definition() === consequent.definition()) {
		        return make_node(AST_Binary, self, {
		            operator: "||",
		            left: condition,
		            right: alternative
		        });
		    }
		    // if (foo) exp = something; else exp = something_else;
		    //                   |
		    //                   v
		    // exp = foo ? something : something_else;
		    if (
		        consequent instanceof AST_Assign
		        && alternative instanceof AST_Assign
		        && consequent.operator === alternative.operator
		        && consequent.logical === alternative.logical
		        && consequent.left.equivalent_to(alternative.left)
		        && (!self.condition.has_side_effects(compressor)
		            || consequent.operator == "="
		                && !consequent.left.has_side_effects(compressor))
		    ) {
		        return make_node(AST_Assign, self, {
		            operator: consequent.operator,
		            left: consequent.left,
		            logical: consequent.logical,
		            right: make_node(AST_Conditional, self, {
		                condition: self.condition,
		                consequent: consequent.right,
		                alternative: alternative.right
		            })
		        });
		    }
		    // x ? y(a) : y(b) --> y(x ? a : b)
		    var arg_index;
		    if (consequent instanceof AST_Call
		        && alternative.TYPE === consequent.TYPE
		        && consequent.args.length > 0
		        && consequent.args.length == alternative.args.length
		        && consequent.expression.equivalent_to(alternative.expression)
		        && !self.condition.has_side_effects(compressor)
		        && !consequent.expression.has_side_effects(compressor)
		        && typeof (arg_index = single_arg_diff()) == "number") {
		        var node = consequent.clone();
		        node.args[arg_index] = make_node(AST_Conditional, self, {
		            condition: self.condition,
		            consequent: consequent.args[arg_index],
		            alternative: alternative.args[arg_index]
		        });
		        return node;
		    }
		    // a ? b : c ? b : d --> (a || c) ? b : d
		    if (alternative instanceof AST_Conditional
		        && consequent.equivalent_to(alternative.consequent)) {
		        return make_node(AST_Conditional, self, {
		            condition: make_node(AST_Binary, self, {
		                operator: "||",
		                left: condition,
		                right: alternative.condition
		            }),
		            consequent: consequent,
		            alternative: alternative.alternative
		        }).optimize(compressor);
		    }

		    // a == null ? b : a -> a ?? b
		    if (
		        compressor.option("ecma") >= 2020 &&
		        is_nullish_check(condition, alternative, compressor)
		    ) {
		        return make_node(AST_Binary, self, {
		            operator: "??",
		            left: alternative,
		            right: consequent
		        }).optimize(compressor);
		    }

		    // a ? b : (c, b) --> (a || c), b
		    if (alternative instanceof AST_Sequence
		        && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {
		        return make_sequence(self, [
		            make_node(AST_Binary, self, {
		                operator: "||",
		                left: condition,
		                right: make_sequence(self, alternative.expressions.slice(0, -1))
		            }),
		            consequent
		        ]).optimize(compressor);
		    }
		    // a ? b : (c && b) --> (a || c) && b
		    if (alternative instanceof AST_Binary
		        && alternative.operator == "&&"
		        && consequent.equivalent_to(alternative.right)) {
		        return make_node(AST_Binary, self, {
		            operator: "&&",
		            left: make_node(AST_Binary, self, {
		                operator: "||",
		                left: condition,
		                right: alternative.left
		            }),
		            right: consequent
		        }).optimize(compressor);
		    }
		    // x?y?z:a:a --> x&&y?z:a
		    if (consequent instanceof AST_Conditional
		        && consequent.alternative.equivalent_to(alternative)) {
		        return make_node(AST_Conditional, self, {
		            condition: make_node(AST_Binary, self, {
		                left: self.condition,
		                operator: "&&",
		                right: consequent.condition
		            }),
		            consequent: consequent.consequent,
		            alternative: alternative
		        });
		    }
		    // x ? y : y --> x, y
		    if (consequent.equivalent_to(alternative)) {
		        return make_sequence(self, [
		            self.condition,
		            consequent
		        ]).optimize(compressor);
		    }
		    // x ? y || z : z --> x && y || z
		    if (consequent instanceof AST_Binary
		        && consequent.operator == "||"
		        && consequent.right.equivalent_to(alternative)) {
		        return make_node(AST_Binary, self, {
		            operator: "||",
		            left: make_node(AST_Binary, self, {
		                operator: "&&",
		                left: self.condition,
		                right: consequent.left
		            }),
		            right: alternative
		        }).optimize(compressor);
		    }

		    const in_bool = compressor.in_boolean_context();
		    if (is_true(self.consequent)) {
		        if (is_false(self.alternative)) {
		            // c ? true : false ---> !!c
		            return booleanize(self.condition);
		        }
		        // c ? true : x ---> !!c || x
		        return make_node(AST_Binary, self, {
		            operator: "||",
		            left: booleanize(self.condition),
		            right: self.alternative
		        });
		    }
		    if (is_false(self.consequent)) {
		        if (is_true(self.alternative)) {
		            // c ? false : true ---> !c
		            return booleanize(self.condition.negate(compressor));
		        }
		        // c ? false : x ---> !c && x
		        return make_node(AST_Binary, self, {
		            operator: "&&",
		            left: booleanize(self.condition.negate(compressor)),
		            right: self.alternative
		        });
		    }
		    if (is_true(self.alternative)) {
		        // c ? x : true ---> !c || x
		        return make_node(AST_Binary, self, {
		            operator: "||",
		            left: booleanize(self.condition.negate(compressor)),
		            right: self.consequent
		        });
		    }
		    if (is_false(self.alternative)) {
		        // c ? x : false ---> !!c && x
		        return make_node(AST_Binary, self, {
		            operator: "&&",
		            left: booleanize(self.condition),
		            right: self.consequent
		        });
		    }

		    return self;

		    function booleanize(node) {
		        if (node.is_boolean()) return node;
		        // !!expression
		        return make_node(AST_UnaryPrefix, node, {
		            operator: "!",
		            expression: node.negate(compressor)
		        });
		    }

		    // AST_True or !0
		    function is_true(node) {
		        return node instanceof AST_True
		            || in_bool
		                && node instanceof AST_Constant
		                && node.getValue()
		            || (node instanceof AST_UnaryPrefix
		                && node.operator == "!"
		                && node.expression instanceof AST_Constant
		                && !node.expression.getValue());
		    }
		    // AST_False or !1
		    function is_false(node) {
		        return node instanceof AST_False
		            || in_bool
		                && node instanceof AST_Constant
		                && !node.getValue()
		            || (node instanceof AST_UnaryPrefix
		                && node.operator == "!"
		                && node.expression instanceof AST_Constant
		                && node.expression.getValue());
		    }

		    function single_arg_diff() {
		        var a = consequent.args;
		        var b = alternative.args;
		        for (var i = 0, len = a.length; i < len; i++) {
		            if (a[i] instanceof AST_Expansion) return;
		            if (!a[i].equivalent_to(b[i])) {
		                if (b[i] instanceof AST_Expansion) return;
		                for (var j = i + 1; j < len; j++) {
		                    if (a[j] instanceof AST_Expansion) return;
		                    if (!a[j].equivalent_to(b[j])) return;
		                }
		                return i;
		            }
		        }
		    }
		});

		def_optimize(AST_Boolean, function(self, compressor) {
		    if (compressor.in_boolean_context()) return make_node(AST_Number, self, {
		        value: +self.value
		    });
		    var p = compressor.parent();
		    if (compressor.option("booleans_as_integers")) {
		        if (p instanceof AST_Binary && (p.operator == "===" || p.operator == "!==")) {
		            p.operator = p.operator.replace(/=$/, "");
		        }
		        return make_node(AST_Number, self, {
		            value: +self.value
		        });
		    }
		    if (compressor.option("booleans")) {
		        if (p instanceof AST_Binary && (p.operator == "=="
		                                        || p.operator == "!=")) {
		            return make_node(AST_Number, self, {
		                value: +self.value
		            });
		        }
		        return make_node(AST_UnaryPrefix, self, {
		            operator: "!",
		            expression: make_node(AST_Number, self, {
		                value: 1 - self.value
		            })
		        });
		    }
		    return self;
		});

		function safe_to_flatten(value, compressor) {
		    if (value instanceof AST_SymbolRef) {
		        value = value.fixed_value();
		    }
		    if (!value) return false;
		    if (!(value instanceof AST_Lambda || value instanceof AST_Class)) return true;
		    if (!(value instanceof AST_Lambda && value.contains_this())) return true;
		    return compressor.parent() instanceof AST_New;
		}

		AST_PropAccess.DEFMETHOD("flatten_object", function(key, compressor) {
		    if (!compressor.option("properties")) return;
		    if (key === "__proto__") return;

		    var arrows = compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015;
		    var expr = this.expression;
		    if (expr instanceof AST_Object) {
		        var props = expr.properties;

		        for (var i = props.length; --i >= 0;) {
		            var prop = props[i];

		            if ("" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key) {
		                const all_props_flattenable = props.every((p) =>
		                    (p instanceof AST_ObjectKeyVal
		                        || arrows && p instanceof AST_ConciseMethod && !p.is_generator
		                    )
		                    && !p.computed_key()
		                );

		                if (!all_props_flattenable) return;
		                if (!safe_to_flatten(prop.value, compressor)) return;

		                return make_node(AST_Sub, this, {
		                    expression: make_node(AST_Array, expr, {
		                        elements: props.map(function(prop) {
		                            var v = prop.value;
		                            if (v instanceof AST_Accessor) {
		                                v = make_node(AST_Function, v, v);
		                            }

		                            var k = prop.key;
		                            if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {
		                                return make_sequence(prop, [ k, v ]);
		                            }

		                            return v;
		                        })
		                    }),
		                    property: make_node(AST_Number, this, {
		                        value: i
		                    })
		                });
		            }
		        }
		    }
		});

		def_optimize(AST_Sub, function(self, compressor) {
		    var expr = self.expression;
		    var prop = self.property;
		    if (compressor.option("properties")) {
		        var key = prop.evaluate(compressor);
		        if (key !== prop) {
		            if (typeof key == "string") {
		                if (key == "undefined") {
		                    key = undefined;
		                } else {
		                    var value = parseFloat(key);
		                    if (value.toString() == key) {
		                        key = value;
		                    }
		                }
		            }
		            prop = self.property = best_of_expression(
		                prop,
		                make_node_from_constant(key, prop).transform(compressor)
		            );
		            var property = "" + key;
		            if (is_basic_identifier_string(property)
		                && property.length <= prop.size() + 1) {
		                return make_node(AST_Dot, self, {
		                    expression: expr,
		                    optional: self.optional,
		                    property: property,
		                    quote: prop.quote,
		                }).optimize(compressor);
		            }
		        }
		    }
		    var fn;
		    OPT_ARGUMENTS: if (compressor.option("arguments")
		        && expr instanceof AST_SymbolRef
		        && expr.name == "arguments"
		        && expr.definition().orig.length == 1
		        && (fn = expr.scope) instanceof AST_Lambda
		        && fn.uses_arguments
		        && !(fn instanceof AST_Arrow)
		        && prop instanceof AST_Number) {
		        var index = prop.getValue();
		        var params = new Set();
		        var argnames = fn.argnames;
		        for (var n = 0; n < argnames.length; n++) {
		            if (!(argnames[n] instanceof AST_SymbolFunarg)) {
		                break OPT_ARGUMENTS; // destructuring parameter - bail
		            }
		            var param = argnames[n].name;
		            if (params.has(param)) {
		                break OPT_ARGUMENTS; // duplicate parameter - bail
		            }
		            params.add(param);
		        }
		        var argname = fn.argnames[index];
		        if (argname && compressor.has_directive("use strict")) {
		            var def = argname.definition();
		            if (!compressor.option("reduce_vars") || def.assignments || def.orig.length > 1) {
		                argname = null;
		            }
		        } else if (!argname && !compressor.option("keep_fargs") && index < fn.argnames.length + 5) {
		            while (index >= fn.argnames.length) {
		                argname = fn.create_symbol(AST_SymbolFunarg, {
		                    source: fn,
		                    scope: fn,
		                    tentative_name: "argument_" + fn.argnames.length,
		                });
		                fn.argnames.push(argname);
		            }
		        }
		        if (argname) {
		            var sym = make_node(AST_SymbolRef, self, argname);
		            sym.reference({});
		            clear_flag(argname, UNUSED);
		            return sym;
		        }
		    }
		    if (compressor.is_lhs()) return self;
		    if (key !== prop) {
		        var sub = self.flatten_object(property, compressor);
		        if (sub) {
		            expr = self.expression = sub.expression;
		            prop = self.property = sub.property;
		        }
		    }
		    if (compressor.option("properties") && compressor.option("side_effects")
		        && prop instanceof AST_Number && expr instanceof AST_Array) {
		        var index = prop.getValue();
		        var elements = expr.elements;
		        var retValue = elements[index];
		        FLATTEN: if (safe_to_flatten(retValue, compressor)) {
		            var flatten = true;
		            var values = [];
		            for (var i = elements.length; --i > index;) {
		                var value = elements[i].drop_side_effect_free(compressor);
		                if (value) {
		                    values.unshift(value);
		                    if (flatten && value.has_side_effects(compressor)) flatten = false;
		                }
		            }
		            if (retValue instanceof AST_Expansion) break FLATTEN;
		            retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;
		            if (!flatten) values.unshift(retValue);
		            while (--i >= 0) {
		                var value = elements[i];
		                if (value instanceof AST_Expansion) break FLATTEN;
		                value = value.drop_side_effect_free(compressor);
		                if (value) values.unshift(value);
		                else index--;
		            }
		            if (flatten) {
		                values.push(retValue);
		                return make_sequence(self, values).optimize(compressor);
		            } else return make_node(AST_Sub, self, {
		                expression: make_node(AST_Array, expr, {
		                    elements: values
		                }),
		                property: make_node(AST_Number, prop, {
		                    value: index
		                })
		            });
		        }
		    }
		    var ev = self.evaluate(compressor);
		    if (ev !== self) {
		        ev = make_node_from_constant(ev, self).optimize(compressor);
		        return best_of(compressor, ev, self);
		    }
		    return self;
		});

		def_optimize(AST_Chain, function (self, compressor) {
		    if (is_nullish(self.expression, compressor)) {
		        let parent = compressor.parent();
		        // It's valid to delete a nullish optional chain, but if we optimized
		        // this to `delete undefined` then it would appear to be a syntax error
		        // when we try to optimize the delete. Thankfully, `delete 0` is fine.
		        if (parent instanceof AST_UnaryPrefix && parent.operator === "delete") {
		            return make_node_from_constant(0, self);
		        }
		        return make_node(AST_Undefined, self);
		    }
		    return self;
		});

		def_optimize(AST_Dot, function(self, compressor) {
		    const parent = compressor.parent();
		    if (compressor.is_lhs()) return self;
		    if (compressor.option("unsafe_proto")
		        && self.expression instanceof AST_Dot
		        && self.expression.property == "prototype") {
		        var exp = self.expression.expression;
		        if (is_undeclared_ref(exp)) switch (exp.name) {
		          case "Array":
		            self.expression = make_node(AST_Array, self.expression, {
		                elements: []
		            });
		            break;
		          case "Function":
		            self.expression = make_node(AST_Function, self.expression, {
		                argnames: [],
		                body: []
		            });
		            break;
		          case "Number":
		            self.expression = make_node(AST_Number, self.expression, {
		                value: 0
		            });
		            break;
		          case "Object":
		            self.expression = make_node(AST_Object, self.expression, {
		                properties: []
		            });
		            break;
		          case "RegExp":
		            self.expression = make_node(AST_RegExp, self.expression, {
		                value: { source: "t", flags: "" }
		            });
		            break;
		          case "String":
		            self.expression = make_node(AST_String, self.expression, {
		                value: ""
		            });
		            break;
		        }
		    }
		    if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {
		        const sub = self.flatten_object(self.property, compressor);
		        if (sub) return sub.optimize(compressor);
		    }

		    if (self.expression instanceof AST_PropAccess
		        && parent instanceof AST_PropAccess) {
		        return self;
		    }

		    let ev = self.evaluate(compressor);
		    if (ev !== self) {
		        ev = make_node_from_constant(ev, self).optimize(compressor);
		        return best_of(compressor, ev, self);
		    }
		    return self;
		});

		function literals_in_boolean_context(self, compressor) {
		    if (compressor.in_boolean_context()) {
		        return best_of(compressor, self, make_sequence(self, [
		            self,
		            make_node(AST_True, self)
		        ]).optimize(compressor));
		    }
		    return self;
		}

		function inline_array_like_spread(elements) {
		    for (var i = 0; i < elements.length; i++) {
		        var el = elements[i];
		        if (el instanceof AST_Expansion) {
		            var expr = el.expression;
		            if (
		                expr instanceof AST_Array
		                && !expr.elements.some(elm => elm instanceof AST_Hole)
		            ) {
		                elements.splice(i, 1, ...expr.elements);
		                // Step back one, as the element at i is now new.
		                i--;
		            }
		            // In array-like spread, spreading a non-iterable value is TypeError.
		            // We therefore can’t optimize anything else, unlike with object spread.
		        }
		    }
		}

		def_optimize(AST_Array, function(self, compressor) {
		    var optimized = literals_in_boolean_context(self, compressor);
		    if (optimized !== self) {
		        return optimized;
		    }
		    inline_array_like_spread(self.elements);
		    return self;
		});

		function inline_object_prop_spread(props, compressor) {
		    for (var i = 0; i < props.length; i++) {
		        var prop = props[i];
		        if (prop instanceof AST_Expansion) {
		            const expr = prop.expression;
		            if (
		                expr instanceof AST_Object
		                && expr.properties.every(prop => prop instanceof AST_ObjectKeyVal)
		            ) {
		                props.splice(i, 1, ...expr.properties);
		                // Step back one, as the property at i is now new.
		                i--;
		            } else if (expr instanceof AST_Constant
		                && !(expr instanceof AST_String)) {
		                // Unlike array-like spread, in object spread, spreading a
		                // non-iterable value silently does nothing; it is thus safe
		                // to remove. AST_String is the only iterable AST_Constant.
		                props.splice(i, 1);
		                i--;
		            } else if (is_nullish(expr, compressor)) {
		                // Likewise, null and undefined can be silently removed.
		                props.splice(i, 1);
		                i--;
		            }
		        }
		    }
		}

		def_optimize(AST_Object, function(self, compressor) {
		    var optimized = literals_in_boolean_context(self, compressor);
		    if (optimized !== self) {
		        return optimized;
		    }
		    inline_object_prop_spread(self.properties, compressor);
		    return self;
		});

		def_optimize(AST_RegExp, literals_in_boolean_context);

		def_optimize(AST_Return, function(self, compressor) {
		    if (self.value && is_undefined(self.value, compressor)) {
		        self.value = null;
		    }
		    return self;
		});

		def_optimize(AST_Arrow, opt_AST_Lambda);

		def_optimize(AST_Function, function(self, compressor) {
		    self = opt_AST_Lambda(self, compressor);
		    if (compressor.option("unsafe_arrows")
		        && compressor.option("ecma") >= 2015
		        && !self.name
		        && !self.is_generator
		        && !self.uses_arguments
		        && !self.pinned()) {
		        const uses_this = walk(self, node => {
		            if (node instanceof AST_This) return walk_abort;
		        });
		        if (!uses_this) return make_node(AST_Arrow, self, self).optimize(compressor);
		    }
		    return self;
		});

		def_optimize(AST_Class, function(self) {
		    // HACK to avoid compress failure.
		    // AST_Class is not really an AST_Scope/AST_Block as it lacks a body.
		    return self;
		});

		def_optimize(AST_ClassStaticBlock, function(self, compressor) {
		    tighten_body(self.body, compressor);
		    return self;
		});

		def_optimize(AST_Yield, function(self, compressor) {
		    if (self.expression && !self.is_star && is_undefined(self.expression, compressor)) {
		        self.expression = null;
		    }
		    return self;
		});

		def_optimize(AST_TemplateString, function(self, compressor) {
		    if (
		        !compressor.option("evaluate")
		        || compressor.parent() instanceof AST_PrefixedTemplateString
		    ) {
		        return self;
		    }

		    var segments = [];
		    for (var i = 0; i < self.segments.length; i++) {
		        var segment = self.segments[i];
		        if (segment instanceof AST_Node) {
		            var result = segment.evaluate(compressor);
		            // Evaluate to constant value
		            // Constant value shorter than ${segment}
		            if (result !== segment && (result + "").length <= segment.size() + "${}".length) {
		                // There should always be a previous and next segment if segment is a node
		                segments[segments.length - 1].value = segments[segments.length - 1].value + result + self.segments[++i].value;
		                continue;
		            }
		            // `before ${`innerBefore ${any} innerAfter`} after` => `before innerBefore ${any} innerAfter after`
		            // TODO:
		            // `before ${'test' + foo} after` => `before innerBefore ${any} innerAfter after`
		            // `before ${foo + 'test} after` => `before innerBefore ${any} innerAfter after`
		            if (segment instanceof AST_TemplateString) {
		                var inners = segment.segments;
		                segments[segments.length - 1].value += inners[0].value;
		                for (var j = 1; j < inners.length; j++) {
		                    segment = inners[j];
		                    segments.push(segment);
		                }
		                continue;
		            }
		        }
		        segments.push(segment);
		    }
		    self.segments = segments;

		    // `foo` => "foo"
		    if (segments.length == 1) {
		        return make_node(AST_String, self, segments[0]);
		    }

		    if (
		        segments.length === 3
		        && segments[1] instanceof AST_Node
		        && (
		            segments[1].is_string(compressor)
		            || segments[1].is_number(compressor)
		            || is_nullish(segments[1], compressor)
		            || compressor.option("unsafe")
		        )
		    ) {
		        // `foo${bar}` => "foo" + bar
		        if (segments[2].value === "") {
		            return make_node(AST_Binary, self, {
		                operator: "+",
		                left: make_node(AST_String, self, {
		                    value: segments[0].value,
		                }),
		                right: segments[1],
		            });
		        }
		        // `${bar}baz` => bar + "baz"
		        if (segments[0].value === "") {
		            return make_node(AST_Binary, self, {
		                operator: "+",
		                left: segments[1],
		                right: make_node(AST_String, self, {
		                    value: segments[2].value,
		                }),
		            });
		        }
		    }
		    return self;
		});

		def_optimize(AST_PrefixedTemplateString, function(self) {
		    return self;
		});

		// ["p"]:1 ---> p:1
		// [42]:1 ---> 42:1
		function lift_key(self, compressor) {
		    if (!compressor.option("computed_props")) return self;
		    // save a comparison in the typical case
		    if (!(self.key instanceof AST_Constant)) return self;
		    // allow certain acceptable props as not all AST_Constants are true constants
		    if (self.key instanceof AST_String || self.key instanceof AST_Number) {
		        if (self.key.value === "__proto__") return self;
		        if (self.key.value == "constructor"
		            && compressor.parent() instanceof AST_Class) return self;
		        if (self instanceof AST_ObjectKeyVal) {
		            self.quote = self.key.quote;
		            self.key = self.key.value;
		        } else if (self instanceof AST_ClassProperty) {
		            self.quote = self.key.quote;
		            self.key = make_node(AST_SymbolClassProperty, self.key, {
		                name: self.key.value
		            });
		        } else {
		            self.quote = self.key.quote;
		            self.key = make_node(AST_SymbolMethod, self.key, {
		                name: self.key.value
		            });
		        }
		    }
		    return self;
		}

		def_optimize(AST_ObjectProperty, lift_key);

		def_optimize(AST_ConciseMethod, function(self, compressor) {
		    lift_key(self, compressor);
		    // p(){return x;} ---> p:()=>x
		    if (compressor.option("arrows")
		        && compressor.parent() instanceof AST_Object
		        && !self.is_generator
		        && !self.value.uses_arguments
		        && !self.value.pinned()
		        && self.value.body.length == 1
		        && self.value.body[0] instanceof AST_Return
		        && self.value.body[0].value
		        && !self.value.contains_this()) {
		        var arrow = make_node(AST_Arrow, self.value, self.value);
		        arrow.async = self.async;
		        arrow.is_generator = self.is_generator;
		        return make_node(AST_ObjectKeyVal, self, {
		            key: self.key instanceof AST_SymbolMethod ? self.key.name : self.key,
		            value: arrow,
		            quote: self.quote,
		        });
		    }
		    return self;
		});

		def_optimize(AST_ObjectKeyVal, function(self, compressor) {
		    lift_key(self, compressor);
		    // p:function(){} ---> p(){}
		    // p:function*(){} ---> *p(){}
		    // p:async function(){} ---> async p(){}
		    // p:()=>{} ---> p(){}
		    // p:async()=>{} ---> async p(){}
		    var unsafe_methods = compressor.option("unsafe_methods");
		    if (unsafe_methods
		        && compressor.option("ecma") >= 2015
		        && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self.key + ""))) {
		        var key = self.key;
		        var value = self.value;
		        var is_arrow_with_block = value instanceof AST_Arrow
		            && Array.isArray(value.body)
		            && !value.contains_this();
		        if ((is_arrow_with_block || value instanceof AST_Function) && !value.name) {
		            return make_node(AST_ConciseMethod, self, {
		                async: value.async,
		                is_generator: value.is_generator,
		                key: key instanceof AST_Node ? key : make_node(AST_SymbolMethod, self, {
		                    name: key,
		                }),
		                value: make_node(AST_Accessor, value, value),
		                quote: self.quote,
		            });
		        }
		    }
		    return self;
		});

		def_optimize(AST_Destructuring, function(self, compressor) {
		    if (compressor.option("pure_getters") == true
		        && compressor.option("unused")
		        && !self.is_array
		        && Array.isArray(self.names)
		        && !is_destructuring_export_decl(compressor)
		        && !(self.names[self.names.length - 1] instanceof AST_Expansion)) {
		        var keep = [];
		        for (var i = 0; i < self.names.length; i++) {
		            var elem = self.names[i];
		            if (!(elem instanceof AST_ObjectKeyVal
		                && typeof elem.key == "string"
		                && elem.value instanceof AST_SymbolDeclaration
		                && !should_retain(compressor, elem.value.definition()))) {
		                keep.push(elem);
		            }
		        }
		        if (keep.length != self.names.length) {
		            self.names = keep;
		        }
		    }
		    return self;

		    function is_destructuring_export_decl(compressor) {
		        var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];
		        for (var a = 0, p = 0, len = ancestors.length; a < len; p++) {
		            var parent = compressor.parent(p);
		            if (!parent) return false;
		            if (a === 0 && parent.TYPE == "Destructuring") continue;
		            if (!ancestors[a].test(parent.TYPE)) {
		                return false;
		            }
		            a++;
		        }
		        return true;
		    }

		    function should_retain(compressor, def) {
		        if (def.references.length) return true;
		        if (!def.global) return false;
		        if (compressor.toplevel.vars) {
		            if (compressor.top_retain) {
		                return compressor.top_retain(def);
		            }
		            return false;
		        }
		        return true;
		    }
		});

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		// a small wrapper around source-map and @jridgewell/source-map
		async function SourceMap(options) {
		    options = defaults(options, {
		        file : null,
		        root : null,
		        orig : null,
		        files: {},
		    });

		    var orig_map;
		    var generator = new sourceMap.SourceMapGenerator({
		        file       : options.file,
		        sourceRoot : options.root
		    });

		    let sourcesContent = {__proto__: null};
		    let files = options.files;
		    for (var name in files) if (HOP(files, name)) {
		        sourcesContent[name] = files[name];
		    }
		    if (options.orig) {
		        // We support both @jridgewell/source-map (which has a sync
		        // SourceMapConsumer) and source-map (which has an async
		        // SourceMapConsumer).
		        orig_map = await new sourceMap.SourceMapConsumer(options.orig);
		        if (orig_map.sourcesContent) {
		            orig_map.sources.forEach(function(source, i) {
		                var content = orig_map.sourcesContent[i];
		                if (content) {
		                    sourcesContent[source] = content;
		                }
		            });
		        }
		    }

		    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
		        let generatedPos = { line: gen_line, column: gen_col };

		        if (orig_map) {
		            var info = orig_map.originalPositionFor({
		                line: orig_line,
		                column: orig_col
		            });
		            if (info.source === null) {
		                generator.addMapping({
		                    generated: generatedPos,
		                    original: null,
		                    source: null,
		                    name: null
		                });
		                return;
		            }
		            source = info.source;
		            orig_line = info.line;
		            orig_col = info.column;
		            name = info.name || name;
		        }
		        generator.addMapping({
		            generated : generatedPos,
		            original  : { line: orig_line, column: orig_col },
		            source    : source,
		            name      : name
		        });
		        generator.setSourceContent(source, sourcesContent[source]);
		    }

		    function clean(map) {
		        const allNull = map.sourcesContent && map.sourcesContent.every(c => c == null);
		        if (allNull) delete map.sourcesContent;
		        if (map.file === undefined) delete map.file;
		        if (map.sourceRoot === undefined) delete map.sourceRoot;
		        return map;
		    }

		    function getDecoded() {
		        if (!generator.toDecodedMap) return null;
		        return clean(generator.toDecodedMap());
		    }

		    function getEncoded() {
		        return clean(generator.toJSON());
		    }

		    function destroy() {
		        // @jridgewell/source-map's SourceMapConsumer does not need to be
		        // manually freed.
		        if (orig_map && orig_map.destroy) orig_map.destroy();
		    }

		    return {
		        add,
		        getDecoded,
		        getEncoded,
		        destroy,
		    };
		}

		var domprops = [
		    "$&",
		    "$'",
		    "$*",
		    "$+",
		    "$1",
		    "$2",
		    "$3",
		    "$4",
		    "$5",
		    "$6",
		    "$7",
		    "$8",
		    "$9",
		    "$_",
		    "$`",
		    "$input",
		    "-moz-animation",
		    "-moz-animation-delay",
		    "-moz-animation-direction",
		    "-moz-animation-duration",
		    "-moz-animation-fill-mode",
		    "-moz-animation-iteration-count",
		    "-moz-animation-name",
		    "-moz-animation-play-state",
		    "-moz-animation-timing-function",
		    "-moz-appearance",
		    "-moz-backface-visibility",
		    "-moz-border-end",
		    "-moz-border-end-color",
		    "-moz-border-end-style",
		    "-moz-border-end-width",
		    "-moz-border-image",
		    "-moz-border-start",
		    "-moz-border-start-color",
		    "-moz-border-start-style",
		    "-moz-border-start-width",
		    "-moz-box-align",
		    "-moz-box-direction",
		    "-moz-box-flex",
		    "-moz-box-ordinal-group",
		    "-moz-box-orient",
		    "-moz-box-pack",
		    "-moz-box-sizing",
		    "-moz-float-edge",
		    "-moz-font-feature-settings",
		    "-moz-font-language-override",
		    "-moz-force-broken-image-icon",
		    "-moz-hyphens",
		    "-moz-image-region",
		    "-moz-margin-end",
		    "-moz-margin-start",
		    "-moz-orient",
		    "-moz-osx-font-smoothing",
		    "-moz-outline-radius",
		    "-moz-outline-radius-bottomleft",
		    "-moz-outline-radius-bottomright",
		    "-moz-outline-radius-topleft",
		    "-moz-outline-radius-topright",
		    "-moz-padding-end",
		    "-moz-padding-start",
		    "-moz-perspective",
		    "-moz-perspective-origin",
		    "-moz-tab-size",
		    "-moz-text-size-adjust",
		    "-moz-transform",
		    "-moz-transform-origin",
		    "-moz-transform-style",
		    "-moz-transition",
		    "-moz-transition-delay",
		    "-moz-transition-duration",
		    "-moz-transition-property",
		    "-moz-transition-timing-function",
		    "-moz-user-focus",
		    "-moz-user-input",
		    "-moz-user-modify",
		    "-moz-user-select",
		    "-moz-window-dragging",
		    "-webkit-align-content",
		    "-webkit-align-items",
		    "-webkit-align-self",
		    "-webkit-animation",
		    "-webkit-animation-delay",
		    "-webkit-animation-direction",
		    "-webkit-animation-duration",
		    "-webkit-animation-fill-mode",
		    "-webkit-animation-iteration-count",
		    "-webkit-animation-name",
		    "-webkit-animation-play-state",
		    "-webkit-animation-timing-function",
		    "-webkit-appearance",
		    "-webkit-backface-visibility",
		    "-webkit-background-clip",
		    "-webkit-background-origin",
		    "-webkit-background-size",
		    "-webkit-border-bottom-left-radius",
		    "-webkit-border-bottom-right-radius",
		    "-webkit-border-image",
		    "-webkit-border-radius",
		    "-webkit-border-top-left-radius",
		    "-webkit-border-top-right-radius",
		    "-webkit-box-align",
		    "-webkit-box-direction",
		    "-webkit-box-flex",
		    "-webkit-box-ordinal-group",
		    "-webkit-box-orient",
		    "-webkit-box-pack",
		    "-webkit-box-shadow",
		    "-webkit-box-sizing",
		    "-webkit-filter",
		    "-webkit-flex",
		    "-webkit-flex-basis",
		    "-webkit-flex-direction",
		    "-webkit-flex-flow",
		    "-webkit-flex-grow",
		    "-webkit-flex-shrink",
		    "-webkit-flex-wrap",
		    "-webkit-justify-content",
		    "-webkit-line-clamp",
		    "-webkit-mask",
		    "-webkit-mask-clip",
		    "-webkit-mask-composite",
		    "-webkit-mask-image",
		    "-webkit-mask-origin",
		    "-webkit-mask-position",
		    "-webkit-mask-position-x",
		    "-webkit-mask-position-y",
		    "-webkit-mask-repeat",
		    "-webkit-mask-size",
		    "-webkit-order",
		    "-webkit-perspective",
		    "-webkit-perspective-origin",
		    "-webkit-text-fill-color",
		    "-webkit-text-size-adjust",
		    "-webkit-text-stroke",
		    "-webkit-text-stroke-color",
		    "-webkit-text-stroke-width",
		    "-webkit-transform",
		    "-webkit-transform-origin",
		    "-webkit-transform-style",
		    "-webkit-transition",
		    "-webkit-transition-delay",
		    "-webkit-transition-duration",
		    "-webkit-transition-property",
		    "-webkit-transition-timing-function",
		    "-webkit-user-select",
		    "0",
		    "1",
		    "10",
		    "11",
		    "12",
		    "13",
		    "14",
		    "15",
		    "16",
		    "17",
		    "18",
		    "19",
		    "2",
		    "20",
		    "3",
		    "4",
		    "5",
		    "6",
		    "7",
		    "8",
		    "9",
		    "@@iterator",
		    "ABORT_ERR",
		    "ACTIVE",
		    "ACTIVE_ATTRIBUTES",
		    "ACTIVE_TEXTURE",
		    "ACTIVE_UNIFORMS",
		    "ACTIVE_UNIFORM_BLOCKS",
		    "ADDITION",
		    "ALIASED_LINE_WIDTH_RANGE",
		    "ALIASED_POINT_SIZE_RANGE",
		    "ALL",
		    "ALLOW_KEYBOARD_INPUT",
		    "ALLPASS",
		    "ALPHA",
		    "ALPHA_BITS",
		    "ALREADY_SIGNALED",
		    "ALT_MASK",
		    "ALWAYS",
		    "ANY_SAMPLES_PASSED",
		    "ANY_SAMPLES_PASSED_CONSERVATIVE",
		    "ANY_TYPE",
		    "ANY_UNORDERED_NODE_TYPE",
		    "ARRAY_BUFFER",
		    "ARRAY_BUFFER_BINDING",
		    "ATTACHED_SHADERS",
		    "ATTRIBUTE_NODE",
		    "AT_TARGET",
		    "AbortController",
		    "AbortSignal",
		    "AbsoluteOrientationSensor",
		    "AbstractRange",
		    "Accelerometer",
		    "AddSearchProvider",
		    "AggregateError",
		    "AnalyserNode",
		    "Animation",
		    "AnimationEffect",
		    "AnimationEvent",
		    "AnimationPlaybackEvent",
		    "AnimationTimeline",
		    "AnonXMLHttpRequest",
		    "Any",
		    "ApplicationCache",
		    "ApplicationCacheErrorEvent",
		    "Array",
		    "ArrayBuffer",
		    "ArrayType",
		    "Atomics",
		    "Attr",
		    "Audio",
		    "AudioBuffer",
		    "AudioBufferSourceNode",
		    "AudioContext",
		    "AudioDestinationNode",
		    "AudioListener",
		    "AudioNode",
		    "AudioParam",
		    "AudioParamMap",
		    "AudioProcessingEvent",
		    "AudioScheduledSourceNode",
		    "AudioStreamTrack",
		    "AudioWorklet",
		    "AudioWorkletNode",
		    "AuthenticatorAssertionResponse",
		    "AuthenticatorAttestationResponse",
		    "AuthenticatorResponse",
		    "AutocompleteErrorEvent",
		    "BACK",
		    "BAD_BOUNDARYPOINTS_ERR",
		    "BAD_REQUEST",
		    "BANDPASS",
		    "BLEND",
		    "BLEND_COLOR",
		    "BLEND_DST_ALPHA",
		    "BLEND_DST_RGB",
		    "BLEND_EQUATION",
		    "BLEND_EQUATION_ALPHA",
		    "BLEND_EQUATION_RGB",
		    "BLEND_SRC_ALPHA",
		    "BLEND_SRC_RGB",
		    "BLUE",
		    "BLUE_BITS",
		    "BLUR",
		    "BOOL",
		    "BOOLEAN_TYPE",
		    "BOOL_VEC2",
		    "BOOL_VEC3",
		    "BOOL_VEC4",
		    "BOTH",
		    "BROWSER_DEFAULT_WEBGL",
		    "BUBBLING_PHASE",
		    "BUFFER_SIZE",
		    "BUFFER_USAGE",
		    "BYTE",
		    "BYTES_PER_ELEMENT",
		    "BackgroundFetchManager",
		    "BackgroundFetchRecord",
		    "BackgroundFetchRegistration",
		    "BarProp",
		    "BarcodeDetector",
		    "BaseAudioContext",
		    "BaseHref",
		    "BatteryManager",
		    "BeforeInstallPromptEvent",
		    "BeforeLoadEvent",
		    "BeforeUnloadEvent",
		    "BigInt",
		    "BigInt64Array",
		    "BigUint64Array",
		    "BiquadFilterNode",
		    "Blob",
		    "BlobEvent",
		    "Bluetooth",
		    "BluetoothCharacteristicProperties",
		    "BluetoothDevice",
		    "BluetoothRemoteGATTCharacteristic",
		    "BluetoothRemoteGATTDescriptor",
		    "BluetoothRemoteGATTServer",
		    "BluetoothRemoteGATTService",
		    "BluetoothUUID",
		    "Boolean",
		    "BroadcastChannel",
		    "ByteLengthQueuingStrategy",
		    "CAPTURING_PHASE",
		    "CCW",
		    "CDATASection",
		    "CDATA_SECTION_NODE",
		    "CHANGE",
		    "CHARSET_RULE",
		    "CHECKING",
		    "CLAMP_TO_EDGE",
		    "CLICK",
		    "CLOSED",
		    "CLOSING",
		    "COLOR",
		    "COLOR_ATTACHMENT0",
		    "COLOR_ATTACHMENT1",
		    "COLOR_ATTACHMENT10",
		    "COLOR_ATTACHMENT11",
		    "COLOR_ATTACHMENT12",
		    "COLOR_ATTACHMENT13",
		    "COLOR_ATTACHMENT14",
		    "COLOR_ATTACHMENT15",
		    "COLOR_ATTACHMENT2",
		    "COLOR_ATTACHMENT3",
		    "COLOR_ATTACHMENT4",
		    "COLOR_ATTACHMENT5",
		    "COLOR_ATTACHMENT6",
		    "COLOR_ATTACHMENT7",
		    "COLOR_ATTACHMENT8",
		    "COLOR_ATTACHMENT9",
		    "COLOR_BUFFER_BIT",
		    "COLOR_CLEAR_VALUE",
		    "COLOR_WRITEMASK",
		    "COMMENT_NODE",
		    "COMPARE_REF_TO_TEXTURE",
		    "COMPILE_STATUS",
		    "COMPLETION_STATUS_KHR",
		    "COMPRESSED_RGBA_S3TC_DXT1_EXT",
		    "COMPRESSED_RGBA_S3TC_DXT3_EXT",
		    "COMPRESSED_RGBA_S3TC_DXT5_EXT",
		    "COMPRESSED_RGB_S3TC_DXT1_EXT",
		    "COMPRESSED_TEXTURE_FORMATS",
		    "COMPUTE",
		    "CONDITION_SATISFIED",
		    "CONFIGURATION_UNSUPPORTED",
		    "CONNECTING",
		    "CONSTANT_ALPHA",
		    "CONSTANT_COLOR",
		    "CONSTRAINT_ERR",
		    "CONTEXT_LOST_WEBGL",
		    "CONTROL_MASK",
		    "COPY_DST",
		    "COPY_READ_BUFFER",
		    "COPY_READ_BUFFER_BINDING",
		    "COPY_SRC",
		    "COPY_WRITE_BUFFER",
		    "COPY_WRITE_BUFFER_BINDING",
		    "COUNTER_STYLE_RULE",
		    "CSS",
		    "CSS2Properties",
		    "CSSAnimation",
		    "CSSCharsetRule",
		    "CSSConditionRule",
		    "CSSCounterStyleRule",
		    "CSSFontFaceRule",
		    "CSSFontFeatureValuesRule",
		    "CSSGroupingRule",
		    "CSSImageValue",
		    "CSSImportRule",
		    "CSSKeyframeRule",
		    "CSSKeyframesRule",
		    "CSSKeywordValue",
		    "CSSMathInvert",
		    "CSSMathMax",
		    "CSSMathMin",
		    "CSSMathNegate",
		    "CSSMathProduct",
		    "CSSMathSum",
		    "CSSMathValue",
		    "CSSMatrixComponent",
		    "CSSMediaRule",
		    "CSSMozDocumentRule",
		    "CSSNameSpaceRule",
		    "CSSNamespaceRule",
		    "CSSNumericArray",
		    "CSSNumericValue",
		    "CSSPageRule",
		    "CSSPerspective",
		    "CSSPositionValue",
		    "CSSPrimitiveValue",
		    "CSSRotate",
		    "CSSRule",
		    "CSSRuleList",
		    "CSSScale",
		    "CSSSkew",
		    "CSSSkewX",
		    "CSSSkewY",
		    "CSSStyleDeclaration",
		    "CSSStyleRule",
		    "CSSStyleSheet",
		    "CSSStyleValue",
		    "CSSSupportsRule",
		    "CSSTransformComponent",
		    "CSSTransformValue",
		    "CSSTransition",
		    "CSSTranslate",
		    "CSSUnitValue",
		    "CSSUnknownRule",
		    "CSSUnparsedValue",
		    "CSSValue",
		    "CSSValueList",
		    "CSSVariableReferenceValue",
		    "CSSVariablesDeclaration",
		    "CSSVariablesRule",
		    "CSSViewportRule",
		    "CSS_ATTR",
		    "CSS_CM",
		    "CSS_COUNTER",
		    "CSS_CUSTOM",
		    "CSS_DEG",
		    "CSS_DIMENSION",
		    "CSS_EMS",
		    "CSS_EXS",
		    "CSS_FILTER_BLUR",
		    "CSS_FILTER_BRIGHTNESS",
		    "CSS_FILTER_CONTRAST",
		    "CSS_FILTER_CUSTOM",
		    "CSS_FILTER_DROP_SHADOW",
		    "CSS_FILTER_GRAYSCALE",
		    "CSS_FILTER_HUE_ROTATE",
		    "CSS_FILTER_INVERT",
		    "CSS_FILTER_OPACITY",
		    "CSS_FILTER_REFERENCE",
		    "CSS_FILTER_SATURATE",
		    "CSS_FILTER_SEPIA",
		    "CSS_GRAD",
		    "CSS_HZ",
		    "CSS_IDENT",
		    "CSS_IN",
		    "CSS_INHERIT",
		    "CSS_KHZ",
		    "CSS_MATRIX",
		    "CSS_MATRIX3D",
		    "CSS_MM",
		    "CSS_MS",
		    "CSS_NUMBER",
		    "CSS_PC",
		    "CSS_PERCENTAGE",
		    "CSS_PERSPECTIVE",
		    "CSS_PRIMITIVE_VALUE",
		    "CSS_PT",
		    "CSS_PX",
		    "CSS_RAD",
		    "CSS_RECT",
		    "CSS_RGBCOLOR",
		    "CSS_ROTATE",
		    "CSS_ROTATE3D",
		    "CSS_ROTATEX",
		    "CSS_ROTATEY",
		    "CSS_ROTATEZ",
		    "CSS_S",
		    "CSS_SCALE",
		    "CSS_SCALE3D",
		    "CSS_SCALEX",
		    "CSS_SCALEY",
		    "CSS_SCALEZ",
		    "CSS_SKEW",
		    "CSS_SKEWX",
		    "CSS_SKEWY",
		    "CSS_STRING",
		    "CSS_TRANSLATE",
		    "CSS_TRANSLATE3D",
		    "CSS_TRANSLATEX",
		    "CSS_TRANSLATEY",
		    "CSS_TRANSLATEZ",
		    "CSS_UNKNOWN",
		    "CSS_URI",
		    "CSS_VALUE_LIST",
		    "CSS_VH",
		    "CSS_VMAX",
		    "CSS_VMIN",
		    "CSS_VW",
		    "CULL_FACE",
		    "CULL_FACE_MODE",
		    "CURRENT_PROGRAM",
		    "CURRENT_QUERY",
		    "CURRENT_VERTEX_ATTRIB",
		    "CUSTOM",
		    "CW",
		    "Cache",
		    "CacheStorage",
		    "CanvasCaptureMediaStream",
		    "CanvasCaptureMediaStreamTrack",
		    "CanvasGradient",
		    "CanvasPattern",
		    "CanvasRenderingContext2D",
		    "CaretPosition",
		    "ChannelMergerNode",
		    "ChannelSplitterNode",
		    "CharacterData",
		    "ClientRect",
		    "ClientRectList",
		    "Clipboard",
		    "ClipboardEvent",
		    "ClipboardItem",
		    "CloseEvent",
		    "Collator",
		    "CommandEvent",
		    "Comment",
		    "CompileError",
		    "CompositionEvent",
		    "CompressionStream",
		    "Console",
		    "ConstantSourceNode",
		    "Controllers",
		    "ConvolverNode",
		    "CountQueuingStrategy",
		    "Counter",
		    "Credential",
		    "CredentialsContainer",
		    "Crypto",
		    "CryptoKey",
		    "CustomElementRegistry",
		    "CustomEvent",
		    "DATABASE_ERR",
		    "DATA_CLONE_ERR",
		    "DATA_ERR",
		    "DBLCLICK",
		    "DECR",
		    "DECR_WRAP",
		    "DELETE_STATUS",
		    "DEPTH",
		    "DEPTH24_STENCIL8",
		    "DEPTH32F_STENCIL8",
		    "DEPTH_ATTACHMENT",
		    "DEPTH_BITS",
		    "DEPTH_BUFFER_BIT",
		    "DEPTH_CLEAR_VALUE",
		    "DEPTH_COMPONENT",
		    "DEPTH_COMPONENT16",
		    "DEPTH_COMPONENT24",
		    "DEPTH_COMPONENT32F",
		    "DEPTH_FUNC",
		    "DEPTH_RANGE",
		    "DEPTH_STENCIL",
		    "DEPTH_STENCIL_ATTACHMENT",
		    "DEPTH_TEST",
		    "DEPTH_WRITEMASK",
		    "DEVICE_INELIGIBLE",
		    "DIRECTION_DOWN",
		    "DIRECTION_LEFT",
		    "DIRECTION_RIGHT",
		    "DIRECTION_UP",
		    "DISABLED",
		    "DISPATCH_REQUEST_ERR",
		    "DITHER",
		    "DOCUMENT_FRAGMENT_NODE",
		    "DOCUMENT_NODE",
		    "DOCUMENT_POSITION_CONTAINED_BY",
		    "DOCUMENT_POSITION_CONTAINS",
		    "DOCUMENT_POSITION_DISCONNECTED",
		    "DOCUMENT_POSITION_FOLLOWING",
		    "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
		    "DOCUMENT_POSITION_PRECEDING",
		    "DOCUMENT_TYPE_NODE",
		    "DOMCursor",
		    "DOMError",
		    "DOMException",
		    "DOMImplementation",
		    "DOMImplementationLS",
		    "DOMMatrix",
		    "DOMMatrixReadOnly",
		    "DOMParser",
		    "DOMPoint",
		    "DOMPointReadOnly",
		    "DOMQuad",
		    "DOMRect",
		    "DOMRectList",
		    "DOMRectReadOnly",
		    "DOMRequest",
		    "DOMSTRING_SIZE_ERR",
		    "DOMSettableTokenList",
		    "DOMStringList",
		    "DOMStringMap",
		    "DOMTokenList",
		    "DOMTransactionEvent",
		    "DOM_DELTA_LINE",
		    "DOM_DELTA_PAGE",
		    "DOM_DELTA_PIXEL",
		    "DOM_INPUT_METHOD_DROP",
		    "DOM_INPUT_METHOD_HANDWRITING",
		    "DOM_INPUT_METHOD_IME",
		    "DOM_INPUT_METHOD_KEYBOARD",
		    "DOM_INPUT_METHOD_MULTIMODAL",
		    "DOM_INPUT_METHOD_OPTION",
		    "DOM_INPUT_METHOD_PASTE",
		    "DOM_INPUT_METHOD_SCRIPT",
		    "DOM_INPUT_METHOD_UNKNOWN",
		    "DOM_INPUT_METHOD_VOICE",
		    "DOM_KEY_LOCATION_JOYSTICK",
		    "DOM_KEY_LOCATION_LEFT",
		    "DOM_KEY_LOCATION_MOBILE",
		    "DOM_KEY_LOCATION_NUMPAD",
		    "DOM_KEY_LOCATION_RIGHT",
		    "DOM_KEY_LOCATION_STANDARD",
		    "DOM_VK_0",
		    "DOM_VK_1",
		    "DOM_VK_2",
		    "DOM_VK_3",
		    "DOM_VK_4",
		    "DOM_VK_5",
		    "DOM_VK_6",
		    "DOM_VK_7",
		    "DOM_VK_8",
		    "DOM_VK_9",
		    "DOM_VK_A",
		    "DOM_VK_ACCEPT",
		    "DOM_VK_ADD",
		    "DOM_VK_ALT",
		    "DOM_VK_ALTGR",
		    "DOM_VK_AMPERSAND",
		    "DOM_VK_ASTERISK",
		    "DOM_VK_AT",
		    "DOM_VK_ATTN",
		    "DOM_VK_B",
		    "DOM_VK_BACKSPACE",
		    "DOM_VK_BACK_QUOTE",
		    "DOM_VK_BACK_SLASH",
		    "DOM_VK_BACK_SPACE",
		    "DOM_VK_C",
		    "DOM_VK_CANCEL",
		    "DOM_VK_CAPS_LOCK",
		    "DOM_VK_CIRCUMFLEX",
		    "DOM_VK_CLEAR",
		    "DOM_VK_CLOSE_BRACKET",
		    "DOM_VK_CLOSE_CURLY_BRACKET",
		    "DOM_VK_CLOSE_PAREN",
		    "DOM_VK_COLON",
		    "DOM_VK_COMMA",
		    "DOM_VK_CONTEXT_MENU",
		    "DOM_VK_CONTROL",
		    "DOM_VK_CONVERT",
		    "DOM_VK_CRSEL",
		    "DOM_VK_CTRL",
		    "DOM_VK_D",
		    "DOM_VK_DECIMAL",
		    "DOM_VK_DELETE",
		    "DOM_VK_DIVIDE",
		    "DOM_VK_DOLLAR",
		    "DOM_VK_DOUBLE_QUOTE",
		    "DOM_VK_DOWN",
		    "DOM_VK_E",
		    "DOM_VK_EISU",
		    "DOM_VK_END",
		    "DOM_VK_ENTER",
		    "DOM_VK_EQUALS",
		    "DOM_VK_EREOF",
		    "DOM_VK_ESCAPE",
		    "DOM_VK_EXCLAMATION",
		    "DOM_VK_EXECUTE",
		    "DOM_VK_EXSEL",
		    "DOM_VK_F",
		    "DOM_VK_F1",
		    "DOM_VK_F10",
		    "DOM_VK_F11",
		    "DOM_VK_F12",
		    "DOM_VK_F13",
		    "DOM_VK_F14",
		    "DOM_VK_F15",
		    "DOM_VK_F16",
		    "DOM_VK_F17",
		    "DOM_VK_F18",
		    "DOM_VK_F19",
		    "DOM_VK_F2",
		    "DOM_VK_F20",
		    "DOM_VK_F21",
		    "DOM_VK_F22",
		    "DOM_VK_F23",
		    "DOM_VK_F24",
		    "DOM_VK_F25",
		    "DOM_VK_F26",
		    "DOM_VK_F27",
		    "DOM_VK_F28",
		    "DOM_VK_F29",
		    "DOM_VK_F3",
		    "DOM_VK_F30",
		    "DOM_VK_F31",
		    "DOM_VK_F32",
		    "DOM_VK_F33",
		    "DOM_VK_F34",
		    "DOM_VK_F35",
		    "DOM_VK_F36",
		    "DOM_VK_F4",
		    "DOM_VK_F5",
		    "DOM_VK_F6",
		    "DOM_VK_F7",
		    "DOM_VK_F8",
		    "DOM_VK_F9",
		    "DOM_VK_FINAL",
		    "DOM_VK_FRONT",
		    "DOM_VK_G",
		    "DOM_VK_GREATER_THAN",
		    "DOM_VK_H",
		    "DOM_VK_HANGUL",
		    "DOM_VK_HANJA",
		    "DOM_VK_HASH",
		    "DOM_VK_HELP",
		    "DOM_VK_HK_TOGGLE",
		    "DOM_VK_HOME",
		    "DOM_VK_HYPHEN_MINUS",
		    "DOM_VK_I",
		    "DOM_VK_INSERT",
		    "DOM_VK_J",
		    "DOM_VK_JUNJA",
		    "DOM_VK_K",
		    "DOM_VK_KANA",
		    "DOM_VK_KANJI",
		    "DOM_VK_L",
		    "DOM_VK_LEFT",
		    "DOM_VK_LEFT_TAB",
		    "DOM_VK_LESS_THAN",
		    "DOM_VK_M",
		    "DOM_VK_META",
		    "DOM_VK_MODECHANGE",
		    "DOM_VK_MULTIPLY",
		    "DOM_VK_N",
		    "DOM_VK_NONCONVERT",
		    "DOM_VK_NUMPAD0",
		    "DOM_VK_NUMPAD1",
		    "DOM_VK_NUMPAD2",
		    "DOM_VK_NUMPAD3",
		    "DOM_VK_NUMPAD4",
		    "DOM_VK_NUMPAD5",
		    "DOM_VK_NUMPAD6",
		    "DOM_VK_NUMPAD7",
		    "DOM_VK_NUMPAD8",
		    "DOM_VK_NUMPAD9",
		    "DOM_VK_NUM_LOCK",
		    "DOM_VK_O",
		    "DOM_VK_OEM_1",
		    "DOM_VK_OEM_102",
		    "DOM_VK_OEM_2",
		    "DOM_VK_OEM_3",
		    "DOM_VK_OEM_4",
		    "DOM_VK_OEM_5",
		    "DOM_VK_OEM_6",
		    "DOM_VK_OEM_7",
		    "DOM_VK_OEM_8",
		    "DOM_VK_OEM_COMMA",
		    "DOM_VK_OEM_MINUS",
		    "DOM_VK_OEM_PERIOD",
		    "DOM_VK_OEM_PLUS",
		    "DOM_VK_OPEN_BRACKET",
		    "DOM_VK_OPEN_CURLY_BRACKET",
		    "DOM_VK_OPEN_PAREN",
		    "DOM_VK_P",
		    "DOM_VK_PA1",
		    "DOM_VK_PAGEDOWN",
		    "DOM_VK_PAGEUP",
		    "DOM_VK_PAGE_DOWN",
		    "DOM_VK_PAGE_UP",
		    "DOM_VK_PAUSE",
		    "DOM_VK_PERCENT",
		    "DOM_VK_PERIOD",
		    "DOM_VK_PIPE",
		    "DOM_VK_PLAY",
		    "DOM_VK_PLUS",
		    "DOM_VK_PRINT",
		    "DOM_VK_PRINTSCREEN",
		    "DOM_VK_PROCESSKEY",
		    "DOM_VK_PROPERITES",
		    "DOM_VK_Q",
		    "DOM_VK_QUESTION_MARK",
		    "DOM_VK_QUOTE",
		    "DOM_VK_R",
		    "DOM_VK_REDO",
		    "DOM_VK_RETURN",
		    "DOM_VK_RIGHT",
		    "DOM_VK_S",
		    "DOM_VK_SCROLL_LOCK",
		    "DOM_VK_SELECT",
		    "DOM_VK_SEMICOLON",
		    "DOM_VK_SEPARATOR",
		    "DOM_VK_SHIFT",
		    "DOM_VK_SLASH",
		    "DOM_VK_SLEEP",
		    "DOM_VK_SPACE",
		    "DOM_VK_SUBTRACT",
		    "DOM_VK_T",
		    "DOM_VK_TAB",
		    "DOM_VK_TILDE",
		    "DOM_VK_U",
		    "DOM_VK_UNDERSCORE",
		    "DOM_VK_UNDO",
		    "DOM_VK_UNICODE",
		    "DOM_VK_UP",
		    "DOM_VK_V",
		    "DOM_VK_VOLUME_DOWN",
		    "DOM_VK_VOLUME_MUTE",
		    "DOM_VK_VOLUME_UP",
		    "DOM_VK_W",
		    "DOM_VK_WIN",
		    "DOM_VK_WINDOW",
		    "DOM_VK_WIN_ICO_00",
		    "DOM_VK_WIN_ICO_CLEAR",
		    "DOM_VK_WIN_ICO_HELP",
		    "DOM_VK_WIN_OEM_ATTN",
		    "DOM_VK_WIN_OEM_AUTO",
		    "DOM_VK_WIN_OEM_BACKTAB",
		    "DOM_VK_WIN_OEM_CLEAR",
		    "DOM_VK_WIN_OEM_COPY",
		    "DOM_VK_WIN_OEM_CUSEL",
		    "DOM_VK_WIN_OEM_ENLW",
		    "DOM_VK_WIN_OEM_FINISH",
		    "DOM_VK_WIN_OEM_FJ_JISHO",
		    "DOM_VK_WIN_OEM_FJ_LOYA",
		    "DOM_VK_WIN_OEM_FJ_MASSHOU",
		    "DOM_VK_WIN_OEM_FJ_ROYA",
		    "DOM_VK_WIN_OEM_FJ_TOUROKU",
		    "DOM_VK_WIN_OEM_JUMP",
		    "DOM_VK_WIN_OEM_PA1",
		    "DOM_VK_WIN_OEM_PA2",
		    "DOM_VK_WIN_OEM_PA3",
		    "DOM_VK_WIN_OEM_RESET",
		    "DOM_VK_WIN_OEM_WSCTRL",
		    "DOM_VK_X",
		    "DOM_VK_XF86XK_ADD_FAVORITE",
		    "DOM_VK_XF86XK_APPLICATION_LEFT",
		    "DOM_VK_XF86XK_APPLICATION_RIGHT",
		    "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
		    "DOM_VK_XF86XK_AUDIO_FORWARD",
		    "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
		    "DOM_VK_XF86XK_AUDIO_MEDIA",
		    "DOM_VK_XF86XK_AUDIO_MUTE",
		    "DOM_VK_XF86XK_AUDIO_NEXT",
		    "DOM_VK_XF86XK_AUDIO_PAUSE",
		    "DOM_VK_XF86XK_AUDIO_PLAY",
		    "DOM_VK_XF86XK_AUDIO_PREV",
		    "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
		    "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
		    "DOM_VK_XF86XK_AUDIO_RECORD",
		    "DOM_VK_XF86XK_AUDIO_REPEAT",
		    "DOM_VK_XF86XK_AUDIO_REWIND",
		    "DOM_VK_XF86XK_AUDIO_STOP",
		    "DOM_VK_XF86XK_AWAY",
		    "DOM_VK_XF86XK_BACK",
		    "DOM_VK_XF86XK_BACK_FORWARD",
		    "DOM_VK_XF86XK_BATTERY",
		    "DOM_VK_XF86XK_BLUE",
		    "DOM_VK_XF86XK_BLUETOOTH",
		    "DOM_VK_XF86XK_BOOK",
		    "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
		    "DOM_VK_XF86XK_CALCULATOR",
		    "DOM_VK_XF86XK_CALENDAR",
		    "DOM_VK_XF86XK_CD",
		    "DOM_VK_XF86XK_CLOSE",
		    "DOM_VK_XF86XK_COMMUNITY",
		    "DOM_VK_XF86XK_CONTRAST_ADJUST",
		    "DOM_VK_XF86XK_COPY",
		    "DOM_VK_XF86XK_CUT",
		    "DOM_VK_XF86XK_CYCLE_ANGLE",
		    "DOM_VK_XF86XK_DISPLAY",
		    "DOM_VK_XF86XK_DOCUMENTS",
		    "DOM_VK_XF86XK_DOS",
		    "DOM_VK_XF86XK_EJECT",
		    "DOM_VK_XF86XK_EXCEL",
		    "DOM_VK_XF86XK_EXPLORER",
		    "DOM_VK_XF86XK_FAVORITES",
		    "DOM_VK_XF86XK_FINANCE",
		    "DOM_VK_XF86XK_FORWARD",
		    "DOM_VK_XF86XK_FRAME_BACK",
		    "DOM_VK_XF86XK_FRAME_FORWARD",
		    "DOM_VK_XF86XK_GAME",
		    "DOM_VK_XF86XK_GO",
		    "DOM_VK_XF86XK_GREEN",
		    "DOM_VK_XF86XK_HIBERNATE",
		    "DOM_VK_XF86XK_HISTORY",
		    "DOM_VK_XF86XK_HOME_PAGE",
		    "DOM_VK_XF86XK_HOT_LINKS",
		    "DOM_VK_XF86XK_I_TOUCH",
		    "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
		    "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
		    "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
		    "DOM_VK_XF86XK_LAUNCH0",
		    "DOM_VK_XF86XK_LAUNCH1",
		    "DOM_VK_XF86XK_LAUNCH2",
		    "DOM_VK_XF86XK_LAUNCH3",
		    "DOM_VK_XF86XK_LAUNCH4",
		    "DOM_VK_XF86XK_LAUNCH5",
		    "DOM_VK_XF86XK_LAUNCH6",
		    "DOM_VK_XF86XK_LAUNCH7",
		    "DOM_VK_XF86XK_LAUNCH8",
		    "DOM_VK_XF86XK_LAUNCH9",
		    "DOM_VK_XF86XK_LAUNCH_A",
		    "DOM_VK_XF86XK_LAUNCH_B",
		    "DOM_VK_XF86XK_LAUNCH_C",
		    "DOM_VK_XF86XK_LAUNCH_D",
		    "DOM_VK_XF86XK_LAUNCH_E",
		    "DOM_VK_XF86XK_LAUNCH_F",
		    "DOM_VK_XF86XK_LIGHT_BULB",
		    "DOM_VK_XF86XK_LOG_OFF",
		    "DOM_VK_XF86XK_MAIL",
		    "DOM_VK_XF86XK_MAIL_FORWARD",
		    "DOM_VK_XF86XK_MARKET",
		    "DOM_VK_XF86XK_MEETING",
		    "DOM_VK_XF86XK_MEMO",
		    "DOM_VK_XF86XK_MENU_KB",
		    "DOM_VK_XF86XK_MENU_PB",
		    "DOM_VK_XF86XK_MESSENGER",
		    "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
		    "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
		    "DOM_VK_XF86XK_MUSIC",
		    "DOM_VK_XF86XK_MY_COMPUTER",
		    "DOM_VK_XF86XK_MY_SITES",
		    "DOM_VK_XF86XK_NEW",
		    "DOM_VK_XF86XK_NEWS",
		    "DOM_VK_XF86XK_OFFICE_HOME",
		    "DOM_VK_XF86XK_OPEN",
		    "DOM_VK_XF86XK_OPEN_URL",
		    "DOM_VK_XF86XK_OPTION",
		    "DOM_VK_XF86XK_PASTE",
		    "DOM_VK_XF86XK_PHONE",
		    "DOM_VK_XF86XK_PICTURES",
		    "DOM_VK_XF86XK_POWER_DOWN",
		    "DOM_VK_XF86XK_POWER_OFF",
		    "DOM_VK_XF86XK_RED",
		    "DOM_VK_XF86XK_REFRESH",
		    "DOM_VK_XF86XK_RELOAD",
		    "DOM_VK_XF86XK_REPLY",
		    "DOM_VK_XF86XK_ROCKER_DOWN",
		    "DOM_VK_XF86XK_ROCKER_ENTER",
		    "DOM_VK_XF86XK_ROCKER_UP",
		    "DOM_VK_XF86XK_ROTATE_WINDOWS",
		    "DOM_VK_XF86XK_ROTATION_KB",
		    "DOM_VK_XF86XK_ROTATION_PB",
		    "DOM_VK_XF86XK_SAVE",
		    "DOM_VK_XF86XK_SCREEN_SAVER",
		    "DOM_VK_XF86XK_SCROLL_CLICK",
		    "DOM_VK_XF86XK_SCROLL_DOWN",
		    "DOM_VK_XF86XK_SCROLL_UP",
		    "DOM_VK_XF86XK_SEARCH",
		    "DOM_VK_XF86XK_SEND",
		    "DOM_VK_XF86XK_SHOP",
		    "DOM_VK_XF86XK_SPELL",
		    "DOM_VK_XF86XK_SPLIT_SCREEN",
		    "DOM_VK_XF86XK_STANDBY",
		    "DOM_VK_XF86XK_START",
		    "DOM_VK_XF86XK_STOP",
		    "DOM_VK_XF86XK_SUBTITLE",
		    "DOM_VK_XF86XK_SUPPORT",
		    "DOM_VK_XF86XK_SUSPEND",
		    "DOM_VK_XF86XK_TASK_PANE",
		    "DOM_VK_XF86XK_TERMINAL",
		    "DOM_VK_XF86XK_TIME",
		    "DOM_VK_XF86XK_TOOLS",
		    "DOM_VK_XF86XK_TOP_MENU",
		    "DOM_VK_XF86XK_TO_DO_LIST",
		    "DOM_VK_XF86XK_TRAVEL",
		    "DOM_VK_XF86XK_USER1KB",
		    "DOM_VK_XF86XK_USER2KB",
		    "DOM_VK_XF86XK_USER_PB",
		    "DOM_VK_XF86XK_UWB",
		    "DOM_VK_XF86XK_VENDOR_HOME",
		    "DOM_VK_XF86XK_VIDEO",
		    "DOM_VK_XF86XK_VIEW",
		    "DOM_VK_XF86XK_WAKE_UP",
		    "DOM_VK_XF86XK_WEB_CAM",
		    "DOM_VK_XF86XK_WHEEL_BUTTON",
		    "DOM_VK_XF86XK_WLAN",
		    "DOM_VK_XF86XK_WORD",
		    "DOM_VK_XF86XK_WWW",
		    "DOM_VK_XF86XK_XFER",
		    "DOM_VK_XF86XK_YELLOW",
		    "DOM_VK_XF86XK_ZOOM_IN",
		    "DOM_VK_XF86XK_ZOOM_OUT",
		    "DOM_VK_Y",
		    "DOM_VK_Z",
		    "DOM_VK_ZOOM",
		    "DONE",
		    "DONT_CARE",
		    "DOWNLOADING",
		    "DRAGDROP",
		    "DRAW_BUFFER0",
		    "DRAW_BUFFER1",
		    "DRAW_BUFFER10",
		    "DRAW_BUFFER11",
		    "DRAW_BUFFER12",
		    "DRAW_BUFFER13",
		    "DRAW_BUFFER14",
		    "DRAW_BUFFER15",
		    "DRAW_BUFFER2",
		    "DRAW_BUFFER3",
		    "DRAW_BUFFER4",
		    "DRAW_BUFFER5",
		    "DRAW_BUFFER6",
		    "DRAW_BUFFER7",
		    "DRAW_BUFFER8",
		    "DRAW_BUFFER9",
		    "DRAW_FRAMEBUFFER",
		    "DRAW_FRAMEBUFFER_BINDING",
		    "DST_ALPHA",
		    "DST_COLOR",
		    "DYNAMIC_COPY",
		    "DYNAMIC_DRAW",
		    "DYNAMIC_READ",
		    "DataChannel",
		    "DataTransfer",
		    "DataTransferItem",
		    "DataTransferItemList",
		    "DataView",
		    "Date",
		    "DateTimeFormat",
		    "DecompressionStream",
		    "DelayNode",
		    "DeprecationReportBody",
		    "DesktopNotification",
		    "DesktopNotificationCenter",
		    "DeviceLightEvent",
		    "DeviceMotionEvent",
		    "DeviceMotionEventAcceleration",
		    "DeviceMotionEventRotationRate",
		    "DeviceOrientationEvent",
		    "DeviceProximityEvent",
		    "DeviceStorage",
		    "DeviceStorageChangeEvent",
		    "Directory",
		    "DisplayNames",
		    "Document",
		    "DocumentFragment",
		    "DocumentTimeline",
		    "DocumentType",
		    "DragEvent",
		    "DynamicsCompressorNode",
		    "E",
		    "ELEMENT_ARRAY_BUFFER",
		    "ELEMENT_ARRAY_BUFFER_BINDING",
		    "ELEMENT_NODE",
		    "EMPTY",
		    "ENCODING_ERR",
		    "ENDED",
		    "END_TO_END",
		    "END_TO_START",
		    "ENTITY_NODE",
		    "ENTITY_REFERENCE_NODE",
		    "EPSILON",
		    "EQUAL",
		    "EQUALPOWER",
		    "ERROR",
		    "EXPONENTIAL_DISTANCE",
		    "Element",
		    "ElementInternals",
		    "ElementQuery",
		    "EnterPictureInPictureEvent",
		    "Entity",
		    "EntityReference",
		    "Error",
		    "ErrorEvent",
		    "EvalError",
		    "Event",
		    "EventException",
		    "EventSource",
		    "EventTarget",
		    "External",
		    "FASTEST",
		    "FIDOSDK",
		    "FILTER_ACCEPT",
		    "FILTER_INTERRUPT",
		    "FILTER_REJECT",
		    "FILTER_SKIP",
		    "FINISHED_STATE",
		    "FIRST_ORDERED_NODE_TYPE",
		    "FLOAT",
		    "FLOAT_32_UNSIGNED_INT_24_8_REV",
		    "FLOAT_MAT2",
		    "FLOAT_MAT2x3",
		    "FLOAT_MAT2x4",
		    "FLOAT_MAT3",
		    "FLOAT_MAT3x2",
		    "FLOAT_MAT3x4",
		    "FLOAT_MAT4",
		    "FLOAT_MAT4x2",
		    "FLOAT_MAT4x3",
		    "FLOAT_VEC2",
		    "FLOAT_VEC3",
		    "FLOAT_VEC4",
		    "FOCUS",
		    "FONT_FACE_RULE",
		    "FONT_FEATURE_VALUES_RULE",
		    "FRAGMENT",
		    "FRAGMENT_SHADER",
		    "FRAGMENT_SHADER_DERIVATIVE_HINT",
		    "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
		    "FRAMEBUFFER",
		    "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
		    "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
		    "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
		    "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
		    "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
		    "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
		    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
		    "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
		    "FRAMEBUFFER_BINDING",
		    "FRAMEBUFFER_COMPLETE",
		    "FRAMEBUFFER_DEFAULT",
		    "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
		    "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
		    "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
		    "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
		    "FRAMEBUFFER_UNSUPPORTED",
		    "FRONT",
		    "FRONT_AND_BACK",
		    "FRONT_FACE",
		    "FUNC_ADD",
		    "FUNC_REVERSE_SUBTRACT",
		    "FUNC_SUBTRACT",
		    "FeaturePolicy",
		    "FeaturePolicyViolationReportBody",
		    "FederatedCredential",
		    "Feed",
		    "FeedEntry",
		    "File",
		    "FileError",
		    "FileList",
		    "FileReader",
		    "FileSystem",
		    "FileSystemDirectoryEntry",
		    "FileSystemDirectoryReader",
		    "FileSystemEntry",
		    "FileSystemFileEntry",
		    "FinalizationRegistry",
		    "FindInPage",
		    "Float32Array",
		    "Float64Array",
		    "FocusEvent",
		    "FontFace",
		    "FontFaceSet",
		    "FontFaceSetLoadEvent",
		    "FormData",
		    "FormDataEvent",
		    "FragmentDirective",
		    "Function",
		    "GENERATE_MIPMAP_HINT",
		    "GEQUAL",
		    "GREATER",
		    "GREEN",
		    "GREEN_BITS",
		    "GainNode",
		    "Gamepad",
		    "GamepadAxisMoveEvent",
		    "GamepadButton",
		    "GamepadButtonEvent",
		    "GamepadEvent",
		    "GamepadHapticActuator",
		    "GamepadPose",
		    "Geolocation",
		    "GeolocationCoordinates",
		    "GeolocationPosition",
		    "GeolocationPositionError",
		    "GestureEvent",
		    "Global",
		    "Gyroscope",
		    "HALF_FLOAT",
		    "HAVE_CURRENT_DATA",
		    "HAVE_ENOUGH_DATA",
		    "HAVE_FUTURE_DATA",
		    "HAVE_METADATA",
		    "HAVE_NOTHING",
		    "HEADERS_RECEIVED",
		    "HIDDEN",
		    "HIERARCHY_REQUEST_ERR",
		    "HIGHPASS",
		    "HIGHSHELF",
		    "HIGH_FLOAT",
		    "HIGH_INT",
		    "HORIZONTAL",
		    "HORIZONTAL_AXIS",
		    "HRTF",
		    "HTMLAllCollection",
		    "HTMLAnchorElement",
		    "HTMLAppletElement",
		    "HTMLAreaElement",
		    "HTMLAudioElement",
		    "HTMLBRElement",
		    "HTMLBaseElement",
		    "HTMLBaseFontElement",
		    "HTMLBlockquoteElement",
		    "HTMLBodyElement",
		    "HTMLButtonElement",
		    "HTMLCanvasElement",
		    "HTMLCollection",
		    "HTMLCommandElement",
		    "HTMLContentElement",
		    "HTMLDListElement",
		    "HTMLDataElement",
		    "HTMLDataListElement",
		    "HTMLDetailsElement",
		    "HTMLDialogElement",
		    "HTMLDirectoryElement",
		    "HTMLDivElement",
		    "HTMLDocument",
		    "HTMLElement",
		    "HTMLEmbedElement",
		    "HTMLFieldSetElement",
		    "HTMLFontElement",
		    "HTMLFormControlsCollection",
		    "HTMLFormElement",
		    "HTMLFrameElement",
		    "HTMLFrameSetElement",
		    "HTMLHRElement",
		    "HTMLHeadElement",
		    "HTMLHeadingElement",
		    "HTMLHtmlElement",
		    "HTMLIFrameElement",
		    "HTMLImageElement",
		    "HTMLInputElement",
		    "HTMLIsIndexElement",
		    "HTMLKeygenElement",
		    "HTMLLIElement",
		    "HTMLLabelElement",
		    "HTMLLegendElement",
		    "HTMLLinkElement",
		    "HTMLMapElement",
		    "HTMLMarqueeElement",
		    "HTMLMediaElement",
		    "HTMLMenuElement",
		    "HTMLMenuItemElement",
		    "HTMLMetaElement",
		    "HTMLMeterElement",
		    "HTMLModElement",
		    "HTMLOListElement",
		    "HTMLObjectElement",
		    "HTMLOptGroupElement",
		    "HTMLOptionElement",
		    "HTMLOptionsCollection",
		    "HTMLOutputElement",
		    "HTMLParagraphElement",
		    "HTMLParamElement",
		    "HTMLPictureElement",
		    "HTMLPreElement",
		    "HTMLProgressElement",
		    "HTMLPropertiesCollection",
		    "HTMLQuoteElement",
		    "HTMLScriptElement",
		    "HTMLSelectElement",
		    "HTMLShadowElement",
		    "HTMLSlotElement",
		    "HTMLSourceElement",
		    "HTMLSpanElement",
		    "HTMLStyleElement",
		    "HTMLTableCaptionElement",
		    "HTMLTableCellElement",
		    "HTMLTableColElement",
		    "HTMLTableElement",
		    "HTMLTableRowElement",
		    "HTMLTableSectionElement",
		    "HTMLTemplateElement",
		    "HTMLTextAreaElement",
		    "HTMLTimeElement",
		    "HTMLTitleElement",
		    "HTMLTrackElement",
		    "HTMLUListElement",
		    "HTMLUnknownElement",
		    "HTMLVideoElement",
		    "HashChangeEvent",
		    "Headers",
		    "History",
		    "Hz",
		    "ICE_CHECKING",
		    "ICE_CLOSED",
		    "ICE_COMPLETED",
		    "ICE_CONNECTED",
		    "ICE_FAILED",
		    "ICE_GATHERING",
		    "ICE_WAITING",
		    "IDBCursor",
		    "IDBCursorWithValue",
		    "IDBDatabase",
		    "IDBDatabaseException",
		    "IDBFactory",
		    "IDBFileHandle",
		    "IDBFileRequest",
		    "IDBIndex",
		    "IDBKeyRange",
		    "IDBMutableFile",
		    "IDBObjectStore",
		    "IDBOpenDBRequest",
		    "IDBRequest",
		    "IDBTransaction",
		    "IDBVersionChangeEvent",
		    "IDLE",
		    "IIRFilterNode",
		    "IMPLEMENTATION_COLOR_READ_FORMAT",
		    "IMPLEMENTATION_COLOR_READ_TYPE",
		    "IMPORT_RULE",
		    "INCR",
		    "INCR_WRAP",
		    "INDEX",
		    "INDEX_SIZE_ERR",
		    "INDIRECT",
		    "INT",
		    "INTERLEAVED_ATTRIBS",
		    "INT_2_10_10_10_REV",
		    "INT_SAMPLER_2D",
		    "INT_SAMPLER_2D_ARRAY",
		    "INT_SAMPLER_3D",
		    "INT_SAMPLER_CUBE",
		    "INT_VEC2",
		    "INT_VEC3",
		    "INT_VEC4",
		    "INUSE_ATTRIBUTE_ERR",
		    "INVALID_ACCESS_ERR",
		    "INVALID_CHARACTER_ERR",
		    "INVALID_ENUM",
		    "INVALID_EXPRESSION_ERR",
		    "INVALID_FRAMEBUFFER_OPERATION",
		    "INVALID_INDEX",
		    "INVALID_MODIFICATION_ERR",
		    "INVALID_NODE_TYPE_ERR",
		    "INVALID_OPERATION",
		    "INVALID_STATE_ERR",
		    "INVALID_VALUE",
		    "INVERSE_DISTANCE",
		    "INVERT",
		    "IceCandidate",
		    "IdleDeadline",
		    "Image",
		    "ImageBitmap",
		    "ImageBitmapRenderingContext",
		    "ImageCapture",
		    "ImageData",
		    "Infinity",
		    "InputDeviceCapabilities",
		    "InputDeviceInfo",
		    "InputEvent",
		    "InputMethodContext",
		    "InstallTrigger",
		    "InstallTriggerImpl",
		    "Instance",
		    "Int16Array",
		    "Int32Array",
		    "Int8Array",
		    "Intent",
		    "InternalError",
		    "IntersectionObserver",
		    "IntersectionObserverEntry",
		    "Intl",
		    "IsSearchProviderInstalled",
		    "Iterator",
		    "JSON",
		    "KEEP",
		    "KEYDOWN",
		    "KEYFRAMES_RULE",
		    "KEYFRAME_RULE",
		    "KEYPRESS",
		    "KEYUP",
		    "KeyEvent",
		    "Keyboard",
		    "KeyboardEvent",
		    "KeyboardLayoutMap",
		    "KeyframeEffect",
		    "LENGTHADJUST_SPACING",
		    "LENGTHADJUST_SPACINGANDGLYPHS",
		    "LENGTHADJUST_UNKNOWN",
		    "LEQUAL",
		    "LESS",
		    "LINEAR",
		    "LINEAR_DISTANCE",
		    "LINEAR_MIPMAP_LINEAR",
		    "LINEAR_MIPMAP_NEAREST",
		    "LINES",
		    "LINE_LOOP",
		    "LINE_STRIP",
		    "LINE_WIDTH",
		    "LINK_STATUS",
		    "LIVE",
		    "LN10",
		    "LN2",
		    "LOADED",
		    "LOADING",
		    "LOG10E",
		    "LOG2E",
		    "LOWPASS",
		    "LOWSHELF",
		    "LOW_FLOAT",
		    "LOW_INT",
		    "LSException",
		    "LSParserFilter",
		    "LUMINANCE",
		    "LUMINANCE_ALPHA",
		    "LargestContentfulPaint",
		    "LayoutShift",
		    "LayoutShiftAttribution",
		    "LinearAccelerationSensor",
		    "LinkError",
		    "ListFormat",
		    "LocalMediaStream",
		    "Locale",
		    "Location",
		    "Lock",
		    "LockManager",
		    "MAP_READ",
		    "MAP_WRITE",
		    "MAX",
		    "MAX_3D_TEXTURE_SIZE",
		    "MAX_ARRAY_TEXTURE_LAYERS",
		    "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
		    "MAX_COLOR_ATTACHMENTS",
		    "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
		    "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
		    "MAX_COMBINED_UNIFORM_BLOCKS",
		    "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
		    "MAX_CUBE_MAP_TEXTURE_SIZE",
		    "MAX_DRAW_BUFFERS",
		    "MAX_ELEMENTS_INDICES",
		    "MAX_ELEMENTS_VERTICES",
		    "MAX_ELEMENT_INDEX",
		    "MAX_FRAGMENT_INPUT_COMPONENTS",
		    "MAX_FRAGMENT_UNIFORM_BLOCKS",
		    "MAX_FRAGMENT_UNIFORM_COMPONENTS",
		    "MAX_FRAGMENT_UNIFORM_VECTORS",
		    "MAX_PROGRAM_TEXEL_OFFSET",
		    "MAX_RENDERBUFFER_SIZE",
		    "MAX_SAFE_INTEGER",
		    "MAX_SAMPLES",
		    "MAX_SERVER_WAIT_TIMEOUT",
		    "MAX_TEXTURE_IMAGE_UNITS",
		    "MAX_TEXTURE_LOD_BIAS",
		    "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
		    "MAX_TEXTURE_SIZE",
		    "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
		    "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
		    "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
		    "MAX_UNIFORM_BLOCK_SIZE",
		    "MAX_UNIFORM_BUFFER_BINDINGS",
		    "MAX_VALUE",
		    "MAX_VARYING_COMPONENTS",
		    "MAX_VARYING_VECTORS",
		    "MAX_VERTEX_ATTRIBS",
		    "MAX_VERTEX_OUTPUT_COMPONENTS",
		    "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
		    "MAX_VERTEX_UNIFORM_BLOCKS",
		    "MAX_VERTEX_UNIFORM_COMPONENTS",
		    "MAX_VERTEX_UNIFORM_VECTORS",
		    "MAX_VIEWPORT_DIMS",
		    "MEDIA_ERR_ABORTED",
		    "MEDIA_ERR_DECODE",
		    "MEDIA_ERR_ENCRYPTED",
		    "MEDIA_ERR_NETWORK",
		    "MEDIA_ERR_SRC_NOT_SUPPORTED",
		    "MEDIA_KEYERR_CLIENT",
		    "MEDIA_KEYERR_DOMAIN",
		    "MEDIA_KEYERR_HARDWARECHANGE",
		    "MEDIA_KEYERR_OUTPUT",
		    "MEDIA_KEYERR_SERVICE",
		    "MEDIA_KEYERR_UNKNOWN",
		    "MEDIA_RULE",
		    "MEDIUM_FLOAT",
		    "MEDIUM_INT",
		    "META_MASK",
		    "MIDIAccess",
		    "MIDIConnectionEvent",
		    "MIDIInput",
		    "MIDIInputMap",
		    "MIDIMessageEvent",
		    "MIDIOutput",
		    "MIDIOutputMap",
		    "MIDIPort",
		    "MIN",
		    "MIN_PROGRAM_TEXEL_OFFSET",
		    "MIN_SAFE_INTEGER",
		    "MIN_VALUE",
		    "MIRRORED_REPEAT",
		    "MODE_ASYNCHRONOUS",
		    "MODE_SYNCHRONOUS",
		    "MODIFICATION",
		    "MOUSEDOWN",
		    "MOUSEDRAG",
		    "MOUSEMOVE",
		    "MOUSEOUT",
		    "MOUSEOVER",
		    "MOUSEUP",
		    "MOZ_KEYFRAMES_RULE",
		    "MOZ_KEYFRAME_RULE",
		    "MOZ_SOURCE_CURSOR",
		    "MOZ_SOURCE_ERASER",
		    "MOZ_SOURCE_KEYBOARD",
		    "MOZ_SOURCE_MOUSE",
		    "MOZ_SOURCE_PEN",
		    "MOZ_SOURCE_TOUCH",
		    "MOZ_SOURCE_UNKNOWN",
		    "MSGESTURE_FLAG_BEGIN",
		    "MSGESTURE_FLAG_CANCEL",
		    "MSGESTURE_FLAG_END",
		    "MSGESTURE_FLAG_INERTIA",
		    "MSGESTURE_FLAG_NONE",
		    "MSPOINTER_TYPE_MOUSE",
		    "MSPOINTER_TYPE_PEN",
		    "MSPOINTER_TYPE_TOUCH",
		    "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
		    "MS_ASYNC_CALLBACK_STATUS_CANCEL",
		    "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
		    "MS_ASYNC_CALLBACK_STATUS_ERROR",
		    "MS_ASYNC_CALLBACK_STATUS_JOIN",
		    "MS_ASYNC_OP_STATUS_CANCELED",
		    "MS_ASYNC_OP_STATUS_ERROR",
		    "MS_ASYNC_OP_STATUS_SUCCESS",
		    "MS_MANIPULATION_STATE_ACTIVE",
		    "MS_MANIPULATION_STATE_CANCELLED",
		    "MS_MANIPULATION_STATE_COMMITTED",
		    "MS_MANIPULATION_STATE_DRAGGING",
		    "MS_MANIPULATION_STATE_INERTIA",
		    "MS_MANIPULATION_STATE_PRESELECT",
		    "MS_MANIPULATION_STATE_SELECTING",
		    "MS_MANIPULATION_STATE_STOPPED",
		    "MS_MEDIA_ERR_ENCRYPTED",
		    "MS_MEDIA_KEYERR_CLIENT",
		    "MS_MEDIA_KEYERR_DOMAIN",
		    "MS_MEDIA_KEYERR_HARDWARECHANGE",
		    "MS_MEDIA_KEYERR_OUTPUT",
		    "MS_MEDIA_KEYERR_SERVICE",
		    "MS_MEDIA_KEYERR_UNKNOWN",
		    "Map",
		    "Math",
		    "MathMLElement",
		    "MediaCapabilities",
		    "MediaCapabilitiesInfo",
		    "MediaController",
		    "MediaDeviceInfo",
		    "MediaDevices",
		    "MediaElementAudioSourceNode",
		    "MediaEncryptedEvent",
		    "MediaError",
		    "MediaKeyError",
		    "MediaKeyEvent",
		    "MediaKeyMessageEvent",
		    "MediaKeyNeededEvent",
		    "MediaKeySession",
		    "MediaKeyStatusMap",
		    "MediaKeySystemAccess",
		    "MediaKeys",
		    "MediaList",
		    "MediaMetadata",
		    "MediaQueryList",
		    "MediaQueryListEvent",
		    "MediaRecorder",
		    "MediaRecorderErrorEvent",
		    "MediaSession",
		    "MediaSettingsRange",
		    "MediaSource",
		    "MediaStream",
		    "MediaStreamAudioDestinationNode",
		    "MediaStreamAudioSourceNode",
		    "MediaStreamEvent",
		    "MediaStreamTrack",
		    "MediaStreamTrackAudioSourceNode",
		    "MediaStreamTrackEvent",
		    "Memory",
		    "MessageChannel",
		    "MessageEvent",
		    "MessagePort",
		    "Methods",
		    "MimeType",
		    "MimeTypeArray",
		    "Module",
		    "MouseEvent",
		    "MouseScrollEvent",
		    "MozAnimation",
		    "MozAnimationDelay",
		    "MozAnimationDirection",
		    "MozAnimationDuration",
		    "MozAnimationFillMode",
		    "MozAnimationIterationCount",
		    "MozAnimationName",
		    "MozAnimationPlayState",
		    "MozAnimationTimingFunction",
		    "MozAppearance",
		    "MozBackfaceVisibility",
		    "MozBinding",
		    "MozBorderBottomColors",
		    "MozBorderEnd",
		    "MozBorderEndColor",
		    "MozBorderEndStyle",
		    "MozBorderEndWidth",
		    "MozBorderImage",
		    "MozBorderLeftColors",
		    "MozBorderRightColors",
		    "MozBorderStart",
		    "MozBorderStartColor",
		    "MozBorderStartStyle",
		    "MozBorderStartWidth",
		    "MozBorderTopColors",
		    "MozBoxAlign",
		    "MozBoxDirection",
		    "MozBoxFlex",
		    "MozBoxOrdinalGroup",
		    "MozBoxOrient",
		    "MozBoxPack",
		    "MozBoxSizing",
		    "MozCSSKeyframeRule",
		    "MozCSSKeyframesRule",
		    "MozColumnCount",
		    "MozColumnFill",
		    "MozColumnGap",
		    "MozColumnRule",
		    "MozColumnRuleColor",
		    "MozColumnRuleStyle",
		    "MozColumnRuleWidth",
		    "MozColumnWidth",
		    "MozColumns",
		    "MozContactChangeEvent",
		    "MozFloatEdge",
		    "MozFontFeatureSettings",
		    "MozFontLanguageOverride",
		    "MozForceBrokenImageIcon",
		    "MozHyphens",
		    "MozImageRegion",
		    "MozMarginEnd",
		    "MozMarginStart",
		    "MozMmsEvent",
		    "MozMmsMessage",
		    "MozMobileMessageThread",
		    "MozOSXFontSmoothing",
		    "MozOrient",
		    "MozOsxFontSmoothing",
		    "MozOutlineRadius",
		    "MozOutlineRadiusBottomleft",
		    "MozOutlineRadiusBottomright",
		    "MozOutlineRadiusTopleft",
		    "MozOutlineRadiusTopright",
		    "MozPaddingEnd",
		    "MozPaddingStart",
		    "MozPerspective",
		    "MozPerspectiveOrigin",
		    "MozPowerManager",
		    "MozSettingsEvent",
		    "MozSmsEvent",
		    "MozSmsMessage",
		    "MozStackSizing",
		    "MozTabSize",
		    "MozTextAlignLast",
		    "MozTextDecorationColor",
		    "MozTextDecorationLine",
		    "MozTextDecorationStyle",
		    "MozTextSizeAdjust",
		    "MozTransform",
		    "MozTransformOrigin",
		    "MozTransformStyle",
		    "MozTransition",
		    "MozTransitionDelay",
		    "MozTransitionDuration",
		    "MozTransitionProperty",
		    "MozTransitionTimingFunction",
		    "MozUserFocus",
		    "MozUserInput",
		    "MozUserModify",
		    "MozUserSelect",
		    "MozWindowDragging",
		    "MozWindowShadow",
		    "MutationEvent",
		    "MutationObserver",
		    "MutationRecord",
		    "NAMESPACE_ERR",
		    "NAMESPACE_RULE",
		    "NEAREST",
		    "NEAREST_MIPMAP_LINEAR",
		    "NEAREST_MIPMAP_NEAREST",
		    "NEGATIVE_INFINITY",
		    "NETWORK_EMPTY",
		    "NETWORK_ERR",
		    "NETWORK_IDLE",
		    "NETWORK_LOADED",
		    "NETWORK_LOADING",
		    "NETWORK_NO_SOURCE",
		    "NEVER",
		    "NEW",
		    "NEXT",
		    "NEXT_NO_DUPLICATE",
		    "NICEST",
		    "NODE_AFTER",
		    "NODE_BEFORE",
		    "NODE_BEFORE_AND_AFTER",
		    "NODE_INSIDE",
		    "NONE",
		    "NON_TRANSIENT_ERR",
		    "NOTATION_NODE",
		    "NOTCH",
		    "NOTEQUAL",
		    "NOT_ALLOWED_ERR",
		    "NOT_FOUND_ERR",
		    "NOT_READABLE_ERR",
		    "NOT_SUPPORTED_ERR",
		    "NO_DATA_ALLOWED_ERR",
		    "NO_ERR",
		    "NO_ERROR",
		    "NO_MODIFICATION_ALLOWED_ERR",
		    "NUMBER_TYPE",
		    "NUM_COMPRESSED_TEXTURE_FORMATS",
		    "NaN",
		    "NamedNodeMap",
		    "NavigationPreloadManager",
		    "Navigator",
		    "NearbyLinks",
		    "NetworkInformation",
		    "Node",
		    "NodeFilter",
		    "NodeIterator",
		    "NodeList",
		    "Notation",
		    "Notification",
		    "NotifyPaintEvent",
		    "Number",
		    "NumberFormat",
		    "OBJECT_TYPE",
		    "OBSOLETE",
		    "OK",
		    "ONE",
		    "ONE_MINUS_CONSTANT_ALPHA",
		    "ONE_MINUS_CONSTANT_COLOR",
		    "ONE_MINUS_DST_ALPHA",
		    "ONE_MINUS_DST_COLOR",
		    "ONE_MINUS_SRC_ALPHA",
		    "ONE_MINUS_SRC_COLOR",
		    "OPEN",
		    "OPENED",
		    "OPENING",
		    "ORDERED_NODE_ITERATOR_TYPE",
		    "ORDERED_NODE_SNAPSHOT_TYPE",
		    "OTHER_ERROR",
		    "OUT_OF_MEMORY",
		    "Object",
		    "OfflineAudioCompletionEvent",
		    "OfflineAudioContext",
		    "OfflineResourceList",
		    "OffscreenCanvas",
		    "OffscreenCanvasRenderingContext2D",
		    "Option",
		    "OrientationSensor",
		    "OscillatorNode",
		    "OverconstrainedError",
		    "OverflowEvent",
		    "PACK_ALIGNMENT",
		    "PACK_ROW_LENGTH",
		    "PACK_SKIP_PIXELS",
		    "PACK_SKIP_ROWS",
		    "PAGE_RULE",
		    "PARSE_ERR",
		    "PATHSEG_ARC_ABS",
		    "PATHSEG_ARC_REL",
		    "PATHSEG_CLOSEPATH",
		    "PATHSEG_CURVETO_CUBIC_ABS",
		    "PATHSEG_CURVETO_CUBIC_REL",
		    "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
		    "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
		    "PATHSEG_CURVETO_QUADRATIC_ABS",
		    "PATHSEG_CURVETO_QUADRATIC_REL",
		    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
		    "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
		    "PATHSEG_LINETO_ABS",
		    "PATHSEG_LINETO_HORIZONTAL_ABS",
		    "PATHSEG_LINETO_HORIZONTAL_REL",
		    "PATHSEG_LINETO_REL",
		    "PATHSEG_LINETO_VERTICAL_ABS",
		    "PATHSEG_LINETO_VERTICAL_REL",
		    "PATHSEG_MOVETO_ABS",
		    "PATHSEG_MOVETO_REL",
		    "PATHSEG_UNKNOWN",
		    "PATH_EXISTS_ERR",
		    "PEAKING",
		    "PERMISSION_DENIED",
		    "PERSISTENT",
		    "PI",
		    "PIXEL_PACK_BUFFER",
		    "PIXEL_PACK_BUFFER_BINDING",
		    "PIXEL_UNPACK_BUFFER",
		    "PIXEL_UNPACK_BUFFER_BINDING",
		    "PLAYING_STATE",
		    "POINTS",
		    "POLYGON_OFFSET_FACTOR",
		    "POLYGON_OFFSET_FILL",
		    "POLYGON_OFFSET_UNITS",
		    "POSITION_UNAVAILABLE",
		    "POSITIVE_INFINITY",
		    "PREV",
		    "PREV_NO_DUPLICATE",
		    "PROCESSING_INSTRUCTION_NODE",
		    "PageChangeEvent",
		    "PageTransitionEvent",
		    "PaintRequest",
		    "PaintRequestList",
		    "PannerNode",
		    "PasswordCredential",
		    "Path2D",
		    "PaymentAddress",
		    "PaymentInstruments",
		    "PaymentManager",
		    "PaymentMethodChangeEvent",
		    "PaymentRequest",
		    "PaymentRequestUpdateEvent",
		    "PaymentResponse",
		    "Performance",
		    "PerformanceElementTiming",
		    "PerformanceEntry",
		    "PerformanceEventTiming",
		    "PerformanceLongTaskTiming",
		    "PerformanceMark",
		    "PerformanceMeasure",
		    "PerformanceNavigation",
		    "PerformanceNavigationTiming",
		    "PerformanceObserver",
		    "PerformanceObserverEntryList",
		    "PerformancePaintTiming",
		    "PerformanceResourceTiming",
		    "PerformanceServerTiming",
		    "PerformanceTiming",
		    "PeriodicSyncManager",
		    "PeriodicWave",
		    "PermissionStatus",
		    "Permissions",
		    "PhotoCapabilities",
		    "PictureInPictureWindow",
		    "Plugin",
		    "PluginArray",
		    "PluralRules",
		    "PointerEvent",
		    "PopStateEvent",
		    "PopupBlockedEvent",
		    "Presentation",
		    "PresentationAvailability",
		    "PresentationConnection",
		    "PresentationConnectionAvailableEvent",
		    "PresentationConnectionCloseEvent",
		    "PresentationConnectionList",
		    "PresentationReceiver",
		    "PresentationRequest",
		    "ProcessingInstruction",
		    "ProgressEvent",
		    "Promise",
		    "PromiseRejectionEvent",
		    "PropertyNodeList",
		    "Proxy",
		    "PublicKeyCredential",
		    "PushManager",
		    "PushSubscription",
		    "PushSubscriptionOptions",
		    "Q",
		    "QUERY_RESOLVE",
		    "QUERY_RESULT",
		    "QUERY_RESULT_AVAILABLE",
		    "QUOTA_ERR",
		    "QUOTA_EXCEEDED_ERR",
		    "QueryInterface",
		    "R11F_G11F_B10F",
		    "R16F",
		    "R16I",
		    "R16UI",
		    "R32F",
		    "R32I",
		    "R32UI",
		    "R8",
		    "R8I",
		    "R8UI",
		    "R8_SNORM",
		    "RASTERIZER_DISCARD",
		    "READ",
		    "READ_BUFFER",
		    "READ_FRAMEBUFFER",
		    "READ_FRAMEBUFFER_BINDING",
		    "READ_ONLY",
		    "READ_ONLY_ERR",
		    "READ_WRITE",
		    "RED",
		    "RED_BITS",
		    "RED_INTEGER",
		    "REMOVAL",
		    "RENDERBUFFER",
		    "RENDERBUFFER_ALPHA_SIZE",
		    "RENDERBUFFER_BINDING",
		    "RENDERBUFFER_BLUE_SIZE",
		    "RENDERBUFFER_DEPTH_SIZE",
		    "RENDERBUFFER_GREEN_SIZE",
		    "RENDERBUFFER_HEIGHT",
		    "RENDERBUFFER_INTERNAL_FORMAT",
		    "RENDERBUFFER_RED_SIZE",
		    "RENDERBUFFER_SAMPLES",
		    "RENDERBUFFER_STENCIL_SIZE",
		    "RENDERBUFFER_WIDTH",
		    "RENDERER",
		    "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
		    "RENDERING_INTENT_AUTO",
		    "RENDERING_INTENT_PERCEPTUAL",
		    "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
		    "RENDERING_INTENT_SATURATION",
		    "RENDERING_INTENT_UNKNOWN",
		    "RENDER_ATTACHMENT",
		    "REPEAT",
		    "REPLACE",
		    "RG",
		    "RG16F",
		    "RG16I",
		    "RG16UI",
		    "RG32F",
		    "RG32I",
		    "RG32UI",
		    "RG8",
		    "RG8I",
		    "RG8UI",
		    "RG8_SNORM",
		    "RGB",
		    "RGB10_A2",
		    "RGB10_A2UI",
		    "RGB16F",
		    "RGB16I",
		    "RGB16UI",
		    "RGB32F",
		    "RGB32I",
		    "RGB32UI",
		    "RGB565",
		    "RGB5_A1",
		    "RGB8",
		    "RGB8I",
		    "RGB8UI",
		    "RGB8_SNORM",
		    "RGB9_E5",
		    "RGBA",
		    "RGBA16F",
		    "RGBA16I",
		    "RGBA16UI",
		    "RGBA32F",
		    "RGBA32I",
		    "RGBA32UI",
		    "RGBA4",
		    "RGBA8",
		    "RGBA8I",
		    "RGBA8UI",
		    "RGBA8_SNORM",
		    "RGBA_INTEGER",
		    "RGBColor",
		    "RGB_INTEGER",
		    "RG_INTEGER",
		    "ROTATION_CLOCKWISE",
		    "ROTATION_COUNTERCLOCKWISE",
		    "RTCCertificate",
		    "RTCDTMFSender",
		    "RTCDTMFToneChangeEvent",
		    "RTCDataChannel",
		    "RTCDataChannelEvent",
		    "RTCDtlsTransport",
		    "RTCError",
		    "RTCErrorEvent",
		    "RTCIceCandidate",
		    "RTCIceTransport",
		    "RTCPeerConnection",
		    "RTCPeerConnectionIceErrorEvent",
		    "RTCPeerConnectionIceEvent",
		    "RTCRtpReceiver",
		    "RTCRtpSender",
		    "RTCRtpTransceiver",
		    "RTCSctpTransport",
		    "RTCSessionDescription",
		    "RTCStatsReport",
		    "RTCTrackEvent",
		    "RadioNodeList",
		    "Range",
		    "RangeError",
		    "RangeException",
		    "ReadableStream",
		    "ReadableStreamDefaultReader",
		    "RecordErrorEvent",
		    "Rect",
		    "ReferenceError",
		    "Reflect",
		    "RegExp",
		    "RelativeOrientationSensor",
		    "RelativeTimeFormat",
		    "RemotePlayback",
		    "Report",
		    "ReportBody",
		    "ReportingObserver",
		    "Request",
		    "ResizeObserver",
		    "ResizeObserverEntry",
		    "ResizeObserverSize",
		    "Response",
		    "RuntimeError",
		    "SAMPLER_2D",
		    "SAMPLER_2D_ARRAY",
		    "SAMPLER_2D_ARRAY_SHADOW",
		    "SAMPLER_2D_SHADOW",
		    "SAMPLER_3D",
		    "SAMPLER_BINDING",
		    "SAMPLER_CUBE",
		    "SAMPLER_CUBE_SHADOW",
		    "SAMPLES",
		    "SAMPLE_ALPHA_TO_COVERAGE",
		    "SAMPLE_BUFFERS",
		    "SAMPLE_COVERAGE",
		    "SAMPLE_COVERAGE_INVERT",
		    "SAMPLE_COVERAGE_VALUE",
		    "SAWTOOTH",
		    "SCHEDULED_STATE",
		    "SCISSOR_BOX",
		    "SCISSOR_TEST",
		    "SCROLL_PAGE_DOWN",
		    "SCROLL_PAGE_UP",
		    "SDP_ANSWER",
		    "SDP_OFFER",
		    "SDP_PRANSWER",
		    "SECURITY_ERR",
		    "SELECT",
		    "SEPARATE_ATTRIBS",
		    "SERIALIZE_ERR",
		    "SEVERITY_ERROR",
		    "SEVERITY_FATAL_ERROR",
		    "SEVERITY_WARNING",
		    "SHADER_COMPILER",
		    "SHADER_TYPE",
		    "SHADING_LANGUAGE_VERSION",
		    "SHIFT_MASK",
		    "SHORT",
		    "SHOWING",
		    "SHOW_ALL",
		    "SHOW_ATTRIBUTE",
		    "SHOW_CDATA_SECTION",
		    "SHOW_COMMENT",
		    "SHOW_DOCUMENT",
		    "SHOW_DOCUMENT_FRAGMENT",
		    "SHOW_DOCUMENT_TYPE",
		    "SHOW_ELEMENT",
		    "SHOW_ENTITY",
		    "SHOW_ENTITY_REFERENCE",
		    "SHOW_NOTATION",
		    "SHOW_PROCESSING_INSTRUCTION",
		    "SHOW_TEXT",
		    "SIGNALED",
		    "SIGNED_NORMALIZED",
		    "SINE",
		    "SOUNDFIELD",
		    "SQLException",
		    "SQRT1_2",
		    "SQRT2",
		    "SQUARE",
		    "SRC_ALPHA",
		    "SRC_ALPHA_SATURATE",
		    "SRC_COLOR",
		    "SRGB",
		    "SRGB8",
		    "SRGB8_ALPHA8",
		    "START_TO_END",
		    "START_TO_START",
		    "STATIC_COPY",
		    "STATIC_DRAW",
		    "STATIC_READ",
		    "STENCIL",
		    "STENCIL_ATTACHMENT",
		    "STENCIL_BACK_FAIL",
		    "STENCIL_BACK_FUNC",
		    "STENCIL_BACK_PASS_DEPTH_FAIL",
		    "STENCIL_BACK_PASS_DEPTH_PASS",
		    "STENCIL_BACK_REF",
		    "STENCIL_BACK_VALUE_MASK",
		    "STENCIL_BACK_WRITEMASK",
		    "STENCIL_BITS",
		    "STENCIL_BUFFER_BIT",
		    "STENCIL_CLEAR_VALUE",
		    "STENCIL_FAIL",
		    "STENCIL_FUNC",
		    "STENCIL_INDEX",
		    "STENCIL_INDEX8",
		    "STENCIL_PASS_DEPTH_FAIL",
		    "STENCIL_PASS_DEPTH_PASS",
		    "STENCIL_REF",
		    "STENCIL_TEST",
		    "STENCIL_VALUE_MASK",
		    "STENCIL_WRITEMASK",
		    "STORAGE",
		    "STORAGE_BINDING",
		    "STREAM_COPY",
		    "STREAM_DRAW",
		    "STREAM_READ",
		    "STRING_TYPE",
		    "STYLE_RULE",
		    "SUBPIXEL_BITS",
		    "SUPPORTS_RULE",
		    "SVGAElement",
		    "SVGAltGlyphDefElement",
		    "SVGAltGlyphElement",
		    "SVGAltGlyphItemElement",
		    "SVGAngle",
		    "SVGAnimateColorElement",
		    "SVGAnimateElement",
		    "SVGAnimateMotionElement",
		    "SVGAnimateTransformElement",
		    "SVGAnimatedAngle",
		    "SVGAnimatedBoolean",
		    "SVGAnimatedEnumeration",
		    "SVGAnimatedInteger",
		    "SVGAnimatedLength",
		    "SVGAnimatedLengthList",
		    "SVGAnimatedNumber",
		    "SVGAnimatedNumberList",
		    "SVGAnimatedPreserveAspectRatio",
		    "SVGAnimatedRect",
		    "SVGAnimatedString",
		    "SVGAnimatedTransformList",
		    "SVGAnimationElement",
		    "SVGCircleElement",
		    "SVGClipPathElement",
		    "SVGColor",
		    "SVGComponentTransferFunctionElement",
		    "SVGCursorElement",
		    "SVGDefsElement",
		    "SVGDescElement",
		    "SVGDiscardElement",
		    "SVGDocument",
		    "SVGElement",
		    "SVGElementInstance",
		    "SVGElementInstanceList",
		    "SVGEllipseElement",
		    "SVGException",
		    "SVGFEBlendElement",
		    "SVGFEColorMatrixElement",
		    "SVGFEComponentTransferElement",
		    "SVGFECompositeElement",
		    "SVGFEConvolveMatrixElement",
		    "SVGFEDiffuseLightingElement",
		    "SVGFEDisplacementMapElement",
		    "SVGFEDistantLightElement",
		    "SVGFEDropShadowElement",
		    "SVGFEFloodElement",
		    "SVGFEFuncAElement",
		    "SVGFEFuncBElement",
		    "SVGFEFuncGElement",
		    "SVGFEFuncRElement",
		    "SVGFEGaussianBlurElement",
		    "SVGFEImageElement",
		    "SVGFEMergeElement",
		    "SVGFEMergeNodeElement",
		    "SVGFEMorphologyElement",
		    "SVGFEOffsetElement",
		    "SVGFEPointLightElement",
		    "SVGFESpecularLightingElement",
		    "SVGFESpotLightElement",
		    "SVGFETileElement",
		    "SVGFETurbulenceElement",
		    "SVGFilterElement",
		    "SVGFontElement",
		    "SVGFontFaceElement",
		    "SVGFontFaceFormatElement",
		    "SVGFontFaceNameElement",
		    "SVGFontFaceSrcElement",
		    "SVGFontFaceUriElement",
		    "SVGForeignObjectElement",
		    "SVGGElement",
		    "SVGGeometryElement",
		    "SVGGlyphElement",
		    "SVGGlyphRefElement",
		    "SVGGradientElement",
		    "SVGGraphicsElement",
		    "SVGHKernElement",
		    "SVGImageElement",
		    "SVGLength",
		    "SVGLengthList",
		    "SVGLineElement",
		    "SVGLinearGradientElement",
		    "SVGMPathElement",
		    "SVGMarkerElement",
		    "SVGMaskElement",
		    "SVGMatrix",
		    "SVGMetadataElement",
		    "SVGMissingGlyphElement",
		    "SVGNumber",
		    "SVGNumberList",
		    "SVGPaint",
		    "SVGPathElement",
		    "SVGPathSeg",
		    "SVGPathSegArcAbs",
		    "SVGPathSegArcRel",
		    "SVGPathSegClosePath",
		    "SVGPathSegCurvetoCubicAbs",
		    "SVGPathSegCurvetoCubicRel",
		    "SVGPathSegCurvetoCubicSmoothAbs",
		    "SVGPathSegCurvetoCubicSmoothRel",
		    "SVGPathSegCurvetoQuadraticAbs",
		    "SVGPathSegCurvetoQuadraticRel",
		    "SVGPathSegCurvetoQuadraticSmoothAbs",
		    "SVGPathSegCurvetoQuadraticSmoothRel",
		    "SVGPathSegLinetoAbs",
		    "SVGPathSegLinetoHorizontalAbs",
		    "SVGPathSegLinetoHorizontalRel",
		    "SVGPathSegLinetoRel",
		    "SVGPathSegLinetoVerticalAbs",
		    "SVGPathSegLinetoVerticalRel",
		    "SVGPathSegList",
		    "SVGPathSegMovetoAbs",
		    "SVGPathSegMovetoRel",
		    "SVGPatternElement",
		    "SVGPoint",
		    "SVGPointList",
		    "SVGPolygonElement",
		    "SVGPolylineElement",
		    "SVGPreserveAspectRatio",
		    "SVGRadialGradientElement",
		    "SVGRect",
		    "SVGRectElement",
		    "SVGRenderingIntent",
		    "SVGSVGElement",
		    "SVGScriptElement",
		    "SVGSetElement",
		    "SVGStopElement",
		    "SVGStringList",
		    "SVGStyleElement",
		    "SVGSwitchElement",
		    "SVGSymbolElement",
		    "SVGTRefElement",
		    "SVGTSpanElement",
		    "SVGTextContentElement",
		    "SVGTextElement",
		    "SVGTextPathElement",
		    "SVGTextPositioningElement",
		    "SVGTitleElement",
		    "SVGTransform",
		    "SVGTransformList",
		    "SVGUnitTypes",
		    "SVGUseElement",
		    "SVGVKernElement",
		    "SVGViewElement",
		    "SVGViewSpec",
		    "SVGZoomAndPan",
		    "SVGZoomEvent",
		    "SVG_ANGLETYPE_DEG",
		    "SVG_ANGLETYPE_GRAD",
		    "SVG_ANGLETYPE_RAD",
		    "SVG_ANGLETYPE_UNKNOWN",
		    "SVG_ANGLETYPE_UNSPECIFIED",
		    "SVG_CHANNEL_A",
		    "SVG_CHANNEL_B",
		    "SVG_CHANNEL_G",
		    "SVG_CHANNEL_R",
		    "SVG_CHANNEL_UNKNOWN",
		    "SVG_COLORTYPE_CURRENTCOLOR",
		    "SVG_COLORTYPE_RGBCOLOR",
		    "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
		    "SVG_COLORTYPE_UNKNOWN",
		    "SVG_EDGEMODE_DUPLICATE",
		    "SVG_EDGEMODE_NONE",
		    "SVG_EDGEMODE_UNKNOWN",
		    "SVG_EDGEMODE_WRAP",
		    "SVG_FEBLEND_MODE_COLOR",
		    "SVG_FEBLEND_MODE_COLOR_BURN",
		    "SVG_FEBLEND_MODE_COLOR_DODGE",
		    "SVG_FEBLEND_MODE_DARKEN",
		    "SVG_FEBLEND_MODE_DIFFERENCE",
		    "SVG_FEBLEND_MODE_EXCLUSION",
		    "SVG_FEBLEND_MODE_HARD_LIGHT",
		    "SVG_FEBLEND_MODE_HUE",
		    "SVG_FEBLEND_MODE_LIGHTEN",
		    "SVG_FEBLEND_MODE_LUMINOSITY",
		    "SVG_FEBLEND_MODE_MULTIPLY",
		    "SVG_FEBLEND_MODE_NORMAL",
		    "SVG_FEBLEND_MODE_OVERLAY",
		    "SVG_FEBLEND_MODE_SATURATION",
		    "SVG_FEBLEND_MODE_SCREEN",
		    "SVG_FEBLEND_MODE_SOFT_LIGHT",
		    "SVG_FEBLEND_MODE_UNKNOWN",
		    "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
		    "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
		    "SVG_FECOLORMATRIX_TYPE_MATRIX",
		    "SVG_FECOLORMATRIX_TYPE_SATURATE",
		    "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
		    "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
		    "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
		    "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
		    "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
		    "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
		    "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
		    "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
		    "SVG_FECOMPOSITE_OPERATOR_ATOP",
		    "SVG_FECOMPOSITE_OPERATOR_IN",
		    "SVG_FECOMPOSITE_OPERATOR_OUT",
		    "SVG_FECOMPOSITE_OPERATOR_OVER",
		    "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
		    "SVG_FECOMPOSITE_OPERATOR_XOR",
		    "SVG_INVALID_VALUE_ERR",
		    "SVG_LENGTHTYPE_CM",
		    "SVG_LENGTHTYPE_EMS",
		    "SVG_LENGTHTYPE_EXS",
		    "SVG_LENGTHTYPE_IN",
		    "SVG_LENGTHTYPE_MM",
		    "SVG_LENGTHTYPE_NUMBER",
		    "SVG_LENGTHTYPE_PC",
		    "SVG_LENGTHTYPE_PERCENTAGE",
		    "SVG_LENGTHTYPE_PT",
		    "SVG_LENGTHTYPE_PX",
		    "SVG_LENGTHTYPE_UNKNOWN",
		    "SVG_MARKERUNITS_STROKEWIDTH",
		    "SVG_MARKERUNITS_UNKNOWN",
		    "SVG_MARKERUNITS_USERSPACEONUSE",
		    "SVG_MARKER_ORIENT_ANGLE",
		    "SVG_MARKER_ORIENT_AUTO",
		    "SVG_MARKER_ORIENT_UNKNOWN",
		    "SVG_MASKTYPE_ALPHA",
		    "SVG_MASKTYPE_LUMINANCE",
		    "SVG_MATRIX_NOT_INVERTABLE",
		    "SVG_MEETORSLICE_MEET",
		    "SVG_MEETORSLICE_SLICE",
		    "SVG_MEETORSLICE_UNKNOWN",
		    "SVG_MORPHOLOGY_OPERATOR_DILATE",
		    "SVG_MORPHOLOGY_OPERATOR_ERODE",
		    "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
		    "SVG_PAINTTYPE_CURRENTCOLOR",
		    "SVG_PAINTTYPE_NONE",
		    "SVG_PAINTTYPE_RGBCOLOR",
		    "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
		    "SVG_PAINTTYPE_UNKNOWN",
		    "SVG_PAINTTYPE_URI",
		    "SVG_PAINTTYPE_URI_CURRENTCOLOR",
		    "SVG_PAINTTYPE_URI_NONE",
		    "SVG_PAINTTYPE_URI_RGBCOLOR",
		    "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
		    "SVG_PRESERVEASPECTRATIO_NONE",
		    "SVG_PRESERVEASPECTRATIO_UNKNOWN",
		    "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
		    "SVG_PRESERVEASPECTRATIO_XMAXYMID",
		    "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
		    "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
		    "SVG_PRESERVEASPECTRATIO_XMIDYMID",
		    "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
		    "SVG_PRESERVEASPECTRATIO_XMINYMAX",
		    "SVG_PRESERVEASPECTRATIO_XMINYMID",
		    "SVG_PRESERVEASPECTRATIO_XMINYMIN",
		    "SVG_SPREADMETHOD_PAD",
		    "SVG_SPREADMETHOD_REFLECT",
		    "SVG_SPREADMETHOD_REPEAT",
		    "SVG_SPREADMETHOD_UNKNOWN",
		    "SVG_STITCHTYPE_NOSTITCH",
		    "SVG_STITCHTYPE_STITCH",
		    "SVG_STITCHTYPE_UNKNOWN",
		    "SVG_TRANSFORM_MATRIX",
		    "SVG_TRANSFORM_ROTATE",
		    "SVG_TRANSFORM_SCALE",
		    "SVG_TRANSFORM_SKEWX",
		    "SVG_TRANSFORM_SKEWY",
		    "SVG_TRANSFORM_TRANSLATE",
		    "SVG_TRANSFORM_UNKNOWN",
		    "SVG_TURBULENCE_TYPE_FRACTALNOISE",
		    "SVG_TURBULENCE_TYPE_TURBULENCE",
		    "SVG_TURBULENCE_TYPE_UNKNOWN",
		    "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
		    "SVG_UNIT_TYPE_UNKNOWN",
		    "SVG_UNIT_TYPE_USERSPACEONUSE",
		    "SVG_WRONG_TYPE_ERR",
		    "SVG_ZOOMANDPAN_DISABLE",
		    "SVG_ZOOMANDPAN_MAGNIFY",
		    "SVG_ZOOMANDPAN_UNKNOWN",
		    "SYNC_CONDITION",
		    "SYNC_FENCE",
		    "SYNC_FLAGS",
		    "SYNC_FLUSH_COMMANDS_BIT",
		    "SYNC_GPU_COMMANDS_COMPLETE",
		    "SYNC_STATUS",
		    "SYNTAX_ERR",
		    "SavedPages",
		    "Screen",
		    "ScreenOrientation",
		    "Script",
		    "ScriptProcessorNode",
		    "ScrollAreaEvent",
		    "SecurityPolicyViolationEvent",
		    "Selection",
		    "Sensor",
		    "SensorErrorEvent",
		    "ServiceWorker",
		    "ServiceWorkerContainer",
		    "ServiceWorkerRegistration",
		    "SessionDescription",
		    "Set",
		    "ShadowRoot",
		    "SharedArrayBuffer",
		    "SharedWorker",
		    "SimpleGestureEvent",
		    "SourceBuffer",
		    "SourceBufferList",
		    "SpeechSynthesis",
		    "SpeechSynthesisErrorEvent",
		    "SpeechSynthesisEvent",
		    "SpeechSynthesisUtterance",
		    "SpeechSynthesisVoice",
		    "StaticRange",
		    "StereoPannerNode",
		    "StopIteration",
		    "Storage",
		    "StorageEvent",
		    "StorageManager",
		    "String",
		    "StructType",
		    "StylePropertyMap",
		    "StylePropertyMapReadOnly",
		    "StyleSheet",
		    "StyleSheetList",
		    "SubmitEvent",
		    "SubtleCrypto",
		    "Symbol",
		    "SyncManager",
		    "SyntaxError",
		    "TEMPORARY",
		    "TEXTPATH_METHODTYPE_ALIGN",
		    "TEXTPATH_METHODTYPE_STRETCH",
		    "TEXTPATH_METHODTYPE_UNKNOWN",
		    "TEXTPATH_SPACINGTYPE_AUTO",
		    "TEXTPATH_SPACINGTYPE_EXACT",
		    "TEXTPATH_SPACINGTYPE_UNKNOWN",
		    "TEXTURE",
		    "TEXTURE0",
		    "TEXTURE1",
		    "TEXTURE10",
		    "TEXTURE11",
		    "TEXTURE12",
		    "TEXTURE13",
		    "TEXTURE14",
		    "TEXTURE15",
		    "TEXTURE16",
		    "TEXTURE17",
		    "TEXTURE18",
		    "TEXTURE19",
		    "TEXTURE2",
		    "TEXTURE20",
		    "TEXTURE21",
		    "TEXTURE22",
		    "TEXTURE23",
		    "TEXTURE24",
		    "TEXTURE25",
		    "TEXTURE26",
		    "TEXTURE27",
		    "TEXTURE28",
		    "TEXTURE29",
		    "TEXTURE3",
		    "TEXTURE30",
		    "TEXTURE31",
		    "TEXTURE4",
		    "TEXTURE5",
		    "TEXTURE6",
		    "TEXTURE7",
		    "TEXTURE8",
		    "TEXTURE9",
		    "TEXTURE_2D",
		    "TEXTURE_2D_ARRAY",
		    "TEXTURE_3D",
		    "TEXTURE_BASE_LEVEL",
		    "TEXTURE_BINDING",
		    "TEXTURE_BINDING_2D",
		    "TEXTURE_BINDING_2D_ARRAY",
		    "TEXTURE_BINDING_3D",
		    "TEXTURE_BINDING_CUBE_MAP",
		    "TEXTURE_COMPARE_FUNC",
		    "TEXTURE_COMPARE_MODE",
		    "TEXTURE_CUBE_MAP",
		    "TEXTURE_CUBE_MAP_NEGATIVE_X",
		    "TEXTURE_CUBE_MAP_NEGATIVE_Y",
		    "TEXTURE_CUBE_MAP_NEGATIVE_Z",
		    "TEXTURE_CUBE_MAP_POSITIVE_X",
		    "TEXTURE_CUBE_MAP_POSITIVE_Y",
		    "TEXTURE_CUBE_MAP_POSITIVE_Z",
		    "TEXTURE_IMMUTABLE_FORMAT",
		    "TEXTURE_IMMUTABLE_LEVELS",
		    "TEXTURE_MAG_FILTER",
		    "TEXTURE_MAX_ANISOTROPY_EXT",
		    "TEXTURE_MAX_LEVEL",
		    "TEXTURE_MAX_LOD",
		    "TEXTURE_MIN_FILTER",
		    "TEXTURE_MIN_LOD",
		    "TEXTURE_WRAP_R",
		    "TEXTURE_WRAP_S",
		    "TEXTURE_WRAP_T",
		    "TEXT_NODE",
		    "TIMEOUT",
		    "TIMEOUT_ERR",
		    "TIMEOUT_EXPIRED",
		    "TIMEOUT_IGNORED",
		    "TOO_LARGE_ERR",
		    "TRANSACTION_INACTIVE_ERR",
		    "TRANSFORM_FEEDBACK",
		    "TRANSFORM_FEEDBACK_ACTIVE",
		    "TRANSFORM_FEEDBACK_BINDING",
		    "TRANSFORM_FEEDBACK_BUFFER",
		    "TRANSFORM_FEEDBACK_BUFFER_BINDING",
		    "TRANSFORM_FEEDBACK_BUFFER_MODE",
		    "TRANSFORM_FEEDBACK_BUFFER_SIZE",
		    "TRANSFORM_FEEDBACK_BUFFER_START",
		    "TRANSFORM_FEEDBACK_PAUSED",
		    "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
		    "TRANSFORM_FEEDBACK_VARYINGS",
		    "TRIANGLE",
		    "TRIANGLES",
		    "TRIANGLE_FAN",
		    "TRIANGLE_STRIP",
		    "TYPE_BACK_FORWARD",
		    "TYPE_ERR",
		    "TYPE_MISMATCH_ERR",
		    "TYPE_NAVIGATE",
		    "TYPE_RELOAD",
		    "TYPE_RESERVED",
		    "Table",
		    "TaskAttributionTiming",
		    "Text",
		    "TextDecoder",
		    "TextDecoderStream",
		    "TextEncoder",
		    "TextEncoderStream",
		    "TextEvent",
		    "TextMetrics",
		    "TextTrack",
		    "TextTrackCue",
		    "TextTrackCueList",
		    "TextTrackList",
		    "TimeEvent",
		    "TimeRanges",
		    "Touch",
		    "TouchEvent",
		    "TouchList",
		    "TrackEvent",
		    "TransformStream",
		    "TransitionEvent",
		    "TreeWalker",
		    "TrustedHTML",
		    "TrustedScript",
		    "TrustedScriptURL",
		    "TrustedTypePolicy",
		    "TrustedTypePolicyFactory",
		    "TypeError",
		    "TypedObject",
		    "U2F",
		    "UIEvent",
		    "UNCACHED",
		    "UNIFORM",
		    "UNIFORM_ARRAY_STRIDE",
		    "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
		    "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
		    "UNIFORM_BLOCK_BINDING",
		    "UNIFORM_BLOCK_DATA_SIZE",
		    "UNIFORM_BLOCK_INDEX",
		    "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
		    "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
		    "UNIFORM_BUFFER",
		    "UNIFORM_BUFFER_BINDING",
		    "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
		    "UNIFORM_BUFFER_SIZE",
		    "UNIFORM_BUFFER_START",
		    "UNIFORM_IS_ROW_MAJOR",
		    "UNIFORM_MATRIX_STRIDE",
		    "UNIFORM_OFFSET",
		    "UNIFORM_SIZE",
		    "UNIFORM_TYPE",
		    "UNKNOWN_ERR",
		    "UNKNOWN_RULE",
		    "UNMASKED_RENDERER_WEBGL",
		    "UNMASKED_VENDOR_WEBGL",
		    "UNORDERED_NODE_ITERATOR_TYPE",
		    "UNORDERED_NODE_SNAPSHOT_TYPE",
		    "UNPACK_ALIGNMENT",
		    "UNPACK_COLORSPACE_CONVERSION_WEBGL",
		    "UNPACK_FLIP_Y_WEBGL",
		    "UNPACK_IMAGE_HEIGHT",
		    "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
		    "UNPACK_ROW_LENGTH",
		    "UNPACK_SKIP_IMAGES",
		    "UNPACK_SKIP_PIXELS",
		    "UNPACK_SKIP_ROWS",
		    "UNSCHEDULED_STATE",
		    "UNSENT",
		    "UNSIGNALED",
		    "UNSIGNED_BYTE",
		    "UNSIGNED_INT",
		    "UNSIGNED_INT_10F_11F_11F_REV",
		    "UNSIGNED_INT_24_8",
		    "UNSIGNED_INT_2_10_10_10_REV",
		    "UNSIGNED_INT_5_9_9_9_REV",
		    "UNSIGNED_INT_SAMPLER_2D",
		    "UNSIGNED_INT_SAMPLER_2D_ARRAY",
		    "UNSIGNED_INT_SAMPLER_3D",
		    "UNSIGNED_INT_SAMPLER_CUBE",
		    "UNSIGNED_INT_VEC2",
		    "UNSIGNED_INT_VEC3",
		    "UNSIGNED_INT_VEC4",
		    "UNSIGNED_NORMALIZED",
		    "UNSIGNED_SHORT",
		    "UNSIGNED_SHORT_4_4_4_4",
		    "UNSIGNED_SHORT_5_5_5_1",
		    "UNSIGNED_SHORT_5_6_5",
		    "UNSPECIFIED_EVENT_TYPE_ERR",
		    "UPDATEREADY",
		    "URIError",
		    "URL",
		    "URLSearchParams",
		    "URLUnencoded",
		    "URL_MISMATCH_ERR",
		    "USB",
		    "USBAlternateInterface",
		    "USBConfiguration",
		    "USBConnectionEvent",
		    "USBDevice",
		    "USBEndpoint",
		    "USBInTransferResult",
		    "USBInterface",
		    "USBIsochronousInTransferPacket",
		    "USBIsochronousInTransferResult",
		    "USBIsochronousOutTransferPacket",
		    "USBIsochronousOutTransferResult",
		    "USBOutTransferResult",
		    "UTC",
		    "Uint16Array",
		    "Uint32Array",
		    "Uint8Array",
		    "Uint8ClampedArray",
		    "UserActivation",
		    "UserMessageHandler",
		    "UserMessageHandlersNamespace",
		    "UserProximityEvent",
		    "VALIDATE_STATUS",
		    "VALIDATION_ERR",
		    "VARIABLES_RULE",
		    "VENDOR",
		    "VERSION",
		    "VERSION_CHANGE",
		    "VERSION_ERR",
		    "VERTEX",
		    "VERTEX_ARRAY_BINDING",
		    "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
		    "VERTEX_ATTRIB_ARRAY_DIVISOR",
		    "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
		    "VERTEX_ATTRIB_ARRAY_ENABLED",
		    "VERTEX_ATTRIB_ARRAY_INTEGER",
		    "VERTEX_ATTRIB_ARRAY_NORMALIZED",
		    "VERTEX_ATTRIB_ARRAY_POINTER",
		    "VERTEX_ATTRIB_ARRAY_SIZE",
		    "VERTEX_ATTRIB_ARRAY_STRIDE",
		    "VERTEX_ATTRIB_ARRAY_TYPE",
		    "VERTEX_SHADER",
		    "VERTICAL",
		    "VERTICAL_AXIS",
		    "VER_ERR",
		    "VIEWPORT",
		    "VIEWPORT_RULE",
		    "VRDisplay",
		    "VRDisplayCapabilities",
		    "VRDisplayEvent",
		    "VREyeParameters",
		    "VRFieldOfView",
		    "VRFrameData",
		    "VRPose",
		    "VRStageParameters",
		    "VTTCue",
		    "VTTRegion",
		    "ValidityState",
		    "VideoPlaybackQuality",
		    "VideoStreamTrack",
		    "VisualViewport",
		    "WAIT_FAILED",
		    "WEBKIT_FILTER_RULE",
		    "WEBKIT_KEYFRAMES_RULE",
		    "WEBKIT_KEYFRAME_RULE",
		    "WEBKIT_REGION_RULE",
		    "WRITE",
		    "WRONG_DOCUMENT_ERR",
		    "WakeLock",
		    "WakeLockSentinel",
		    "WasmAnyRef",
		    "WaveShaperNode",
		    "WeakMap",
		    "WeakRef",
		    "WeakSet",
		    "WebAssembly",
		    "WebGL2RenderingContext",
		    "WebGLActiveInfo",
		    "WebGLBuffer",
		    "WebGLContextEvent",
		    "WebGLFramebuffer",
		    "WebGLProgram",
		    "WebGLQuery",
		    "WebGLRenderbuffer",
		    "WebGLRenderingContext",
		    "WebGLSampler",
		    "WebGLShader",
		    "WebGLShaderPrecisionFormat",
		    "WebGLSync",
		    "WebGLTexture",
		    "WebGLTransformFeedback",
		    "WebGLUniformLocation",
		    "WebGLVertexArray",
		    "WebGLVertexArrayObject",
		    "WebKitAnimationEvent",
		    "WebKitBlobBuilder",
		    "WebKitCSSFilterRule",
		    "WebKitCSSFilterValue",
		    "WebKitCSSKeyframeRule",
		    "WebKitCSSKeyframesRule",
		    "WebKitCSSMatrix",
		    "WebKitCSSRegionRule",
		    "WebKitCSSTransformValue",
		    "WebKitDataCue",
		    "WebKitGamepad",
		    "WebKitMediaKeyError",
		    "WebKitMediaKeyMessageEvent",
		    "WebKitMediaKeySession",
		    "WebKitMediaKeys",
		    "WebKitMediaSource",
		    "WebKitMutationObserver",
		    "WebKitNamespace",
		    "WebKitPlaybackTargetAvailabilityEvent",
		    "WebKitPoint",
		    "WebKitShadowRoot",
		    "WebKitSourceBuffer",
		    "WebKitSourceBufferList",
		    "WebKitTransitionEvent",
		    "WebSocket",
		    "WebkitAlignContent",
		    "WebkitAlignItems",
		    "WebkitAlignSelf",
		    "WebkitAnimation",
		    "WebkitAnimationDelay",
		    "WebkitAnimationDirection",
		    "WebkitAnimationDuration",
		    "WebkitAnimationFillMode",
		    "WebkitAnimationIterationCount",
		    "WebkitAnimationName",
		    "WebkitAnimationPlayState",
		    "WebkitAnimationTimingFunction",
		    "WebkitAppearance",
		    "WebkitBackfaceVisibility",
		    "WebkitBackgroundClip",
		    "WebkitBackgroundOrigin",
		    "WebkitBackgroundSize",
		    "WebkitBorderBottomLeftRadius",
		    "WebkitBorderBottomRightRadius",
		    "WebkitBorderImage",
		    "WebkitBorderRadius",
		    "WebkitBorderTopLeftRadius",
		    "WebkitBorderTopRightRadius",
		    "WebkitBoxAlign",
		    "WebkitBoxDirection",
		    "WebkitBoxFlex",
		    "WebkitBoxOrdinalGroup",
		    "WebkitBoxOrient",
		    "WebkitBoxPack",
		    "WebkitBoxShadow",
		    "WebkitBoxSizing",
		    "WebkitFilter",
		    "WebkitFlex",
		    "WebkitFlexBasis",
		    "WebkitFlexDirection",
		    "WebkitFlexFlow",
		    "WebkitFlexGrow",
		    "WebkitFlexShrink",
		    "WebkitFlexWrap",
		    "WebkitJustifyContent",
		    "WebkitLineClamp",
		    "WebkitMask",
		    "WebkitMaskClip",
		    "WebkitMaskComposite",
		    "WebkitMaskImage",
		    "WebkitMaskOrigin",
		    "WebkitMaskPosition",
		    "WebkitMaskPositionX",
		    "WebkitMaskPositionY",
		    "WebkitMaskRepeat",
		    "WebkitMaskSize",
		    "WebkitOrder",
		    "WebkitPerspective",
		    "WebkitPerspectiveOrigin",
		    "WebkitTextFillColor",
		    "WebkitTextSizeAdjust",
		    "WebkitTextStroke",
		    "WebkitTextStrokeColor",
		    "WebkitTextStrokeWidth",
		    "WebkitTransform",
		    "WebkitTransformOrigin",
		    "WebkitTransformStyle",
		    "WebkitTransition",
		    "WebkitTransitionDelay",
		    "WebkitTransitionDuration",
		    "WebkitTransitionProperty",
		    "WebkitTransitionTimingFunction",
		    "WebkitUserSelect",
		    "WheelEvent",
		    "Window",
		    "Worker",
		    "Worklet",
		    "WritableStream",
		    "WritableStreamDefaultWriter",
		    "XMLDocument",
		    "XMLHttpRequest",
		    "XMLHttpRequestEventTarget",
		    "XMLHttpRequestException",
		    "XMLHttpRequestProgressEvent",
		    "XMLHttpRequestUpload",
		    "XMLSerializer",
		    "XMLStylesheetProcessingInstruction",
		    "XPathEvaluator",
		    "XPathException",
		    "XPathExpression",
		    "XPathNSResolver",
		    "XPathResult",
		    "XRBoundedReferenceSpace",
		    "XRDOMOverlayState",
		    "XRFrame",
		    "XRHitTestResult",
		    "XRHitTestSource",
		    "XRInputSource",
		    "XRInputSourceArray",
		    "XRInputSourceEvent",
		    "XRInputSourcesChangeEvent",
		    "XRLayer",
		    "XRPose",
		    "XRRay",
		    "XRReferenceSpace",
		    "XRReferenceSpaceEvent",
		    "XRRenderState",
		    "XRRigidTransform",
		    "XRSession",
		    "XRSessionEvent",
		    "XRSpace",
		    "XRSystem",
		    "XRTransientInputHitTestResult",
		    "XRTransientInputHitTestSource",
		    "XRView",
		    "XRViewerPose",
		    "XRViewport",
		    "XRWebGLLayer",
		    "XSLTProcessor",
		    "ZERO",
		    "_XD0M_",
		    "_YD0M_",
		    "__brand",
		    "__defineGetter__",
		    "__defineSetter__",
		    "__lookupGetter__",
		    "__lookupSetter__",
		    "__opera",
		    "__proto__",
		    "_browserjsran",
		    "a",
		    "aLink",
		    "abbr",
		    "abort",
		    "aborted",
		    "abs",
		    "absolute",
		    "acceleration",
		    "accelerationIncludingGravity",
		    "accelerator",
		    "accept",
		    "acceptCharset",
		    "acceptNode",
		    "access",
		    "accessKey",
		    "accessKeyLabel",
		    "accuracy",
		    "acos",
		    "acosh",
		    "action",
		    "actionURL",
		    "actions",
		    "activated",
		    "active",
		    "activeCues",
		    "activeElement",
		    "activeSourceBuffers",
		    "activeSourceCount",
		    "activeTexture",
		    "activeVRDisplays",
		    "actualBoundingBoxAscent",
		    "actualBoundingBoxDescent",
		    "actualBoundingBoxLeft",
		    "actualBoundingBoxRight",
		    "add",
		    "addAll",
		    "addBehavior",
		    "addCandidate",
		    "addColorStop",
		    "addCue",
		    "addElement",
		    "addEventListener",
		    "addFilter",
		    "addFromString",
		    "addFromUri",
		    "addIceCandidate",
		    "addImport",
		    "addListener",
		    "addModule",
		    "addNamed",
		    "addPageRule",
		    "addPath",
		    "addPointer",
		    "addRange",
		    "addRegion",
		    "addRule",
		    "addSearchEngine",
		    "addSourceBuffer",
		    "addStream",
		    "addTextTrack",
		    "addTrack",
		    "addTransceiver",
		    "addWakeLockListener",
		    "added",
		    "addedNodes",
		    "additionalName",
		    "additiveSymbols",
		    "addons",
		    "address",
		    "addressLine",
		    "addressModeU",
		    "addressModeV",
		    "addressModeW",
		    "adoptNode",
		    "adoptedStyleSheets",
		    "adr",
		    "advance",
		    "after",
		    "album",
		    "alert",
		    "algorithm",
		    "align",
		    "align-content",
		    "align-items",
		    "align-self",
		    "alignContent",
		    "alignItems",
		    "alignSelf",
		    "alignmentBaseline",
		    "alinkColor",
		    "all",
		    "allSettled",
		    "allow",
		    "allowFullscreen",
		    "allowPaymentRequest",
		    "allowedDirections",
		    "allowedFeatures",
		    "allowedToPlay",
		    "allowsFeature",
		    "alpha",
		    "alphaMode",
		    "alphaToCoverageEnabled",
		    "alt",
		    "altGraphKey",
		    "altHtml",
		    "altKey",
		    "altLeft",
		    "alternate",
		    "alternateSetting",
		    "alternates",
		    "altitude",
		    "altitudeAccuracy",
		    "amplitude",
		    "ancestorOrigins",
		    "anchor",
		    "anchorNode",
		    "anchorOffset",
		    "anchors",
		    "and",
		    "angle",
		    "angularAcceleration",
		    "angularVelocity",
		    "animVal",
		    "animate",
		    "animatedInstanceRoot",
		    "animatedNormalizedPathSegList",
		    "animatedPathSegList",
		    "animatedPoints",
		    "animation",
		    "animation-delay",
		    "animation-direction",
		    "animation-duration",
		    "animation-fill-mode",
		    "animation-iteration-count",
		    "animation-name",
		    "animation-play-state",
		    "animation-timing-function",
		    "animationDelay",
		    "animationDirection",
		    "animationDuration",
		    "animationFillMode",
		    "animationIterationCount",
		    "animationName",
		    "animationPlayState",
		    "animationStartTime",
		    "animationTimingFunction",
		    "animationsPaused",
		    "anniversary",
		    "antialias",
		    "anticipatedRemoval",
		    "any",
		    "app",
		    "appCodeName",
		    "appMinorVersion",
		    "appName",
		    "appNotifications",
		    "appVersion",
		    "appearance",
		    "append",
		    "appendBuffer",
		    "appendChild",
		    "appendData",
		    "appendItem",
		    "appendMedium",
		    "appendNamed",
		    "appendRule",
		    "appendStream",
		    "appendWindowEnd",
		    "appendWindowStart",
		    "applets",
		    "applicationCache",
		    "applicationServerKey",
		    "apply",
		    "applyConstraints",
		    "applyElement",
		    "arc",
		    "arcTo",
		    "architecture",
		    "archive",
		    "areas",
		    "arguments",
		    "ariaAtomic",
		    "ariaAutoComplete",
		    "ariaBusy",
		    "ariaChecked",
		    "ariaColCount",
		    "ariaColIndex",
		    "ariaColSpan",
		    "ariaCurrent",
		    "ariaDescription",
		    "ariaDisabled",
		    "ariaExpanded",
		    "ariaHasPopup",
		    "ariaHidden",
		    "ariaKeyShortcuts",
		    "ariaLabel",
		    "ariaLevel",
		    "ariaLive",
		    "ariaModal",
		    "ariaMultiLine",
		    "ariaMultiSelectable",
		    "ariaOrientation",
		    "ariaPlaceholder",
		    "ariaPosInSet",
		    "ariaPressed",
		    "ariaReadOnly",
		    "ariaRelevant",
		    "ariaRequired",
		    "ariaRoleDescription",
		    "ariaRowCount",
		    "ariaRowIndex",
		    "ariaRowSpan",
		    "ariaSelected",
		    "ariaSetSize",
		    "ariaSort",
		    "ariaValueMax",
		    "ariaValueMin",
		    "ariaValueNow",
		    "ariaValueText",
		    "arrayBuffer",
		    "arrayLayerCount",
		    "arrayStride",
		    "artist",
		    "artwork",
		    "as",
		    "asIntN",
		    "asUintN",
		    "asin",
		    "asinh",
		    "aspect",
		    "assert",
		    "assign",
		    "assignedElements",
		    "assignedNodes",
		    "assignedSlot",
		    "async",
		    "asyncIterator",
		    "atEnd",
		    "atan",
		    "atan2",
		    "atanh",
		    "atob",
		    "attachEvent",
		    "attachInternals",
		    "attachShader",
		    "attachShadow",
		    "attachments",
		    "attack",
		    "attestationObject",
		    "attrChange",
		    "attrName",
		    "attributeFilter",
		    "attributeName",
		    "attributeNamespace",
		    "attributeOldValue",
		    "attributeStyleMap",
		    "attributes",
		    "attribution",
		    "audioBitsPerSecond",
		    "audioTracks",
		    "audioWorklet",
		    "authenticatedSignedWrites",
		    "authenticatorData",
		    "autoIncrement",
		    "autobuffer",
		    "autocapitalize",
		    "autocomplete",
		    "autocorrect",
		    "autofocus",
		    "automationRate",
		    "autoplay",
		    "availHeight",
		    "availLeft",
		    "availTop",
		    "availWidth",
		    "availability",
		    "available",
		    "aversion",
		    "ax",
		    "axes",
		    "axis",
		    "ay",
		    "azimuth",
		    "b",
		    "back",
		    "backface-visibility",
		    "backfaceVisibility",
		    "background",
		    "background-attachment",
		    "background-blend-mode",
		    "background-clip",
		    "background-color",
		    "background-image",
		    "background-origin",
		    "background-position",
		    "background-position-x",
		    "background-position-y",
		    "background-repeat",
		    "background-size",
		    "backgroundAttachment",
		    "backgroundBlendMode",
		    "backgroundClip",
		    "backgroundColor",
		    "backgroundFetch",
		    "backgroundImage",
		    "backgroundOrigin",
		    "backgroundPosition",
		    "backgroundPositionX",
		    "backgroundPositionY",
		    "backgroundRepeat",
		    "backgroundSize",
		    "badInput",
		    "badge",
		    "balance",
		    "baseArrayLayer",
		    "baseFrequencyX",
		    "baseFrequencyY",
		    "baseLatency",
		    "baseLayer",
		    "baseMipLevel",
		    "baseNode",
		    "baseOffset",
		    "baseURI",
		    "baseVal",
		    "baselineShift",
		    "battery",
		    "bday",
		    "before",
		    "beginComputePass",
		    "beginElement",
		    "beginElementAt",
		    "beginOcclusionQuery",
		    "beginPath",
		    "beginQuery",
		    "beginRenderPass",
		    "beginTransformFeedback",
		    "beginningOfPassWriteIndex",
		    "behavior",
		    "behaviorCookie",
		    "behaviorPart",
		    "behaviorUrns",
		    "beta",
		    "bezierCurveTo",
		    "bgColor",
		    "bgProperties",
		    "bias",
		    "big",
		    "bigint64",
		    "biguint64",
		    "binaryType",
		    "bind",
		    "bindAttribLocation",
		    "bindBuffer",
		    "bindBufferBase",
		    "bindBufferRange",
		    "bindFramebuffer",
		    "bindGroupLayouts",
		    "bindRenderbuffer",
		    "bindSampler",
		    "bindTexture",
		    "bindTransformFeedback",
		    "bindVertexArray",
		    "binding",
		    "bitness",
		    "blend",
		    "blendColor",
		    "blendEquation",
		    "blendEquationSeparate",
		    "blendFunc",
		    "blendFuncSeparate",
		    "blink",
		    "blitFramebuffer",
		    "blob",
		    "block-size",
		    "blockDirection",
		    "blockSize",
		    "blockedURI",
		    "blue",
		    "bluetooth",
		    "blur",
		    "body",
		    "bodyUsed",
		    "bold",
		    "bookmarks",
		    "booleanValue",
		    "border",
		    "border-block",
		    "border-block-color",
		    "border-block-end",
		    "border-block-end-color",
		    "border-block-end-style",
		    "border-block-end-width",
		    "border-block-start",
		    "border-block-start-color",
		    "border-block-start-style",
		    "border-block-start-width",
		    "border-block-style",
		    "border-block-width",
		    "border-bottom",
		    "border-bottom-color",
		    "border-bottom-left-radius",
		    "border-bottom-right-radius",
		    "border-bottom-style",
		    "border-bottom-width",
		    "border-collapse",
		    "border-color",
		    "border-end-end-radius",
		    "border-end-start-radius",
		    "border-image",
		    "border-image-outset",
		    "border-image-repeat",
		    "border-image-slice",
		    "border-image-source",
		    "border-image-width",
		    "border-inline",
		    "border-inline-color",
		    "border-inline-end",
		    "border-inline-end-color",
		    "border-inline-end-style",
		    "border-inline-end-width",
		    "border-inline-start",
		    "border-inline-start-color",
		    "border-inline-start-style",
		    "border-inline-start-width",
		    "border-inline-style",
		    "border-inline-width",
		    "border-left",
		    "border-left-color",
		    "border-left-style",
		    "border-left-width",
		    "border-radius",
		    "border-right",
		    "border-right-color",
		    "border-right-style",
		    "border-right-width",
		    "border-spacing",
		    "border-start-end-radius",
		    "border-start-start-radius",
		    "border-style",
		    "border-top",
		    "border-top-color",
		    "border-top-left-radius",
		    "border-top-right-radius",
		    "border-top-style",
		    "border-top-width",
		    "border-width",
		    "borderBlock",
		    "borderBlockColor",
		    "borderBlockEnd",
		    "borderBlockEndColor",
		    "borderBlockEndStyle",
		    "borderBlockEndWidth",
		    "borderBlockStart",
		    "borderBlockStartColor",
		    "borderBlockStartStyle",
		    "borderBlockStartWidth",
		    "borderBlockStyle",
		    "borderBlockWidth",
		    "borderBottom",
		    "borderBottomColor",
		    "borderBottomLeftRadius",
		    "borderBottomRightRadius",
		    "borderBottomStyle",
		    "borderBottomWidth",
		    "borderBoxSize",
		    "borderCollapse",
		    "borderColor",
		    "borderColorDark",
		    "borderColorLight",
		    "borderEndEndRadius",
		    "borderEndStartRadius",
		    "borderImage",
		    "borderImageOutset",
		    "borderImageRepeat",
		    "borderImageSlice",
		    "borderImageSource",
		    "borderImageWidth",
		    "borderInline",
		    "borderInlineColor",
		    "borderInlineEnd",
		    "borderInlineEndColor",
		    "borderInlineEndStyle",
		    "borderInlineEndWidth",
		    "borderInlineStart",
		    "borderInlineStartColor",
		    "borderInlineStartStyle",
		    "borderInlineStartWidth",
		    "borderInlineStyle",
		    "borderInlineWidth",
		    "borderLeft",
		    "borderLeftColor",
		    "borderLeftStyle",
		    "borderLeftWidth",
		    "borderRadius",
		    "borderRight",
		    "borderRightColor",
		    "borderRightStyle",
		    "borderRightWidth",
		    "borderSpacing",
		    "borderStartEndRadius",
		    "borderStartStartRadius",
		    "borderStyle",
		    "borderTop",
		    "borderTopColor",
		    "borderTopLeftRadius",
		    "borderTopRightRadius",
		    "borderTopStyle",
		    "borderTopWidth",
		    "borderWidth",
		    "bottom",
		    "bottomMargin",
		    "bound",
		    "boundElements",
		    "boundingClientRect",
		    "boundingHeight",
		    "boundingLeft",
		    "boundingTop",
		    "boundingWidth",
		    "bounds",
		    "boundsGeometry",
		    "box-decoration-break",
		    "box-shadow",
		    "box-sizing",
		    "boxDecorationBreak",
		    "boxShadow",
		    "boxSizing",
		    "brand",
		    "brands",
		    "break-after",
		    "break-before",
		    "break-inside",
		    "breakAfter",
		    "breakBefore",
		    "breakInside",
		    "broadcast",
		    "browserLanguage",
		    "btoa",
		    "bubbles",
		    "buffer",
		    "bufferData",
		    "bufferDepth",
		    "bufferSize",
		    "bufferSubData",
		    "buffered",
		    "bufferedAmount",
		    "bufferedAmountLowThreshold",
		    "buffers",
		    "buildID",
		    "buildNumber",
		    "button",
		    "buttonID",
		    "buttons",
		    "byteLength",
		    "byteOffset",
		    "bytesPerRow",
		    "bytesWritten",
		    "c",
		    "cache",
		    "caches",
		    "call",
		    "caller",
		    "canBeFormatted",
		    "canBeMounted",
		    "canBeShared",
		    "canHaveChildren",
		    "canHaveHTML",
		    "canInsertDTMF",
		    "canMakePayment",
		    "canPlayType",
		    "canPresent",
		    "canTrickleIceCandidates",
		    "cancel",
		    "cancelAndHoldAtTime",
		    "cancelAnimationFrame",
		    "cancelBubble",
		    "cancelIdleCallback",
		    "cancelScheduledValues",
		    "cancelVideoFrameCallback",
		    "cancelWatchAvailability",
		    "cancelable",
		    "candidate",
		    "canonicalUUID",
		    "canvas",
		    "capabilities",
		    "caption",
		    "caption-side",
		    "captionSide",
		    "capture",
		    "captureEvents",
		    "captureStackTrace",
		    "captureStream",
		    "caret-color",
		    "caretBidiLevel",
		    "caretColor",
		    "caretPositionFromPoint",
		    "caretRangeFromPoint",
		    "cast",
		    "catch",
		    "category",
		    "cbrt",
		    "cd",
		    "ceil",
		    "cellIndex",
		    "cellPadding",
		    "cellSpacing",
		    "cells",
		    "ch",
		    "chOff",
		    "chain",
		    "challenge",
		    "changeType",
		    "changedTouches",
		    "channel",
		    "channelCount",
		    "channelCountMode",
		    "channelInterpretation",
		    "char",
		    "charAt",
		    "charCode",
		    "charCodeAt",
		    "charIndex",
		    "charLength",
		    "characterData",
		    "characterDataOldValue",
		    "characterSet",
		    "characteristic",
		    "charging",
		    "chargingTime",
		    "charset",
		    "check",
		    "checkEnclosure",
		    "checkFramebufferStatus",
		    "checkIntersection",
		    "checkValidity",
		    "checked",
		    "childElementCount",
		    "childList",
		    "childNodes",
		    "children",
		    "chrome",
		    "ciphertext",
		    "cite",
		    "city",
		    "claimInterface",
		    "claimed",
		    "classList",
		    "className",
		    "classid",
		    "clear",
		    "clearAppBadge",
		    "clearAttributes",
		    "clearBuffer",
		    "clearBufferfi",
		    "clearBufferfv",
		    "clearBufferiv",
		    "clearBufferuiv",
		    "clearColor",
		    "clearData",
		    "clearDepth",
		    "clearHalt",
		    "clearImmediate",
		    "clearInterval",
		    "clearLiveSeekableRange",
		    "clearMarks",
		    "clearMaxGCPauseAccumulator",
		    "clearMeasures",
		    "clearParameters",
		    "clearRect",
		    "clearResourceTimings",
		    "clearShadow",
		    "clearStencil",
		    "clearTimeout",
		    "clearValue",
		    "clearWatch",
		    "click",
		    "clickCount",
		    "clientDataJSON",
		    "clientHeight",
		    "clientInformation",
		    "clientLeft",
		    "clientRect",
		    "clientRects",
		    "clientTop",
		    "clientWaitSync",
		    "clientWidth",
		    "clientX",
		    "clientY",
		    "clip",
		    "clip-path",
		    "clip-rule",
		    "clipBottom",
		    "clipLeft",
		    "clipPath",
		    "clipPathUnits",
		    "clipRight",
		    "clipRule",
		    "clipTop",
		    "clipboard",
		    "clipboardData",
		    "clone",
		    "cloneContents",
		    "cloneNode",
		    "cloneRange",
		    "close",
		    "closePath",
		    "closed",
		    "closest",
		    "clz",
		    "clz32",
		    "cm",
		    "cmp",
		    "code",
		    "codeBase",
		    "codePointAt",
		    "codeType",
		    "colSpan",
		    "collapse",
		    "collapseToEnd",
		    "collapseToStart",
		    "collapsed",
		    "collect",
		    "colno",
		    "color",
		    "color-adjust",
		    "color-interpolation",
		    "color-interpolation-filters",
		    "colorAdjust",
		    "colorAttachments",
		    "colorDepth",
		    "colorFormats",
		    "colorInterpolation",
		    "colorInterpolationFilters",
		    "colorMask",
		    "colorSpace",
		    "colorType",
		    "cols",
		    "column-count",
		    "column-fill",
		    "column-gap",
		    "column-rule",
		    "column-rule-color",
		    "column-rule-style",
		    "column-rule-width",
		    "column-span",
		    "column-width",
		    "columnCount",
		    "columnFill",
		    "columnGap",
		    "columnNumber",
		    "columnRule",
		    "columnRuleColor",
		    "columnRuleStyle",
		    "columnRuleWidth",
		    "columnSpan",
		    "columnWidth",
		    "columns",
		    "command",
		    "commit",
		    "commitPreferences",
		    "commitStyles",
		    "commonAncestorContainer",
		    "compact",
		    "compare",
		    "compareBoundaryPoints",
		    "compareDocumentPosition",
		    "compareEndPoints",
		    "compareExchange",
		    "compareNode",
		    "comparePoint",
		    "compatMode",
		    "compatible",
		    "compile",
		    "compileShader",
		    "compileStreaming",
		    "complete",
		    "component",
		    "componentFromPoint",
		    "composed",
		    "composedPath",
		    "composite",
		    "compositionEndOffset",
		    "compositionStartOffset",
		    "compressedTexImage2D",
		    "compressedTexImage3D",
		    "compressedTexSubImage2D",
		    "compressedTexSubImage3D",
		    "compute",
		    "computedStyleMap",
		    "concat",
		    "conditionText",
		    "coneInnerAngle",
		    "coneOuterAngle",
		    "coneOuterGain",
		    "configurable",
		    "configuration",
		    "configurationName",
		    "configurationValue",
		    "configurations",
		    "configure",
		    "confirm",
		    "confirmComposition",
		    "confirmSiteSpecificTrackingException",
		    "confirmWebWideTrackingException",
		    "connect",
		    "connectEnd",
		    "connectShark",
		    "connectStart",
		    "connected",
		    "connection",
		    "connectionList",
		    "connectionSpeed",
		    "connectionState",
		    "connections",
		    "console",
		    "consolidate",
		    "constants",
		    "constraint",
		    "constrictionActive",
		    "construct",
		    "constructor",
		    "contactID",
		    "contain",
		    "containerId",
		    "containerName",
		    "containerSrc",
		    "containerType",
		    "contains",
		    "containsNode",
		    "content",
		    "contentBoxSize",
		    "contentDocument",
		    "contentEditable",
		    "contentHint",
		    "contentOverflow",
		    "contentRect",
		    "contentScriptType",
		    "contentStyleType",
		    "contentType",
		    "contentWindow",
		    "context",
		    "contextMenu",
		    "contextmenu",
		    "continue",
		    "continuePrimaryKey",
		    "continuous",
		    "control",
		    "controlTransferIn",
		    "controlTransferOut",
		    "controller",
		    "controls",
		    "controlsList",
		    "convertPointFromNode",
		    "convertQuadFromNode",
		    "convertRectFromNode",
		    "convertToBlob",
		    "convertToSpecifiedUnits",
		    "cookie",
		    "cookieEnabled",
		    "coords",
		    "copyBufferSubData",
		    "copyBufferToBuffer",
		    "copyBufferToTexture",
		    "copyExternalImageToTexture",
		    "copyFromChannel",
		    "copyTexImage2D",
		    "copyTexSubImage2D",
		    "copyTexSubImage3D",
		    "copyTextureToBuffer",
		    "copyTextureToTexture",
		    "copyToChannel",
		    "copyWithin",
		    "correspondingElement",
		    "correspondingUseElement",
		    "corruptedVideoFrames",
		    "cos",
		    "cosh",
		    "count",
		    "countReset",
		    "counter-increment",
		    "counter-reset",
		    "counter-set",
		    "counterIncrement",
		    "counterReset",
		    "counterSet",
		    "country",
		    "cpuClass",
		    "cpuSleepAllowed",
		    "create",
		    "createAnalyser",
		    "createAnswer",
		    "createAttribute",
		    "createAttributeNS",
		    "createBindGroup",
		    "createBindGroupLayout",
		    "createBiquadFilter",
		    "createBuffer",
		    "createBufferSource",
		    "createCDATASection",
		    "createCSSStyleSheet",
		    "createCaption",
		    "createChannelMerger",
		    "createChannelSplitter",
		    "createCommandEncoder",
		    "createComment",
		    "createComputePipeline",
		    "createComputePipelineAsync",
		    "createConstantSource",
		    "createContextualFragment",
		    "createControlRange",
		    "createConvolver",
		    "createDTMFSender",
		    "createDataChannel",
		    "createDelay",
		    "createDelayNode",
		    "createDocument",
		    "createDocumentFragment",
		    "createDocumentType",
		    "createDynamicsCompressor",
		    "createElement",
		    "createElementNS",
		    "createEntityReference",
		    "createEvent",
		    "createEventObject",
		    "createExpression",
		    "createFramebuffer",
		    "createFunction",
		    "createGain",
		    "createGainNode",
		    "createHTML",
		    "createHTMLDocument",
		    "createIIRFilter",
		    "createImageBitmap",
		    "createImageData",
		    "createIndex",
		    "createJavaScriptNode",
		    "createLinearGradient",
		    "createMediaElementSource",
		    "createMediaKeys",
		    "createMediaStreamDestination",
		    "createMediaStreamSource",
		    "createMediaStreamTrackSource",
		    "createMutableFile",
		    "createNSResolver",
		    "createNodeIterator",
		    "createNotification",
		    "createObjectStore",
		    "createObjectURL",
		    "createOffer",
		    "createOscillator",
		    "createPanner",
		    "createPattern",
		    "createPeriodicWave",
		    "createPipelineLayout",
		    "createPolicy",
		    "createPopup",
		    "createProcessingInstruction",
		    "createProgram",
		    "createQuery",
		    "createQuerySet",
		    "createRadialGradient",
		    "createRange",
		    "createRangeCollection",
		    "createReader",
		    "createRenderBundleEncoder",
		    "createRenderPipeline",
		    "createRenderPipelineAsync",
		    "createRenderbuffer",
		    "createSVGAngle",
		    "createSVGLength",
		    "createSVGMatrix",
		    "createSVGNumber",
		    "createSVGPathSegArcAbs",
		    "createSVGPathSegArcRel",
		    "createSVGPathSegClosePath",
		    "createSVGPathSegCurvetoCubicAbs",
		    "createSVGPathSegCurvetoCubicRel",
		    "createSVGPathSegCurvetoCubicSmoothAbs",
		    "createSVGPathSegCurvetoCubicSmoothRel",
		    "createSVGPathSegCurvetoQuadraticAbs",
		    "createSVGPathSegCurvetoQuadraticRel",
		    "createSVGPathSegCurvetoQuadraticSmoothAbs",
		    "createSVGPathSegCurvetoQuadraticSmoothRel",
		    "createSVGPathSegLinetoAbs",
		    "createSVGPathSegLinetoHorizontalAbs",
		    "createSVGPathSegLinetoHorizontalRel",
		    "createSVGPathSegLinetoRel",
		    "createSVGPathSegLinetoVerticalAbs",
		    "createSVGPathSegLinetoVerticalRel",
		    "createSVGPathSegMovetoAbs",
		    "createSVGPathSegMovetoRel",
		    "createSVGPoint",
		    "createSVGRect",
		    "createSVGTransform",
		    "createSVGTransformFromMatrix",
		    "createSampler",
		    "createScript",
		    "createScriptProcessor",
		    "createScriptURL",
		    "createSession",
		    "createShader",
		    "createShaderModule",
		    "createShadowRoot",
		    "createStereoPanner",
		    "createStyleSheet",
		    "createTBody",
		    "createTFoot",
		    "createTHead",
		    "createTextNode",
		    "createTextRange",
		    "createTexture",
		    "createTouch",
		    "createTouchList",
		    "createTransformFeedback",
		    "createTreeWalker",
		    "createVertexArray",
		    "createView",
		    "createWaveShaper",
		    "creationTime",
		    "credentials",
		    "crossOrigin",
		    "crossOriginIsolated",
		    "crypto",
		    "csi",
		    "csp",
		    "cssFloat",
		    "cssRules",
		    "cssText",
		    "cssValueType",
		    "ctrlKey",
		    "ctrlLeft",
		    "cues",
		    "cullFace",
		    "cullMode",
		    "currentDirection",
		    "currentLocalDescription",
		    "currentNode",
		    "currentPage",
		    "currentRect",
		    "currentRemoteDescription",
		    "currentScale",
		    "currentScript",
		    "currentSrc",
		    "currentState",
		    "currentStyle",
		    "currentTarget",
		    "currentTime",
		    "currentTranslate",
		    "currentView",
		    "cursor",
		    "curve",
		    "customElements",
		    "customError",
		    "cx",
		    "cy",
		    "d",
		    "data",
		    "dataFld",
		    "dataFormatAs",
		    "dataLoss",
		    "dataLossMessage",
		    "dataPageSize",
		    "dataSrc",
		    "dataTransfer",
		    "database",
		    "databases",
		    "dataset",
		    "dateTime",
		    "db",
		    "debug",
		    "debuggerEnabled",
		    "declare",
		    "decode",
		    "decodeAudioData",
		    "decodeURI",
		    "decodeURIComponent",
		    "decodedBodySize",
		    "decoding",
		    "decodingInfo",
		    "decrypt",
		    "default",
		    "defaultCharset",
		    "defaultChecked",
		    "defaultMuted",
		    "defaultPlaybackRate",
		    "defaultPolicy",
		    "defaultPrevented",
		    "defaultQueue",
		    "defaultRequest",
		    "defaultSelected",
		    "defaultStatus",
		    "defaultURL",
		    "defaultValue",
		    "defaultView",
		    "defaultstatus",
		    "defer",
		    "define",
		    "defineMagicFunction",
		    "defineMagicVariable",
		    "defineProperties",
		    "defineProperty",
		    "deg",
		    "delay",
		    "delayTime",
		    "delegatesFocus",
		    "delete",
		    "deleteBuffer",
		    "deleteCaption",
		    "deleteCell",
		    "deleteContents",
		    "deleteData",
		    "deleteDatabase",
		    "deleteFramebuffer",
		    "deleteFromDocument",
		    "deleteIndex",
		    "deleteMedium",
		    "deleteObjectStore",
		    "deleteProgram",
		    "deleteProperty",
		    "deleteQuery",
		    "deleteRenderbuffer",
		    "deleteRow",
		    "deleteRule",
		    "deleteSampler",
		    "deleteShader",
		    "deleteSync",
		    "deleteTFoot",
		    "deleteTHead",
		    "deleteTexture",
		    "deleteTransformFeedback",
		    "deleteVertexArray",
		    "deliverChangeRecords",
		    "delivery",
		    "deliveryInfo",
		    "deliveryStatus",
		    "deliveryTimestamp",
		    "delta",
		    "deltaMode",
		    "deltaX",
		    "deltaY",
		    "deltaZ",
		    "dependentLocality",
		    "depthBias",
		    "depthBiasClamp",
		    "depthBiasSlopeScale",
		    "depthClearValue",
		    "depthCompare",
		    "depthFailOp",
		    "depthFar",
		    "depthFunc",
		    "depthLoadOp",
		    "depthMask",
		    "depthNear",
		    "depthOrArrayLayers",
		    "depthRange",
		    "depthReadOnly",
		    "depthStencil",
		    "depthStencilAttachment",
		    "depthStencilFormat",
		    "depthStoreOp",
		    "depthWriteEnabled",
		    "deref",
		    "deriveBits",
		    "deriveKey",
		    "description",
		    "deselectAll",
		    "designMode",
		    "desiredSize",
		    "destination",
		    "destinationURL",
		    "destroy",
		    "detach",
		    "detachEvent",
		    "detachShader",
		    "detail",
		    "details",
		    "detect",
		    "detune",
		    "device",
		    "deviceClass",
		    "deviceId",
		    "deviceMemory",
		    "devicePixelContentBoxSize",
		    "devicePixelRatio",
		    "deviceProtocol",
		    "deviceSubclass",
		    "deviceVersionMajor",
		    "deviceVersionMinor",
		    "deviceVersionSubminor",
		    "deviceXDPI",
		    "deviceYDPI",
		    "didTimeout",
		    "diffuseConstant",
		    "digest",
		    "dimension",
		    "dimensions",
		    "dir",
		    "dirName",
		    "direction",
		    "dirxml",
		    "disable",
		    "disablePictureInPicture",
		    "disableRemotePlayback",
		    "disableVertexAttribArray",
		    "disabled",
		    "dischargingTime",
		    "disconnect",
		    "disconnectShark",
		    "dispatchEvent",
		    "dispatchWorkgroups",
		    "dispatchWorkgroupsIndirect",
		    "display",
		    "displayId",
		    "displayName",
		    "disposition",
		    "distanceModel",
		    "div",
		    "divisor",
		    "djsapi",
		    "djsproxy",
		    "doImport",
		    "doNotTrack",
		    "doScroll",
		    "doctype",
		    "document",
		    "documentElement",
		    "documentMode",
		    "documentURI",
		    "dolphin",
		    "dolphinGameCenter",
		    "dolphininfo",
		    "dolphinmeta",
		    "domComplete",
		    "domContentLoadedEventEnd",
		    "domContentLoadedEventStart",
		    "domInteractive",
		    "domLoading",
		    "domOverlayState",
		    "domain",
		    "domainLookupEnd",
		    "domainLookupStart",
		    "dominant-baseline",
		    "dominantBaseline",
		    "done",
		    "dopplerFactor",
		    "dotAll",
		    "downDegrees",
		    "downlink",
		    "download",
		    "downloadTotal",
		    "downloaded",
		    "dpcm",
		    "dpi",
		    "dppx",
		    "dragDrop",
		    "draggable",
		    "draw",
		    "drawArrays",
		    "drawArraysInstanced",
		    "drawArraysInstancedANGLE",
		    "drawBuffers",
		    "drawCustomFocusRing",
		    "drawElements",
		    "drawElementsInstanced",
		    "drawElementsInstancedANGLE",
		    "drawFocusIfNeeded",
		    "drawImage",
		    "drawImageFromRect",
		    "drawIndexed",
		    "drawIndexedIndirect",
		    "drawIndirect",
		    "drawRangeElements",
		    "drawSystemFocusRing",
		    "drawingBufferHeight",
		    "drawingBufferWidth",
		    "dropEffect",
		    "droppedVideoFrames",
		    "dropzone",
		    "dstFactor",
		    "dtmf",
		    "dump",
		    "dumpProfile",
		    "duplicate",
		    "durability",
		    "duration",
		    "dvname",
		    "dvnum",
		    "dx",
		    "dy",
		    "dynsrc",
		    "e",
		    "edgeMode",
		    "effect",
		    "effectAllowed",
		    "effectiveDirective",
		    "effectiveType",
		    "elapsedTime",
		    "element",
		    "elementFromPoint",
		    "elementTiming",
		    "elements",
		    "elementsFromPoint",
		    "elevation",
		    "ellipse",
		    "em",
		    "email",
		    "embeds",
		    "emma",
		    "empty",
		    "empty-cells",
		    "emptyCells",
		    "emptyHTML",
		    "emptyScript",
		    "emulatedPosition",
		    "enable",
		    "enableBackground",
		    "enableDelegations",
		    "enableStyleSheetsForSet",
		    "enableVertexAttribArray",
		    "enabled",
		    "enabledPlugin",
		    "encode",
		    "encodeInto",
		    "encodeURI",
		    "encodeURIComponent",
		    "encodedBodySize",
		    "encoding",
		    "encodingInfo",
		    "encrypt",
		    "enctype",
		    "end",
		    "endContainer",
		    "endElement",
		    "endElementAt",
		    "endOcclusionQuery",
		    "endOfPassWriteIndex",
		    "endOfStream",
		    "endOffset",
		    "endQuery",
		    "endTime",
		    "endTransformFeedback",
		    "ended",
		    "endpoint",
		    "endpointNumber",
		    "endpoints",
		    "endsWith",
		    "enterKeyHint",
		    "entities",
		    "entries",
		    "entryPoint",
		    "entryType",
		    "enumerable",
		    "enumerate",
		    "enumerateDevices",
		    "enumerateEditable",
		    "environmentBlendMode",
		    "equals",
		    "error",
		    "errorCode",
		    "errorDetail",
		    "errorText",
		    "escape",
		    "estimate",
		    "eval",
		    "evaluate",
		    "event",
		    "eventPhase",
		    "every",
		    "ex",
		    "exception",
		    "exchange",
		    "exec",
		    "execCommand",
		    "execCommandShowHelp",
		    "execScript",
		    "executeBundles",
		    "exitFullscreen",
		    "exitPictureInPicture",
		    "exitPointerLock",
		    "exitPresent",
		    "exp",
		    "expand",
		    "expandEntityReferences",
		    "expando",
		    "expansion",
		    "expiration",
		    "expirationTime",
		    "expires",
		    "expiryDate",
		    "explicitOriginalTarget",
		    "expm1",
		    "exponent",
		    "exponentialRampToValueAtTime",
		    "exportKey",
		    "exports",
		    "extend",
		    "extensions",
		    "extentNode",
		    "extentOffset",
		    "external",
		    "externalResourcesRequired",
		    "externalTexture",
		    "extractContents",
		    "extractable",
		    "eye",
		    "f",
		    "face",
		    "factoryReset",
		    "failOp",
		    "failureReason",
		    "fallback",
		    "family",
		    "familyName",
		    "farthestViewportElement",
		    "fastSeek",
		    "fatal",
		    "featureId",
		    "featurePolicy",
		    "featureSettings",
		    "features",
		    "fenceSync",
		    "fetch",
		    "fetchStart",
		    "fftSize",
		    "fgColor",
		    "fieldOfView",
		    "file",
		    "fileCreatedDate",
		    "fileHandle",
		    "fileModifiedDate",
		    "fileName",
		    "fileSize",
		    "fileUpdatedDate",
		    "filename",
		    "files",
		    "filesystem",
		    "fill",
		    "fill-opacity",
		    "fill-rule",
		    "fillLightMode",
		    "fillOpacity",
		    "fillRect",
		    "fillRule",
		    "fillStyle",
		    "fillText",
		    "filter",
		    "filterResX",
		    "filterResY",
		    "filterUnits",
		    "filters",
		    "finally",
		    "find",
		    "findIndex",
		    "findRule",
		    "findText",
		    "finish",
		    "finished",
		    "fireEvent",
		    "firesTouchEvents",
		    "firstChild",
		    "firstElementChild",
		    "firstPage",
		    "fixed",
		    "flags",
		    "flat",
		    "flatMap",
		    "flex",
		    "flex-basis",
		    "flex-direction",
		    "flex-flow",
		    "flex-grow",
		    "flex-shrink",
		    "flex-wrap",
		    "flexBasis",
		    "flexDirection",
		    "flexFlow",
		    "flexGrow",
		    "flexShrink",
		    "flexWrap",
		    "flipX",
		    "flipY",
		    "float",
		    "float32",
		    "float64",
		    "flood-color",
		    "flood-opacity",
		    "floodColor",
		    "floodOpacity",
		    "floor",
		    "flush",
		    "focus",
		    "focusNode",
		    "focusOffset",
		    "font",
		    "font-family",
		    "font-feature-settings",
		    "font-kerning",
		    "font-language-override",
		    "font-optical-sizing",
		    "font-size",
		    "font-size-adjust",
		    "font-stretch",
		    "font-style",
		    "font-synthesis",
		    "font-variant",
		    "font-variant-alternates",
		    "font-variant-caps",
		    "font-variant-east-asian",
		    "font-variant-ligatures",
		    "font-variant-numeric",
		    "font-variant-position",
		    "font-variation-settings",
		    "font-weight",
		    "fontFamily",
		    "fontFeatureSettings",
		    "fontKerning",
		    "fontLanguageOverride",
		    "fontOpticalSizing",
		    "fontSize",
		    "fontSizeAdjust",
		    "fontSmoothingEnabled",
		    "fontStretch",
		    "fontStyle",
		    "fontSynthesis",
		    "fontVariant",
		    "fontVariantAlternates",
		    "fontVariantCaps",
		    "fontVariantEastAsian",
		    "fontVariantLigatures",
		    "fontVariantNumeric",
		    "fontVariantPosition",
		    "fontVariationSettings",
		    "fontWeight",
		    "fontcolor",
		    "fontfaces",
		    "fonts",
		    "fontsize",
		    "for",
		    "forEach",
		    "force",
		    "forceFallbackAdapter",
		    "forceRedraw",
		    "form",
		    "formAction",
		    "formData",
		    "formEnctype",
		    "formMethod",
		    "formNoValidate",
		    "formTarget",
		    "format",
		    "formatToParts",
		    "forms",
		    "forward",
		    "forwardX",
		    "forwardY",
		    "forwardZ",
		    "foundation",
		    "fr",
		    "fragment",
		    "fragmentDirective",
		    "frame",
		    "frameBorder",
		    "frameElement",
		    "frameSpacing",
		    "framebuffer",
		    "framebufferHeight",
		    "framebufferRenderbuffer",
		    "framebufferTexture2D",
		    "framebufferTextureLayer",
		    "framebufferWidth",
		    "frames",
		    "freeSpace",
		    "freeze",
		    "frequency",
		    "frequencyBinCount",
		    "from",
		    "fromCharCode",
		    "fromCodePoint",
		    "fromElement",
		    "fromEntries",
		    "fromFloat32Array",
		    "fromFloat64Array",
		    "fromMatrix",
		    "fromPoint",
		    "fromQuad",
		    "fromRect",
		    "frontFace",
		    "fround",
		    "fullPath",
		    "fullScreen",
		    "fullVersionList",
		    "fullscreen",
		    "fullscreenElement",
		    "fullscreenEnabled",
		    "fx",
		    "fy",
		    "g",
		    "gain",
		    "gamepad",
		    "gamma",
		    "gap",
		    "gatheringState",
		    "gatt",
		    "genderIdentity",
		    "generateCertificate",
		    "generateKey",
		    "generateMipmap",
		    "generateRequest",
		    "geolocation",
		    "gestureObject",
		    "get",
		    "getActiveAttrib",
		    "getActiveUniform",
		    "getActiveUniformBlockName",
		    "getActiveUniformBlockParameter",
		    "getActiveUniforms",
		    "getAdjacentText",
		    "getAll",
		    "getAllKeys",
		    "getAllResponseHeaders",
		    "getAllowlistForFeature",
		    "getAnimations",
		    "getAsFile",
		    "getAsString",
		    "getAttachedShaders",
		    "getAttribLocation",
		    "getAttribute",
		    "getAttributeNS",
		    "getAttributeNames",
		    "getAttributeNode",
		    "getAttributeNodeNS",
		    "getAttributeType",
		    "getAudioTracks",
		    "getAvailability",
		    "getBBox",
		    "getBattery",
		    "getBigInt64",
		    "getBigUint64",
		    "getBindGroupLayout",
		    "getBlob",
		    "getBookmark",
		    "getBoundingClientRect",
		    "getBounds",
		    "getBoxQuads",
		    "getBufferParameter",
		    "getBufferSubData",
		    "getByteFrequencyData",
		    "getByteTimeDomainData",
		    "getCSSCanvasContext",
		    "getCTM",
		    "getCandidateWindowClientRect",
		    "getCanonicalLocales",
		    "getCapabilities",
		    "getChannelData",
		    "getCharNumAtPosition",
		    "getCharacteristic",
		    "getCharacteristics",
		    "getClientExtensionResults",
		    "getClientRect",
		    "getClientRects",
		    "getCoalescedEvents",
		    "getCompilationInfo",
		    "getCompositionAlternatives",
		    "getComputedStyle",
		    "getComputedTextLength",
		    "getComputedTiming",
		    "getConfiguration",
		    "getConstraints",
		    "getContext",
		    "getContextAttributes",
		    "getContributingSources",
		    "getCounterValue",
		    "getCueAsHTML",
		    "getCueById",
		    "getCurrentPosition",
		    "getCurrentTexture",
		    "getCurrentTime",
		    "getData",
		    "getDatabaseNames",
		    "getDate",
		    "getDay",
		    "getDefaultComputedStyle",
		    "getDescriptor",
		    "getDescriptors",
		    "getDestinationInsertionPoints",
		    "getDevices",
		    "getDirectory",
		    "getDisplayMedia",
		    "getDistributedNodes",
		    "getEditable",
		    "getElementById",
		    "getElementsByClassName",
		    "getElementsByName",
		    "getElementsByTagName",
		    "getElementsByTagNameNS",
		    "getEnclosureList",
		    "getEndPositionOfChar",
		    "getEntries",
		    "getEntriesByName",
		    "getEntriesByType",
		    "getError",
		    "getExtension",
		    "getExtentOfChar",
		    "getEyeParameters",
		    "getFeature",
		    "getFile",
		    "getFiles",
		    "getFilesAndDirectories",
		    "getFingerprints",
		    "getFloat32",
		    "getFloat64",
		    "getFloatFrequencyData",
		    "getFloatTimeDomainData",
		    "getFloatValue",
		    "getFragDataLocation",
		    "getFrameData",
		    "getFramebufferAttachmentParameter",
		    "getFrequencyResponse",
		    "getFullYear",
		    "getGamepads",
		    "getHighEntropyValues",
		    "getHitTestResults",
		    "getHitTestResultsForTransientInput",
		    "getHours",
		    "getIdentityAssertion",
		    "getIds",
		    "getImageData",
		    "getIndexedParameter",
		    "getInstalledRelatedApps",
		    "getInt16",
		    "getInt32",
		    "getInt8",
		    "getInternalformatParameter",
		    "getIntersectionList",
		    "getItem",
		    "getItems",
		    "getKey",
		    "getKeyframes",
		    "getLayers",
		    "getLayoutMap",
		    "getLineDash",
		    "getLocalCandidates",
		    "getLocalParameters",
		    "getLocalStreams",
		    "getMappedRange",
		    "getMarks",
		    "getMatchedCSSRules",
		    "getMaxGCPauseSinceClear",
		    "getMeasures",
		    "getMetadata",
		    "getMilliseconds",
		    "getMinutes",
		    "getModifierState",
		    "getMonth",
		    "getNamedItem",
		    "getNamedItemNS",
		    "getNativeFramebufferScaleFactor",
		    "getNotifications",
		    "getNotifier",
		    "getNumberOfChars",
		    "getOffsetReferenceSpace",
		    "getOutputTimestamp",
		    "getOverrideHistoryNavigationMode",
		    "getOverrideStyle",
		    "getOwnPropertyDescriptor",
		    "getOwnPropertyDescriptors",
		    "getOwnPropertyNames",
		    "getOwnPropertySymbols",
		    "getParameter",
		    "getParameters",
		    "getParent",
		    "getPathSegAtLength",
		    "getPhotoCapabilities",
		    "getPhotoSettings",
		    "getPointAtLength",
		    "getPose",
		    "getPredictedEvents",
		    "getPreference",
		    "getPreferenceDefault",
		    "getPreferredCanvasFormat",
		    "getPresentationAttribute",
		    "getPreventDefault",
		    "getPrimaryService",
		    "getPrimaryServices",
		    "getProgramInfoLog",
		    "getProgramParameter",
		    "getPropertyCSSValue",
		    "getPropertyPriority",
		    "getPropertyShorthand",
		    "getPropertyType",
		    "getPropertyValue",
		    "getPrototypeOf",
		    "getQuery",
		    "getQueryParameter",
		    "getRGBColorValue",
		    "getRandomValues",
		    "getRangeAt",
		    "getReader",
		    "getReceivers",
		    "getRectValue",
		    "getRegistration",
		    "getRegistrations",
		    "getRemoteCandidates",
		    "getRemoteCertificates",
		    "getRemoteParameters",
		    "getRemoteStreams",
		    "getRenderbufferParameter",
		    "getResponseHeader",
		    "getRoot",
		    "getRootNode",
		    "getRotationOfChar",
		    "getSVGDocument",
		    "getSamplerParameter",
		    "getScreenCTM",
		    "getSeconds",
		    "getSelectedCandidatePair",
		    "getSelection",
		    "getSenders",
		    "getService",
		    "getSettings",
		    "getShaderInfoLog",
		    "getShaderParameter",
		    "getShaderPrecisionFormat",
		    "getShaderSource",
		    "getSimpleDuration",
		    "getSiteIcons",
		    "getSources",
		    "getSpeculativeParserUrls",
		    "getStartPositionOfChar",
		    "getStartTime",
		    "getState",
		    "getStats",
		    "getStatusForPolicy",
		    "getStorageUpdates",
		    "getStreamById",
		    "getStringValue",
		    "getSubStringLength",
		    "getSubscription",
		    "getSupportedConstraints",
		    "getSupportedExtensions",
		    "getSupportedFormats",
		    "getSyncParameter",
		    "getSynchronizationSources",
		    "getTags",
		    "getTargetRanges",
		    "getTexParameter",
		    "getTime",
		    "getTimezoneOffset",
		    "getTiming",
		    "getTotalLength",
		    "getTrackById",
		    "getTracks",
		    "getTransceivers",
		    "getTransform",
		    "getTransformFeedbackVarying",
		    "getTransformToElement",
		    "getTransports",
		    "getType",
		    "getTypeMapping",
		    "getUTCDate",
		    "getUTCDay",
		    "getUTCFullYear",
		    "getUTCHours",
		    "getUTCMilliseconds",
		    "getUTCMinutes",
		    "getUTCMonth",
		    "getUTCSeconds",
		    "getUint16",
		    "getUint32",
		    "getUint8",
		    "getUniform",
		    "getUniformBlockIndex",
		    "getUniformIndices",
		    "getUniformLocation",
		    "getUserMedia",
		    "getVRDisplays",
		    "getValues",
		    "getVarDate",
		    "getVariableValue",
		    "getVertexAttrib",
		    "getVertexAttribOffset",
		    "getVideoPlaybackQuality",
		    "getVideoTracks",
		    "getViewerPose",
		    "getViewport",
		    "getVoices",
		    "getWakeLockState",
		    "getWriter",
		    "getYear",
		    "givenName",
		    "global",
		    "globalAlpha",
		    "globalCompositeOperation",
		    "globalThis",
		    "glyphOrientationHorizontal",
		    "glyphOrientationVertical",
		    "glyphRef",
		    "go",
		    "gpu",
		    "grabFrame",
		    "grad",
		    "gradientTransform",
		    "gradientUnits",
		    "grammars",
		    "green",
		    "grid",
		    "grid-area",
		    "grid-auto-columns",
		    "grid-auto-flow",
		    "grid-auto-rows",
		    "grid-column",
		    "grid-column-end",
		    "grid-column-gap",
		    "grid-column-start",
		    "grid-gap",
		    "grid-row",
		    "grid-row-end",
		    "grid-row-gap",
		    "grid-row-start",
		    "grid-template",
		    "grid-template-areas",
		    "grid-template-columns",
		    "grid-template-rows",
		    "gridArea",
		    "gridAutoColumns",
		    "gridAutoFlow",
		    "gridAutoRows",
		    "gridColumn",
		    "gridColumnEnd",
		    "gridColumnGap",
		    "gridColumnStart",
		    "gridGap",
		    "gridRow",
		    "gridRowEnd",
		    "gridRowGap",
		    "gridRowStart",
		    "gridTemplate",
		    "gridTemplateAreas",
		    "gridTemplateColumns",
		    "gridTemplateRows",
		    "gripSpace",
		    "group",
		    "groupCollapsed",
		    "groupEnd",
		    "groupId",
		    "hadRecentInput",
		    "hand",
		    "handedness",
		    "hapticActuators",
		    "hardwareConcurrency",
		    "has",
		    "hasAttribute",
		    "hasAttributeNS",
		    "hasAttributes",
		    "hasBeenActive",
		    "hasChildNodes",
		    "hasComposition",
		    "hasDynamicOffset",
		    "hasEnrolledInstrument",
		    "hasExtension",
		    "hasExternalDisplay",
		    "hasFeature",
		    "hasFocus",
		    "hasInstance",
		    "hasLayout",
		    "hasOrientation",
		    "hasOwnProperty",
		    "hasPointerCapture",
		    "hasPosition",
		    "hasReading",
		    "hasStorageAccess",
		    "hash",
		    "head",
		    "headers",
		    "heading",
		    "height",
		    "hidden",
		    "hide",
		    "hideFocus",
		    "high",
		    "highWaterMark",
		    "hint",
		    "hints",
		    "history",
		    "honorificPrefix",
		    "honorificSuffix",
		    "horizontalOverflow",
		    "host",
		    "hostCandidate",
		    "hostname",
		    "href",
		    "hrefTranslate",
		    "hreflang",
		    "hspace",
		    "html5TagCheckInerface",
		    "htmlFor",
		    "htmlText",
		    "httpEquiv",
		    "httpRequestStatusCode",
		    "hwTimestamp",
		    "hyphens",
		    "hypot",
		    "iccId",
		    "iceConnectionState",
		    "iceGatheringState",
		    "iceTransport",
		    "icon",
		    "iconURL",
		    "id",
		    "identifier",
		    "identity",
		    "idpLoginUrl",
		    "ignoreBOM",
		    "ignoreCase",
		    "ignoreDepthValues",
		    "image-orientation",
		    "image-rendering",
		    "imageHeight",
		    "imageOrientation",
		    "imageRendering",
		    "imageSizes",
		    "imageSmoothingEnabled",
		    "imageSmoothingQuality",
		    "imageSrcset",
		    "imageWidth",
		    "images",
		    "ime-mode",
		    "imeMode",
		    "implementation",
		    "importExternalTexture",
		    "importKey",
		    "importNode",
		    "importStylesheet",
		    "imports",
		    "impp",
		    "imul",
		    "in",
		    "in1",
		    "in2",
		    "inBandMetadataTrackDispatchType",
		    "inRange",
		    "includes",
		    "incremental",
		    "indeterminate",
		    "index",
		    "indexNames",
		    "indexOf",
		    "indexedDB",
		    "indicate",
		    "inert",
		    "inertiaDestinationX",
		    "inertiaDestinationY",
		    "info",
		    "init",
		    "initAnimationEvent",
		    "initBeforeLoadEvent",
		    "initClipboardEvent",
		    "initCloseEvent",
		    "initCommandEvent",
		    "initCompositionEvent",
		    "initCustomEvent",
		    "initData",
		    "initDataType",
		    "initDeviceMotionEvent",
		    "initDeviceOrientationEvent",
		    "initDragEvent",
		    "initErrorEvent",
		    "initEvent",
		    "initFocusEvent",
		    "initGestureEvent",
		    "initHashChangeEvent",
		    "initKeyEvent",
		    "initKeyboardEvent",
		    "initMSManipulationEvent",
		    "initMessageEvent",
		    "initMouseEvent",
		    "initMouseScrollEvent",
		    "initMouseWheelEvent",
		    "initMutationEvent",
		    "initNSMouseEvent",
		    "initOverflowEvent",
		    "initPageEvent",
		    "initPageTransitionEvent",
		    "initPointerEvent",
		    "initPopStateEvent",
		    "initProgressEvent",
		    "initScrollAreaEvent",
		    "initSimpleGestureEvent",
		    "initStorageEvent",
		    "initTextEvent",
		    "initTimeEvent",
		    "initTouchEvent",
		    "initTransitionEvent",
		    "initUIEvent",
		    "initWebKitAnimationEvent",
		    "initWebKitTransitionEvent",
		    "initWebKitWheelEvent",
		    "initWheelEvent",
		    "initialTime",
		    "initialize",
		    "initiatorType",
		    "inline-size",
		    "inlineSize",
		    "inlineVerticalFieldOfView",
		    "inner",
		    "innerHTML",
		    "innerHeight",
		    "innerText",
		    "innerWidth",
		    "input",
		    "inputBuffer",
		    "inputEncoding",
		    "inputMethod",
		    "inputMode",
		    "inputSource",
		    "inputSources",
		    "inputType",
		    "inputs",
		    "insertAdjacentElement",
		    "insertAdjacentHTML",
		    "insertAdjacentText",
		    "insertBefore",
		    "insertCell",
		    "insertDTMF",
		    "insertData",
		    "insertDebugMarker",
		    "insertItemBefore",
		    "insertNode",
		    "insertRow",
		    "insertRule",
		    "inset",
		    "inset-block",
		    "inset-block-end",
		    "inset-block-start",
		    "inset-inline",
		    "inset-inline-end",
		    "inset-inline-start",
		    "insetBlock",
		    "insetBlockEnd",
		    "insetBlockStart",
		    "insetInline",
		    "insetInlineEnd",
		    "insetInlineStart",
		    "installing",
		    "instanceRoot",
		    "instantiate",
		    "instantiateStreaming",
		    "instruments",
		    "int16",
		    "int32",
		    "int8",
		    "integrity",
		    "interactionMode",
		    "intercept",
		    "interfaceClass",
		    "interfaceName",
		    "interfaceNumber",
		    "interfaceProtocol",
		    "interfaceSubclass",
		    "interfaces",
		    "interimResults",
		    "internalSubset",
		    "interpretation",
		    "intersectionRatio",
		    "intersectionRect",
		    "intersectsNode",
		    "interval",
		    "invalidIteratorState",
		    "invalidateFramebuffer",
		    "invalidateSubFramebuffer",
		    "inverse",
		    "invertSelf",
		    "is",
		    "is2D",
		    "isActive",
		    "isAlternate",
		    "isArray",
		    "isBingCurrentSearchDefault",
		    "isBuffer",
		    "isCandidateWindowVisible",
		    "isChar",
		    "isCollapsed",
		    "isComposing",
		    "isConcatSpreadable",
		    "isConnected",
		    "isContentEditable",
		    "isContentHandlerRegistered",
		    "isContextLost",
		    "isDefaultNamespace",
		    "isDirectory",
		    "isDisabled",
		    "isEnabled",
		    "isEqual",
		    "isEqualNode",
		    "isExtensible",
		    "isExternalCTAP2SecurityKeySupported",
		    "isFallbackAdapter",
		    "isFile",
		    "isFinite",
		    "isFramebuffer",
		    "isFrozen",
		    "isGenerator",
		    "isHTML",
		    "isHistoryNavigation",
		    "isId",
		    "isIdentity",
		    "isInjected",
		    "isInteger",
		    "isIntersecting",
		    "isLockFree",
		    "isMap",
		    "isMultiLine",
		    "isNaN",
		    "isOpen",
		    "isPointInFill",
		    "isPointInPath",
		    "isPointInRange",
		    "isPointInStroke",
		    "isPrefAlternate",
		    "isPresenting",
		    "isPrimary",
		    "isProgram",
		    "isPropertyImplicit",
		    "isProtocolHandlerRegistered",
		    "isPrototypeOf",
		    "isQuery",
		    "isRenderbuffer",
		    "isSafeInteger",
		    "isSameNode",
		    "isSampler",
		    "isScript",
		    "isScriptURL",
		    "isSealed",
		    "isSecureContext",
		    "isSessionSupported",
		    "isShader",
		    "isSupported",
		    "isSync",
		    "isTextEdit",
		    "isTexture",
		    "isTransformFeedback",
		    "isTrusted",
		    "isTypeSupported",
		    "isUserVerifyingPlatformAuthenticatorAvailable",
		    "isVertexArray",
		    "isView",
		    "isVisible",
		    "isochronousTransferIn",
		    "isochronousTransferOut",
		    "isolation",
		    "italics",
		    "item",
		    "itemId",
		    "itemProp",
		    "itemRef",
		    "itemScope",
		    "itemType",
		    "itemValue",
		    "items",
		    "iterateNext",
		    "iterationComposite",
		    "iterator",
		    "javaEnabled",
		    "jobTitle",
		    "join",
		    "json",
		    "justify-content",
		    "justify-items",
		    "justify-self",
		    "justifyContent",
		    "justifyItems",
		    "justifySelf",
		    "k1",
		    "k2",
		    "k3",
		    "k4",
		    "kHz",
		    "keepalive",
		    "kernelMatrix",
		    "kernelUnitLengthX",
		    "kernelUnitLengthY",
		    "kerning",
		    "key",
		    "keyCode",
		    "keyFor",
		    "keyIdentifier",
		    "keyLightEnabled",
		    "keyLocation",
		    "keyPath",
		    "keyStatuses",
		    "keySystem",
		    "keyText",
		    "keyUsage",
		    "keyboard",
		    "keys",
		    "keytype",
		    "kind",
		    "knee",
		    "label",
		    "labels",
		    "lang",
		    "language",
		    "languages",
		    "largeArcFlag",
		    "lastChild",
		    "lastElementChild",
		    "lastEventId",
		    "lastIndex",
		    "lastIndexOf",
		    "lastInputTime",
		    "lastMatch",
		    "lastMessageSubject",
		    "lastMessageType",
		    "lastModified",
		    "lastModifiedDate",
		    "lastPage",
		    "lastParen",
		    "lastState",
		    "lastStyleSheetSet",
		    "latitude",
		    "layerX",
		    "layerY",
		    "layout",
		    "layoutFlow",
		    "layoutGrid",
		    "layoutGridChar",
		    "layoutGridLine",
		    "layoutGridMode",
		    "layoutGridType",
		    "lbound",
		    "left",
		    "leftContext",
		    "leftDegrees",
		    "leftMargin",
		    "leftProjectionMatrix",
		    "leftViewMatrix",
		    "length",
		    "lengthAdjust",
		    "lengthComputable",
		    "letter-spacing",
		    "letterSpacing",
		    "level",
		    "lighting-color",
		    "lightingColor",
		    "limitingConeAngle",
		    "limits",
		    "line",
		    "line-break",
		    "line-height",
		    "lineAlign",
		    "lineBreak",
		    "lineCap",
		    "lineDashOffset",
		    "lineHeight",
		    "lineJoin",
		    "lineNum",
		    "lineNumber",
		    "linePos",
		    "lineTo",
		    "lineWidth",
		    "linearAcceleration",
		    "linearRampToValueAtTime",
		    "linearVelocity",
		    "lineno",
		    "lines",
		    "link",
		    "linkColor",
		    "linkProgram",
		    "links",
		    "list",
		    "list-style",
		    "list-style-image",
		    "list-style-position",
		    "list-style-type",
		    "listStyle",
		    "listStyleImage",
		    "listStylePosition",
		    "listStyleType",
		    "listener",
		    "load",
		    "loadEventEnd",
		    "loadEventStart",
		    "loadOp",
		    "loadTime",
		    "loadTimes",
		    "loaded",
		    "loading",
		    "localDescription",
		    "localName",
		    "localService",
		    "localStorage",
		    "locale",
		    "localeCompare",
		    "location",
		    "locationbar",
		    "lock",
		    "locked",
		    "lockedFile",
		    "locks",
		    "lodMaxClamp",
		    "lodMinClamp",
		    "log",
		    "log10",
		    "log1p",
		    "log2",
		    "logicalXDPI",
		    "logicalYDPI",
		    "longDesc",
		    "longitude",
		    "lookupNamespaceURI",
		    "lookupPrefix",
		    "loop",
		    "loopEnd",
		    "loopStart",
		    "looping",
		    "lost",
		    "low",
		    "lower",
		    "lowerBound",
		    "lowerOpen",
		    "lowsrc",
		    "m11",
		    "m12",
		    "m13",
		    "m14",
		    "m21",
		    "m22",
		    "m23",
		    "m24",
		    "m31",
		    "m32",
		    "m33",
		    "m34",
		    "m41",
		    "m42",
		    "m43",
		    "m44",
		    "magFilter",
		    "makeXRCompatible",
		    "manifest",
		    "manufacturer",
		    "manufacturerName",
		    "map",
		    "mapAsync",
		    "mapState",
		    "mappedAtCreation",
		    "mapping",
		    "margin",
		    "margin-block",
		    "margin-block-end",
		    "margin-block-start",
		    "margin-bottom",
		    "margin-inline",
		    "margin-inline-end",
		    "margin-inline-start",
		    "margin-left",
		    "margin-right",
		    "margin-top",
		    "marginBlock",
		    "marginBlockEnd",
		    "marginBlockStart",
		    "marginBottom",
		    "marginHeight",
		    "marginInline",
		    "marginInlineEnd",
		    "marginInlineStart",
		    "marginLeft",
		    "marginRight",
		    "marginTop",
		    "marginWidth",
		    "mark",
		    "marker",
		    "marker-end",
		    "marker-mid",
		    "marker-offset",
		    "marker-start",
		    "markerEnd",
		    "markerHeight",
		    "markerMid",
		    "markerOffset",
		    "markerStart",
		    "markerUnits",
		    "markerWidth",
		    "marks",
		    "mask",
		    "mask-clip",
		    "mask-composite",
		    "mask-image",
		    "mask-mode",
		    "mask-origin",
		    "mask-position",
		    "mask-position-x",
		    "mask-position-y",
		    "mask-repeat",
		    "mask-size",
		    "mask-type",
		    "maskClip",
		    "maskComposite",
		    "maskContentUnits",
		    "maskImage",
		    "maskMode",
		    "maskOrigin",
		    "maskPosition",
		    "maskPositionX",
		    "maskPositionY",
		    "maskRepeat",
		    "maskSize",
		    "maskType",
		    "maskUnits",
		    "match",
		    "matchAll",
		    "matchMedia",
		    "matchMedium",
		    "matches",
		    "matrix",
		    "matrixTransform",
		    "max",
		    "max-block-size",
		    "max-height",
		    "max-inline-size",
		    "max-width",
		    "maxActions",
		    "maxAlternatives",
		    "maxAnisotropy",
		    "maxBindGroups",
		    "maxBindGroupsPlusVertexBuffers",
		    "maxBindingsPerBindGroup",
		    "maxBlockSize",
		    "maxBufferSize",
		    "maxChannelCount",
		    "maxChannels",
		    "maxColorAttachmentBytesPerSample",
		    "maxColorAttachments",
		    "maxComputeInvocationsPerWorkgroup",
		    "maxComputeWorkgroupSizeX",
		    "maxComputeWorkgroupSizeY",
		    "maxComputeWorkgroupSizeZ",
		    "maxComputeWorkgroupStorageSize",
		    "maxComputeWorkgroupsPerDimension",
		    "maxConnectionsPerServer",
		    "maxDecibels",
		    "maxDistance",
		    "maxDrawCount",
		    "maxDynamicStorageBuffersPerPipelineLayout",
		    "maxDynamicUniformBuffersPerPipelineLayout",
		    "maxHeight",
		    "maxInlineSize",
		    "maxInterStageShaderComponents",
		    "maxInterStageShaderVariables",
		    "maxLayers",
		    "maxLength",
		    "maxMessageSize",
		    "maxPacketLifeTime",
		    "maxRetransmits",
		    "maxSampledTexturesPerShaderStage",
		    "maxSamplersPerShaderStage",
		    "maxStorageBufferBindingSize",
		    "maxStorageBuffersPerShaderStage",
		    "maxStorageTexturesPerShaderStage",
		    "maxTextureArrayLayers",
		    "maxTextureDimension1D",
		    "maxTextureDimension2D",
		    "maxTextureDimension3D",
		    "maxTouchPoints",
		    "maxUniformBufferBindingSize",
		    "maxUniformBuffersPerShaderStage",
		    "maxValue",
		    "maxVertexAttributes",
		    "maxVertexBufferArrayStride",
		    "maxVertexBuffers",
		    "maxWidth",
		    "measure",
		    "measureText",
		    "media",
		    "mediaCapabilities",
		    "mediaDevices",
		    "mediaElement",
		    "mediaGroup",
		    "mediaKeys",
		    "mediaSession",
		    "mediaStream",
		    "mediaText",
		    "meetOrSlice",
		    "memory",
		    "menubar",
		    "mergeAttributes",
		    "message",
		    "messageClass",
		    "messageHandlers",
		    "messageType",
		    "messages",
		    "metaKey",
		    "metadata",
		    "method",
		    "methodDetails",
		    "methodName",
		    "mid",
		    "mimeType",
		    "mimeTypes",
		    "min",
		    "min-block-size",
		    "min-height",
		    "min-inline-size",
		    "min-width",
		    "minBindingSize",
		    "minBlockSize",
		    "minDecibels",
		    "minFilter",
		    "minHeight",
		    "minInlineSize",
		    "minLength",
		    "minStorageBufferOffsetAlignment",
		    "minUniformBufferOffsetAlignment",
		    "minValue",
		    "minWidth",
		    "mipLevel",
		    "mipLevelCount",
		    "mipmapFilter",
		    "miterLimit",
		    "mix-blend-mode",
		    "mixBlendMode",
		    "mm",
		    "mobile",
		    "mode",
		    "model",
		    "modify",
		    "module",
		    "mount",
		    "move",
		    "moveBy",
		    "moveEnd",
		    "moveFirst",
		    "moveFocusDown",
		    "moveFocusLeft",
		    "moveFocusRight",
		    "moveFocusUp",
		    "moveNext",
		    "moveRow",
		    "moveStart",
		    "moveTo",
		    "moveToBookmark",
		    "moveToElementText",
		    "moveToPoint",
		    "movementX",
		    "movementY",
		    "mozAdd",
		    "mozAnimationStartTime",
		    "mozAnon",
		    "mozApps",
		    "mozAudioCaptured",
		    "mozAudioChannelType",
		    "mozAutoplayEnabled",
		    "mozCancelAnimationFrame",
		    "mozCancelFullScreen",
		    "mozCancelRequestAnimationFrame",
		    "mozCaptureStream",
		    "mozCaptureStreamUntilEnded",
		    "mozClearDataAt",
		    "mozContact",
		    "mozContacts",
		    "mozCreateFileHandle",
		    "mozCurrentTransform",
		    "mozCurrentTransformInverse",
		    "mozCursor",
		    "mozDash",
		    "mozDashOffset",
		    "mozDecodedFrames",
		    "mozExitPointerLock",
		    "mozFillRule",
		    "mozFragmentEnd",
		    "mozFrameDelay",
		    "mozFullScreen",
		    "mozFullScreenElement",
		    "mozFullScreenEnabled",
		    "mozGetAll",
		    "mozGetAllKeys",
		    "mozGetAsFile",
		    "mozGetDataAt",
		    "mozGetMetadata",
		    "mozGetUserMedia",
		    "mozHasAudio",
		    "mozHasItem",
		    "mozHidden",
		    "mozImageSmoothingEnabled",
		    "mozIndexedDB",
		    "mozInnerScreenX",
		    "mozInnerScreenY",
		    "mozInputSource",
		    "mozIsTextField",
		    "mozItem",
		    "mozItemCount",
		    "mozItems",
		    "mozLength",
		    "mozLockOrientation",
		    "mozMatchesSelector",
		    "mozMovementX",
		    "mozMovementY",
		    "mozOpaque",
		    "mozOrientation",
		    "mozPaintCount",
		    "mozPaintedFrames",
		    "mozParsedFrames",
		    "mozPay",
		    "mozPointerLockElement",
		    "mozPresentedFrames",
		    "mozPreservesPitch",
		    "mozPressure",
		    "mozPrintCallback",
		    "mozRTCIceCandidate",
		    "mozRTCPeerConnection",
		    "mozRTCSessionDescription",
		    "mozRemove",
		    "mozRequestAnimationFrame",
		    "mozRequestFullScreen",
		    "mozRequestPointerLock",
		    "mozSetDataAt",
		    "mozSetImageElement",
		    "mozSourceNode",
		    "mozSrcObject",
		    "mozSystem",
		    "mozTCPSocket",
		    "mozTextStyle",
		    "mozTypesAt",
		    "mozUnlockOrientation",
		    "mozUserCancelled",
		    "mozVisibilityState",
		    "ms",
		    "msAnimation",
		    "msAnimationDelay",
		    "msAnimationDirection",
		    "msAnimationDuration",
		    "msAnimationFillMode",
		    "msAnimationIterationCount",
		    "msAnimationName",
		    "msAnimationPlayState",
		    "msAnimationStartTime",
		    "msAnimationTimingFunction",
		    "msBackfaceVisibility",
		    "msBlockProgression",
		    "msCSSOMElementFloatMetrics",
		    "msCaching",
		    "msCachingEnabled",
		    "msCancelRequestAnimationFrame",
		    "msCapsLockWarningOff",
		    "msClearImmediate",
		    "msClose",
		    "msContentZoomChaining",
		    "msContentZoomFactor",
		    "msContentZoomLimit",
		    "msContentZoomLimitMax",
		    "msContentZoomLimitMin",
		    "msContentZoomSnap",
		    "msContentZoomSnapPoints",
		    "msContentZoomSnapType",
		    "msContentZooming",
		    "msConvertURL",
		    "msCrypto",
		    "msDoNotTrack",
		    "msElementsFromPoint",
		    "msElementsFromRect",
		    "msExitFullscreen",
		    "msExtendedCode",
		    "msFillRule",
		    "msFirstPaint",
		    "msFlex",
		    "msFlexAlign",
		    "msFlexDirection",
		    "msFlexFlow",
		    "msFlexItemAlign",
		    "msFlexLinePack",
		    "msFlexNegative",
		    "msFlexOrder",
		    "msFlexPack",
		    "msFlexPositive",
		    "msFlexPreferredSize",
		    "msFlexWrap",
		    "msFlowFrom",
		    "msFlowInto",
		    "msFontFeatureSettings",
		    "msFullscreenElement",
		    "msFullscreenEnabled",
		    "msGetInputContext",
		    "msGetRegionContent",
		    "msGetUntransformedBounds",
		    "msGraphicsTrustStatus",
		    "msGridColumn",
		    "msGridColumnAlign",
		    "msGridColumnSpan",
		    "msGridColumns",
		    "msGridRow",
		    "msGridRowAlign",
		    "msGridRowSpan",
		    "msGridRows",
		    "msHidden",
		    "msHighContrastAdjust",
		    "msHyphenateLimitChars",
		    "msHyphenateLimitLines",
		    "msHyphenateLimitZone",
		    "msHyphens",
		    "msImageSmoothingEnabled",
		    "msImeAlign",
		    "msIndexedDB",
		    "msInterpolationMode",
		    "msIsStaticHTML",
		    "msKeySystem",
		    "msKeys",
		    "msLaunchUri",
		    "msLockOrientation",
		    "msManipulationViewsEnabled",
		    "msMatchMedia",
		    "msMatchesSelector",
		    "msMaxTouchPoints",
		    "msOrientation",
		    "msOverflowStyle",
		    "msPerspective",
		    "msPerspectiveOrigin",
		    "msPlayToDisabled",
		    "msPlayToPreferredSourceUri",
		    "msPlayToPrimary",
		    "msPointerEnabled",
		    "msRegionOverflow",
		    "msReleasePointerCapture",
		    "msRequestAnimationFrame",
		    "msRequestFullscreen",
		    "msSaveBlob",
		    "msSaveOrOpenBlob",
		    "msScrollChaining",
		    "msScrollLimit",
		    "msScrollLimitXMax",
		    "msScrollLimitXMin",
		    "msScrollLimitYMax",
		    "msScrollLimitYMin",
		    "msScrollRails",
		    "msScrollSnapPointsX",
		    "msScrollSnapPointsY",
		    "msScrollSnapType",
		    "msScrollSnapX",
		    "msScrollSnapY",
		    "msScrollTranslation",
		    "msSetImmediate",
		    "msSetMediaKeys",
		    "msSetPointerCapture",
		    "msTextCombineHorizontal",
		    "msTextSizeAdjust",
		    "msToBlob",
		    "msTouchAction",
		    "msTouchSelect",
		    "msTraceAsyncCallbackCompleted",
		    "msTraceAsyncCallbackStarting",
		    "msTraceAsyncOperationCompleted",
		    "msTraceAsyncOperationStarting",
		    "msTransform",
		    "msTransformOrigin",
		    "msTransformStyle",
		    "msTransition",
		    "msTransitionDelay",
		    "msTransitionDuration",
		    "msTransitionProperty",
		    "msTransitionTimingFunction",
		    "msUnlockOrientation",
		    "msUpdateAsyncCallbackRelation",
		    "msUserSelect",
		    "msVisibilityState",
		    "msWrapFlow",
		    "msWrapMargin",
		    "msWrapThrough",
		    "msWriteProfilerMark",
		    "msZoom",
		    "msZoomTo",
		    "mt",
		    "mul",
		    "multiEntry",
		    "multiSelectionObj",
		    "multiline",
		    "multiple",
		    "multiply",
		    "multiplySelf",
		    "multisample",
		    "multisampled",
		    "mutableFile",
		    "muted",
		    "n",
		    "name",
		    "nameProp",
		    "namedItem",
		    "namedRecordset",
		    "names",
		    "namespaceURI",
		    "namespaces",
		    "naturalHeight",
		    "naturalWidth",
		    "navigate",
		    "navigation",
		    "navigationMode",
		    "navigationPreload",
		    "navigationStart",
		    "navigator",
		    "near",
		    "nearestViewportElement",
		    "negative",
		    "negotiated",
		    "netscape",
		    "networkState",
		    "newScale",
		    "newTranslate",
		    "newURL",
		    "newValue",
		    "newValueSpecifiedUnits",
		    "newVersion",
		    "newhome",
		    "next",
		    "nextElementSibling",
		    "nextHopProtocol",
		    "nextNode",
		    "nextPage",
		    "nextSibling",
		    "nickname",
		    "noHref",
		    "noModule",
		    "noResize",
		    "noShade",
		    "noValidate",
		    "noWrap",
		    "node",
		    "nodeName",
		    "nodeType",
		    "nodeValue",
		    "nonce",
		    "normalize",
		    "normalizedPathSegList",
		    "notationName",
		    "notations",
		    "note",
		    "noteGrainOn",
		    "noteOff",
		    "noteOn",
		    "notify",
		    "now",
		    "numOctaves",
		    "number",
		    "numberOfChannels",
		    "numberOfInputs",
		    "numberOfItems",
		    "numberOfOutputs",
		    "numberValue",
		    "oMatchesSelector",
		    "object",
		    "object-fit",
		    "object-position",
		    "objectFit",
		    "objectPosition",
		    "objectStore",
		    "objectStoreNames",
		    "objectType",
		    "observe",
		    "occlusionQuerySet",
		    "of",
		    "offscreenBuffering",
		    "offset",
		    "offset-anchor",
		    "offset-distance",
		    "offset-path",
		    "offset-rotate",
		    "offsetAnchor",
		    "offsetDistance",
		    "offsetHeight",
		    "offsetLeft",
		    "offsetNode",
		    "offsetParent",
		    "offsetPath",
		    "offsetRotate",
		    "offsetTop",
		    "offsetWidth",
		    "offsetX",
		    "offsetY",
		    "ok",
		    "oldURL",
		    "oldValue",
		    "oldVersion",
		    "olderShadowRoot",
		    "onLine",
		    "onSubmittedWorkDone",
		    "onabort",
		    "onabsolutedeviceorientation",
		    "onactivate",
		    "onactive",
		    "onaddsourcebuffer",
		    "onaddstream",
		    "onaddtrack",
		    "onafterprint",
		    "onafterscriptexecute",
		    "onafterupdate",
		    "onanimationcancel",
		    "onanimationend",
		    "onanimationiteration",
		    "onanimationstart",
		    "onappinstalled",
		    "onaudioend",
		    "onaudioprocess",
		    "onaudiostart",
		    "onautocomplete",
		    "onautocompleteerror",
		    "onauxclick",
		    "onbeforeactivate",
		    "onbeforecopy",
		    "onbeforecut",
		    "onbeforedeactivate",
		    "onbeforeeditfocus",
		    "onbeforeinstallprompt",
		    "onbeforepaste",
		    "onbeforeprint",
		    "onbeforescriptexecute",
		    "onbeforeunload",
		    "onbeforeupdate",
		    "onbeforexrselect",
		    "onbegin",
		    "onblocked",
		    "onblur",
		    "onbounce",
		    "onboundary",
		    "onbufferedamountlow",
		    "oncached",
		    "oncancel",
		    "oncandidatewindowhide",
		    "oncandidatewindowshow",
		    "oncandidatewindowupdate",
		    "oncanplay",
		    "oncanplaythrough",
		    "once",
		    "oncellchange",
		    "onchange",
		    "oncharacteristicvaluechanged",
		    "onchargingchange",
		    "onchargingtimechange",
		    "onchecking",
		    "onclick",
		    "onclose",
		    "onclosing",
		    "oncompassneedscalibration",
		    "oncomplete",
		    "onconnect",
		    "onconnecting",
		    "onconnectionavailable",
		    "onconnectionstatechange",
		    "oncontextmenu",
		    "oncontrollerchange",
		    "oncontrolselect",
		    "oncopy",
		    "oncuechange",
		    "oncut",
		    "ondataavailable",
		    "ondatachannel",
		    "ondatasetchanged",
		    "ondatasetcomplete",
		    "ondblclick",
		    "ondeactivate",
		    "ondevicechange",
		    "ondevicelight",
		    "ondevicemotion",
		    "ondeviceorientation",
		    "ondeviceorientationabsolute",
		    "ondeviceproximity",
		    "ondischargingtimechange",
		    "ondisconnect",
		    "ondisplay",
		    "ondownloading",
		    "ondrag",
		    "ondragend",
		    "ondragenter",
		    "ondragexit",
		    "ondragleave",
		    "ondragover",
		    "ondragstart",
		    "ondrop",
		    "ondurationchange",
		    "onemptied",
		    "onencrypted",
		    "onend",
		    "onended",
		    "onenter",
		    "onenterpictureinpicture",
		    "onerror",
		    "onerrorupdate",
		    "onexit",
		    "onfilterchange",
		    "onfinish",
		    "onfocus",
		    "onfocusin",
		    "onfocusout",
		    "onformdata",
		    "onfreeze",
		    "onfullscreenchange",
		    "onfullscreenerror",
		    "ongatheringstatechange",
		    "ongattserverdisconnected",
		    "ongesturechange",
		    "ongestureend",
		    "ongesturestart",
		    "ongotpointercapture",
		    "onhashchange",
		    "onhelp",
		    "onicecandidate",
		    "onicecandidateerror",
		    "oniceconnectionstatechange",
		    "onicegatheringstatechange",
		    "oninactive",
		    "oninput",
		    "oninputsourceschange",
		    "oninvalid",
		    "onkeydown",
		    "onkeypress",
		    "onkeystatuseschange",
		    "onkeyup",
		    "onlanguagechange",
		    "onlayoutcomplete",
		    "onleavepictureinpicture",
		    "onlevelchange",
		    "onload",
		    "onloadeddata",
		    "onloadedmetadata",
		    "onloadend",
		    "onloading",
		    "onloadingdone",
		    "onloadingerror",
		    "onloadstart",
		    "onlosecapture",
		    "onlostpointercapture",
		    "only",
		    "onmark",
		    "onmessage",
		    "onmessageerror",
		    "onmidimessage",
		    "onmousedown",
		    "onmouseenter",
		    "onmouseleave",
		    "onmousemove",
		    "onmouseout",
		    "onmouseover",
		    "onmouseup",
		    "onmousewheel",
		    "onmove",
		    "onmoveend",
		    "onmovestart",
		    "onmozfullscreenchange",
		    "onmozfullscreenerror",
		    "onmozorientationchange",
		    "onmozpointerlockchange",
		    "onmozpointerlockerror",
		    "onmscontentzoom",
		    "onmsfullscreenchange",
		    "onmsfullscreenerror",
		    "onmsgesturechange",
		    "onmsgesturedoubletap",
		    "onmsgestureend",
		    "onmsgesturehold",
		    "onmsgesturestart",
		    "onmsgesturetap",
		    "onmsgotpointercapture",
		    "onmsinertiastart",
		    "onmslostpointercapture",
		    "onmsmanipulationstatechanged",
		    "onmsneedkey",
		    "onmsorientationchange",
		    "onmspointercancel",
		    "onmspointerdown",
		    "onmspointerenter",
		    "onmspointerhover",
		    "onmspointerleave",
		    "onmspointermove",
		    "onmspointerout",
		    "onmspointerover",
		    "onmspointerup",
		    "onmssitemodejumplistitemremoved",
		    "onmsthumbnailclick",
		    "onmute",
		    "onnegotiationneeded",
		    "onnomatch",
		    "onnoupdate",
		    "onobsolete",
		    "onoffline",
		    "ononline",
		    "onopen",
		    "onorientationchange",
		    "onpagechange",
		    "onpagehide",
		    "onpageshow",
		    "onpaste",
		    "onpause",
		    "onpayerdetailchange",
		    "onpaymentmethodchange",
		    "onplay",
		    "onplaying",
		    "onpluginstreamstart",
		    "onpointercancel",
		    "onpointerdown",
		    "onpointerenter",
		    "onpointerleave",
		    "onpointerlockchange",
		    "onpointerlockerror",
		    "onpointermove",
		    "onpointerout",
		    "onpointerover",
		    "onpointerrawupdate",
		    "onpointerup",
		    "onpopstate",
		    "onprocessorerror",
		    "onprogress",
		    "onpropertychange",
		    "onratechange",
		    "onreading",
		    "onreadystatechange",
		    "onrejectionhandled",
		    "onrelease",
		    "onremove",
		    "onremovesourcebuffer",
		    "onremovestream",
		    "onremovetrack",
		    "onrepeat",
		    "onreset",
		    "onresize",
		    "onresizeend",
		    "onresizestart",
		    "onresourcetimingbufferfull",
		    "onresult",
		    "onresume",
		    "onrowenter",
		    "onrowexit",
		    "onrowsdelete",
		    "onrowsinserted",
		    "onscroll",
		    "onsearch",
		    "onsecuritypolicyviolation",
		    "onseeked",
		    "onseeking",
		    "onselect",
		    "onselectedcandidatepairchange",
		    "onselectend",
		    "onselectionchange",
		    "onselectstart",
		    "onshippingaddresschange",
		    "onshippingoptionchange",
		    "onshow",
		    "onsignalingstatechange",
		    "onsoundend",
		    "onsoundstart",
		    "onsourceclose",
		    "onsourceclosed",
		    "onsourceended",
		    "onsourceopen",
		    "onspeechend",
		    "onspeechstart",
		    "onsqueeze",
		    "onsqueezeend",
		    "onsqueezestart",
		    "onstalled",
		    "onstart",
		    "onstatechange",
		    "onstop",
		    "onstorage",
		    "onstoragecommit",
		    "onsubmit",
		    "onsuccess",
		    "onsuspend",
		    "onterminate",
		    "ontextinput",
		    "ontimeout",
		    "ontimeupdate",
		    "ontoggle",
		    "ontonechange",
		    "ontouchcancel",
		    "ontouchend",
		    "ontouchmove",
		    "ontouchstart",
		    "ontrack",
		    "ontransitioncancel",
		    "ontransitionend",
		    "ontransitionrun",
		    "ontransitionstart",
		    "onuncapturederror",
		    "onunhandledrejection",
		    "onunload",
		    "onunmute",
		    "onupdate",
		    "onupdateend",
		    "onupdatefound",
		    "onupdateready",
		    "onupdatestart",
		    "onupgradeneeded",
		    "onuserproximity",
		    "onversionchange",
		    "onvisibilitychange",
		    "onvoiceschanged",
		    "onvolumechange",
		    "onvrdisplayactivate",
		    "onvrdisplayconnect",
		    "onvrdisplaydeactivate",
		    "onvrdisplaydisconnect",
		    "onvrdisplaypresentchange",
		    "onwaiting",
		    "onwaitingforkey",
		    "onwarning",
		    "onwebkitanimationend",
		    "onwebkitanimationiteration",
		    "onwebkitanimationstart",
		    "onwebkitcurrentplaybacktargetiswirelesschanged",
		    "onwebkitfullscreenchange",
		    "onwebkitfullscreenerror",
		    "onwebkitkeyadded",
		    "onwebkitkeyerror",
		    "onwebkitkeymessage",
		    "onwebkitneedkey",
		    "onwebkitorientationchange",
		    "onwebkitplaybacktargetavailabilitychanged",
		    "onwebkitpointerlockchange",
		    "onwebkitpointerlockerror",
		    "onwebkitresourcetimingbufferfull",
		    "onwebkittransitionend",
		    "onwheel",
		    "onzoom",
		    "opacity",
		    "open",
		    "openCursor",
		    "openDatabase",
		    "openKeyCursor",
		    "opened",
		    "opener",
		    "opera",
		    "operation",
		    "operationType",
		    "operator",
		    "opr",
		    "optimum",
		    "options",
		    "or",
		    "order",
		    "orderX",
		    "orderY",
		    "ordered",
		    "org",
		    "organization",
		    "orient",
		    "orientAngle",
		    "orientType",
		    "orientation",
		    "orientationX",
		    "orientationY",
		    "orientationZ",
		    "origin",
		    "originalPolicy",
		    "originalTarget",
		    "orphans",
		    "oscpu",
		    "outerHTML",
		    "outerHeight",
		    "outerText",
		    "outerWidth",
		    "outline",
		    "outline-color",
		    "outline-offset",
		    "outline-style",
		    "outline-width",
		    "outlineColor",
		    "outlineOffset",
		    "outlineStyle",
		    "outlineWidth",
		    "outputBuffer",
		    "outputChannelCount",
		    "outputLatency",
		    "outputs",
		    "overflow",
		    "overflow-anchor",
		    "overflow-block",
		    "overflow-inline",
		    "overflow-wrap",
		    "overflow-x",
		    "overflow-y",
		    "overflowAnchor",
		    "overflowBlock",
		    "overflowInline",
		    "overflowWrap",
		    "overflowX",
		    "overflowY",
		    "overrideMimeType",
		    "oversample",
		    "overscroll-behavior",
		    "overscroll-behavior-block",
		    "overscroll-behavior-inline",
		    "overscroll-behavior-x",
		    "overscroll-behavior-y",
		    "overscrollBehavior",
		    "overscrollBehaviorBlock",
		    "overscrollBehaviorInline",
		    "overscrollBehaviorX",
		    "overscrollBehaviorY",
		    "ownKeys",
		    "ownerDocument",
		    "ownerElement",
		    "ownerNode",
		    "ownerRule",
		    "ownerSVGElement",
		    "owningElement",
		    "p1",
		    "p2",
		    "p3",
		    "p4",
		    "packetSize",
		    "packets",
		    "pad",
		    "padEnd",
		    "padStart",
		    "padding",
		    "padding-block",
		    "padding-block-end",
		    "padding-block-start",
		    "padding-bottom",
		    "padding-inline",
		    "padding-inline-end",
		    "padding-inline-start",
		    "padding-left",
		    "padding-right",
		    "padding-top",
		    "paddingBlock",
		    "paddingBlockEnd",
		    "paddingBlockStart",
		    "paddingBottom",
		    "paddingInline",
		    "paddingInlineEnd",
		    "paddingInlineStart",
		    "paddingLeft",
		    "paddingRight",
		    "paddingTop",
		    "page",
		    "page-break-after",
		    "page-break-before",
		    "page-break-inside",
		    "pageBreakAfter",
		    "pageBreakBefore",
		    "pageBreakInside",
		    "pageCount",
		    "pageLeft",
		    "pageTop",
		    "pageX",
		    "pageXOffset",
		    "pageY",
		    "pageYOffset",
		    "pages",
		    "paint-order",
		    "paintOrder",
		    "paintRequests",
		    "paintType",
		    "paintWorklet",
		    "palette",
		    "pan",
		    "panningModel",
		    "parameterData",
		    "parameters",
		    "parent",
		    "parentElement",
		    "parentNode",
		    "parentRule",
		    "parentStyleSheet",
		    "parentTextEdit",
		    "parentWindow",
		    "parse",
		    "parseAll",
		    "parseFloat",
		    "parseFromString",
		    "parseInt",
		    "part",
		    "participants",
		    "passOp",
		    "passive",
		    "password",
		    "pasteHTML",
		    "path",
		    "pathLength",
		    "pathSegList",
		    "pathSegType",
		    "pathSegTypeAsLetter",
		    "pathname",
		    "pattern",
		    "patternContentUnits",
		    "patternMismatch",
		    "patternTransform",
		    "patternUnits",
		    "pause",
		    "pauseAnimations",
		    "pauseOnExit",
		    "pauseProfilers",
		    "pauseTransformFeedback",
		    "paused",
		    "payerEmail",
		    "payerName",
		    "payerPhone",
		    "paymentManager",
		    "pc",
		    "peerIdentity",
		    "pending",
		    "pendingLocalDescription",
		    "pendingRemoteDescription",
		    "percent",
		    "performance",
		    "periodicSync",
		    "permission",
		    "permissionState",
		    "permissions",
		    "persist",
		    "persisted",
		    "personalbar",
		    "perspective",
		    "perspective-origin",
		    "perspectiveOrigin",
		    "phone",
		    "phoneticFamilyName",
		    "phoneticGivenName",
		    "photo",
		    "pictureInPictureElement",
		    "pictureInPictureEnabled",
		    "pictureInPictureWindow",
		    "ping",
		    "pipeThrough",
		    "pipeTo",
		    "pitch",
		    "pixelBottom",
		    "pixelDepth",
		    "pixelHeight",
		    "pixelLeft",
		    "pixelRight",
		    "pixelStorei",
		    "pixelTop",
		    "pixelUnitToMillimeterX",
		    "pixelUnitToMillimeterY",
		    "pixelWidth",
		    "place-content",
		    "place-items",
		    "place-self",
		    "placeContent",
		    "placeItems",
		    "placeSelf",
		    "placeholder",
		    "platform",
		    "platformVersion",
		    "platforms",
		    "play",
		    "playEffect",
		    "playState",
		    "playbackRate",
		    "playbackState",
		    "playbackTime",
		    "played",
		    "playoutDelayHint",
		    "playsInline",
		    "plugins",
		    "pluginspage",
		    "pname",
		    "pointer-events",
		    "pointerBeforeReferenceNode",
		    "pointerEnabled",
		    "pointerEvents",
		    "pointerId",
		    "pointerLockElement",
		    "pointerType",
		    "points",
		    "pointsAtX",
		    "pointsAtY",
		    "pointsAtZ",
		    "polygonOffset",
		    "pop",
		    "popDebugGroup",
		    "popErrorScope",
		    "populateMatrix",
		    "popupWindowFeatures",
		    "popupWindowName",
		    "popupWindowURI",
		    "port",
		    "port1",
		    "port2",
		    "ports",
		    "posBottom",
		    "posHeight",
		    "posLeft",
		    "posRight",
		    "posTop",
		    "posWidth",
		    "pose",
		    "position",
		    "positionAlign",
		    "positionX",
		    "positionY",
		    "positionZ",
		    "postError",
		    "postMessage",
		    "postalCode",
		    "poster",
		    "pow",
		    "powerEfficient",
		    "powerOff",
		    "powerPreference",
		    "preMultiplySelf",
		    "precision",
		    "preferredStyleSheetSet",
		    "preferredStylesheetSet",
		    "prefix",
		    "preload",
		    "premultipliedAlpha",
		    "prepend",
		    "presentation",
		    "preserveAlpha",
		    "preserveAspectRatio",
		    "preserveAspectRatioString",
		    "pressed",
		    "pressure",
		    "prevValue",
		    "preventDefault",
		    "preventExtensions",
		    "preventSilentAccess",
		    "previousElementSibling",
		    "previousNode",
		    "previousPage",
		    "previousRect",
		    "previousScale",
		    "previousSibling",
		    "previousTranslate",
		    "primaryKey",
		    "primitive",
		    "primitiveType",
		    "primitiveUnits",
		    "principals",
		    "print",
		    "priority",
		    "privateKey",
		    "probablySupportsContext",
		    "process",
		    "processIceMessage",
		    "processingEnd",
		    "processingStart",
		    "processorOptions",
		    "product",
		    "productId",
		    "productName",
		    "productSub",
		    "profile",
		    "profileEnd",
		    "profiles",
		    "projectionMatrix",
		    "promise",
		    "prompt",
		    "properties",
		    "propertyIsEnumerable",
		    "propertyName",
		    "protocol",
		    "protocolLong",
		    "prototype",
		    "provider",
		    "pseudoClass",
		    "pseudoElement",
		    "pt",
		    "publicId",
		    "publicKey",
		    "published",
		    "pulse",
		    "push",
		    "pushDebugGroup",
		    "pushErrorScope",
		    "pushManager",
		    "pushNotification",
		    "pushState",
		    "put",
		    "putImageData",
		    "px",
		    "quadraticCurveTo",
		    "qualifier",
		    "quaternion",
		    "query",
		    "queryCommandEnabled",
		    "queryCommandIndeterm",
		    "queryCommandState",
		    "queryCommandSupported",
		    "queryCommandText",
		    "queryCommandValue",
		    "querySelector",
		    "querySelectorAll",
		    "querySet",
		    "queue",
		    "queueMicrotask",
		    "quote",
		    "quotes",
		    "r",
		    "r1",
		    "r2",
		    "race",
		    "rad",
		    "radiogroup",
		    "radiusX",
		    "radiusY",
		    "random",
		    "range",
		    "rangeCount",
		    "rangeMax",
		    "rangeMin",
		    "rangeOffset",
		    "rangeOverflow",
		    "rangeParent",
		    "rangeUnderflow",
		    "rate",
		    "ratio",
		    "raw",
		    "rawId",
		    "read",
		    "readAsArrayBuffer",
		    "readAsBinaryString",
		    "readAsBlob",
		    "readAsDataURL",
		    "readAsText",
		    "readBuffer",
		    "readEntries",
		    "readOnly",
		    "readPixels",
		    "readReportRequested",
		    "readText",
		    "readValue",
		    "readable",
		    "ready",
		    "readyState",
		    "reason",
		    "reboot",
		    "receivedAlert",
		    "receiver",
		    "receivers",
		    "recipient",
		    "reconnect",
		    "recordNumber",
		    "recordsAvailable",
		    "recordset",
		    "rect",
		    "red",
		    "redEyeReduction",
		    "redirect",
		    "redirectCount",
		    "redirectEnd",
		    "redirectStart",
		    "redirected",
		    "reduce",
		    "reduceRight",
		    "reduction",
		    "refDistance",
		    "refX",
		    "refY",
		    "referenceNode",
		    "referenceSpace",
		    "referrer",
		    "referrerPolicy",
		    "refresh",
		    "region",
		    "regionAnchorX",
		    "regionAnchorY",
		    "regionId",
		    "regions",
		    "register",
		    "registerContentHandler",
		    "registerElement",
		    "registerProperty",
		    "registerProtocolHandler",
		    "reject",
		    "rel",
		    "relList",
		    "relatedAddress",
		    "relatedNode",
		    "relatedPort",
		    "relatedTarget",
		    "release",
		    "releaseCapture",
		    "releaseEvents",
		    "releaseInterface",
		    "releaseLock",
		    "releasePointerCapture",
		    "releaseShaderCompiler",
		    "reliable",
		    "reliableWrite",
		    "reload",
		    "rem",
		    "remainingSpace",
		    "remote",
		    "remoteDescription",
		    "remove",
		    "removeAllRanges",
		    "removeAttribute",
		    "removeAttributeNS",
		    "removeAttributeNode",
		    "removeBehavior",
		    "removeChild",
		    "removeCue",
		    "removeEventListener",
		    "removeFilter",
		    "removeImport",
		    "removeItem",
		    "removeListener",
		    "removeNamedItem",
		    "removeNamedItemNS",
		    "removeNode",
		    "removeParameter",
		    "removeProperty",
		    "removeRange",
		    "removeRegion",
		    "removeRule",
		    "removeSiteSpecificTrackingException",
		    "removeSourceBuffer",
		    "removeStream",
		    "removeTrack",
		    "removeVariable",
		    "removeWakeLockListener",
		    "removeWebWideTrackingException",
		    "removed",
		    "removedNodes",
		    "renderHeight",
		    "renderState",
		    "renderTime",
		    "renderWidth",
		    "renderbufferStorage",
		    "renderbufferStorageMultisample",
		    "renderedBuffer",
		    "renderingMode",
		    "renotify",
		    "repeat",
		    "replace",
		    "replaceAdjacentText",
		    "replaceAll",
		    "replaceChild",
		    "replaceChildren",
		    "replaceData",
		    "replaceId",
		    "replaceItem",
		    "replaceNode",
		    "replaceState",
		    "replaceSync",
		    "replaceTrack",
		    "replaceWholeText",
		    "replaceWith",
		    "reportValidity",
		    "request",
		    "requestAdapter",
		    "requestAdapterInfo",
		    "requestAnimationFrame",
		    "requestAutocomplete",
		    "requestData",
		    "requestDevice",
		    "requestFrame",
		    "requestFullscreen",
		    "requestHitTestSource",
		    "requestHitTestSourceForTransientInput",
		    "requestId",
		    "requestIdleCallback",
		    "requestMIDIAccess",
		    "requestMediaKeySystemAccess",
		    "requestPermission",
		    "requestPictureInPicture",
		    "requestPointerLock",
		    "requestPresent",
		    "requestReferenceSpace",
		    "requestSession",
		    "requestStart",
		    "requestStorageAccess",
		    "requestSubmit",
		    "requestVideoFrameCallback",
		    "requestingWindow",
		    "requireInteraction",
		    "required",
		    "requiredExtensions",
		    "requiredFeatures",
		    "requiredLimits",
		    "reset",
		    "resetPose",
		    "resetTransform",
		    "resize",
		    "resizeBy",
		    "resizeTo",
		    "resolve",
		    "resolveQuerySet",
		    "resolveTarget",
		    "resource",
		    "response",
		    "responseBody",
		    "responseEnd",
		    "responseReady",
		    "responseStart",
		    "responseText",
		    "responseType",
		    "responseURL",
		    "responseXML",
		    "restartIce",
		    "restore",
		    "result",
		    "resultIndex",
		    "resultType",
		    "results",
		    "resume",
		    "resumeProfilers",
		    "resumeTransformFeedback",
		    "retry",
		    "returnValue",
		    "rev",
		    "reverse",
		    "reversed",
		    "revocable",
		    "revokeObjectURL",
		    "rgbColor",
		    "right",
		    "rightContext",
		    "rightDegrees",
		    "rightMargin",
		    "rightProjectionMatrix",
		    "rightViewMatrix",
		    "role",
		    "rolloffFactor",
		    "root",
		    "rootBounds",
		    "rootElement",
		    "rootMargin",
		    "rotate",
		    "rotateAxisAngle",
		    "rotateAxisAngleSelf",
		    "rotateFromVector",
		    "rotateFromVectorSelf",
		    "rotateSelf",
		    "rotation",
		    "rotationAngle",
		    "rotationRate",
		    "round",
		    "roundRect",
		    "row-gap",
		    "rowGap",
		    "rowIndex",
		    "rowSpan",
		    "rows",
		    "rowsPerImage",
		    "rtcpTransport",
		    "rtt",
		    "ruby-align",
		    "ruby-position",
		    "rubyAlign",
		    "rubyOverhang",
		    "rubyPosition",
		    "rules",
		    "runtime",
		    "runtimeStyle",
		    "rx",
		    "ry",
		    "s",
		    "safari",
		    "sample",
		    "sampleCount",
		    "sampleCoverage",
		    "sampleRate",
		    "sampleType",
		    "sampler",
		    "samplerParameterf",
		    "samplerParameteri",
		    "sandbox",
		    "save",
		    "saveData",
		    "scale",
		    "scale3d",
		    "scale3dSelf",
		    "scaleNonUniform",
		    "scaleNonUniformSelf",
		    "scaleSelf",
		    "scheme",
		    "scissor",
		    "scope",
		    "scopeName",
		    "scoped",
		    "screen",
		    "screenBrightness",
		    "screenEnabled",
		    "screenLeft",
		    "screenPixelToMillimeterX",
		    "screenPixelToMillimeterY",
		    "screenTop",
		    "screenX",
		    "screenY",
		    "scriptURL",
		    "scripts",
		    "scroll",
		    "scroll-behavior",
		    "scroll-margin",
		    "scroll-margin-block",
		    "scroll-margin-block-end",
		    "scroll-margin-block-start",
		    "scroll-margin-bottom",
		    "scroll-margin-inline",
		    "scroll-margin-inline-end",
		    "scroll-margin-inline-start",
		    "scroll-margin-left",
		    "scroll-margin-right",
		    "scroll-margin-top",
		    "scroll-padding",
		    "scroll-padding-block",
		    "scroll-padding-block-end",
		    "scroll-padding-block-start",
		    "scroll-padding-bottom",
		    "scroll-padding-inline",
		    "scroll-padding-inline-end",
		    "scroll-padding-inline-start",
		    "scroll-padding-left",
		    "scroll-padding-right",
		    "scroll-padding-top",
		    "scroll-snap-align",
		    "scroll-snap-type",
		    "scrollAmount",
		    "scrollBehavior",
		    "scrollBy",
		    "scrollByLines",
		    "scrollByPages",
		    "scrollDelay",
		    "scrollHeight",
		    "scrollIntoView",
		    "scrollIntoViewIfNeeded",
		    "scrollLeft",
		    "scrollLeftMax",
		    "scrollMargin",
		    "scrollMarginBlock",
		    "scrollMarginBlockEnd",
		    "scrollMarginBlockStart",
		    "scrollMarginBottom",
		    "scrollMarginInline",
		    "scrollMarginInlineEnd",
		    "scrollMarginInlineStart",
		    "scrollMarginLeft",
		    "scrollMarginRight",
		    "scrollMarginTop",
		    "scrollMaxX",
		    "scrollMaxY",
		    "scrollPadding",
		    "scrollPaddingBlock",
		    "scrollPaddingBlockEnd",
		    "scrollPaddingBlockStart",
		    "scrollPaddingBottom",
		    "scrollPaddingInline",
		    "scrollPaddingInlineEnd",
		    "scrollPaddingInlineStart",
		    "scrollPaddingLeft",
		    "scrollPaddingRight",
		    "scrollPaddingTop",
		    "scrollRestoration",
		    "scrollSnapAlign",
		    "scrollSnapType",
		    "scrollTo",
		    "scrollTop",
		    "scrollTopMax",
		    "scrollWidth",
		    "scrollX",
		    "scrollY",
		    "scrollbar-color",
		    "scrollbar-width",
		    "scrollbar3dLightColor",
		    "scrollbarArrowColor",
		    "scrollbarBaseColor",
		    "scrollbarColor",
		    "scrollbarDarkShadowColor",
		    "scrollbarFaceColor",
		    "scrollbarHighlightColor",
		    "scrollbarShadowColor",
		    "scrollbarTrackColor",
		    "scrollbarWidth",
		    "scrollbars",
		    "scrolling",
		    "scrollingElement",
		    "sctp",
		    "sctpCauseCode",
		    "sdp",
		    "sdpLineNumber",
		    "sdpMLineIndex",
		    "sdpMid",
		    "seal",
		    "search",
		    "searchBox",
		    "searchBoxJavaBridge_",
		    "searchParams",
		    "sectionRowIndex",
		    "secureConnectionStart",
		    "security",
		    "seed",
		    "seekToNextFrame",
		    "seekable",
		    "seeking",
		    "select",
		    "selectAllChildren",
		    "selectAlternateInterface",
		    "selectConfiguration",
		    "selectNode",
		    "selectNodeContents",
		    "selectNodes",
		    "selectSingleNode",
		    "selectSubString",
		    "selected",
		    "selectedIndex",
		    "selectedOptions",
		    "selectedStyleSheetSet",
		    "selectedStylesheetSet",
		    "selection",
		    "selectionDirection",
		    "selectionEnd",
		    "selectionStart",
		    "selector",
		    "selectorText",
		    "self",
		    "send",
		    "sendAsBinary",
		    "sendBeacon",
		    "sender",
		    "sentAlert",
		    "sentTimestamp",
		    "separator",
		    "serialNumber",
		    "serializeToString",
		    "serverTiming",
		    "service",
		    "serviceWorker",
		    "session",
		    "sessionId",
		    "sessionStorage",
		    "set",
		    "setActionHandler",
		    "setActive",
		    "setAlpha",
		    "setAppBadge",
		    "setAttribute",
		    "setAttributeNS",
		    "setAttributeNode",
		    "setAttributeNodeNS",
		    "setBaseAndExtent",
		    "setBigInt64",
		    "setBigUint64",
		    "setBindGroup",
		    "setBingCurrentSearchDefault",
		    "setBlendConstant",
		    "setCapture",
		    "setCodecPreferences",
		    "setColor",
		    "setCompositeOperation",
		    "setConfiguration",
		    "setCurrentTime",
		    "setCustomValidity",
		    "setData",
		    "setDate",
		    "setDragImage",
		    "setEnd",
		    "setEndAfter",
		    "setEndBefore",
		    "setEndPoint",
		    "setFillColor",
		    "setFilterRes",
		    "setFloat32",
		    "setFloat64",
		    "setFloatValue",
		    "setFormValue",
		    "setFullYear",
		    "setHeaderValue",
		    "setHours",
		    "setIdentityProvider",
		    "setImmediate",
		    "setIndexBuffer",
		    "setInt16",
		    "setInt32",
		    "setInt8",
		    "setInterval",
		    "setItem",
		    "setKeyframes",
		    "setLineCap",
		    "setLineDash",
		    "setLineJoin",
		    "setLineWidth",
		    "setLiveSeekableRange",
		    "setLocalDescription",
		    "setMatrix",
		    "setMatrixValue",
		    "setMediaKeys",
		    "setMilliseconds",
		    "setMinutes",
		    "setMiterLimit",
		    "setMonth",
		    "setNamedItem",
		    "setNamedItemNS",
		    "setNonUserCodeExceptions",
		    "setOrientToAngle",
		    "setOrientToAuto",
		    "setOrientation",
		    "setOverrideHistoryNavigationMode",
		    "setPaint",
		    "setParameter",
		    "setParameters",
		    "setPeriodicWave",
		    "setPipeline",
		    "setPointerCapture",
		    "setPosition",
		    "setPositionState",
		    "setPreference",
		    "setProperty",
		    "setPrototypeOf",
		    "setRGBColor",
		    "setRGBColorICCColor",
		    "setRadius",
		    "setRangeText",
		    "setRemoteDescription",
		    "setRequestHeader",
		    "setResizable",
		    "setResourceTimingBufferSize",
		    "setRotate",
		    "setScale",
		    "setScissorRect",
		    "setSeconds",
		    "setSelectionRange",
		    "setServerCertificate",
		    "setShadow",
		    "setSinkId",
		    "setSkewX",
		    "setSkewY",
		    "setStart",
		    "setStartAfter",
		    "setStartBefore",
		    "setStdDeviation",
		    "setStencilReference",
		    "setStreams",
		    "setStringValue",
		    "setStrokeColor",
		    "setSuggestResult",
		    "setTargetAtTime",
		    "setTargetValueAtTime",
		    "setTime",
		    "setTimeout",
		    "setTransform",
		    "setTranslate",
		    "setUTCDate",
		    "setUTCFullYear",
		    "setUTCHours",
		    "setUTCMilliseconds",
		    "setUTCMinutes",
		    "setUTCMonth",
		    "setUTCSeconds",
		    "setUint16",
		    "setUint32",
		    "setUint8",
		    "setUri",
		    "setValidity",
		    "setValueAtTime",
		    "setValueCurveAtTime",
		    "setVariable",
		    "setVelocity",
		    "setVersion",
		    "setVertexBuffer",
		    "setViewport",
		    "setYear",
		    "settingName",
		    "settingValue",
		    "sex",
		    "shaderLocation",
		    "shaderSource",
		    "shadowBlur",
		    "shadowColor",
		    "shadowOffsetX",
		    "shadowOffsetY",
		    "shadowRoot",
		    "shape",
		    "shape-image-threshold",
		    "shape-margin",
		    "shape-outside",
		    "shape-rendering",
		    "shapeImageThreshold",
		    "shapeMargin",
		    "shapeOutside",
		    "shapeRendering",
		    "sheet",
		    "shift",
		    "shiftKey",
		    "shiftLeft",
		    "shippingAddress",
		    "shippingOption",
		    "shippingType",
		    "show",
		    "showHelp",
		    "showModal",
		    "showModalDialog",
		    "showModelessDialog",
		    "showNotification",
		    "sidebar",
		    "sign",
		    "signal",
		    "signalingState",
		    "signature",
		    "silent",
		    "sin",
		    "singleNodeValue",
		    "sinh",
		    "sinkId",
		    "sittingToStandingTransform",
		    "size",
		    "sizeToContent",
		    "sizeX",
		    "sizeZ",
		    "sizes",
		    "skewX",
		    "skewXSelf",
		    "skewY",
		    "skewYSelf",
		    "slice",
		    "slope",
		    "slot",
		    "small",
		    "smil",
		    "smooth",
		    "smoothingTimeConstant",
		    "snapToLines",
		    "snapshotItem",
		    "snapshotLength",
		    "some",
		    "sort",
		    "sortingCode",
		    "source",
		    "sourceBuffer",
		    "sourceBuffers",
		    "sourceCapabilities",
		    "sourceFile",
		    "sourceIndex",
		    "sourceMap",
		    "sources",
		    "spacing",
		    "span",
		    "speak",
		    "speakAs",
		    "speaking",
		    "species",
		    "specified",
		    "specularConstant",
		    "specularExponent",
		    "speechSynthesis",
		    "speed",
		    "speedOfSound",
		    "spellcheck",
		    "splice",
		    "split",
		    "splitText",
		    "spreadMethod",
		    "sqrt",
		    "src",
		    "srcElement",
		    "srcFactor",
		    "srcFilter",
		    "srcObject",
		    "srcUrn",
		    "srcdoc",
		    "srclang",
		    "srcset",
		    "stack",
		    "stackTraceLimit",
		    "stacktrace",
		    "stageParameters",
		    "standalone",
		    "standby",
		    "start",
		    "startContainer",
		    "startIce",
		    "startMessages",
		    "startNotifications",
		    "startOffset",
		    "startProfiling",
		    "startRendering",
		    "startShark",
		    "startTime",
		    "startsWith",
		    "state",
		    "status",
		    "statusCode",
		    "statusMessage",
		    "statusText",
		    "statusbar",
		    "stdDeviationX",
		    "stdDeviationY",
		    "stencilBack",
		    "stencilClearValue",
		    "stencilFront",
		    "stencilFunc",
		    "stencilFuncSeparate",
		    "stencilLoadOp",
		    "stencilMask",
		    "stencilMaskSeparate",
		    "stencilOp",
		    "stencilOpSeparate",
		    "stencilReadMask",
		    "stencilReadOnly",
		    "stencilStoreOp",
		    "stencilWriteMask",
		    "step",
		    "stepDown",
		    "stepMismatch",
		    "stepMode",
		    "stepUp",
		    "sticky",
		    "stitchTiles",
		    "stop",
		    "stop-color",
		    "stop-opacity",
		    "stopColor",
		    "stopImmediatePropagation",
		    "stopNotifications",
		    "stopOpacity",
		    "stopProfiling",
		    "stopPropagation",
		    "stopShark",
		    "stopped",
		    "storage",
		    "storageArea",
		    "storageName",
		    "storageStatus",
		    "storageTexture",
		    "store",
		    "storeOp",
		    "storeSiteSpecificTrackingException",
		    "storeWebWideTrackingException",
		    "stpVersion",
		    "stream",
		    "streams",
		    "stretch",
		    "strike",
		    "string",
		    "stringValue",
		    "stringify",
		    "stripIndexFormat",
		    "stroke",
		    "stroke-dasharray",
		    "stroke-dashoffset",
		    "stroke-linecap",
		    "stroke-linejoin",
		    "stroke-miterlimit",
		    "stroke-opacity",
		    "stroke-width",
		    "strokeDasharray",
		    "strokeDashoffset",
		    "strokeLinecap",
		    "strokeLinejoin",
		    "strokeMiterlimit",
		    "strokeOpacity",
		    "strokeRect",
		    "strokeStyle",
		    "strokeText",
		    "strokeWidth",
		    "style",
		    "styleFloat",
		    "styleMap",
		    "styleMedia",
		    "styleSheet",
		    "styleSheetSets",
		    "styleSheets",
		    "sub",
		    "subarray",
		    "subject",
		    "submit",
		    "submitFrame",
		    "submitter",
		    "subscribe",
		    "substr",
		    "substring",
		    "substringData",
		    "subtle",
		    "subtree",
		    "suffix",
		    "suffixes",
		    "summary",
		    "sup",
		    "supported",
		    "supportedContentEncodings",
		    "supportedEntryTypes",
		    "supports",
		    "supportsSession",
		    "surfaceScale",
		    "surroundContents",
		    "suspend",
		    "suspendRedraw",
		    "swapCache",
		    "swapNode",
		    "sweepFlag",
		    "symbols",
		    "sync",
		    "sysexEnabled",
		    "system",
		    "systemCode",
		    "systemId",
		    "systemLanguage",
		    "systemXDPI",
		    "systemYDPI",
		    "tBodies",
		    "tFoot",
		    "tHead",
		    "tabIndex",
		    "table",
		    "table-layout",
		    "tableLayout",
		    "tableValues",
		    "tag",
		    "tagName",
		    "tagUrn",
		    "tags",
		    "taintEnabled",
		    "takePhoto",
		    "takeRecords",
		    "tan",
		    "tangentialPressure",
		    "tanh",
		    "target",
		    "targetElement",
		    "targetRayMode",
		    "targetRaySpace",
		    "targetTouches",
		    "targetX",
		    "targetY",
		    "targets",
		    "tcpType",
		    "tee",
		    "tel",
		    "terminate",
		    "test",
		    "texImage2D",
		    "texImage3D",
		    "texParameterf",
		    "texParameteri",
		    "texStorage2D",
		    "texStorage3D",
		    "texSubImage2D",
		    "texSubImage3D",
		    "text",
		    "text-align",
		    "text-align-last",
		    "text-anchor",
		    "text-combine-upright",
		    "text-decoration",
		    "text-decoration-color",
		    "text-decoration-line",
		    "text-decoration-skip-ink",
		    "text-decoration-style",
		    "text-decoration-thickness",
		    "text-emphasis",
		    "text-emphasis-color",
		    "text-emphasis-position",
		    "text-emphasis-style",
		    "text-indent",
		    "text-justify",
		    "text-orientation",
		    "text-overflow",
		    "text-rendering",
		    "text-shadow",
		    "text-transform",
		    "text-underline-offset",
		    "text-underline-position",
		    "textAlign",
		    "textAlignLast",
		    "textAnchor",
		    "textAutospace",
		    "textBaseline",
		    "textCombineUpright",
		    "textContent",
		    "textDecoration",
		    "textDecorationBlink",
		    "textDecorationColor",
		    "textDecorationLine",
		    "textDecorationLineThrough",
		    "textDecorationNone",
		    "textDecorationOverline",
		    "textDecorationSkipInk",
		    "textDecorationStyle",
		    "textDecorationThickness",
		    "textDecorationUnderline",
		    "textEmphasis",
		    "textEmphasisColor",
		    "textEmphasisPosition",
		    "textEmphasisStyle",
		    "textIndent",
		    "textJustify",
		    "textJustifyTrim",
		    "textKashida",
		    "textKashidaSpace",
		    "textLength",
		    "textOrientation",
		    "textOverflow",
		    "textRendering",
		    "textShadow",
		    "textTracks",
		    "textTransform",
		    "textUnderlineOffset",
		    "textUnderlinePosition",
		    "texture",
		    "then",
		    "threadId",
		    "threshold",
		    "thresholds",
		    "tiltX",
		    "tiltY",
		    "time",
		    "timeEnd",
		    "timeLog",
		    "timeOrigin",
		    "timeRemaining",
		    "timeStamp",
		    "timecode",
		    "timeline",
		    "timelineTime",
		    "timeout",
		    "timestamp",
		    "timestampOffset",
		    "timestampWrites",
		    "timing",
		    "title",
		    "to",
		    "toArray",
		    "toBlob",
		    "toDataURL",
		    "toDateString",
		    "toElement",
		    "toExponential",
		    "toFixed",
		    "toFloat32Array",
		    "toFloat64Array",
		    "toGMTString",
		    "toISOString",
		    "toJSON",
		    "toLocaleDateString",
		    "toLocaleFormat",
		    "toLocaleLowerCase",
		    "toLocaleString",
		    "toLocaleTimeString",
		    "toLocaleUpperCase",
		    "toLowerCase",
		    "toMatrix",
		    "toMethod",
		    "toPrecision",
		    "toPrimitive",
		    "toSdp",
		    "toSource",
		    "toStaticHTML",
		    "toString",
		    "toStringTag",
		    "toSum",
		    "toTimeString",
		    "toUTCString",
		    "toUpperCase",
		    "toggle",
		    "toggleAttribute",
		    "toggleLongPressEnabled",
		    "tone",
		    "toneBuffer",
		    "tooLong",
		    "tooShort",
		    "toolbar",
		    "top",
		    "topMargin",
		    "topology",
		    "total",
		    "totalFrameDelay",
		    "totalVideoFrames",
		    "touch-action",
		    "touchAction",
		    "touched",
		    "touches",
		    "trace",
		    "track",
		    "trackVisibility",
		    "transaction",
		    "transactions",
		    "transceiver",
		    "transferControlToOffscreen",
		    "transferFromImageBitmap",
		    "transferImageBitmap",
		    "transferIn",
		    "transferOut",
		    "transferSize",
		    "transferToImageBitmap",
		    "transform",
		    "transform-box",
		    "transform-origin",
		    "transform-style",
		    "transformBox",
		    "transformFeedbackVaryings",
		    "transformOrigin",
		    "transformPoint",
		    "transformString",
		    "transformStyle",
		    "transformToDocument",
		    "transformToFragment",
		    "transition",
		    "transition-delay",
		    "transition-duration",
		    "transition-property",
		    "transition-timing-function",
		    "transitionDelay",
		    "transitionDuration",
		    "transitionProperty",
		    "transitionTimingFunction",
		    "translate",
		    "translateSelf",
		    "translationX",
		    "translationY",
		    "transport",
		    "trim",
		    "trimEnd",
		    "trimLeft",
		    "trimRight",
		    "trimStart",
		    "trueSpeed",
		    "trunc",
		    "truncate",
		    "trustedTypes",
		    "turn",
		    "twist",
		    "type",
		    "typeDetail",
		    "typeMismatch",
		    "typeMustMatch",
		    "types",
		    "u2f",
		    "ubound",
		    "uint16",
		    "uint32",
		    "uint8",
		    "uint8Clamped",
		    "unclippedDepth",
		    "unconfigure",
		    "undefined",
		    "unescape",
		    "uneval",
		    "unicode",
		    "unicode-bidi",
		    "unicodeBidi",
		    "unicodeRange",
		    "uniform1f",
		    "uniform1fv",
		    "uniform1i",
		    "uniform1iv",
		    "uniform1ui",
		    "uniform1uiv",
		    "uniform2f",
		    "uniform2fv",
		    "uniform2i",
		    "uniform2iv",
		    "uniform2ui",
		    "uniform2uiv",
		    "uniform3f",
		    "uniform3fv",
		    "uniform3i",
		    "uniform3iv",
		    "uniform3ui",
		    "uniform3uiv",
		    "uniform4f",
		    "uniform4fv",
		    "uniform4i",
		    "uniform4iv",
		    "uniform4ui",
		    "uniform4uiv",
		    "uniformBlockBinding",
		    "uniformMatrix2fv",
		    "uniformMatrix2x3fv",
		    "uniformMatrix2x4fv",
		    "uniformMatrix3fv",
		    "uniformMatrix3x2fv",
		    "uniformMatrix3x4fv",
		    "uniformMatrix4fv",
		    "uniformMatrix4x2fv",
		    "uniformMatrix4x3fv",
		    "unique",
		    "uniqueID",
		    "uniqueNumber",
		    "unit",
		    "unitType",
		    "units",
		    "unloadEventEnd",
		    "unloadEventStart",
		    "unlock",
		    "unmap",
		    "unmount",
		    "unobserve",
		    "unpause",
		    "unpauseAnimations",
		    "unreadCount",
		    "unregister",
		    "unregisterContentHandler",
		    "unregisterProtocolHandler",
		    "unscopables",
		    "unselectable",
		    "unshift",
		    "unsubscribe",
		    "unsuspendRedraw",
		    "unsuspendRedrawAll",
		    "unwatch",
		    "unwrapKey",
		    "upDegrees",
		    "upX",
		    "upY",
		    "upZ",
		    "update",
		    "updateCommands",
		    "updateIce",
		    "updateInterval",
		    "updatePlaybackRate",
		    "updateRenderState",
		    "updateSettings",
		    "updateTiming",
		    "updateViaCache",
		    "updateWith",
		    "updated",
		    "updating",
		    "upgrade",
		    "upload",
		    "uploadTotal",
		    "uploaded",
		    "upper",
		    "upperBound",
		    "upperOpen",
		    "uri",
		    "url",
		    "urn",
		    "urns",
		    "usage",
		    "usages",
		    "usb",
		    "usbVersionMajor",
		    "usbVersionMinor",
		    "usbVersionSubminor",
		    "useCurrentView",
		    "useMap",
		    "useProgram",
		    "usedSpace",
		    "user-select",
		    "userActivation",
		    "userAgent",
		    "userAgentData",
		    "userChoice",
		    "userHandle",
		    "userHint",
		    "userLanguage",
		    "userSelect",
		    "userVisibleOnly",
		    "username",
		    "usernameFragment",
		    "utterance",
		    "uuid",
		    "v8BreakIterator",
		    "vAlign",
		    "vLink",
		    "valid",
		    "validate",
		    "validateProgram",
		    "validationMessage",
		    "validity",
		    "value",
		    "valueAsDate",
		    "valueAsNumber",
		    "valueAsString",
		    "valueInSpecifiedUnits",
		    "valueMissing",
		    "valueOf",
		    "valueText",
		    "valueType",
		    "values",
		    "variable",
		    "variant",
		    "variationSettings",
		    "vector-effect",
		    "vectorEffect",
		    "velocityAngular",
		    "velocityExpansion",
		    "velocityX",
		    "velocityY",
		    "vendor",
		    "vendorId",
		    "vendorSub",
		    "verify",
		    "version",
		    "vertex",
		    "vertexAttrib1f",
		    "vertexAttrib1fv",
		    "vertexAttrib2f",
		    "vertexAttrib2fv",
		    "vertexAttrib3f",
		    "vertexAttrib3fv",
		    "vertexAttrib4f",
		    "vertexAttrib4fv",
		    "vertexAttribDivisor",
		    "vertexAttribDivisorANGLE",
		    "vertexAttribI4i",
		    "vertexAttribI4iv",
		    "vertexAttribI4ui",
		    "vertexAttribI4uiv",
		    "vertexAttribIPointer",
		    "vertexAttribPointer",
		    "vertical",
		    "vertical-align",
		    "verticalAlign",
		    "verticalOverflow",
		    "vh",
		    "vibrate",
		    "vibrationActuator",
		    "videoBitsPerSecond",
		    "videoHeight",
		    "videoTracks",
		    "videoWidth",
		    "view",
		    "viewBox",
		    "viewBoxString",
		    "viewDimension",
		    "viewFormats",
		    "viewTarget",
		    "viewTargetString",
		    "viewport",
		    "viewportAnchorX",
		    "viewportAnchorY",
		    "viewportElement",
		    "views",
		    "violatedDirective",
		    "visibility",
		    "visibilityState",
		    "visible",
		    "visualViewport",
		    "vlinkColor",
		    "vmax",
		    "vmin",
		    "voice",
		    "voiceURI",
		    "volume",
		    "vrml",
		    "vspace",
		    "vw",
		    "w",
		    "wait",
		    "waitSync",
		    "waiting",
		    "wake",
		    "wakeLock",
		    "wand",
		    "warn",
		    "wasClean",
		    "wasDiscarded",
		    "watch",
		    "watchAvailability",
		    "watchPosition",
		    "webdriver",
		    "webkitAddKey",
		    "webkitAlignContent",
		    "webkitAlignItems",
		    "webkitAlignSelf",
		    "webkitAnimation",
		    "webkitAnimationDelay",
		    "webkitAnimationDirection",
		    "webkitAnimationDuration",
		    "webkitAnimationFillMode",
		    "webkitAnimationIterationCount",
		    "webkitAnimationName",
		    "webkitAnimationPlayState",
		    "webkitAnimationTimingFunction",
		    "webkitAppearance",
		    "webkitAudioContext",
		    "webkitAudioDecodedByteCount",
		    "webkitAudioPannerNode",
		    "webkitBackfaceVisibility",
		    "webkitBackground",
		    "webkitBackgroundAttachment",
		    "webkitBackgroundClip",
		    "webkitBackgroundColor",
		    "webkitBackgroundImage",
		    "webkitBackgroundOrigin",
		    "webkitBackgroundPosition",
		    "webkitBackgroundPositionX",
		    "webkitBackgroundPositionY",
		    "webkitBackgroundRepeat",
		    "webkitBackgroundSize",
		    "webkitBackingStorePixelRatio",
		    "webkitBorderBottomLeftRadius",
		    "webkitBorderBottomRightRadius",
		    "webkitBorderImage",
		    "webkitBorderImageOutset",
		    "webkitBorderImageRepeat",
		    "webkitBorderImageSlice",
		    "webkitBorderImageSource",
		    "webkitBorderImageWidth",
		    "webkitBorderRadius",
		    "webkitBorderTopLeftRadius",
		    "webkitBorderTopRightRadius",
		    "webkitBoxAlign",
		    "webkitBoxDirection",
		    "webkitBoxFlex",
		    "webkitBoxOrdinalGroup",
		    "webkitBoxOrient",
		    "webkitBoxPack",
		    "webkitBoxShadow",
		    "webkitBoxSizing",
		    "webkitCancelAnimationFrame",
		    "webkitCancelFullScreen",
		    "webkitCancelKeyRequest",
		    "webkitCancelRequestAnimationFrame",
		    "webkitClearResourceTimings",
		    "webkitClosedCaptionsVisible",
		    "webkitConvertPointFromNodeToPage",
		    "webkitConvertPointFromPageToNode",
		    "webkitCreateShadowRoot",
		    "webkitCurrentFullScreenElement",
		    "webkitCurrentPlaybackTargetIsWireless",
		    "webkitDecodedFrameCount",
		    "webkitDirectionInvertedFromDevice",
		    "webkitDisplayingFullscreen",
		    "webkitDroppedFrameCount",
		    "webkitEnterFullScreen",
		    "webkitEnterFullscreen",
		    "webkitEntries",
		    "webkitExitFullScreen",
		    "webkitExitFullscreen",
		    "webkitExitPointerLock",
		    "webkitFilter",
		    "webkitFlex",
		    "webkitFlexBasis",
		    "webkitFlexDirection",
		    "webkitFlexFlow",
		    "webkitFlexGrow",
		    "webkitFlexShrink",
		    "webkitFlexWrap",
		    "webkitFullScreenKeyboardInputAllowed",
		    "webkitFullscreenElement",
		    "webkitFullscreenEnabled",
		    "webkitGenerateKeyRequest",
		    "webkitGetAsEntry",
		    "webkitGetDatabaseNames",
		    "webkitGetEntries",
		    "webkitGetEntriesByName",
		    "webkitGetEntriesByType",
		    "webkitGetFlowByName",
		    "webkitGetGamepads",
		    "webkitGetImageDataHD",
		    "webkitGetNamedFlows",
		    "webkitGetRegionFlowRanges",
		    "webkitGetUserMedia",
		    "webkitHasClosedCaptions",
		    "webkitHidden",
		    "webkitIDBCursor",
		    "webkitIDBDatabase",
		    "webkitIDBDatabaseError",
		    "webkitIDBDatabaseException",
		    "webkitIDBFactory",
		    "webkitIDBIndex",
		    "webkitIDBKeyRange",
		    "webkitIDBObjectStore",
		    "webkitIDBRequest",
		    "webkitIDBTransaction",
		    "webkitImageSmoothingEnabled",
		    "webkitIndexedDB",
		    "webkitInitMessageEvent",
		    "webkitIsFullScreen",
		    "webkitJustifyContent",
		    "webkitKeys",
		    "webkitLineClamp",
		    "webkitLineDashOffset",
		    "webkitLockOrientation",
		    "webkitMask",
		    "webkitMaskClip",
		    "webkitMaskComposite",
		    "webkitMaskImage",
		    "webkitMaskOrigin",
		    "webkitMaskPosition",
		    "webkitMaskPositionX",
		    "webkitMaskPositionY",
		    "webkitMaskRepeat",
		    "webkitMaskSize",
		    "webkitMatchesSelector",
		    "webkitMediaStream",
		    "webkitNotifications",
		    "webkitOfflineAudioContext",
		    "webkitOrder",
		    "webkitOrientation",
		    "webkitPeerConnection00",
		    "webkitPersistentStorage",
		    "webkitPerspective",
		    "webkitPerspectiveOrigin",
		    "webkitPointerLockElement",
		    "webkitPostMessage",
		    "webkitPreservesPitch",
		    "webkitPutImageDataHD",
		    "webkitRTCPeerConnection",
		    "webkitRegionOverset",
		    "webkitRelativePath",
		    "webkitRequestAnimationFrame",
		    "webkitRequestFileSystem",
		    "webkitRequestFullScreen",
		    "webkitRequestFullscreen",
		    "webkitRequestPointerLock",
		    "webkitResolveLocalFileSystemURL",
		    "webkitSetMediaKeys",
		    "webkitSetResourceTimingBufferSize",
		    "webkitShadowRoot",
		    "webkitShowPlaybackTargetPicker",
		    "webkitSlice",
		    "webkitSpeechGrammar",
		    "webkitSpeechGrammarList",
		    "webkitSpeechRecognition",
		    "webkitSpeechRecognitionError",
		    "webkitSpeechRecognitionEvent",
		    "webkitStorageInfo",
		    "webkitSupportsFullscreen",
		    "webkitTemporaryStorage",
		    "webkitTextFillColor",
		    "webkitTextSizeAdjust",
		    "webkitTextStroke",
		    "webkitTextStrokeColor",
		    "webkitTextStrokeWidth",
		    "webkitTransform",
		    "webkitTransformOrigin",
		    "webkitTransformStyle",
		    "webkitTransition",
		    "webkitTransitionDelay",
		    "webkitTransitionDuration",
		    "webkitTransitionProperty",
		    "webkitTransitionTimingFunction",
		    "webkitURL",
		    "webkitUnlockOrientation",
		    "webkitUserSelect",
		    "webkitVideoDecodedByteCount",
		    "webkitVisibilityState",
		    "webkitWirelessVideoPlaybackDisabled",
		    "webkitdirectory",
		    "webkitdropzone",
		    "webstore",
		    "weight",
		    "wgslLanguageFeatures",
		    "whatToShow",
		    "wheelDelta",
		    "wheelDeltaX",
		    "wheelDeltaY",
		    "whenDefined",
		    "which",
		    "white-space",
		    "whiteSpace",
		    "wholeText",
		    "widows",
		    "width",
		    "will-change",
		    "willChange",
		    "willValidate",
		    "window",
		    "withCredentials",
		    "word-break",
		    "word-spacing",
		    "word-wrap",
		    "wordBreak",
		    "wordSpacing",
		    "wordWrap",
		    "workerStart",
		    "wow64",
		    "wrap",
		    "wrapKey",
		    "writable",
		    "writableAuxiliaries",
		    "write",
		    "writeBuffer",
		    "writeMask",
		    "writeText",
		    "writeTexture",
		    "writeTimestamp",
		    "writeValue",
		    "writeWithoutResponse",
		    "writeln",
		    "writing-mode",
		    "writingMode",
		    "x",
		    "x1",
		    "x2",
		    "xChannelSelector",
		    "xmlEncoding",
		    "xmlStandalone",
		    "xmlVersion",
		    "xmlbase",
		    "xmllang",
		    "xmlspace",
		    "xor",
		    "xr",
		    "y",
		    "y1",
		    "y2",
		    "yChannelSelector",
		    "yandex",
		    "z",
		    "z-index",
		    "zIndex",
		    "zoom",
		    "zoomAndPan",
		    "zoomRectScreen",
		];

		/***********************************************************************

		  A JavaScript tokenizer / parser / beautifier / compressor.
		  https://github.com/mishoo/UglifyJS2

		  -------------------------------- (C) ---------------------------------

		                           Author: Mihai Bazon
		                         <mihai.bazon@gmail.com>
		                       http://mihai.bazon.net/blog

		  Distributed under the BSD license:

		    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

		    Redistribution and use in source and binary forms, with or without
		    modification, are permitted provided that the following conditions
		    are met:

		        * Redistributions of source code must retain the above
		          copyright notice, this list of conditions and the following
		          disclaimer.

		        * Redistributions in binary form must reproduce the above
		          copyright notice, this list of conditions and the following
		          disclaimer in the documentation and/or other materials
		          provided with the distribution.

		    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
		    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
		    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
		    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
		    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
		    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
		    SUCH DAMAGE.

		 ***********************************************************************/

		function find_builtins(reserved) {
		    domprops.forEach(add);

		    // Compatibility fix for some standard defined globals not defined on every js environment
		    var new_globals = ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"];
		    var objects = {};
		    var global_ref = typeof commonjsGlobal === "object" ? commonjsGlobal : self;

		    new_globals.forEach(function (new_global) {
		        objects[new_global] = global_ref[new_global] || function() {};
		    });

		    [
		        "null",
		        "true",
		        "false",
		        "NaN",
		        "Infinity",
		        "-Infinity",
		        "undefined",
		    ].forEach(add);
		    [ Object, Array, Function, Number,
		      String, Boolean, Error, Math,
		      Date, RegExp, objects.Symbol, ArrayBuffer,
		      DataView, decodeURI, decodeURIComponent,
		      encodeURI, encodeURIComponent, eval, EvalError,
		      Float32Array, Float64Array, Int8Array, Int16Array,
		      Int32Array, isFinite, isNaN, JSON, objects.Map, parseFloat,
		      parseInt, objects.Promise, objects.Proxy, RangeError, ReferenceError,
		      objects.Reflect, objects.Set, SyntaxError, TypeError, Uint8Array,
		      Uint8ClampedArray, Uint16Array, Uint32Array, URIError,
		      objects.WeakMap, objects.WeakSet
		    ].forEach(function(ctor) {
		        Object.getOwnPropertyNames(ctor).map(add);
		        if (ctor.prototype) {
		            Object.getOwnPropertyNames(ctor.prototype).map(add);
		        }
		    });
		    function add(name) {
		        reserved.add(name);
		    }
		}

		function reserve_quoted_keys(ast, reserved) {
		    function add(name) {
		        push_uniq(reserved, name);
		    }

		    ast.walk(new TreeWalker(function(node) {
		        if (node instanceof AST_ObjectKeyVal && node.quote) {
		            add(node.key);
		        } else if (node instanceof AST_ObjectProperty && node.quote) {
		            add(node.key.name);
		        } else if (node instanceof AST_Sub) {
		            addStrings(node.property, add);
		        }
		    }));
		}

		function addStrings(node, add) {
		    node.walk(new TreeWalker(function(node) {
		        if (node instanceof AST_Sequence) {
		            addStrings(node.tail_node(), add);
		        } else if (node instanceof AST_String) {
		            add(node.value);
		        } else if (node instanceof AST_Conditional) {
		            addStrings(node.consequent, add);
		            addStrings(node.alternative, add);
		        }
		        return true;
		    }));
		}

		function mangle_private_properties(ast, options) {
		    var cprivate = -1;
		    var private_cache = new Map();
		    var nth_identifier = options.nth_identifier || base54;

		    ast =  ast.transform(new TreeTransformer(function(node) {
		        if (
		            node instanceof AST_ClassPrivateProperty
		            || node instanceof AST_PrivateMethod
		            || node instanceof AST_PrivateGetter
		            || node instanceof AST_PrivateSetter
		            || node instanceof AST_PrivateIn
		        ) {
		            node.key.name = mangle_private(node.key.name);
		        } else if (node instanceof AST_DotHash) {
		            node.property = mangle_private(node.property);
		        }
		    }));
		    return ast;

		    function mangle_private(name) {
		        let mangled = private_cache.get(name);
		        if (!mangled) {
		            mangled = nth_identifier.get(++cprivate);
		            private_cache.set(name, mangled);
		        }

		        return mangled;
		    }
		}

		function find_annotated_props(ast) {
		    var annotated_props = new Set();
		    walk(ast, node => {
		        if (
		            node instanceof AST_ClassPrivateProperty
		            || node instanceof AST_PrivateMethod
		            || node instanceof AST_PrivateGetter
		            || node instanceof AST_PrivateSetter
		            || node instanceof AST_DotHash
		        ) ; else if (node instanceof AST_ObjectKeyVal) {
		            if (typeof node.key == "string" && has_annotation(node, _MANGLEPROP)) {
		                annotated_props.add(node.key);
		            }
		        } else if (node instanceof AST_ObjectProperty) {
		            // setter or getter, since KeyVal is handled above
		            if (has_annotation(node, _MANGLEPROP)) {
		                annotated_props.add(node.key.name);
		            }
		        } else if (node instanceof AST_Dot) {
		            if (has_annotation(node, _MANGLEPROP)) {
		                annotated_props.add(node.property);
		            }
		        } else if (node instanceof AST_Sub) {
		            if (node.property instanceof AST_String && has_annotation(node, _MANGLEPROP)) {
		                annotated_props.add(node.property.value);
		            }
		        }
		    });
		    return annotated_props;
		}

		function mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {
		    options = defaults(options, {
		        builtins: false,
		        cache: null,
		        debug: false,
		        keep_quoted: false,
		        nth_identifier: base54,
		        only_cache: false,
		        regex: null,
		        reserved: null,
		        undeclared: false,
		        only_annotated: false,
		    }, true);

		    var nth_identifier = options.nth_identifier;

		    var reserved_option = options.reserved;
		    if (!Array.isArray(reserved_option)) reserved_option = [reserved_option];
		    var reserved = new Set(reserved_option);
		    if (!options.builtins) find_builtins(reserved);

		    var cname = -1;

		    var cache;
		    if (options.cache) {
		        cache = options.cache.props;
		    } else {
		        cache = new Map();
		    }

		    var only_annotated = options.only_annotated;
		    var regex = options.regex && new RegExp(options.regex);

		    // note debug is either false (disabled), or a string of the debug suffix to use (enabled).
		    // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'
		    // the same as passing an empty string.
		    var debug = options.debug !== false;
		    var debug_name_suffix;
		    if (debug) {
		        debug_name_suffix = (options.debug === true ? "" : options.debug);
		    }

		    var names_to_mangle = new Set();
		    var unmangleable = new Set();
		    // Track each already-mangled name to prevent nth_identifier from generating
		    // the same name.
		    cache.forEach((mangled_name) => unmangleable.add(mangled_name));

		    var keep_quoted = !!options.keep_quoted;

		    // step 1: find candidates to mangle
		    ast.walk(new TreeWalker(function(node) {
		        if (
		            node instanceof AST_ClassPrivateProperty
		            || node instanceof AST_PrivateMethod
		            || node instanceof AST_PrivateGetter
		            || node instanceof AST_PrivateSetter
		            || node instanceof AST_DotHash
		        ) ; else if (node instanceof AST_ObjectKeyVal) {
		            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
		                add(node.key);
		            }
		        } else if (node instanceof AST_ObjectProperty) {
		            // setter or getter, since KeyVal is handled above
		            if (!keep_quoted || !node.quote) {
		                add(node.key.name);
		            }
		        } else if (node instanceof AST_Dot) {
		            var declared = !!options.undeclared;
		            if (!declared) {
		                var root = node;
		                while (root.expression) {
		                    root = root.expression;
		                }
		                declared = !(root.thedef && root.thedef.undeclared);
		            }
		            if (declared &&
		                (!keep_quoted || !node.quote)) {
		                add(node.property);
		            }
		        } else if (node instanceof AST_Sub) {
		            if (!keep_quoted) {
		                addStrings(node.property, add);
		            }
		        } else if (node instanceof AST_Call
		            && node.expression.print_to_string() == "Object.defineProperty") {
		            addStrings(node.args[1], add);
		        } else if (node instanceof AST_Binary && node.operator === "in") {
		            addStrings(node.left, add);
		        } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
		            add(node.value);
		        }
		    }));

		    // step 2: transform the tree, renaming properties
		    return ast.transform(new TreeTransformer(function(node) {
		        if (
		            node instanceof AST_ClassPrivateProperty
		            || node instanceof AST_PrivateMethod
		            || node instanceof AST_PrivateGetter
		            || node instanceof AST_PrivateSetter
		            || node instanceof AST_DotHash
		        ) ; else if (node instanceof AST_ObjectKeyVal) {
		            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
		                node.key = mangle(node.key);
		            }
		        } else if (node instanceof AST_ObjectProperty) {
		            // setter, getter, method or class field
		            if (!keep_quoted || !node.quote) {
		                node.key.name = mangle(node.key.name);
		            }
		        } else if (node instanceof AST_Dot) {
		            if (!keep_quoted || !node.quote) {
		                node.property = mangle(node.property);
		            }
		        } else if (!keep_quoted && node instanceof AST_Sub) {
		            node.property = mangleStrings(node.property);
		        } else if (node instanceof AST_Call
		            && node.expression.print_to_string() == "Object.defineProperty") {
		            node.args[1] = mangleStrings(node.args[1]);
		        } else if (node instanceof AST_Binary && node.operator === "in") {
		            node.left = mangleStrings(node.left);
		        } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
		            // Clear _KEY annotation to prevent double mangling
		            clear_annotation(node, _KEY);
		            node.value = mangle(node.value);
		        }
		    }));

		    // only function declarations after this line

		    function can_mangle(name) {
		        if (unmangleable.has(name)) return false;
		        if (reserved.has(name)) return false;
		        if (options.only_cache) {
		            return cache.has(name);
		        }
		        if (/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;
		        return true;
		    }

		    function should_mangle(name) {
		        if (only_annotated && !annotated_props.has(name)) return false;
		        if (regex && !regex.test(name)) {
		            return annotated_props.has(name);
		        }
		        if (reserved.has(name)) return false;
		        return cache.has(name)
		            || names_to_mangle.has(name);
		    }

		    function add(name) {
		        if (can_mangle(name)) {
		            names_to_mangle.add(name);
		        }

		        if (!should_mangle(name)) {
		            unmangleable.add(name);
		        }
		    }

		    function mangle(name) {
		        if (!should_mangle(name)) {
		            return name;
		        }

		        var mangled = cache.get(name);
		        if (!mangled) {
		            if (debug) {
		                // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_.
		                var debug_mangled = "_$" + name + "$" + debug_name_suffix + "_";

		                if (can_mangle(debug_mangled)) {
		                    mangled = debug_mangled;
		                }
		            }

		            // either debug mode is off, or it is on and we could not use the mangled name
		            if (!mangled) {
		                do {
		                    mangled = nth_identifier.get(++cname);
		                } while (!can_mangle(mangled));
		            }

		            cache.set(name, mangled);
		        }
		        return mangled;
		    }

		    function mangleStrings(node) {
		        return node.transform(new TreeTransformer(function(node) {
		            if (node instanceof AST_Sequence) {
		                var last = node.expressions.length - 1;
		                node.expressions[last] = mangleStrings(node.expressions[last]);
		            } else if (node instanceof AST_String) {
		                // Clear _KEY annotation to prevent double mangling
		                clear_annotation(node, _KEY);
		                node.value = mangle(node.value);
		            } else if (node instanceof AST_Conditional) {
		                node.consequent = mangleStrings(node.consequent);
		                node.alternative = mangleStrings(node.alternative);
		            }
		            return node;
		        }));
		    }
		}

		// to/from base64 functions
		// Prefer built-in Buffer, if available, then use hack
		// https://developer.mozilla.org/en-US/docs/Glossary/Base64#The_Unicode_Problem
		var to_ascii = typeof Buffer !== "undefined"
		    ? (b64) => Buffer.from(b64, "base64").toString()
		    : (b64) => decodeURIComponent(escape(atob(b64)));
		var to_base64 = typeof Buffer !== "undefined"
		    ? (str) => Buffer.from(str).toString("base64")
		    : (str) => btoa(unescape(encodeURIComponent(str)));

		function read_source_map(code) {
		    var match = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(code);
		    if (!match) {
		        console.warn("inline source map not found");
		        return null;
		    }
		    return to_ascii(match[2]);
		}

		function set_shorthand(name, options, keys) {
		    if (options[name]) {
		        keys.forEach(function(key) {
		            if (options[key]) {
		                if (typeof options[key] != "object") options[key] = {};
		                if (!(name in options[key])) options[key][name] = options[name];
		            }
		        });
		    }
		}

		function init_cache(cache) {
		    if (!cache) return;
		    if (!("props" in cache)) {
		        cache.props = new Map();
		    } else if (!(cache.props instanceof Map)) {
		        cache.props = map_from_object(cache.props);
		    }
		}

		function cache_to_json(cache) {
		    return {
		        props: map_to_object(cache.props)
		    };
		}

		function log_input(files, options, fs, debug_folder) {
		    if (!(fs && fs.writeFileSync && fs.mkdirSync)) {
		        return;
		    }

		    try {
		        fs.mkdirSync(debug_folder);
		    } catch (e) {
		        if (e.code !== "EEXIST") throw e;
		    }

		    const log_path = `${debug_folder}/terser-debug-${(Math.random() * 9999999) | 0}.log`;

		    options = options || {};

		    const options_str = JSON.stringify(options, (_key, thing) => {
		        if (typeof thing === "function") return "[Function " + thing.toString() + "]";
		        if (thing instanceof RegExp) return "[RegExp " + thing.toString() + "]";
		        return thing;
		    }, 4);

		    const files_str = (file) => {
		        if (typeof file === "object" && options.parse && options.parse.spidermonkey) {
		            return JSON.stringify(file, null, 2);
		        } else if (typeof file === "object") {
		            return Object.keys(file)
		                .map((key) => key + ": " + files_str(file[key]))
		                .join("\n\n");
		        } else if (typeof file === "string") {
		            return "```\n" + file + "\n```";
		        } else {
		            return file; // What do?
		        }
		    };

		    fs.writeFileSync(log_path, "Options: \n" + options_str + "\n\nInput files:\n\n" + files_str(files) + "\n");
		}

		async function minify(files, options, _fs_module) {
		    if (
		        _fs_module
		        && typeof process === "object"
		        && process.env
		        && typeof process.env.TERSER_DEBUG_DIR === "string"
		    ) {
		        log_input(files, options, _fs_module, process.env.TERSER_DEBUG_DIR);
		    }

		    options = defaults(options, {
		        compress: {},
		        ecma: undefined,
		        enclose: false,
		        ie8: false,
		        keep_classnames: undefined,
		        keep_fnames: false,
		        mangle: {},
		        module: false,
		        nameCache: null,
		        output: null,
		        format: null,
		        parse: {},
		        rename: undefined,
		        safari10: false,
		        sourceMap: false,
		        spidermonkey: false,
		        timings: false,
		        toplevel: false,
		        warnings: false,
		        wrap: false,
		    }, true);

		    var timings = options.timings && {
		        start: Date.now()
		    };
		    if (options.keep_classnames === undefined) {
		        options.keep_classnames = options.keep_fnames;
		    }
		    if (options.rename === undefined) {
		        options.rename = options.compress && options.mangle;
		    }
		    if (options.output && options.format) {
		        throw new Error("Please only specify either output or format option, preferrably format.");
		    }
		    options.format = options.format || options.output || {};
		    set_shorthand("ecma", options, [ "parse", "compress", "format" ]);
		    set_shorthand("ie8", options, [ "compress", "mangle", "format" ]);
		    set_shorthand("keep_classnames", options, [ "compress", "mangle" ]);
		    set_shorthand("keep_fnames", options, [ "compress", "mangle" ]);
		    set_shorthand("module", options, [ "parse", "compress", "mangle" ]);
		    set_shorthand("safari10", options, [ "mangle", "format" ]);
		    set_shorthand("toplevel", options, [ "compress", "mangle" ]);
		    set_shorthand("warnings", options, [ "compress" ]); // legacy
		    var quoted_props;
		    if (options.mangle) {
		        options.mangle = defaults(options.mangle, {
		            cache: options.nameCache && (options.nameCache.vars || {}),
		            eval: false,
		            ie8: false,
		            keep_classnames: false,
		            keep_fnames: false,
		            module: false,
		            nth_identifier: base54,
		            properties: false,
		            reserved: [],
		            safari10: false,
		            toplevel: false,
		        }, true);
		        if (options.mangle.properties) {
		            if (typeof options.mangle.properties != "object") {
		                options.mangle.properties = {};
		            }
		            if (options.mangle.properties.keep_quoted) {
		                quoted_props = options.mangle.properties.reserved;
		                if (!Array.isArray(quoted_props)) quoted_props = [];
		                options.mangle.properties.reserved = quoted_props;
		            }
		            if (options.nameCache && !("cache" in options.mangle.properties)) {
		                options.mangle.properties.cache = options.nameCache.props || {};
		            }
		        }
		        init_cache(options.mangle.cache);
		        init_cache(options.mangle.properties.cache);
		    }
		    if (options.sourceMap) {
		        options.sourceMap = defaults(options.sourceMap, {
		            asObject: false,
		            content: null,
		            filename: null,
		            includeSources: false,
		            root: null,
		            url: null,
		        }, true);
		    }

		    // -- Parse phase --
		    if (timings) timings.parse = Date.now();
		    var toplevel;
		    if (files instanceof AST_Toplevel) {
		        toplevel = files;
		    } else {
		        if (typeof files == "string" || (options.parse.spidermonkey && !Array.isArray(files))) {
		            files = [ files ];
		        }
		        options.parse = options.parse || {};
		        options.parse.toplevel = null;

		        if (options.parse.spidermonkey) {
		            options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel, name) {
		                if (!toplevel) return files[name];
		                toplevel.body = toplevel.body.concat(files[name].body);
		                return toplevel;
		            }, null));
		        } else {
		            delete options.parse.spidermonkey;

		            for (var name in files) if (HOP(files, name)) {
		                options.parse.filename = name;
		                options.parse.toplevel = parse(files[name], options.parse);
		                if (options.sourceMap && options.sourceMap.content == "inline") {
		                    if (Object.keys(files).length > 1)
		                        throw new Error("inline source map only works with singular input");
		                    options.sourceMap.content = read_source_map(files[name]);
		                }
		            }
		        }
		        if (options.parse.toplevel === null) {
		            throw new Error("no source file given");
		        }

		        toplevel = options.parse.toplevel;
		    }
		    if (quoted_props && options.mangle.properties.keep_quoted !== "strict") {
		        reserve_quoted_keys(toplevel, quoted_props);
		    }
		    var annotated_props;
		    if (options.mangle && options.mangle.properties) {
		        annotated_props = find_annotated_props(toplevel);
		    }
		    if (options.wrap) {
		        toplevel = toplevel.wrap_commonjs(options.wrap);
		    }
		    if (options.enclose) {
		        toplevel = toplevel.wrap_enclose(options.enclose);
		    }
		    if (timings) timings.rename = Date.now();

		    // -- Compress phase --
		    if (timings) timings.compress = Date.now();
		    if (options.compress) {
		        toplevel = new Compressor(options.compress, {
		            mangle_options: options.mangle
		        }).compress(toplevel);
		    }

		    // -- Mangle phase --
		    if (timings) timings.scope = Date.now();
		    if (options.mangle) toplevel.figure_out_scope(options.mangle);
		    if (timings) timings.mangle = Date.now();
		    if (options.mangle) {
		        toplevel.compute_char_frequency(options.mangle);
		        toplevel.mangle_names(options.mangle);
		        toplevel = mangle_private_properties(toplevel, options.mangle);
		    }
		    if (timings) timings.properties = Date.now();
		    if (options.mangle && options.mangle.properties) {
		        toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);
		    }

		    // Format phase
		    if (timings) timings.format = Date.now();
		    var result = {};
		    if (options.format.ast) {
		        result.ast = toplevel;
		    }
		    if (options.format.spidermonkey) {
		        result.ast = toplevel.to_mozilla_ast();
		    }
		    let format_options;
		    if (!HOP(options.format, "code") || options.format.code) {
		        // Make a shallow copy so that we can modify without mutating the user's input.
		        format_options = {...options.format};
		        if (!format_options.ast) {
		            // Destroy stuff to save RAM. (unless the deprecated `ast` option is on)
		            format_options._destroy_ast = true;

		            walk(toplevel, node => {
		                if (node instanceof AST_Scope) {
		                    node.variables = undefined;
		                    node.enclosed = undefined;
		                    node.parent_scope = undefined;
		                }
		                if (node.block_scope) {
		                    node.block_scope.variables = undefined;
		                    node.block_scope.enclosed = undefined;
		                    node.parent_scope = undefined;
		                }
		            });
		        }

		        if (options.sourceMap) {
		            if (options.sourceMap.includeSources && files instanceof AST_Toplevel) {
		                throw new Error("original source content unavailable");
		            }
		            format_options.source_map = await SourceMap({
		                file: options.sourceMap.filename,
		                orig: options.sourceMap.content,
		                root: options.sourceMap.root,
		                files: options.sourceMap.includeSources ? files : null,
		            });
		        }
		        delete format_options.ast;
		        delete format_options.code;
		        delete format_options.spidermonkey;
		        var stream = OutputStream(format_options);
		        toplevel.print(stream);
		        result.code = stream.get();
		        if (options.sourceMap) {
		            Object.defineProperty(result, "map", {
		                configurable: true,
		                enumerable: true,
		                get() {
		                    const map = format_options.source_map.getEncoded();
		                    return (result.map = options.sourceMap.asObject ? map : JSON.stringify(map));
		                },
		                set(value) {
		                    Object.defineProperty(result, "map", {
		                        value,
		                        writable: true,
		                    });
		                }
		            });
		            result.decoded_map = format_options.source_map.getDecoded();
		            if (options.sourceMap.url == "inline") {
		                var sourceMap = typeof result.map === "object" ? JSON.stringify(result.map) : result.map;
		                result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(sourceMap);
		            } else if (options.sourceMap.url) {
		                result.code += "\n//# sourceMappingURL=" + options.sourceMap.url;
		            }
		        }
		    }
		    if (options.nameCache && options.mangle) {
		        if (options.mangle.cache) options.nameCache.vars = cache_to_json(options.mangle.cache);
		        if (options.mangle.properties && options.mangle.properties.cache) {
		            options.nameCache.props = cache_to_json(options.mangle.properties.cache);
		        }
		    }
		    if (format_options && format_options.source_map) {
		        format_options.source_map.destroy();
		    }
		    if (timings) {
		        timings.end = Date.now();
		        result.timings = {
		            parse: 1e-3 * (timings.rename - timings.parse),
		            rename: 1e-3 * (timings.compress - timings.rename),
		            compress: 1e-3 * (timings.scope - timings.compress),
		            scope: 1e-3 * (timings.mangle - timings.scope),
		            mangle: 1e-3 * (timings.properties - timings.mangle),
		            properties: 1e-3 * (timings.format - timings.properties),
		            format: 1e-3 * (timings.end - timings.format),
		            total: 1e-3 * (timings.end - timings.start)
		        };
		    }
		    return result;
		}

		async function run_cli({ program, packageJson, fs, path }) {
		    const skip_keys = new Set([ "cname", "parent_scope", "scope", "uses_eval", "uses_with" ]);
		    var files = {};
		    var options = {
		        compress: false,
		        mangle: false
		    };
		    const default_options = await _default_options();
		    program.version(packageJson.name + " " + packageJson.version);
		    program.parseArgv = program.parse;
		    program.parse = undefined;

		    if (process.argv.includes("ast")) program.helpInformation = describe_ast;
		    else if (process.argv.includes("options")) program.helpInformation = function() {
		        var text = [];
		        for (var option in default_options) {
		            text.push("--" + (option === "sourceMap" ? "source-map" : option) + " options:");
		            text.push(format_object(default_options[option]));
		            text.push("");
		        }
		        return text.join("\n");
		    };

		    program.option("-p, --parse <options>", "Specify parser options.", parse_js());
		    program.option("-c, --compress [options]", "Enable compressor/specify compressor options.", parse_js());
		    program.option("-m, --mangle [options]", "Mangle names/specify mangler options.", parse_js());
		    program.option("--mangle-props [options]", "Mangle properties/specify mangler options.", parse_js());
		    program.option("-f, --format [options]", "Format options.", parse_js());
		    program.option("-b, --beautify [options]", "Alias for --format.", parse_js());
		    program.option("-o, --output <file>", "Output file (default STDOUT).");
		    program.option("--comments [filter]", "Preserve copyright comments in the output.");
		    program.option("--config-file <file>", "Read minify() options from JSON file.");
		    program.option("-d, --define <expr>[=value]", "Global definitions.", parse_js("define"));
		    program.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017...");
		    program.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values.");
		    program.option("--ie8", "Support non-standard Internet Explorer 8.");
		    program.option("--keep-classnames", "Do not mangle/drop class names.");
		    program.option("--keep-fnames", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name.");
		    program.option("--module", "Input is an ES6 module");
		    program.option("--name-cache <file>", "File to hold mangled name mappings.");
		    program.option("--rename", "Force symbol expansion.");
		    program.option("--no-rename", "Disable symbol expansion.");
		    program.option("--safari10", "Support non-standard Safari 10.");
		    program.option("--source-map [options]", "Enable source map/specify source map options.", parse_js());
		    program.option("--timings", "Display operations run time on STDERR.");
		    program.option("--toplevel", "Compress and/or mangle variables in toplevel scope.");
		    program.option("--wrap <name>", "Embed everything as a function with “exports” corresponding to “name” globally.");
		    program.arguments("[files...]").parseArgv(process.argv);
		    if (program.configFile) {
		        options = JSON.parse(read_file(program.configFile));
		    }
		    if (!program.output && program.sourceMap && program.sourceMap.url != "inline") {
		        fatal("ERROR: cannot write source map to STDOUT");
		    }

		    [
		        "compress",
		        "enclose",
		        "ie8",
		        "mangle",
		        "module",
		        "safari10",
		        "sourceMap",
		        "toplevel",
		        "wrap"
		    ].forEach(function(name) {
		        if (name in program) {
		            options[name] = program[name];
		        }
		    });

		    if ("ecma" in program) {
		        if (program.ecma != (program.ecma | 0)) fatal("ERROR: ecma must be an integer");
		        const ecma = program.ecma | 0;
		        if (ecma > 5 && ecma < 2015)
		            options.ecma = ecma + 2009;
		        else
		            options.ecma = ecma;
		    }
		    if (program.format || program.beautify) {
		        const chosenOption = program.format || program.beautify;
		        options.format = typeof chosenOption === "object" ? chosenOption : {};
		    }
		    if (program.comments) {
		        if (typeof options.format != "object") options.format = {};
		        options.format.comments = typeof program.comments == "string" ? (program.comments == "false" ? false : program.comments) : "some";
		    }
		    if (program.define) {
		        if (typeof options.compress != "object") options.compress = {};
		        if (typeof options.compress.global_defs != "object") options.compress.global_defs = {};
		        for (var expr in program.define) {
		            options.compress.global_defs[expr] = program.define[expr];
		        }
		    }
		    if (program.keepClassnames) {
		        options.keep_classnames = true;
		    }
		    if (program.keepFnames) {
		        options.keep_fnames = true;
		    }
		    if (program.mangleProps) {
		        if (program.mangleProps.domprops) {
		            delete program.mangleProps.domprops;
		        } else {
		            if (typeof program.mangleProps != "object") program.mangleProps = {};
		            if (!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];
		        }
		        if (typeof options.mangle != "object") options.mangle = {};
		        options.mangle.properties = program.mangleProps;
		    }
		    if (program.nameCache) {
		        options.nameCache = JSON.parse(read_file(program.nameCache, "{}"));
		    }
		    if (program.output == "ast") {
		        options.format = {
		            ast: true,
		            code: false
		        };
		    }
		    if (program.parse) {
		        if (!program.parse.acorn && !program.parse.spidermonkey) {
		            options.parse = program.parse;
		        } else if (program.sourceMap && program.sourceMap.content == "inline") {
		            fatal("ERROR: inline source map only works with built-in parser");
		        }
		    }
		    if (~program.rawArgs.indexOf("--rename")) {
		        options.rename = true;
		    } else if (!program.rename) {
		        options.rename = false;
		    }

		    let convert_path = name => name;
		    if (typeof program.sourceMap == "object" && "base" in program.sourceMap) {
		        convert_path = function() {
		            var base = program.sourceMap.base;
		            delete options.sourceMap.base;
		            return function(name) {
		                return path.relative(base, name);
		            };
		        }();
		    }

		    let filesList;
		    if (options.files && options.files.length) {
		        filesList = options.files;

		        delete options.files;
		    } else if (program.args.length) {
		        filesList = program.args;
		    }

		    if (filesList) {
		        simple_glob(filesList).forEach(function(name) {
		            files[convert_path(name)] = read_file(name);
		        });
		    } else {
		        await new Promise((resolve) => {
		            var chunks = [];
		            process.stdin.setEncoding("utf8");
		            process.stdin.on("data", function(chunk) {
		                chunks.push(chunk);
		            }).on("end", function() {
		                files = [ chunks.join("") ];
		                resolve();
		            });
		            process.stdin.resume();
		        });
		    }

		    await run_cli();

		    function convert_ast(fn) {
		        return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
		    }

		    async function run_cli() {
		        var content = program.sourceMap && program.sourceMap.content;
		        if (content && content !== "inline") {
		            options.sourceMap.content = read_file(content, content);
		        }
		        if (program.timings) options.timings = true;

		        try {
		            if (program.parse) {
		                if (program.parse.acorn) {
		                    files = convert_ast(function(toplevel, name) {
		                        return requireAcorn().parse(files[name], {
		                            ecmaVersion: 2018,
		                            locations: true,
		                            program: toplevel,
		                            sourceFile: name,
		                            sourceType: options.module || program.parse.module ? "module" : "script"
		                        });
		                    });
		                } else if (program.parse.spidermonkey) {
		                    files = convert_ast(function(toplevel, name) {
		                        var obj = JSON.parse(files[name]);
		                        if (!toplevel) return obj;
		                        toplevel.body = toplevel.body.concat(obj.body);
		                        return toplevel;
		                    });
		                }
		            }
		        } catch (ex) {
		            fatal(ex);
		        }

		        let result;
		        try {
		            result = await minify(files, options, fs);
		        } catch (ex) {
		            if (ex.name == "SyntaxError") {
		                print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
		                var col = ex.col;
		                var lines = files[ex.filename].split(/\r?\n/);
		                var line = lines[ex.line - 1];
		                if (!line && !col) {
		                    line = lines[ex.line - 2];
		                    col = line.length;
		                }
		                if (line) {
		                    var limit = 70;
		                    if (col > limit) {
		                        line = line.slice(col - limit);
		                        col = limit;
		                    }
		                    print_error(line.slice(0, 80));
		                    print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
		                }
		            }
		            if (ex.defs) {
		                print_error("Supported options:");
		                print_error(format_object(ex.defs));
		            }
		            fatal(ex);
		            return;
		        }

		        if (program.output == "ast") {
		            if (!options.compress && !options.mangle) {
		                result.ast.figure_out_scope({});
		            }
		            console.log(JSON.stringify(result.ast, function(key, value) {
		                if (value) switch (key) {
		                  case "thedef":
		                    return symdef(value);
		                  case "enclosed":
		                    return value.length ? value.map(symdef) : undefined;
		                  case "variables":
		                  case "globals":
		                    return value.size ? collect_from_map(value, symdef) : undefined;
		                }
		                if (skip_keys.has(key)) return;
		                if (value instanceof AST_Token) return;
		                if (value instanceof Map) return;
		                if (value instanceof AST_Node) {
		                    var result = {
		                        _class: "AST_" + value.TYPE
		                    };
		                    if (value.block_scope) {
		                        result.variables = value.block_scope.variables;
		                        result.enclosed = value.block_scope.enclosed;
		                    }
		                    value.CTOR.PROPS.forEach(function(prop) {
		                        if (prop !== "block_scope") {
		                            result[prop] = value[prop];
		                        }
		                    });
		                    return result;
		                }
		                return value;
		            }, 2));
		        } else if (program.output == "spidermonkey") {
		            try {
		                const minified = await minify(
		                    result.code,
		                    {
		                        compress: false,
		                        mangle: false,
		                        format: {
		                            ast: true,
		                            code: false
		                        }
		                    },
		                    fs
		                );
		                console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));
		            } catch (ex) {
		                fatal(ex);
		                return;
		            }
		        } else if (program.output) {
		            fs.writeFileSync(program.output, result.code);
		            if (options.sourceMap && options.sourceMap.url !== "inline" && result.map) {
		                fs.writeFileSync(program.output + ".map", result.map);
		            }
		        } else {
		            console.log(result.code);
		        }
		        if (program.nameCache) {
		            fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));
		        }
		        if (result.timings) for (var phase in result.timings) {
		            print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
		        }
		    }

		    function fatal(message) {
		        if (message instanceof Error) message = message.stack.replace(/^\S*?Error:/, "ERROR:");
		        print_error(message);
		        process.exit(1);
		    }

		    // A file glob function that only supports "*" and "?" wildcards in the basename.
		    // Example: "foo/bar/*baz??.*.js"
		    // Argument `glob` may be a string or an array of strings.
		    // Returns an array of strings. Garbage in, garbage out.
		    function simple_glob(glob) {
		        if (Array.isArray(glob)) {
		            return [].concat.apply([], glob.map(simple_glob));
		        }
		        if (glob && glob.match(/[*?]/)) {
		            var dir = path.dirname(glob);
		            try {
		                var entries = fs.readdirSync(dir);
		            } catch (ex) {}
		            if (entries) {
		                var pattern = "^" + path.basename(glob)
		                    .replace(/[.+^$[\]\\(){}]/g, "\\$&")
		                    .replace(/\*/g, "[^/\\\\]*")
		                    .replace(/\?/g, "[^/\\\\]") + "$";
		                var mod = process.platform === "win32" ? "i" : "";
		                var rx = new RegExp(pattern, mod);
		                var results = entries.filter(function(name) {
		                    return rx.test(name);
		                }).map(function(name) {
		                    return path.join(dir, name);
		                });
		                if (results.length) return results;
		            }
		        }
		        return [ glob ];
		    }

		    function read_file(path, default_value) {
		        try {
		            return fs.readFileSync(path, "utf8");
		        } catch (ex) {
		            if ((ex.code == "ENOENT" || ex.code == "ENAMETOOLONG") && default_value != null) return default_value;
		            fatal(ex);
		        }
		    }

		    function parse_js(flag) {
		        return function(value, options) {
		            options = options || {};
		            try {
		                walk(parse(value, { expression: true }), node => {
		                    if (node instanceof AST_Assign) {
		                        var name = node.left.print_to_string();
		                        var value = node.right;
		                        if (flag) {
		                            options[name] = value;
		                        } else if (value instanceof AST_Array) {
		                            options[name] = value.elements.map(to_string);
		                        } else if (value instanceof AST_RegExp) {
		                            value = value.value;
		                            options[name] = new RegExp(value.source, value.flags);
		                        } else {
		                            options[name] = to_string(value);
		                        }
		                        return true;
		                    }
		                    if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {
		                        var name = node.print_to_string();
		                        options[name] = true;
		                        return true;
		                    }
		                    if (!(node instanceof AST_Sequence)) throw node;

		                    function to_string(value) {
		                        return value instanceof AST_Constant ? value.getValue() : value.print_to_string({
		                            quote_keys: true
		                        });
		                    }
		                });
		            } catch(ex) {
		                if (flag) {
		                    fatal("Error parsing arguments for '" + flag + "': " + value);
		                } else {
		                    options[value] = null;
		                }
		            }
		            return options;
		        };
		    }

		    function symdef(def) {
		        var ret = (1e6 + def.id) + " " + def.name;
		        if (def.mangled_name) ret += " " + def.mangled_name;
		        return ret;
		    }

		    function collect_from_map(map, callback) {
		        var result = [];
		        map.forEach(function (def) {
		            result.push(callback(def));
		        });
		        return result;
		    }

		    function format_object(obj) {
		        var lines = [];
		        var padding = "";
		        Object.keys(obj).map(function(name) {
		            if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
		            return [ name, JSON.stringify(obj[name]) ];
		        }).forEach(function(tokens) {
		            lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
		        });
		        return lines.join("\n");
		    }

		    function print_error(msg) {
		        process.stderr.write(msg);
		        process.stderr.write("\n");
		    }

		    function describe_ast() {
		        var out = OutputStream({ beautify: true });
		        function doitem(ctor) {
		            out.print("AST_" + ctor.TYPE);
		            const props = ctor.SELF_PROPS.filter(prop => !/^\$/.test(prop));

		            if (props.length > 0) {
		                out.space();
		                out.with_parens(function() {
		                    props.forEach(function(prop, i) {
		                        if (i) out.space();
		                        out.print(prop);
		                    });
		                });
		            }

		            if (ctor.documentation) {
		                out.space();
		                out.print_string(ctor.documentation);
		            }

		            if (ctor.SUBCLASSES.length > 0) {
		                out.space();
		                out.with_block(function() {
		                    ctor.SUBCLASSES.forEach(function(ctor) {
		                        out.indent();
		                        doitem(ctor);
		                        out.newline();
		                    });
		                });
		            }
		        }
		        doitem(AST_Node);
		        return out + "\n";
		    }
		}

		async function _default_options() {
		    const defs = {};

		    Object.keys(infer_options({ 0: 0 })).forEach((component) => {
		        const options = infer_options({
		            [component]: {0: 0}
		        });

		        if (options) defs[component] = options;
		    });
		    return defs;
		}

		async function infer_options(options) {
		    try {
		        await minify("", options);
		    } catch (error) {
		        return error.defs;
		    }
		}

		exports._default_options = _default_options;
		exports._run_cli = run_cli;
		exports.minify = minify;

		}))); 
	} (bundle_min, bundle_min.exports));
	return bundle_min.exports;
}

var hasRequiredHtmlminifier;

function requireHtmlminifier () {
	if (hasRequiredHtmlminifier) return htmlminifier;
	hasRequiredHtmlminifier = 1;

	var CleanCSS = requireCleanCss();
	var decode = requireHe().decode;
	var HTMLParser = requireHtmlparser().HTMLParser;
	var endTag = requireHtmlparser().endTag;
	var RelateUrl = requireLib();
	var TokenChain = requireTokenchain();
	var Terser = requireBundle_min();
	var utils = requireUtils();

	function trimWhitespace(str) {
	  return str && str.replace(/^[ \n\r\t\f]+/, '').replace(/[ \n\r\t\f]+$/, '');
	}

	function collapseWhitespaceAll(str) {
	  // Non-breaking space is specifically handled inside the replacer function here:
	  return str && str.replace(/[ \n\r\t\f\xA0]+/g, function(spaces) {
	    return spaces === '\t' ? '\t' : spaces.replace(/(^|\xA0+)[^\xA0]+/g, '$1 ');
	  });
	}

	function collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {
	  var lineBreakBefore = '', lineBreakAfter = '';

	  if (options.preserveLineBreaks) {
	    str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function() {
	      lineBreakBefore = '\n';
	      return '';
	    }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function() {
	      lineBreakAfter = '\n';
	      return '';
	    });
	  }

	  if (trimLeft) {
	    // Non-breaking space is specifically handled inside the replacer function here:
	    str = str.replace(/^[ \n\r\t\f\xA0]+/, function(spaces) {
	      var conservative = !lineBreakBefore && options.conservativeCollapse;
	      if (conservative && spaces === '\t') {
	        return '\t';
	      }
	      return spaces.replace(/^[^\xA0]+/, '').replace(/(\xA0+)[^\xA0]+/g, '$1 ') || (conservative ? ' ' : '');
	    });
	  }

	  if (trimRight) {
	    // Non-breaking space is specifically handled inside the replacer function here:
	    str = str.replace(/[ \n\r\t\f\xA0]+$/, function(spaces) {
	      var conservative = !lineBreakAfter && options.conservativeCollapse;
	      if (conservative && spaces === '\t') {
	        return '\t';
	      }
	      return spaces.replace(/[^\xA0]+(\xA0+)/g, ' $1').replace(/[^\xA0]+$/, '') || (conservative ? ' ' : '');
	    });
	  }

	  if (collapseAll) {
	    // strip non space whitespace then compress spaces to one
	    str = collapseWhitespaceAll(str);
	  }

	  return lineBreakBefore + str + lineBreakAfter;
	}

	var createMapFromString = utils.createMapFromString;
	// non-empty tags that will maintain whitespace around them
	var inlineTags = createMapFromString('a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var');
	// non-empty tags that will maintain whitespace within them
	var inlineTextTags = createMapFromString('a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var');
	// self-closing tags that will maintain whitespace around them
	var selfClosingInlineTags = createMapFromString('comment,img,input,wbr');

	function collapseWhitespaceSmart(str, prevTag, nextTag, options) {
	  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);
	  if (trimLeft && !options.collapseInlineTagWhitespace) {
	    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);
	  }
	  var trimRight = nextTag && !selfClosingInlineTags(nextTag);
	  if (trimRight && !options.collapseInlineTagWhitespace) {
	    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);
	  }
	  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
	}

	function isConditionalComment(text) {
	  return /^\[if\s[^\]]+]|\[endif]$/.test(text);
	}

	function isIgnoredComment(text, options) {
	  for (var i = 0, len = options.ignoreCustomComments.length; i < len; i++) {
	    if (options.ignoreCustomComments[i].test(text)) {
	      return true;
	    }
	  }
	  return false;
	}

	function isEventAttribute(attrName, options) {
	  var patterns = options.customEventAttributes;
	  if (patterns) {
	    for (var i = patterns.length; i--;) {
	      if (patterns[i].test(attrName)) {
	        return true;
	      }
	    }
	    return false;
	  }
	  return /^on[a-z]{3,}$/.test(attrName);
	}

	function canRemoveAttributeQuotes(value) {
	  // https://mathiasbynens.be/notes/unquoted-attribute-values
	  return /^[^ \t\n\f\r"'`=<>]+$/.test(value);
	}

	function attributesInclude(attributes, attribute) {
	  for (var i = attributes.length; i--;) {
	    if (attributes[i].name.toLowerCase() === attribute) {
	      return true;
	    }
	  }
	  return false;
	}

	function isAttributeRedundant(tag, attrName, attrValue, attrs) {
	  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';

	  return (
	    tag === 'script' &&
	    attrName === 'language' &&
	    attrValue === 'javascript' ||

	    tag === 'form' &&
	    attrName === 'method' &&
	    attrValue === 'get' ||

	    tag === 'input' &&
	    attrName === 'type' &&
	    attrValue === 'text' ||

	    tag === 'script' &&
	    attrName === 'charset' &&
	    !attributesInclude(attrs, 'src') ||

	    tag === 'a' &&
	    attrName === 'name' &&
	    attributesInclude(attrs, 'id') ||

	    tag === 'area' &&
	    attrName === 'shape' &&
	    attrValue === 'rect'
	  );
	}

	// https://mathiasbynens.be/demo/javascript-mime-type
	// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type
	var executableScriptsMimetypes = utils.createMap([
	  'text/javascript',
	  'text/ecmascript',
	  'text/jscript',
	  'application/javascript',
	  'application/x-javascript',
	  'application/ecmascript',
	  'module'
	]);

	var keepScriptsMimetypes = utils.createMap([
	  'module'
	]);

	function isScriptTypeAttribute(attrValue) {
	  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
	  return attrValue === '' || executableScriptsMimetypes(attrValue);
	}

	function keepScriptTypeAttribute(attrValue) {
	  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
	  return keepScriptsMimetypes(attrValue);
	}

	function isExecutableScript(tag, attrs) {
	  if (tag !== 'script') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    var attrName = attrs[i].name.toLowerCase();
	    if (attrName === 'type') {
	      return isScriptTypeAttribute(attrs[i].value);
	    }
	  }
	  return true;
	}

	function isStyleLinkTypeAttribute(attrValue) {
	  attrValue = trimWhitespace(attrValue).toLowerCase();
	  return attrValue === '' || attrValue === 'text/css';
	}

	function isStyleSheet(tag, attrs) {
	  if (tag !== 'style') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    var attrName = attrs[i].name.toLowerCase();
	    if (attrName === 'type') {
	      return isStyleLinkTypeAttribute(attrs[i].value);
	    }
	  }
	  return true;
	}

	var isSimpleBoolean = createMapFromString('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible');
	var isBooleanValue = createMapFromString('true,false');

	function isBooleanAttribute(attrName, attrValue) {
	  return isSimpleBoolean(attrName) || attrName === 'draggable' && !isBooleanValue(attrValue);
	}

	function isUriTypeAttribute(attrName, tag) {
	  return (
	    /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' ||
	    tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) ||
	    tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) ||
	    tag === 'q' && attrName === 'cite' ||
	    tag === 'blockquote' && attrName === 'cite' ||
	    (tag === 'ins' || tag === 'del') && attrName === 'cite' ||
	    tag === 'form' && attrName === 'action' ||
	    tag === 'input' && (attrName === 'src' || attrName === 'usemap') ||
	    tag === 'head' && attrName === 'profile' ||
	    tag === 'script' && (attrName === 'src' || attrName === 'for')
	  );
	}

	function isNumberTypeAttribute(attrName, tag) {
	  return (
	    /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' ||
	    tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') ||
	    tag === 'select' && (attrName === 'size' || attrName === 'tabindex') ||
	    tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) ||
	    tag === 'colgroup' && attrName === 'span' ||
	    tag === 'col' && attrName === 'span' ||
	    (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan')
	  );
	}

	function isLinkType(tag, attrs, value) {
	  if (tag !== 'link') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name === 'rel' && attrs[i].value === value) {
	      return true;
	    }
	  }
	}

	function isMediaQuery(tag, attrs, attrName) {
	  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));
	}

	var srcsetTags = createMapFromString('img,source');

	function isSrcset(attrName, tag) {
	  return attrName === 'srcset' && srcsetTags(tag);
	}

	async function cleanAttributeValue(tag, attrName, attrValue, options, attrs) {
	  if (isEventAttribute(attrName, options)) {
	    attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, '');
	    return await options.minifyJS(attrValue, true);
	  }
	  else if (attrName === 'class') {
	    attrValue = trimWhitespace(attrValue);
	    if (options.sortClassName) {
	      attrValue = options.sortClassName(attrValue);
	    }
	    else {
	      attrValue = collapseWhitespaceAll(attrValue);
	    }
	    return attrValue;
	  }
	  else if (isUriTypeAttribute(attrName, tag)) {
	    attrValue = trimWhitespace(attrValue);
	    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);
	  }
	  else if (isNumberTypeAttribute(attrName, tag)) {
	    return trimWhitespace(attrValue);
	  }
	  else if (attrName === 'style') {
	    attrValue = trimWhitespace(attrValue);
	    if (attrValue) {
	      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
	        attrValue = attrValue.replace(/\s*;$/, ';');
	      }
	      attrValue = options.minifyCSS(attrValue, 'inline');
	    }
	    return attrValue;
	  }
	  else if (isSrcset(attrName, tag)) {
	    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset
	    attrValue = trimWhitespace(attrValue).split(/\s+,\s*|\s*,\s+/).map(function(candidate) {
	      var url = candidate;
	      var descriptor = '';
	      var match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
	      if (match) {
	        url = url.slice(0, -match[0].length);
	        var num = +match[1].slice(0, -1);
	        var suffix = match[1].slice(-1);
	        if (num !== 1 || suffix !== 'x') {
	          descriptor = ' ' + num + suffix;
	        }
	      }
	      return options.minifyURLs(url) + descriptor;
	    }).join(', ');
	  }
	  else if (isMetaViewport(tag, attrs) && attrName === 'content') {
	    attrValue = attrValue.replace(/\s+/g, '').replace(/[0-9]+\.[0-9]+/g, function(numString) {
	      // "0.90000" -> "0.9"
	      // "1.0" -> "1"
	      // "1.0001" -> "1.0001" (unchanged)
	      return (+numString).toString();
	    });
	  }
	  else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {
	    return collapseWhitespaceAll(attrValue);
	  }
	  else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
	    attrValue = trimWhitespace(attrValue.replace(/ ?[\n\r]+ ?/g, '').replace(/\s{2,}/g, options.conservativeCollapse ? ' ' : ''));
	  }
	  else if (tag === 'script' && attrName === 'type') {
	    attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ';'));
	  }
	  else if (isMediaQuery(tag, attrs, attrName)) {
	    attrValue = trimWhitespace(attrValue);
	    return options.minifyCSS(attrValue, 'media');
	  }
	  return attrValue;
	}

	function isMetaViewport(tag, attrs) {
	  if (tag !== 'meta') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {
	      return true;
	    }
	  }
	}

	function isContentSecurityPolicy(tag, attrs) {
	  if (tag !== 'meta') {
	    return false;
	  }
	  for (var i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {
	      return true;
	    }
	  }
	}

	function ignoreCSS(id) {
	  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';
	}

	// Wrap CSS declarations for CleanCSS > 3.x
	// See https://github.com/jakubpawlowicz/clean-css/issues/418
	function wrapCSS(text, type) {
	  switch (type) {
	    case 'inline':
	      return '*{' + text + '}';
	    case 'media':
	      return '@media ' + text + '{a{top:0}}';
	    default:
	      return text;
	  }
	}

	function unwrapCSS(text, type) {
	  var matches;
	  switch (type) {
	    case 'inline':
	      matches = text.match(/^\*\{([\s\S]*)\}$/);
	      break;
	    case 'media':
	      matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
	      break;
	  }
	  return matches ? matches[1] : text;
	}

	async function cleanConditionalComment(comment, options) {
	  return options.processConditionalComments ? await utils.replaceAsync(comment, /^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, async function(match, prefix, text, suffix) {
	    return prefix + await minify(text, options, true) + suffix;
	  }) : comment;
	}

	async function processScript(text, options, currentAttrs) {
	  for (var i = 0, len = currentAttrs.length; i < len; i++) {
	    if (currentAttrs[i].name.toLowerCase() === 'type' &&
	        options.processScripts.indexOf(currentAttrs[i].value) > -1) {
	      return await minify(text, options);
	    }
	  }
	  return text;
	}

	// Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags
	// with the following deviations:
	// - retain <body> if followed by <noscript>
	// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags
	// - retain all tags which are adjacent to non-standard HTML tags
	var optionalStartTags = createMapFromString('html,head,body,colgroup,tbody');
	var optionalEndTags = createMapFromString('html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th');
	var headerTags = createMapFromString('meta,link,script,style,template,noscript');
	var descriptionTags = createMapFromString('dt,dd');
	var pBlockTags = createMapFromString('address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul');
	var pInlineTags = createMapFromString('a,audio,del,ins,map,noscript,video');
	var rubyTags = createMapFromString('rb,rt,rtc,rp');
	var rtcTag = createMapFromString('rb,rtc,rp');
	var optionTag = createMapFromString('option,optgroup');
	var tableContentTags = createMapFromString('tbody,tfoot');
	var tableSectionTags = createMapFromString('thead,tbody,tfoot');
	var cellTags = createMapFromString('td,th');
	var topLevelTags = createMapFromString('html,head,body');
	var compactTags = createMapFromString('html,body');
	var looseTags = createMapFromString('head,colgroup,caption');
	var trailingTags = createMapFromString('dt,thead');
	var htmlTags = createMapFromString('a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp');

	function canRemoveParentTag(optionalStartTag, tag) {
	  switch (optionalStartTag) {
	    case 'html':
	    case 'head':
	      return true;
	    case 'body':
	      return !headerTags(tag);
	    case 'colgroup':
	      return tag === 'col';
	    case 'tbody':
	      return tag === 'tr';
	  }
	  return false;
	}

	function isStartTagMandatory(optionalEndTag, tag) {
	  switch (tag) {
	    case 'colgroup':
	      return optionalEndTag === 'colgroup';
	    case 'tbody':
	      return tableSectionTags(optionalEndTag);
	  }
	  return false;
	}

	function canRemovePrecedingTag(optionalEndTag, tag) {
	  switch (optionalEndTag) {
	    case 'html':
	    case 'head':
	    case 'body':
	    case 'colgroup':
	    case 'caption':
	      return true;
	    case 'li':
	    case 'optgroup':
	    case 'tr':
	      return tag === optionalEndTag;
	    case 'dt':
	    case 'dd':
	      return descriptionTags(tag);
	    case 'p':
	      return pBlockTags(tag);
	    case 'rb':
	    case 'rt':
	    case 'rp':
	      return rubyTags(tag);
	    case 'rtc':
	      return rtcTag(tag);
	    case 'option':
	      return optionTag(tag);
	    case 'thead':
	    case 'tbody':
	      return tableContentTags(tag);
	    case 'tfoot':
	      return tag === 'tbody';
	    case 'td':
	    case 'th':
	      return cellTags(tag);
	  }
	  return false;
	}

	var reEmptyAttribute = new RegExp(
	  '^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' +
	    '?:down|up|over|move|out)|key(?:press|down|up)))$');

	function canDeleteEmptyAttribute(tag, attrName, attrValue, options) {
	  var isValueEmpty = !attrValue || /^\s*$/.test(attrValue);
	  if (!isValueEmpty) {
	    return false;
	  }
	  if (typeof options.removeEmptyAttributes === 'function') {
	    return options.removeEmptyAttributes(attrName, tag);
	  }
	  return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);
	}

	function hasAttrName(name, attrs) {
	  for (var i = attrs.length - 1; i >= 0; i--) {
	    if (attrs[i].name === name) {
	      return true;
	    }
	  }
	  return false;
	}

	function canRemoveElement(tag, attrs) {
	  switch (tag) {
	    case 'textarea':
	      return false;
	    case 'audio':
	    case 'script':
	    case 'video':
	      if (hasAttrName('src', attrs)) {
	        return false;
	      }
	      break;
	    case 'iframe':
	      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {
	        return false;
	      }
	      break;
	    case 'object':
	      if (hasAttrName('data', attrs)) {
	        return false;
	      }
	      break;
	    case 'applet':
	      if (hasAttrName('code', attrs)) {
	        return false;
	      }
	      break;
	  }
	  return true;
	}

	function canCollapseWhitespace(tag) {
	  return !/^(?:script|style|pre|textarea)$/.test(tag);
	}

	function canTrimWhitespace(tag) {
	  return !/^(?:pre|textarea)$/.test(tag);
	}

	async function normalizeAttr(attr, attrs, tag, options) {
	  var attrName = options.name(attr.name),
	      attrValue = attr.value;

	  if (options.decodeEntities && attrValue) {
	    attrValue = decode(attrValue, { isAttributeValue: true });
	  }

	  if (options.removeRedundantAttributes &&
	    isAttributeRedundant(tag, attrName, attrValue, attrs) ||
	    options.removeScriptTypeAttributes && tag === 'script' &&
	    attrName === 'type' && isScriptTypeAttribute(attrValue) && !keepScriptTypeAttribute(attrValue) ||
	    options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') &&
	    attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {
	    return;
	  }

	  if (attrValue) {
	    attrValue = await cleanAttributeValue(tag, attrName, attrValue, options, attrs);
	  }

	  if (options.removeEmptyAttributes &&
	      canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
	    return;
	  }

	  if (options.decodeEntities && attrValue) {
	    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');
	  }

	  return {
	    attr: attr,
	    name: attrName,
	    value: attrValue
	  };
	}

	function buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {
	  var attrName = normalized.name,
	      attrValue = normalized.value,
	      attr = normalized.attr,
	      attrQuote = attr.quote,
	      attrFragment,
	      emittedAttrValue;

	  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes ||
	      ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {
	    if (!options.preventAttributesEscaping) {
	      if (typeof options.quoteCharacter === 'undefined') {
	        var apos = (attrValue.match(/'/g) || []).length;
	        var quot = (attrValue.match(/"/g) || []).length;
	        attrQuote = apos < quot ? '\'' : '"';
	      }
	      else {
	        attrQuote = options.quoteCharacter === '\'' ? '\'' : '"';
	      }
	      if (attrQuote === '"') {
	        attrValue = attrValue.replace(/"/g, '&#34;');
	      }
	      else {
	        attrValue = attrValue.replace(/'/g, '&#39;');
	      }
	    }
	    emittedAttrValue = attrQuote + attrValue + attrQuote;
	    if (!isLast && !options.removeTagWhitespace) {
	      emittedAttrValue += ' ';
	    }
	  }
	  // make sure trailing slash is not interpreted as HTML self-closing tag
	  else if (isLast && !hasUnarySlash && !/\/$/.test(attrValue)) {
	    emittedAttrValue = attrValue;
	  }
	  else {
	    emittedAttrValue = attrValue + ' ';
	  }

	  if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes &&
	      isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {
	    attrFragment = attrName;
	    if (!isLast) {
	      attrFragment += ' ';
	    }
	  }
	  else {
	    attrFragment = attrName + attr.customAssign + emittedAttrValue;
	  }

	  return attr.customOpen + attrFragment + attr.customClose;
	}

	function identity(value) {
	  return value;
	}

	function processOptions(values) {
	  var options = {
	    name: function(name) {
	      return name.toLowerCase();
	    },
	    canCollapseWhitespace: canCollapseWhitespace,
	    canTrimWhitespace: canTrimWhitespace,
	    html5: true,
	    ignoreCustomComments: [
	      /^!/,
	      /^\s*#/
	    ],
	    ignoreCustomFragments: [
	      /<%[\s\S]*?%>/,
	      /<\?[\s\S]*?\?>/
	    ],
	    includeAutoGeneratedTags: true,
	    log: identity,
	    minifyCSS: identity,
	    minifyJS: identity,
	    minifyURLs: identity
	  };
	  Object.keys(values).forEach(function(key) {
	    var value = values[key];
	    if (key === 'caseSensitive') {
	      if (value) {
	        options.name = identity;
	      }
	    }
	    else if (key === 'log') {
	      if (typeof value === 'function') {
	        options.log = value;
	      }
	    }
	    else if (key === 'minifyCSS' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value !== 'object') {
	        value = {};
	      }
	      options.minifyCSS = function(text, type) {
	        text = text.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function(match, prefix, quote, url, suffix) {
	          return prefix + quote + options.minifyURLs(url) + quote + suffix;
	        });
	        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));
	        if (cleanCssOutput.errors.length > 0) {
	          cleanCssOutput.errors.forEach(options.log);
	          return text;
	        }
	        return unwrapCSS(cleanCssOutput.styles, type);
	      };
	    }
	    else if (key === 'minifyJS' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value !== 'object') {
	        value = {};
	      }
	      (value.parse || (value.parse = {})).bare_returns = false;
	      options.minifyJS = async function(text, inline) {
	        var start = text.match(/^\s*<!--.*/);
	        var code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;
	        value.parse.bare_returns = inline;
	        try {
	          const result = await Terser.minify(code, value);
	          return result.code.replace(/;$/, '');
	        }
	        catch (error) {
	          options.log(error);
	          return text;
	        }
	      };
	    }
	    else if (key === 'minifyURLs' && typeof value !== 'function') {
	      if (!value) {
	        return;
	      }
	      if (typeof value === 'string') {
	        value = { site: value };
	      }
	      else if (typeof value !== 'object') {
	        value = {};
	      }
	      options.minifyURLs = function(text) {
	        try {
	          return RelateUrl.relate(text, value);
	        }
	        catch (err) {
	          options.log(err);
	          return text;
	        }
	      };
	    }
	    else {
	      options[key] = value;
	    }
	  });
	  return options;
	}

	function uniqueId(value) {
	  var id;
	  do {
	    id = Math.random().toString(36).replace(/^0\.[0-9]*/, '');
	  } while (~value.indexOf(id));
	  return id;
	}

	var specialContentTags = createMapFromString('script,style');

	async function createSortFns(value, options, uidIgnore, uidAttr) {
	  var attrChains = options.sortAttributes && Object.create(null);
	  var classChain = options.sortClassName && new TokenChain();

	  function attrNames(attrs) {
	    return attrs.map(function(attr) {
	      return options.name(attr.name);
	    });
	  }

	  function shouldSkipUID(token, uid) {
	    return !uid || token.indexOf(uid) === -1;
	  }

	  function shouldSkipUIDs(token) {
	    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
	  }

	  async function scan(input) {
	    var currentTag, currentType;
	    const parser = new HTMLParser(input, {
	      start: function(tag, attrs) {
	        if (attrChains) {
	          if (!attrChains[tag]) {
	            attrChains[tag] = new TokenChain();
	          }
	          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));
	        }
	        for (var i = 0, len = attrs.length; i < len; i++) {
	          var attr = attrs[i];
	          if (classChain && attr.value && options.name(attr.name) === 'class') {
	            classChain.add(trimWhitespace(attr.value).split(/[ \t\n\f\r]+/).filter(shouldSkipUIDs));
	          }
	          else if (options.processScripts && attr.name.toLowerCase() === 'type') {
	            currentTag = tag;
	            currentType = attr.value;
	          }
	        }
	      },
	      end: function() {
	        currentTag = '';
	      },
	      chars: async function(text) {
	        if (options.processScripts && specialContentTags(currentTag) &&
	            options.processScripts.indexOf(currentType) > -1) {
	          await scan(text);
	        }
	      }
	    });

	    await parser.parse();
	  }

	  var log = options.log;
	  options.log = identity;
	  options.sortAttributes = false;
	  options.sortClassName = false;
	  await scan(await minify(value, options));
	  options.log = log;
	  if (attrChains) {
	    var attrSorters = Object.create(null);
	    for (var tag in attrChains) {
	      attrSorters[tag] = attrChains[tag].createSorter();
	    }
	    options.sortAttributes = function(tag, attrs) {
	      var sorter = attrSorters[tag];
	      if (sorter) {
	        var attrMap = Object.create(null);
	        var names = attrNames(attrs);
	        names.forEach(function(name, index) {
	          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
	        });
	        sorter.sort(names).forEach(function(name, index) {
	          attrs[index] = attrMap[name].shift();
	        });
	      }
	    };
	  }
	  if (classChain) {
	    var sorter = classChain.createSorter();
	    options.sortClassName = function(value) {
	      return sorter.sort(value.split(/[ \n\f\r]+/)).join(' ');
	    };
	  }
	}

	async function minify(value, options, partialMarkup) {
	  if (options.collapseWhitespace) {
	    value = collapseWhitespace(value, options, true, true);
	  }

	  var buffer = [],
	      charsPrevTag,
	      currentChars = '',
	      hasChars,
	      currentTag = '',
	      currentAttrs = [],
	      stackNoTrimWhitespace = [],
	      stackNoCollapseWhitespace = [],
	      optionalStartTag = '',
	      optionalEndTag = '',
	      ignoredMarkupChunks = [],
	      ignoredCustomMarkupChunks = [],
	      uidIgnore,
	      uidAttr,
	      uidPattern;

	  // temporarily replace ignored chunks with comments,
	  // so that we don't have to worry what's there.
	  // for all we care there might be
	  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content
	  value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function(match, group1) {
	    if (!uidIgnore) {
	      uidIgnore = uniqueId(value);
	      var pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');
	      if (options.ignoreCustomComments) {
	        options.ignoreCustomComments = options.ignoreCustomComments.slice();
	      }
	      else {
	        options.ignoreCustomComments = [];
	      }
	      options.ignoreCustomComments.push(pattern);
	    }
	    var token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';
	    ignoredMarkupChunks.push(group1);
	    return token;
	  });

	  var customFragments = options.ignoreCustomFragments.map(function(re) {
	    return re.source;
	  });
	  if (customFragments.length) {
	    var reCustomIgnore = new RegExp('\\s*(?:' + customFragments.join('|') + ')+\\s*', 'g');
	    // temporarily replace custom ignored fragments with unique attributes
	    value = value.replace(reCustomIgnore, function(match) {
	      if (!uidAttr) {
	        uidAttr = uniqueId(value);
	        uidPattern = new RegExp('(\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\s*)', 'g');
	        if (options.minifyCSS) {
	          options.minifyCSS = (function(fn) {
	            return function(text, type) {
	              text = text.replace(uidPattern, function(match, prefix, index) {
	                var chunks = ignoredCustomMarkupChunks[+index];
	                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
	              });
	              var ids = [];
	              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function(warning) {
	                var match = uidPattern.exec(warning);
	                if (match) {
	                  var id = uidAttr + match[2] + uidAttr;
	                  text = text.replace(id, ignoreCSS(id));
	                  ids.push(id);
	                }
	              });
	              text = fn(text, type);
	              ids.forEach(function(id) {
	                text = text.replace(ignoreCSS(id), id);
	              });
	              return text;
	            };
	          })(options.minifyCSS);
	        }
	        if (options.minifyJS) {
	          options.minifyJS = (function(fn) {
	            return function(text, type) {
	              return fn(text.replace(uidPattern, function(match, prefix, index) {
	                var chunks = ignoredCustomMarkupChunks[+index];
	                return chunks[1] + uidAttr + index + uidAttr + chunks[2];
	              }), type);
	            };
	          })(options.minifyJS);
	        }
	      }
	      var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
	      ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
	      return '\t' + token + '\t';
	    });
	  }

	  if (options.sortAttributes && typeof options.sortAttributes !== 'function' ||
	      options.sortClassName && typeof options.sortClassName !== 'function') {
	    await createSortFns(value, options, uidIgnore, uidAttr);
	  }

	  function _canCollapseWhitespace(tag, attrs) {
	    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
	  }

	  function _canTrimWhitespace(tag, attrs) {
	    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
	  }

	  function removeStartTag() {
	    var index = buffer.length - 1;
	    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {
	      index--;
	    }
	    buffer.length = Math.max(0, index);
	  }

	  function removeEndTag() {
	    var index = buffer.length - 1;
	    while (index > 0 && !/^<\//.test(buffer[index])) {
	      index--;
	    }
	    buffer.length = Math.max(0, index);
	  }

	  // look for trailing whitespaces, bypass any inline tags
	  function trimTrailingWhitespace(index, nextTag) {
	    for (var endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {
	      var str = buffer[index];
	      var match = str.match(/^<\/([\w:-]+)>$/);
	      if (match) {
	        endTag = match[1];
	      }
	      else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {
	        break;
	      }
	    }
	  }

	  // look for trailing whitespaces from previously processed text
	  // which may not be trimmed due to a following comment or an empty
	  // element which has now been removed
	  function squashTrailingWhitespace(nextTag) {
	    var charsIndex = buffer.length - 1;
	    if (buffer.length > 1) {
	      var item = buffer[buffer.length - 1];
	      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
	        charsIndex--;
	      }
	    }
	    trimTrailingWhitespace(charsIndex, nextTag);
	  }

	  const parser = new HTMLParser(value, {
	    partialMarkup: partialMarkup,
	    continueOnParseError: options.continueOnParseError,
	    customAttrAssign: options.customAttrAssign,
	    customAttrSurround: options.customAttrSurround,
	    html5: options.html5,

	    start: async function(tag, attrs, unary, unarySlash, autoGenerated) {
	      if (tag.toLowerCase() === 'svg') {
	        options = Object.create(options);
	        options.caseSensitive = true;
	        options.keepClosingSlash = true;
	        options.name = identity;
	      }
	      tag = options.name(tag);
	      currentTag = tag;
	      charsPrevTag = tag;
	      if (!inlineTextTags(tag)) {
	        currentChars = '';
	      }
	      hasChars = false;
	      currentAttrs = attrs;

	      var optional = options.removeOptionalTags;
	      if (optional) {
	        var htmlTag = htmlTags(tag);
	        // <html> may be omitted if first thing inside is not comment
	        // <head> may be omitted if first thing inside is an element
	        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
	        // <colgroup> may be omitted if first thing inside is <col>
	        // <tbody> may be omitted if first thing inside is <tr>
	        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // end-tag-followed-by-start-tag omission rules
	        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
	          removeEndTag();
	          // <colgroup> cannot be omitted if preceding </colgroup> is omitted
	          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted
	          optional = !isStartTagMandatory(optionalEndTag, tag);
	        }
	        optionalEndTag = '';
	      }

	      // set whitespace flags for nested tags (eg. <code> within a <pre>)
	      if (options.collapseWhitespace) {
	        if (!stackNoTrimWhitespace.length) {
	          squashTrailingWhitespace(tag);
	        }
	        if (!unary) {
	          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {
	            stackNoTrimWhitespace.push(tag);
	          }
	          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {
	            stackNoCollapseWhitespace.push(tag);
	          }
	        }
	      }

	      var openTag = '<' + tag;
	      var hasUnarySlash = unarySlash && options.keepClosingSlash;

	      buffer.push(openTag);

	      if (options.sortAttributes) {
	        options.sortAttributes(tag, attrs);
	      }

	      var parts = [];
	      for (var i = attrs.length, isLast = true; --i >= 0;) {
	        var normalized = await normalizeAttr(attrs[i], attrs, tag, options);
	        if (normalized) {
	          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
	          isLast = false;
	        }
	      }
	      if (parts.length > 0) {
	        buffer.push(' ');
	        buffer.push.apply(buffer, parts);
	      }
	      // start tag must never be omitted if it has any attributes
	      else if (optional && optionalStartTags(tag)) {
	        optionalStartTag = tag;
	      }

	      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');

	      if (autoGenerated && !options.includeAutoGeneratedTags) {
	        removeStartTag();
	        optionalStartTag = '';
	      }
	    },
	    end: function(tag, attrs, autoGenerated) {
	      if (tag.toLowerCase() === 'svg') {
	        options = Object.getPrototypeOf(options);
	      }
	      tag = options.name(tag);

	      // check if current tag is in a whitespace stack
	      if (options.collapseWhitespace) {
	        if (stackNoTrimWhitespace.length) {
	          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
	            stackNoTrimWhitespace.pop();
	          }
	        }
	        else {
	          squashTrailingWhitespace('/' + tag);
	        }
	        if (stackNoCollapseWhitespace.length &&
	          tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
	          stackNoCollapseWhitespace.pop();
	        }
	      }

	      var isElementEmpty = false;
	      if (tag === currentTag) {
	        currentTag = '';
	        isElementEmpty = !hasChars;
	      }

	      if (options.removeOptionalTags) {
	        // <html>, <head> or <body> may be omitted if the element is empty
	        if (isElementEmpty && topLevelTags(optionalStartTag)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // </html> or </body> may be omitted if not followed by comment
	        // </head> may be omitted if not followed by space or comment
	        // </p> may be omitted if no more content in non-</a> parent
	        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
	        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags(tag))) {
	          removeEndTag();
	        }
	        optionalEndTag = optionalEndTags(tag) ? tag : '';
	      }

	      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
	        // remove last "element" from buffer
	        removeStartTag();
	        optionalStartTag = '';
	        optionalEndTag = '';
	      }
	      else {
	        if (autoGenerated && !options.includeAutoGeneratedTags) {
	          optionalEndTag = '';
	        }
	        else {
	          buffer.push('</' + tag + '>');
	        }
	        charsPrevTag = '/' + tag;
	        if (!inlineTags(tag)) {
	          currentChars = '';
	        }
	        else if (isElementEmpty) {
	          currentChars += '|';
	        }
	      }
	    },
	    chars: async function(text, prevTag, nextTag) {
	      prevTag = prevTag === '' ? 'comment' : prevTag;
	      nextTag = nextTag === '' ? 'comment' : nextTag;
	      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
	        text = decode(text);
	      }
	      if (options.collapseWhitespace) {
	        if (!stackNoTrimWhitespace.length) {
	          if (prevTag === 'comment') {
	            var prevComment = buffer[buffer.length - 1];
	            if (prevComment.indexOf(uidIgnore) === -1) {
	              if (!prevComment) {
	                prevTag = charsPrevTag;
	              }
	              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {
	                var charsIndex = buffer.length - 2;
	                buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function(trailingSpaces) {
	                  text = trailingSpaces + text;
	                  return '';
	                });
	              }
	            }
	          }
	          if (prevTag) {
	            if (prevTag === '/nobr' || prevTag === 'wbr') {
	              if (/^\s/.test(text)) {
	                var tagIndex = buffer.length - 1;
	                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {
	                  tagIndex--;
	                }
	                trimTrailingWhitespace(tagIndex - 1, 'br');
	              }
	            }
	            else if (inlineTextTags(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {
	              text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
	            }
	          }
	          if (prevTag || nextTag) {
	            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);
	          }
	          else {
	            text = collapseWhitespace(text, options, true, true);
	          }
	          if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {
	            trimTrailingWhitespace(buffer.length - 1, nextTag);
	          }
	        }
	        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {
	          text = collapseWhitespace(text, options, false, false, true);
	        }
	      }
	      if (options.processScripts && specialContentTags(currentTag)) {
	        text = await processScript(text, options, currentAttrs);
	      }
	      if (isExecutableScript(currentTag, currentAttrs)) {
	        text = await options.minifyJS(text);
	      }
	      if (isStyleSheet(currentTag, currentAttrs)) {
	        text = options.minifyCSS(text);
	      }
	      if (options.removeOptionalTags && text) {
	        // <html> may be omitted if first thing inside is not comment
	        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
	        if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\s/.test(text)) {
	          removeStartTag();
	        }
	        optionalStartTag = '';
	        // </html> or </body> may be omitted if not followed by comment
	        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment
	        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\s/.test(text)) {
	          removeEndTag();
	        }
	        optionalEndTag = '';
	      }
	      charsPrevTag = /^\s*$/.test(text) ? prevTag : 'comment';
	      if (options.decodeEntities && text && !specialContentTags(currentTag)) {
	        // Escape any `&` symbols that start either:
	        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)
	        // 2) or any other character reference (i.e. one that does end with `;`)
	        // Note that `&` can be escaped as `&amp`, without the semi-colon.
	        // https://mathiasbynens.be/notes/ambiguous-ampersands
	        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');
	      }
	      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
	        text = text.replace(uidPattern, function(match, prefix, index) {
	          return ignoredCustomMarkupChunks[+index][0];
	        });
	      }
	      currentChars += text;
	      if (text) {
	        hasChars = true;
	      }
	      buffer.push(text);
	    },
	    comment: async function(text, nonStandard) {
	      var prefix = nonStandard ? '<!' : '<!--';
	      var suffix = nonStandard ? '>' : '-->';
	      if (isConditionalComment(text)) {
	        text = prefix + await cleanConditionalComment(text, options) + suffix;
	      }
	      else if (options.removeComments) {
	        if (isIgnoredComment(text, options)) {
	          text = '<!--' + text + '-->';
	        }
	        else {
	          text = '';
	        }
	      }
	      else {
	        text = prefix + text + suffix;
	      }
	      if (options.removeOptionalTags && text) {
	        // preceding comments suppress tag omissions
	        optionalStartTag = '';
	        optionalEndTag = '';
	      }
	      buffer.push(text);
	    },
	    doctype: function(doctype) {
	      buffer.push(options.useShortDoctype ? '<!doctype' +
	        (options.removeTagWhitespace ? '' : ' ') + 'html>' :
	        collapseWhitespaceAll(doctype));
	    }
	  });

	  await parser.parse();

	  if (options.removeOptionalTags) {
	    // <html> may be omitted if first thing inside is not comment
	    // <head> or <body> may be omitted if empty
	    if (topLevelTags(optionalStartTag)) {
	      removeStartTag();
	    }
	    // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
	    if (optionalEndTag && !trailingTags(optionalEndTag)) {
	      removeEndTag();
	    }
	  }
	  if (options.collapseWhitespace) {
	    squashTrailingWhitespace('br');
	  }

	  return joinResultSegments(buffer, options, uidPattern ? function(str) {
	    return str.replace(uidPattern, function(match, prefix, index, suffix) {
	      var chunk = ignoredCustomMarkupChunks[+index][0];
	      if (options.collapseWhitespace) {
	        if (prefix !== '\t') {
	          chunk = prefix + chunk;
	        }
	        if (suffix !== '\t') {
	          chunk += suffix;
	        }
	        return collapseWhitespace(chunk, {
	          preserveLineBreaks: options.preserveLineBreaks,
	          conservativeCollapse: !options.trimCustomFragments
	        }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
	      }
	      return chunk;
	    });
	  } : identity, uidIgnore ? function(str) {
	    return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function(match, index) {
	      return ignoredMarkupChunks[+index];
	    });
	  } : identity);
	}

	function joinResultSegments(results, options, restoreCustom, restoreIgnore) {
	  var str;
	  var maxLineLength = options.maxLineLength;
	  var noNewlinesBeforeTagClose = options.noNewlinesBeforeTagClose;

	  if (maxLineLength) {
	    var line = '', lines = [];
	    while (results.length) {
	      var len = line.length;
	      var end = results[0].indexOf('\n');
	      var isClosingTag = Boolean(results[0].match(endTag));
	      var shouldKeepSameLine = noNewlinesBeforeTagClose && isClosingTag;
	      if (end < 0) {
	        line += restoreIgnore(restoreCustom(results.shift()));
	      }
	      else {
	        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
	        results[0] = results[0].slice(end + 1);
	      }
	      if (len > 0 && line.length > maxLineLength && !shouldKeepSameLine) {
	        lines.push(line.slice(0, len));
	        line = line.slice(len);
	      }
	      else if (end >= 0) {
	        lines.push(line);
	        line = '';
	      }
	    }
	    if (line) {
	      lines.push(line);
	    }
	    str = lines.join('\n');
	  }
	  else {
	    str = restoreIgnore(restoreCustom(results.join('')));
	  }
	  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
	}

	htmlminifier.minify = async function(value, options) {
	  var start = Date.now();
	  options = processOptions(options || {});
	  var result = await minify(value, options);
	  options.log('minified in: ' + (Date.now() - start) + 'ms');
	  return result;
	};
	return htmlminifier;
}

const promisify = require$$0$5.promisify;

const vm = require$$1$4;
const fs = fs$1;
const _ = lodashExports;
const path = require$$0$4;
const { CachedChildCompilation } = cachedChildCompiler;

const { createHtmlTagObject, htmlTagObjectToString, HtmlTagArray } = htmlTags;

const prettyError = errors;
const chunkSorter = chunksorterExports;
const getHtmlWebpackPluginHooks = hooks.getHtmlWebpackPluginHooks;
const { assert } = require$$10;

const fsReadFileAsync = promisify(fs.readFile);

class HtmlWebpackPlugin {
  /**
   * @param {HtmlWebpackOptions} [options]
   */
  constructor (options) {
    /** @type {HtmlWebpackOptions} */
    this.userOptions = options || {};
    this.version = HtmlWebpackPlugin.version;
  }

  apply (compiler) {
    // Wait for configuration preset plugions to apply all configure webpack defaults
    compiler.hooks.initialize.tap('HtmlWebpackPlugin', () => {
      const userOptions = this.userOptions;

      // Default options
      /** @type {ProcessedHtmlWebpackOptions} */
      const defaultOptions = {
        template: 'auto',
        templateContent: false,
        templateParameters: templateParametersGenerator,
        filename: 'index.html',
        publicPath: userOptions.publicPath === undefined ? 'auto' : userOptions.publicPath,
        hash: false,
        inject: userOptions.scriptLoading === 'blocking' ? 'body' : 'head',
        scriptLoading: 'defer',
        compile: true,
        favicon: false,
        minify: 'auto',
        cache: true,
        showErrors: true,
        chunks: 'all',
        excludeChunks: [],
        chunksSortMode: 'auto',
        meta: {},
        base: false,
        title: 'Webpack App',
        xhtml: false
      };

      /** @type {ProcessedHtmlWebpackOptions} */
      const options = Object.assign(defaultOptions, userOptions);
      this.options = options;

      // Assert correct option spelling
      assert(options.scriptLoading === 'defer' || options.scriptLoading === 'blocking' || options.scriptLoading === 'module', 'scriptLoading needs to be set to "defer", "blocking" or "module"');
      assert(options.inject === true || options.inject === false || options.inject === 'head' || options.inject === 'body', 'inject needs to be set to true, false, "head" or "body');

      // Default metaOptions if no template is provided
      if (!userOptions.template && options.templateContent === false && options.meta) {
        const defaultMeta = {
          // TODO remove in the next major release
          // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag
          viewport: 'width=device-width, initial-scale=1'
        };
        options.meta = Object.assign({}, options.meta, defaultMeta, userOptions.meta);
      }

      // entryName to fileName conversion function
      const userOptionFilename = userOptions.filename || defaultOptions.filename;
      const filenameFunction = typeof userOptionFilename === 'function'
        ? userOptionFilename
        // Replace '[name]' with entry name
        : (entryName) => userOptionFilename.replace(/\[name\]/g, entryName);

      /** output filenames for the given entry names */
      const entryNames = Object.keys(compiler.options.entry);
      const outputFileNames = new Set((entryNames.length ? entryNames : ['main']).map(filenameFunction));

      /** Option for every entry point */
      const entryOptions = Array.from(outputFileNames).map((filename) => ({
        ...options,
        filename
      }));

      // Hook all options into the webpack compiler
      entryOptions.forEach((instanceOptions) => {
        hookIntoCompiler(compiler, instanceOptions, this);
      });
    });
  }

  /**
   * Once webpack is done with compiling the template into a NodeJS code this function
   * evaluates it to generate the html result
   *
   * The evaluateCompilationResult is only a class function to allow spying during testing.
   * Please change that in a further refactoring
   *
   * @param {string} source
   * @param {string} templateFilename
   * @returns {Promise<string | (() => string | Promise<string>)>}
   */
  evaluateCompilationResult (source, publicPath, templateFilename) {
    if (!source) {
      return Promise.reject(new Error('The child compilation didn\'t provide a result'));
    }
    // The LibraryTemplatePlugin stores the template result in a local variable.
    // By adding it to the end the value gets extracted during evaluation
    if (source.indexOf('HTML_WEBPACK_PLUGIN_RESULT') >= 0) {
      source += ';\nHTML_WEBPACK_PLUGIN_RESULT';
    }
    const templateWithoutLoaders = templateFilename.replace(/^.+!/, '').replace(/\?.+$/, '');
    const vmContext = vm.createContext({
      ...commonjsGlobal,
      HTML_WEBPACK_PLUGIN: true,
      require: require,
      htmlWebpackPluginPublicPath: publicPath,
      __filename: templateWithoutLoaders,
      __dirname: path.dirname(templateWithoutLoaders),
      AbortController: commonjsGlobal.AbortController,
      AbortSignal: commonjsGlobal.AbortSignal,
      Blob: commonjsGlobal.Blob,
      Buffer: commonjsGlobal.Buffer,
      ByteLengthQueuingStrategy: commonjsGlobal.ByteLengthQueuingStrategy,
      BroadcastChannel: commonjsGlobal.BroadcastChannel,
      CompressionStream: commonjsGlobal.CompressionStream,
      CountQueuingStrategy: commonjsGlobal.CountQueuingStrategy,
      Crypto: commonjsGlobal.Crypto,
      CryptoKey: commonjsGlobal.CryptoKey,
      CustomEvent: commonjsGlobal.CustomEvent,
      DecompressionStream: commonjsGlobal.DecompressionStream,
      Event: commonjsGlobal.Event,
      EventTarget: commonjsGlobal.EventTarget,
      File: commonjsGlobal.File,
      FormData: commonjsGlobal.FormData,
      Headers: commonjsGlobal.Headers,
      MessageChannel: commonjsGlobal.MessageChannel,
      MessageEvent: commonjsGlobal.MessageEvent,
      MessagePort: commonjsGlobal.MessagePort,
      PerformanceEntry: commonjsGlobal.PerformanceEntry,
      PerformanceMark: commonjsGlobal.PerformanceMark,
      PerformanceMeasure: commonjsGlobal.PerformanceMeasure,
      PerformanceObserver: commonjsGlobal.PerformanceObserver,
      PerformanceObserverEntryList: commonjsGlobal.PerformanceObserverEntryList,
      PerformanceResourceTiming: commonjsGlobal.PerformanceResourceTiming,
      ReadableByteStreamController: commonjsGlobal.ReadableByteStreamController,
      ReadableStream: commonjsGlobal.ReadableStream,
      ReadableStreamBYOBReader: commonjsGlobal.ReadableStreamBYOBReader,
      ReadableStreamBYOBRequest: commonjsGlobal.ReadableStreamBYOBRequest,
      ReadableStreamDefaultController: commonjsGlobal.ReadableStreamDefaultController,
      ReadableStreamDefaultReader: commonjsGlobal.ReadableStreamDefaultReader,
      Response: commonjsGlobal.Response,
      Request: commonjsGlobal.Request,
      SubtleCrypto: commonjsGlobal.SubtleCrypto,
      DOMException: commonjsGlobal.DOMException,
      TextDecoder: commonjsGlobal.TextDecoder,
      TextDecoderStream: commonjsGlobal.TextDecoderStream,
      TextEncoder: commonjsGlobal.TextEncoder,
      TextEncoderStream: commonjsGlobal.TextEncoderStream,
      TransformStream: commonjsGlobal.TransformStream,
      TransformStreamDefaultController: commonjsGlobal.TransformStreamDefaultController,
      URL: commonjsGlobal.URL,
      URLSearchParams: commonjsGlobal.URLSearchParams,
      WebAssembly: commonjsGlobal.WebAssembly,
      WritableStream: commonjsGlobal.WritableStream,
      WritableStreamDefaultController: commonjsGlobal.WritableStreamDefaultController,
      WritableStreamDefaultWriter: commonjsGlobal.WritableStreamDefaultWriter
    });
    const vmScript = new vm.Script(source, { filename: templateWithoutLoaders });
    // Evaluate code and cast to string
    let newSource;
    try {
      newSource = vmScript.runInContext(vmContext);
    } catch (e) {
      return Promise.reject(e);
    }
    if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {
      newSource = newSource.default;
    }
    return typeof newSource === 'string' || typeof newSource === 'function'
      ? Promise.resolve(newSource)
      : Promise.reject(new Error('The loader "' + templateWithoutLoaders + '" didn\'t return html.'));
  }
}

/**
 * connect the html-webpack-plugin to the webpack compiler lifecycle hooks
 *
 * @param {import('webpack').Compiler} compiler
 * @param {ProcessedHtmlWebpackOptions} options
 * @param {HtmlWebpackPlugin} plugin
 */
function hookIntoCompiler (compiler, options, plugin) {
  const webpack = compiler.webpack;
  // Instance variables to keep caching information
  // for multiple builds
  let assetJson;
  /**
   * store the previous generated asset to emit them even if the content did not change
   * to support watch mode for third party plugins like the clean-webpack-plugin or the compression plugin
   * @type {Array<{html: string, name: string}>}
   */
  let previousEmittedAssets = [];

  options.template = getFullTemplatePath(options.template, compiler.context);

  // Inject child compiler plugin
  const childCompilerPlugin = new CachedChildCompilation(compiler);
  if (!options.templateContent) {
    childCompilerPlugin.addEntry(options.template);
  }

  // convert absolute filename into relative so that webpack can
  // generate it at correct location
  const filename = options.filename;
  if (path.resolve(filename) === path.normalize(filename)) {
    const outputPath = /** @type {string} - Once initialized the path is always a string */(compiler.options.output.path);
    options.filename = path.relative(outputPath, filename);
  }

  // Check if webpack is running in production mode
  // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14
  const isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;

  const minify = options.minify;
  if (minify === true || (minify === 'auto' && isProductionLikeMode)) {
    /** @type { import('html-minifier-terser').Options } */
    options.minify = {
      // https://www.npmjs.com/package/html-minifier-terser#options-quick-reference
      collapseWhitespace: true,
      keepClosingSlash: true,
      removeComments: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true,
      useShortDoctype: true
    };
  }

  compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin',
    /**
       * Hook into the webpack compilation
       * @param {WebpackCompilation} compilation
      */
    (compilation) => {
      compilation.hooks.processAssets.tapAsync(
        {
          name: 'HtmlWebpackPlugin',
          stage:
          /**
           * Generate the html after minification and dev tooling is done
           */
          webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE
        },
        /**
         * Hook into the process assets hook
         * @param {WebpackCompilation} compilationAssets
         * @param {(err?: Error) => void} callback
         */
        (compilationAssets, callback) => {
          // Get all entry point names for this html file
          const entryNames = Array.from(compilation.entrypoints.keys());
          const filteredEntryNames = filterChunks(entryNames, options.chunks, options.excludeChunks);
          const sortedEntryNames = sortEntryChunks(filteredEntryNames, options.chunksSortMode, compilation);

          const templateResult = options.templateContent
            ? { mainCompilationHash: compilation.hash }
            : childCompilerPlugin.getCompilationEntryResult(options.template);

          if ('error' in templateResult) {
            compilation.errors.push(prettyError(templateResult.error, compiler.context).toString());
          }

          // If the child compilation was not executed during a previous main compile run
          // it is a cached result
          const isCompilationCached = templateResult.mainCompilationHash !== compilation.hash;

          /** The public path used inside the html file */
          const htmlPublicPath = getPublicPath(compilation, options.filename, options.publicPath);

          /** Generated file paths from the entry point names */
          const assets = htmlWebpackPluginAssets(compilation, sortedEntryNames, htmlPublicPath);

          // If the template and the assets did not change we don't have to emit the html
          const newAssetJson = JSON.stringify(getAssetFiles(assets));
          if (isCompilationCached && options.cache && assetJson === newAssetJson) {
            previousEmittedAssets.forEach(({ name, html }) => {
              compilation.emitAsset(name, new webpack.sources.RawSource(html, false));
            });
            return callback();
          } else {
            previousEmittedAssets = [];
            assetJson = newAssetJson;
          }

          // The html-webpack plugin uses a object representation for the html-tags which will be injected
          // to allow altering them more easily
          // Just before they are converted a third-party-plugin author might change the order and content
          const assetsPromise = getFaviconPublicPath(options.favicon, compilation, assets.publicPath)
            .then((faviconPath) => {
              assets.favicon = faviconPath;
              return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({
                assets: assets,
                outputName: options.filename,
                plugin: plugin
              });
            });

          // Turn the js and css paths into grouped HtmlTagObjects
          const assetTagGroupsPromise = assetsPromise
          // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped
            .then(({ assets }) => getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({
              assetTags: {
                scripts: generatedScriptTags(assets.js),
                styles: generateStyleTags(assets.css),
                meta: [
                  ...generateBaseTag(options.base),
                  ...generatedMetaTags(options.meta),
                  ...generateFaviconTags(assets.favicon)
                ]
              },
              outputName: options.filename,
              publicPath: htmlPublicPath,
              plugin: plugin
            }))
            .then(({ assetTags }) => {
              // Inject scripts to body unless it set explicitly to head
              const scriptTarget = options.inject === 'head' ||
                (options.inject !== 'body' && options.scriptLoading !== 'blocking') ? 'head' : 'body';
              // Group assets to `head` and `body` tag arrays
              const assetGroups = generateAssetGroups(assetTags, scriptTarget);
              // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped
              return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({
                headTags: assetGroups.headTags,
                bodyTags: assetGroups.bodyTags,
                outputName: options.filename,
                publicPath: htmlPublicPath,
                plugin: plugin
              });
            });

          // Turn the compiled template into a nodejs function or into a nodejs string
          const templateEvaluationPromise = Promise.resolve()
            .then(() => {
              if ('error' in templateResult) {
                return options.showErrors ? prettyError(templateResult.error, compiler.context).toHtml() : 'ERROR';
              }
              // Allow to use a custom function / string instead
              if (options.templateContent !== false) {
                return options.templateContent;
              }
              // Once everything is compiled evaluate the html factory
              // and replace it with its content
              return ('compiledEntry' in templateResult)
                ? plugin.evaluateCompilationResult(templateResult.compiledEntry.content, htmlPublicPath, options.template)
                : Promise.reject(new Error('Child compilation contained no compiledEntry'));
            });
          const templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise])
          // Execute the template
            .then(([assetsHookResult, assetTags, compilationResult]) => typeof compilationResult !== 'function'
              ? compilationResult
              : executeTemplate(compilationResult, assetsHookResult.assets, { headTags: assetTags.headTags, bodyTags: assetTags.bodyTags }, compilation));

          const injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise])
          // Allow plugins to change the html before assets are injected
            .then(([assetTags, html]) => {
              const pluginArgs = { html, headTags: assetTags.headTags, bodyTags: assetTags.bodyTags, plugin: plugin, outputName: options.filename };
              return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);
            })
            .then(({ html, headTags, bodyTags }) => {
              return postProcessHtml(html, assets, { headTags, bodyTags });
            });

          const emitHtmlPromise = injectedHtmlPromise
          // Allow plugins to change the html after assets are injected
            .then((html) => {
              const pluginArgs = { html, plugin: plugin, outputName: options.filename };
              return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs)
                .then(result => result.html);
            })
            .catch(err => {
              // In case anything went wrong the promise is resolved
              // with the error message and an error is logged
              compilation.errors.push(prettyError(err, compiler.context).toString());
              return options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';
            })
            .then(html => {
              const filename = options.filename.replace(/\[templatehash([^\]]*)\]/g, require$$0$5.deprecate(
                (match, options) => `[contenthash${options}]`,
                '[templatehash] is now [contenthash]')
              );
              const replacedFilename = replacePlaceholdersInFilename(filename, html, compilation);
              // Add the evaluated html code to the webpack assets
              compilation.emitAsset(replacedFilename.path, new webpack.sources.RawSource(html, false), replacedFilename.info);
              previousEmittedAssets.push({ name: replacedFilename.path, html });
              return replacedFilename.path;
            })
            .then((finalOutputName) => getHtmlWebpackPluginHooks(compilation).afterEmit.promise({
              outputName: finalOutputName,
              plugin: plugin
            }).catch(err => {
              console.error(err);
              return null;
            }).then(() => null));

          // Once all files are added to the webpack compilation
          // let the webpack compiler continue
          emitHtmlPromise.then(() => {
            callback();
          });
        });
    });

  /**
   * Generate the template parameters for the template function
   * @param {WebpackCompilation} compilation
   * @param {{
      publicPath: string,
      js: Array<string>,
      css: Array<string>,
      manifest?: string,
      favicon?: string
    }} assets
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * @returns {Promise<{[key: any]: any}>}
   */
  function getTemplateParameters (compilation, assets, assetTags) {
    const templateParameters = options.templateParameters;
    if (templateParameters === false) {
      return Promise.resolve({});
    }
    if (typeof templateParameters !== 'function' && typeof templateParameters !== 'object') {
      throw new Error('templateParameters has to be either a function or an object');
    }
    const templateParameterFunction = typeof templateParameters === 'function'
      // A custom function can overwrite the entire template parameter preparation
      ? templateParameters
      // If the template parameters is an object merge it with the default values
      : (compilation, assets, assetTags, options) => Object.assign({},
        templateParametersGenerator(compilation, assets, assetTags, options),
        templateParameters
      );
    const preparedAssetTags = {
      headTags: prepareAssetTagGroupForRendering(assetTags.headTags),
      bodyTags: prepareAssetTagGroupForRendering(assetTags.bodyTags)
    };
    return Promise
      .resolve()
      .then(() => templateParameterFunction(compilation, assets, preparedAssetTags, options));
  }

  /**
   * This function renders the actual html by executing the template function
   *
   * @param {(templateParameters) => string | Promise<string>} templateFunction
   * @param {{
      publicPath: string,
      js: Array<string>,
      css: Array<string>,
      manifest?: string,
      favicon?: string
    }} assets
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * @param {WebpackCompilation} compilation
   *
   * @returns Promise<string>
   */
  function executeTemplate (templateFunction, assets, assetTags, compilation) {
    // Template processing
    const templateParamsPromise = getTemplateParameters(compilation, assets, assetTags);
    return templateParamsPromise.then((templateParams) => {
      try {
        // If html is a promise return the promise
        // If html is a string turn it into a promise
        return templateFunction(templateParams);
      } catch (e) {
        compilation.errors.push(new Error('Template execution failed: ' + e));
        return Promise.reject(e);
      }
    });
  }

  /**
   * Html Post processing
   *
   * @param {any} html
   * The input html
   * @param {any} assets
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * The asset tags to inject
   *
   * @returns {Promise<string>}
   */
  function postProcessHtml (html, assets, assetTags) {
    if (typeof html !== 'string') {
      return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));
    }
    const htmlAfterInjection = options.inject
      ? injectAssetsIntoHtml(html, assets, assetTags)
      : html;
    const htmlAfterMinification = minifyHtml(htmlAfterInjection);
    return Promise.resolve(htmlAfterMinification);
  }

  /*
   * Pushes the content of the given filename to the compilation assets
   * @param {string} filename
   * @param {WebpackCompilation} compilation
   *
   * @returns {string} file basename
   */
  function addFileToAssets (filename, compilation) {
    filename = path.resolve(compilation.compiler.context, filename);
    return fsReadFileAsync(filename)
      .then(source => new webpack.sources.RawSource(source, false))
      .catch(() => Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename)))
      .then(rawSource => {
        const basename = path.basename(filename);
        compilation.fileDependencies.add(filename);
        compilation.emitAsset(basename, rawSource);
        return basename;
      });
  }

  /**
   * Replace [contenthash] in filename
   *
   * @see https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/
   *
   * @param {string} filename
   * @param {string|Buffer} fileContent
   * @param {WebpackCompilation} compilation
   * @returns {{ path: string, info: {} }}
   */
  function replacePlaceholdersInFilename (filename, fileContent, compilation) {
    if (/\[\\*([\w:]+)\\*\]/i.test(filename) === false) {
      return { path: filename, info: {} };
    }
    const hash = compiler.webpack.util.createHash(compilation.outputOptions.hashFunction);
    hash.update(fileContent);
    if (compilation.outputOptions.hashSalt) {
      hash.update(compilation.outputOptions.hashSalt);
    }
    const contentHash = hash.digest(compilation.outputOptions.hashDigest).slice(0, compilation.outputOptions.hashDigestLength);
    return compilation.getPathWithInfo(
      filename,
      {
        contentHash,
        chunk: {
          hash: contentHash,
          contentHash
        }
      }
    );
  }

  /**
   * Helper to sort chunks
   * @param {string[]} entryNames
   * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode
   * @param {WebpackCompilation} compilation
   */
  function sortEntryChunks (entryNames, sortMode, compilation) {
    // Custom function
    if (typeof sortMode === 'function') {
      return entryNames.sort(sortMode);
    }
    // Check if the given sort mode is a valid chunkSorter sort mode
    if (typeof chunkSorter[sortMode] !== 'undefined') {
      return chunkSorter[sortMode](entryNames, compilation, options);
    }
    throw new Error('"' + sortMode + '" is not a valid chunk sort mode');
  }

  /**
   * Return all chunks from the compilation result which match the exclude and include filters
   * @param {any} chunks
   * @param {string[]|'all'} includedChunks
   * @param {string[]} excludedChunks
   */
  function filterChunks (chunks, includedChunks, excludedChunks) {
    return chunks.filter(chunkName => {
      // Skip if the chunks should be filtered and the given chunk was not added explicity
      if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {
        return false;
      }
      // Skip if the chunks should be filtered and the given chunk was excluded explicity
      if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {
        return false;
      }
      // Add otherwise
      return true;
    });
  }

  /**
   * Generate the relative or absolute base url to reference images, css, and javascript files
   * from within the html file - the publicPath
   *
   * @param {WebpackCompilation} compilation
   * @param {string} childCompilationOutputName
   * @param {string | 'auto'} customPublicPath
   * @returns {string}
   */
  function getPublicPath (compilation, childCompilationOutputName, customPublicPath) {
    const compilationHash = compilation.hash;

    /**
     * @type {string} the configured public path to the asset root
     * if a path publicPath is set in the current webpack config use it otherwise
     * fallback to a relative path
     */
    const webpackPublicPath = compilation.getAssetPath(compilation.outputOptions.publicPath, { hash: compilationHash });

    // Webpack 5 introduced "auto" as default value
    const isPublicPathDefined = webpackPublicPath !== 'auto';

    let publicPath =
      // If the html-webpack-plugin options contain a custom public path uset it
      customPublicPath !== 'auto'
        ? customPublicPath
        : (isPublicPathDefined
          // If a hard coded public path exists use it
          ? webpackPublicPath
          // If no public path was set get a relative url path
          : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path)
            .split(path.sep).join('/')
        );

    if (publicPath.length && publicPath.substr(-1, 1) !== '/') {
      publicPath += '/';
    }

    return publicPath;
  }

  /**
   * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation
   * for all given entry names
   * @param {WebpackCompilation} compilation
   * @param {string[]} entryNames
   * @param {string | 'auto'} publicPath
   * @returns {{
      publicPath: string,
      js: Array<string>,
      css: Array<string>,
      manifest?: string,
      favicon?: string
    }}
   */
  function htmlWebpackPluginAssets (compilation, entryNames, publicPath) {
    const compilationHash = compilation.hash;
    /**
     * @type {{
        publicPath: string,
        js: Array<string>,
        css: Array<string>,
        manifest?: string,
        favicon?: string
      }}
     */
    const assets = {
      // The public path
      publicPath,
      // Will contain all js and mjs files
      js: [],
      // Will contain all css files
      css: [],
      // Will contain the html5 appcache manifest files if it exists
      manifest: Object.keys(compilation.assets).find(assetFile => path.extname(assetFile) === '.appcache'),
      // Favicon
      favicon: undefined
    };

    // Append a hash for cache busting
    if (options.hash && assets.manifest) {
      assets.manifest = appendHash(assets.manifest, compilationHash);
    }

    // Extract paths to .js, .mjs and .css files from the current compilation
    const entryPointPublicPathMap = {};
    const extensionRegexp = /\.(css|js|mjs)(\?|$)/;
    for (let i = 0; i < entryNames.length; i++) {
      const entryName = entryNames[i];
      /** entryPointUnfilteredFiles - also includes hot module update files */
      const entryPointUnfilteredFiles = compilation.entrypoints.get(entryName).getFiles();

      const entryPointFiles = entryPointUnfilteredFiles.filter((chunkFile) => {
        const asset = compilation.getAsset(chunkFile);
        if (!asset) {
          return true;
        }
        // Prevent hot-module files from being included:
        const assetMetaInformation = asset.info || {};
        return !(assetMetaInformation.hotModuleReplacement || assetMetaInformation.development);
      });

      // Prepend the publicPath and append the hash depending on the
      // webpack.output.publicPath and hashOptions
      // E.g. bundle.js -> /bundle.js?hash
      const entryPointPublicPaths = entryPointFiles
        .map(chunkFile => {
          const entryPointPublicPath = publicPath + urlencodePath(chunkFile);
          return options.hash
            ? appendHash(entryPointPublicPath, compilationHash)
            : entryPointPublicPath;
        });

      entryPointPublicPaths.forEach((entryPointPublicPath) => {
        const extMatch = extensionRegexp.exec(entryPointPublicPath);
        // Skip if the public path is not a .css, .mjs or .js file
        if (!extMatch) {
          return;
        }
        // Skip if this file is already known
        // (e.g. because of common chunk optimizations)
        if (entryPointPublicPathMap[entryPointPublicPath]) {
          return;
        }
        entryPointPublicPathMap[entryPointPublicPath] = true;
        // ext will contain .js or .css, because .mjs recognizes as .js
        const ext = extMatch[1] === 'mjs' ? 'js' : extMatch[1];
        assets[ext].push(entryPointPublicPath);
      });
    }
    return assets;
  }

  /**
   * Converts a favicon file from disk to a webpack resource
   * and returns the url to the resource
   *
   * @param {string|false} faviconFilePath
   * @param {WebpackCompilation} compilation
   * @param {string} publicPath
   * @returns {Promise<string|undefined>}
   */
  function getFaviconPublicPath (faviconFilePath, compilation, publicPath) {
    if (!faviconFilePath) {
      return Promise.resolve(undefined);
    }
    return addFileToAssets(faviconFilePath, compilation)
      .then((faviconName) => {
        const faviconPath = publicPath + faviconName;
        if (options.hash) {
          return appendHash(faviconPath, compilation.hash);
        }
        return faviconPath;
      });
  }

  /**
   * Generate all tags script for the given file paths
   * @param {Array<string>} jsAssets
   * @returns {Array<HtmlTagObject>}
   */
  function generatedScriptTags (jsAssets) {
    return jsAssets.map(scriptAsset => ({
      tagName: 'script',
      voidTag: false,
      meta: { plugin: 'html-webpack-plugin' },
      attributes: {
        defer: options.scriptLoading === 'defer',
        type: options.scriptLoading === 'module' ? 'module' : undefined,
        src: scriptAsset
      }
    }));
  }

  /**
   * Generate all style tags for the given file paths
   * @param {Array<string>} cssAssets
   * @returns {Array<HtmlTagObject>}
   */
  function generateStyleTags (cssAssets) {
    return cssAssets.map(styleAsset => ({
      tagName: 'link',
      voidTag: true,
      meta: { plugin: 'html-webpack-plugin' },
      attributes: {
        href: styleAsset,
        rel: 'stylesheet'
      }
    }));
  }

  /**
   * Generate an optional base tag
   * @param { false
            | string
            | {[attributeName: string]: string} // attributes e.g. { href:"http://example.com/page.html" target:"_blank" }
            } baseOption
  * @returns {Array<HtmlTagObject>}
  */
  function generateBaseTag (baseOption) {
    if (baseOption === false) {
      return [];
    } else {
      return [{
        tagName: 'base',
        voidTag: true,
        meta: { plugin: 'html-webpack-plugin' },
        attributes: (typeof baseOption === 'string') ? {
          href: baseOption
        } : baseOption
      }];
    }
  }

  /**
   * Generate all meta tags for the given meta configuration
   * @param {false | {
            [name: string]:
              false // disabled
              | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`
              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:"viewport" content:"width=500, initial-scale=1" }
        }} metaOptions
  * @returns {Array<HtmlTagObject>}
  */
  function generatedMetaTags (metaOptions) {
    if (metaOptions === false) {
      return [];
    }
    // Make tags self-closing in case of xhtml
    // Turn { "viewport" : "width=500, initial-scale=1" } into
    // [{ name:"viewport" content:"width=500, initial-scale=1" }]
    const metaTagAttributeObjects = Object.keys(metaOptions)
      .map((metaName) => {
        const metaTagContent = metaOptions[metaName];
        return (typeof metaTagContent === 'string') ? {
          name: metaName,
          content: metaTagContent
        } : metaTagContent;
      })
      .filter((attribute) => attribute !== false);
      // Turn [{ name:"viewport" content:"width=500, initial-scale=1" }] into
      // the html-webpack-plugin tag structure
    return metaTagAttributeObjects.map((metaTagAttributes) => {
      if (metaTagAttributes === false) {
        throw new Error('Invalid meta tag');
      }
      return {
        tagName: 'meta',
        voidTag: true,
        meta: { plugin: 'html-webpack-plugin' },
        attributes: metaTagAttributes
      };
    });
  }

  /**
   * Generate a favicon tag for the given file path
   * @param {string| undefined} faviconPath
   * @returns {Array<HtmlTagObject>}
   */
  function generateFaviconTags (faviconPath) {
    if (!faviconPath) {
      return [];
    }
    return [{
      tagName: 'link',
      voidTag: true,
      meta: { plugin: 'html-webpack-plugin' },
      attributes: {
        rel: 'icon',
        href: faviconPath
      }
    }];
  }

  /**
   * Group assets to head and bottom tags
   *
   * @param {{
      scripts: Array<HtmlTagObject>;
      styles: Array<HtmlTagObject>;
      meta: Array<HtmlTagObject>;
    }} assetTags
  * @param {"body" | "head"} scriptTarget
  * @returns {{
      headTags: Array<HtmlTagObject>;
      bodyTags: Array<HtmlTagObject>;
    }}
  */
  function generateAssetGroups (assetTags, scriptTarget) {
    /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */
    const result = {
      headTags: [
        ...assetTags.meta,
        ...assetTags.styles
      ],
      bodyTags: []
    };
    // Add script tags to head or body depending on
    // the htmlPluginOptions
    if (scriptTarget === 'body') {
      result.bodyTags.push(...assetTags.scripts);
    } else {
      // If script loading is blocking add the scripts to the end of the head
      // If script loading is non-blocking add the scripts infront of the css files
      const insertPosition = options.scriptLoading === 'blocking' ? result.headTags.length : assetTags.meta.length;
      result.headTags.splice(insertPosition, 0, ...assetTags.scripts);
    }
    return result;
  }

  /**
   * Add toString methods for easier rendering
   * inside the template
   *
   * @param {Array<HtmlTagObject>} assetTagGroup
   * @returns {Array<HtmlTagObject>}
   */
  function prepareAssetTagGroupForRendering (assetTagGroup) {
    const xhtml = options.xhtml;
    return HtmlTagArray.from(assetTagGroup.map((assetTag) => {
      const copiedAssetTag = Object.assign({}, assetTag);
      copiedAssetTag.toString = function () {
        return htmlTagObjectToString(this, xhtml);
      };
      return copiedAssetTag;
    }));
  }

  /**
   * Injects the assets into the given html string
   *
   * @param {string} html
   * The input html
   * @param {any} assets
   * @param {{
       headTags: HtmlTagObject[],
       bodyTags: HtmlTagObject[]
     }} assetTags
   * The asset tags to inject
   *
   * @returns {string}
   */
  function injectAssetsIntoHtml (html, assets, assetTags) {
    const htmlRegExp = /(<html[^>]*>)/i;
    const headRegExp = /(<\/head\s*>)/i;
    const bodyRegExp = /(<\/body\s*>)/i;
    const metaViewportRegExp = /<meta[^>]+name=["']viewport["'][^>]*>/i;
    const body = assetTags.bodyTags.map((assetTagObject) => htmlTagObjectToString(assetTagObject, options.xhtml));
    const head = assetTags.headTags.filter((item) => {
      if (item.tagName === 'meta' && item.attributes && item.attributes.name === 'viewport' && metaViewportRegExp.test(html)) {
        return false;
      }

      return true;
    }).map((assetTagObject) => htmlTagObjectToString(assetTagObject, options.xhtml));

    if (body.length) {
      if (bodyRegExp.test(html)) {
        // Append assets to body element
        html = html.replace(bodyRegExp, match => body.join('') + match);
      } else {
        // Append scripts to the end of the file if no <body> element exists:
        html += body.join('');
      }
    }

    if (head.length) {
      // Create a head tag if none exists
      if (!headRegExp.test(html)) {
        if (!htmlRegExp.test(html)) {
          html = '<head></head>' + html;
        } else {
          html = html.replace(htmlRegExp, match => match + '<head></head>');
        }
      }

      // Append assets to head element
      html = html.replace(headRegExp, match => head.join('') + match);
    }

    // Inject manifest into the opening html tag
    if (assets.manifest) {
      html = html.replace(/(<html[^>]*)(>)/i, (match, start, end) => {
        // Append the manifest only if no manifest was specified
        if (/\smanifest\s*=/.test(match)) {
          return match;
        }
        return start + ' manifest="' + assets.manifest + '"' + end;
      });
    }
    return html;
  }

  /**
   * Appends a cache busting hash to the query string of the url
   * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175
   * @param {string} url
   * @param {string} hash
   */
  function appendHash (url, hash) {
    if (!url) {
      return url;
    }
    return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;
  }

  /**
   * Encode each path component using `encodeURIComponent` as files can contain characters
   * which needs special encoding in URLs like `+ `.
   *
   * Valid filesystem characters which need to be encoded for urls:
   *
   * # pound, % percent, & ampersand, { left curly bracket, } right curly bracket,
   * \ back slash, < left angle bracket, > right angle bracket, * asterisk, ? question mark,
   * blank spaces, $ dollar sign, ! exclamation point, ' single quotes, " double quotes,
   * : colon, @ at sign, + plus sign, ` backtick, | pipe, = equal sign
   *
   * However the query string must not be encoded:
   *
   *  fo:demonstration-path/very fancy+name.js?path=/home?value=abc&value=def#zzz
   *    ^             ^    ^    ^     ^    ^  ^    ^^    ^     ^   ^     ^   ^
   *    |             |    |    |     |    |  |    ||    |     |   |     |   |
   *    encoded       |    |    encoded    |  |    ||    |     |   |     |   |
   *                 ignored              ignored  ignored     ignored   ignored
   *
   * @param {string} filePath
   */
  function urlencodePath (filePath) {
    // People use the filepath in quite unexpected ways.
    // Try to extract the first querystring of the url:
    //
    // some+path/demo.html?value=abc?def
    //
    const queryStringStart = filePath.indexOf('?');
    const urlPath = queryStringStart === -1 ? filePath : filePath.substr(0, queryStringStart);
    const queryString = filePath.substr(urlPath.length);
    // Encode all parts except '/' which are not part of the querystring:
    const encodedUrlPath = urlPath.split('/').map(encodeURIComponent).join('/');
    return encodedUrlPath + queryString;
  }

  /**
   * Helper to return the absolute template path with a fallback loader
   * @param {string} template
   * The path to the template e.g. './index.html'
   * @param {string} context
   * The webpack base resolution path for relative paths e.g. process.cwd()
   */
  function getFullTemplatePath (template, context) {
    if (template === 'auto') {
      template = path.resolve(context, 'src/index.ejs');
      if (!fs.existsSync(template)) {
        template = path.join(__dirname, 'default_index.ejs');
      }
    }
    // If the template doesn't use a loader use the lodash template loader
    if (template.indexOf('!') === -1) {
      template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);
    }
    // Resolve template path
    return template.replace(
      /([!])([^/\\][^!?]+|[^/\\!?])($|\?[^!?\n]+$)/,
      (match, prefix, filepath, postfix) => prefix + path.resolve(filepath) + postfix);
  }

  /**
   * Minify the given string using html-minifier-terser
   *
   * As this is a breaking change to html-webpack-plugin 3.x
   * provide an extended error message to explain how to get back
   * to the old behaviour
   *
   * @param {string} html
   */
  function minifyHtml (html) {
    if (typeof options.minify !== 'object') {
      return html;
    }
    try {
      return requireHtmlminifier().minify(html, options.minify);
    } catch (e) {
      const isParseError = String(e.message).indexOf('Parse Error') === 0;
      if (isParseError) {
        e.message = 'html-webpack-plugin could not minify the generated output.\n' +
            'In production mode the html minifcation is enabled by default.\n' +
            'If you are not generating a valid html output please disable it manually.\n' +
            'You can do so by adding the following setting to your HtmlWebpackPlugin config:\n|\n|' +
            '    minify: false\n|\n' +
            'See https://github.com/jantimon/html-webpack-plugin#options for details.\n\n' +
            'For parser dedicated bugs please create an issue here:\n' +
            'https://danielruf.github.io/html-minifier-terser/' +
          '\n' + e.message;
      }
      throw e;
    }
  }

  /**
   * Helper to return a sorted unique array of all asset files out of the
   * asset object
   */
  function getAssetFiles (assets) {
    const files = _.uniq(Object.keys(assets).filter(assetType => assetType !== 'chunks' && assets[assetType]).reduce((files, assetType) => files.concat(assets[assetType]), []));
    files.sort();
    return files;
  }
}

/**
 * The default for options.templateParameter
 * Generate the template parameters
 *
 * Generate the template parameters for the template function
 * @param {WebpackCompilation} compilation
 * @param {{
   publicPath: string,
   js: Array<string>,
   css: Array<string>,
   manifest?: string,
   favicon?: string
 }} assets
 * @param {{
     headTags: HtmlTagObject[],
     bodyTags: HtmlTagObject[]
   }} assetTags
 * @param {ProcessedHtmlWebpackOptions} options
 * @returns {TemplateParameter}
 */
function templateParametersGenerator (compilation, assets, assetTags, options) {
  return {
    compilation: compilation,
    webpackConfig: compilation.options,
    htmlWebpackPlugin: {
      tags: assetTags,
      files: assets,
      options: options
    }
  };
}

// Statics:
/**
 * The major version number of this plugin
 */
HtmlWebpackPlugin.version = 5;

/**
 * A static helper to get the hooks for this plugin
 *
 * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });
 */
HtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;
HtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;

var htmlWebpackPlugin = HtmlWebpackPlugin;

var HtmlWebpackPlugin$1 = /*@__PURE__*/getDefaultExportFromCjs(htmlWebpackPlugin);

const PLUGIN_NAME = 'hfex-auto-externals-plugin';
function checkExternalConfiguration() {
    const modPath = require$$0$4.join(process.cwd(), 'node_modules/hfex-external-configuration');
    const pnpmLockPath = require$$0$4.join(process.cwd(), 'pnpm-lock.yaml');
    fs$1.existsSync(pnpmLockPath) ? 'npx pnpm add' : 'npm install';
    if (!fs$1.existsSync(modPath)) {
        console.info(`${(`${PLUGIN_NAME} ⬇️ 检测到未安装hfex-external-configuration，正在自动安装...`)}`);
        // shelljs.exec(`${cliCommand} hfex-external-configuration --save-dev`, {
        //     cwd: process.cwd(),
        //     silent: true
        // });
    }
}
function resolveExternalList() {
    const packageVerList = require(require$$0$4.join(process.cwd(), 'node_modules/hfex-external-configuration'));
    const pkgInfo = require(require$$0$4.join(process.cwd(), 'package.json'));
    if (!packageVerList || packageVerList.length <= 0) {
        return [];
    }
    const externalList = [];
    const pkgDependencies = Object.entries(pkgInfo.dependencies);
    pkgDependencies.forEach(([name, ver]) => {
        const dependence = packageVerList.find((v) => {
            return name === v.name;
        });
        if (!dependence) {
            return;
        }
        const verItem = dependence.packageInfo.find((v) => ver === v.version);
        if (verItem && verItem.packageLink && verItem.exposedField) {
            externalList.push(Object.assign(Object.assign({}, dependence), { packageLink: verItem.packageLink, exposedField: verItem.exposedField }));
        }
    });
    return externalList;
}
function HfexAutoExternalsPlugin() {
    checkExternalConfiguration();
    return createUnplugin(() => {
        return {
            name: PLUGIN_NAME,
            enforce: 'post',
            webpack(compiler) {
                const envMode = compiler.options.mode;
                if (envMode !== 'production') {
                    const autoExternals = {};
                    const externalsList = resolveExternalList();
                    let jsExternalsScript = '';
                    externalsList.forEach(pck => {
                        autoExternals[pck.name] = pck.exposedField;
                        jsExternalsScript += `<script crossorigin="anonymous" src="${pck.packageLink}"></script>\n\r  `;
                    });
                    compiler.options.externals = Object.assign({}, compiler.options.externals || {}, autoExternals);
                    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
                        console.log('PLUGIN_NAME-----------' + PLUGIN_NAME);
                        HtmlWebpackPlugin$1.getHooks(compilation).beforeEmit.tapAsync(PLUGIN_NAME, (htmlPluginData, callback) => {
                            console.log('PLUGIN_NAMEeeeeeeeeeeeee-----------' + PLUGIN_NAME);
                            htmlPluginData.html = htmlPluginData.html.replace(/<body>([.\n\r\s\S]*?)(<script|<\/body)/g, `<body>$1${jsExternalsScript}$2`);
                            console.log(htmlPluginData.html);
                            callback();
                        });
                    });
                }
            }
        };
    });
}

var webpack = HfexAutoExternalsPlugin().webpack;

export { webpack as default };
